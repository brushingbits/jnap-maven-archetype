<?xml version="1.0" encoding="UTF-8"?><taglib xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-jsptaglibrary_2_1.xsd" version="2.1"><display-name>jnap-ui ExtJS 3 Tag Library</display-name><tlib-version>2.1</tlib-version><short-name>jnap-ui-extjs3</short-name><uri>http://www.brushingbits.org/jnap/ui/tags-extjs3</uri><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 <p>An Action is a piece of reusable functionality that can be abstracted out of any particular component so that it can
 be usefully shared among multiple components. Actions let you share handlers, configuration options and UI updates
 across any components that support the Action interface (primarily <a href="output/Ext.Toolbar.html"
 ext:cls="Ext.Toolbar">Ext.Toolbar</a>, <a href="output/Ext.Button.html" ext:cls="Ext.Button">Ext.Button</a> and <a
 href="output/Ext.menu.Menu.html" ext:cls="Ext.menu.Menu">Ext.menu.Menu</a> components).</p> 
 <p>Aside from supporting
 the config object interface, any component that needs to use Actions must also support the following method list, as
 these will be called as needed by the Action class: setText(string), setIconCls(string), setDisabled(boolean),
 setVisible(boolean) and setHandler(function).</p> Example usage:
 <br /> 
 <pre><code><i>// Define the shared action. 
 Each component below will have the same</i>
 <i>// display text and icon, and will display the same message on
 click.</i>
 <b>var</b> action = <b>new</b> Ext.Action({
     <a href="output/Ext.Action.html#Ext.Action-text"
 ext:member="text" ext:cls="Ext.Action">text</a>: <em>'Do something'</em>,
     <a
 href="output/Ext.Action.html#Ext.Action-handler" ext:member="handler" ext:cls="Ext.Action">handler</a>:
 <b>function</b>(){
         Ext.Msg.alert(<em>'Click'</em>, <em>'You did something.'</em>);
     },
     <a
 href="output/Ext.Action.html#Ext.Action-iconCls" ext:member="iconCls" ext:cls="Ext.Action">iconCls</a>:
 <em>'<b>do</b>-something'</em>,
     <a href="output/Ext.Action.html#Ext.Action-itemId" ext:member="itemId"
 ext:cls="Ext.Action">itemId</a>: <em>'myAction'</em>
 });
 
 <b>var</b> panel = <b>new</b> Ext.Panel({
     title:
 <em>'Actions'</em>,
     width: 500,
     height: 300,
     tbar: [
         <i>// Add the action directly to a toolbar as a
 menu button</i>
         action,
         {
             text: <em>'Action Menu'</em>,
             <i>// Add the action to
 a menu as a text item</i>
             menu: [action]
         }
     ],
     items: [
         <i>// Add the action to the
 panel body as a standard button</i>
         <b>new</b> Ext.Button(action)
     ],
     renderTo: Ext.getBody()
 });
 
 <i>//
 Change the text <b>for</b> all components using the action</i>
 action.setText(<em>'Something <b>else</b>'</em>);
 
 <i>//
 Reference an action through a container using the itemId</i>
 <b>var</b> btn =
 panel.getComponent(<em>'myAction'</em>);
 <b>var</b> aRef = btn.baseAction;
 aRef.setText(<em>'New
 text'</em>);</code></pre>]]></description><name>action</name><tag-class>org.brushingbits.jnap.ui.extjs3.Action</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[True to disable all components using this action, false to enable them (defaults to false).]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The function that will be invoked by each component tied to this action when the component's primary event is triggered
 (defaults to undefined).]]></description><name>handler</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide all components using this action, false to show them (defaults to false).]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class selector that specifies a background image to be used as the header icon for all components using this
 action (defaults to ''). An example of specifying a custom icon class would be something like: // specify the property
 in the config for the class:
      ...
      iconCls: 'do-something'
 
 // css class that specifies background image to be
 used as the icon image:
 .do-something { background-image: url(../images/my-icon.gif) 0 6px no-repeat !important; }]]></description><name>iconCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[See Ext.Component.itemId.]]></description><name>itemId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The scope (this reference) in which the handler is executed. Defaults to this Button.]]></description><name>scope</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The text to set for all components using this action (defaults to '').]]></description><name>text</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 <p>Base class for any <a href="output/Ext.Component.html" ext:cls="Ext.Component">Component</a> that is to be sized as a
 box, using width and height.</p> 
 <p>BoxComponent provides automatic box model adjustments for sizing and positioning
 and will work correctly within the Component rendering model.</p> 
 <p>A BoxComponent may be created as a custom
 Component which encapsulates any HTML element, either a pre-existing element, or one that is created to your
 specifications at render time. Usually, to participate in layouts, a Component will need to be a <b>Box</b>Component in
 order to have its width and height managed.</p> 
 <p>To use a pre-existing element as a BoxComponent, configure it so
 that you preset the <b>el</b> property to the element to reference:</p>
 <pre><code><b>var</b> pageHeader = <b>new</b>
 Ext.BoxComponent({
     el: <em>'my-header-div'</em>
 });</code></pre> This may then be 
 <a
 href="output/Ext.Container.html#Ext.Container-add" ext:member="add" ext:cls="Ext.Container">added</a> to a 
 <a
 href="output/Ext.Container.html" ext:cls="Ext.Container">Container</a> as a child item.
 <p></p> 
 <p>To create a
 BoxComponent based around a HTML element to be created at render time, use the <a
 href="output/Ext.Component.html#Ext.Component-autoEl" ext:member="autoEl" ext:cls="Ext.Component">autoEl</a> config
 option which takes the form of a <a href="output/Ext.DomHelper.html" ext:cls="Ext.DomHelper">DomHelper</a>
 specification:</p>
 <pre><code><b>var</b> myImage = <b>new</b> Ext.BoxComponent({
     autoEl: {
         tag:
 <em>'img'</em>,
         src: <em>'/images/my-image.jpg'</em>
     }
 });</code></pre>
 <p></p>]]></description><name>boxComponent</name><tag-class>org.brushingbits.jnap.ui.extjs3.BoxComponent</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[Whether the component can move the Dom node when rendering (defaults to true).]]></description><name>allowDomMove</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use an
 AnchorLayout (or subclass thereof). based layout manager, for example: Ext.form.FormPanel specifying layout: 'anchor' //
 or 'form', or 'absolute' See Ext.layout.AnchorLayout.anchor also.]]></description><name>anchor</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element corresponding to a DIV that is already present in
 the document that specifies some structural markup for this component. Description : When applyTo is used, constituent
 parts of the component can also be specified by id or CSS class name within the main element, and the component being
 created may attempt to create its subcomponents from that markup if applicable. Notes : When using this config, a call
 to render() is not required. If applyTo is specified, any value passed for renderTo will be ignored and the target
 element's parent node will automatically be used as the component's container.]]></description><name>applyTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A tag name or DomHelper spec used to create the Element which will encapsulate this Component. You do not normally need
 to specify this. For the base classes Ext.Component, Ext.BoxComponent, and Ext.Container, this defaults to 'div'. The
 more complex Ext classes use a more complex DOM structure created by their own onRender methods. This is intended to
 allow the developer to create application-specific utility Components encapsulated by different DOM elements. Example
 usage: <pre><code>{
     xtype: 'box',
     autoEl: {
         tag: 'img',
         src: 'http://www.example.com/example.jpg'
     }
 },
 {
     xtype: 'box',
     autoEl: {
         tag: 'blockquote',
         html: 'autoEl is cool!'
     }
 }, {
     xtype: 'container',
     autoEl: 'ul',
     cls: 'ux-unordered-list',
     items: {
         xtype: 'box',
         autoEl: 'li',
   
      html: 'First list item'
     }
 }</pre></code>]]></description><name>autoEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to use height:'auto', false to use fixed height (or allow it to be managed by its parent Container's layout
 manager. Defaults to false. Note: Although many components inherit this config option, not all will function as expected
 with a height of 'auto'. Setting autoHeight:true means that the browser will manage height based on the element's
 contents, and that Ext will not manage it at all. If the browser is managing the height, be aware that resizes performed
 by the browser in response to changes within the structure of the Component cannot be detected. Therefore changes to the
 height might result in elements needing to be synchronized with the new height. Example: var w = new Ext.Window({
    
 title: 'Window',
     width: 600,
     autoHeight: true,
     items: {
         title: 'Collapse Me',
         height: 400,
  
 collapsible: true,
         border: false,
         listeners: {
             beforecollapse: function() {
                w.el.shadow.hide();
             },
             beforeexpand: function() {
                w.el.shadow.hide();
             },
             collapse: function() {
                w.syncShadow();
             },
             expand: function() {
                w.syncShadow();
             }
         }
     }
 }).show();]]></description><name>autoHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to use overflow:'auto' on the components layout element and show scroll bars automatically when necessary, false to
 clip any overflowing content (defaults to false).]]></description><name>autoScroll</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True if the component should check for hidden classes (e.g. 'x-hidden' or 'x-hide-display') and remove them on render
 (defaults to false).]]></description><name>autoShow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to use width:'auto', false to use fixed width (or allow it to be managed by its parent Container's layout manager.
 Defaults to false. Note: Although many components inherit this config option, not all will function as expected with a
 width of 'auto'. Setting autoWidth:true means that the browser will manage width based on the element's contents, and
 that Ext will not manage it at all. If the browser is managing the width, be aware that resizes performed by the browser
 in response to changes within the structure of the Component cannot be detected. Therefore changes to the width might
 result in elements needing to be synchronized with the new width. For example, where the target element is: <div
 id='grid-container' style='margin-left:25%;width:50%'></div> A Panel rendered into that target element must listen for
 browser window resize in order to relay its child items when the browser changes its width: var myPanel = new
 Ext.Panel({
     renderTo: 'grid-container',
     monitorResize: true, // relay on browser resize
     title: 'Panel',
    
 height: 400,
     autoWidth: true,
     layout: 'hbox',
     layoutConfig: {
         align: 'stretch'
     },
     defaults: {
         flex: 1
     },
     items: [{
         title: 'Box 1',
     }, {
         title: 'Box 2'
     }, {
         title:
 'Box 3'
     }],
 });]]></description><name>autoWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to [].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class used to to apply to the special clearing div rendered directly after each form field wrapper to provide
 field clearing (defaults to 'x-form-clear-left'). Note: this config is only used when this Component is rendered by a
 Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or specifying
 layout:'form') and either a fieldLabel is specified or isFormField=true is specified. See Ext.layout.FormLayout.fieldTpl
 also.]]></description><name>clearCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element (defaults to ''). This can be useful for
 adding customized styles to the component or any of its children using standard CSS rules.]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's container. This can be useful for adding customized
 styles to the container or any of its children using standard CSS rules. See Ext.layout.ContainerLayout.extraCls also.
 Note: ctCls defaults to '' except for the following class which assigns a value by default: Box Layout :
 'x-box-layout-ct' To configure the above Class with an extra CSS class append to the default. For example, for BoxLayout
 (Hbox and Vbox): ctCls: 'x-box-layout-ct custom-class']]></description><name>ctCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component disabled (default is false).]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class added to the component when it is disabled (defaults to 'x-item-disabled').]]></description><name>disabledClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The label text to display next to this Component (defaults to ''). Note: this config is only used when this Component is
 rendered by a Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or
 specifying layout:'form'). Also see hideLabel and Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
    
 height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name'
    
 }]
 });]]></description><name>fieldLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use a
 BoxLayout. Each child Component with a flex property will be flexed either vertically (by a VBoxLayout) or horizontally
 (by an HBoxLayout) according to the item's relative flex value compared to the sum of all Components with flex value
 specified. Any child items that have either a flex = 0 or flex = undefined will not be 'flexed' (the initial size will
 not be changed).]]></description><name>flex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component hidden (default is false). If true, the hide method will be called internally.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to completely hide the label element (label and separator). Defaults to false. By default, even if you do not
 specify a fieldLabel the space will still be reserved so that the field will line up with other fields that do have
 labels. Setting this to true will cause the field to not reserve that space. Note: see the note for clearCls. Example
 use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield'
        
 hideLabel: true
     }]
 });]]></description><name>hideLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[How this component should be hidden. Supported values are 'visibility' (css visibility), 'offsets' (negative offset
 position) and 'display' (css display). Note: the default of 'display' is generally preferred since items are
 automatically laid out when they are first shown (no sizing is done while hidden).]]></description><name>hideMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide and show the component's container when hide/show is called on the component, false to hide and show the
 component itself (defaults to false). For example, this can be used as a shortcut for a hide button on a window by
 setting hide:true on the button when adding it to its parent container.]]></description><name>hideParent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id of this component (defaults to an auto-assigned id). You should assign an id if you need to be able to
 access the component later and you do not have an object reference available (e.g., using Ext.getCmp). Note that this id
 will also be used as the element id for the containing HTML element that is rendered to the page for this component.
 This allows you to write id-based CSS rules to style the specific instance of this component uniquely, and also to
 select sub-elements using this component's id as the parent. Note: to avoid complications imposed by a unique id also
 see itemId and ref. Note: to access the container of an item see ownerCt.]]></description><name>id</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use the
 FormLayout layout manager (e.g. Ext.form.FormPanel or specifying layout:'form'). An additional CSS class to apply to the
 div wrapping the form item element of this field. If supplied, itemCls at the field level will override the default
 itemCls supplied at the container level. The value specified for itemCls will be added to the default class
 ('x-form-item'). Since it is applied to the item wrapper (see Ext.layout.FormLayout.fieldTpl), it allows you to write
 standard CSS rules that can apply to the field, the label (if specified), or any other element within the markup for the
 field. Note: see the note for fieldLabel. Example use: // Apply a style to the field's label:
 <style>
     .required
 .x-form-item-label {font-weight:bold;color:red;}
 </style>
 
 new Ext.FormPanel({
     height: 100,
     renderTo:
 Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         itemCls: 'required' //this
 label will be styled
     },{
         xtype: 'textfield',
         fieldLabel: 'Favorite Color'
     }]
 });]]></description><name>itemCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An itemId can be used as an alternative way to get a reference to a component when no object reference is available.
 Instead of using an id with Ext.getCmp, use itemId with Ext.Container.getComponent which will retrieve itemId's or id's.
 Since itemId's are an index to the container's internal MixedCollection, the itemId is scoped locally to the container
 -- avoiding potential conflicts with Ext.ComponentMgr which requires a unique id. var c = new Ext.Panel({ //
     height:
 300,
     renderTo: document.body,
     layout: 'auto',
     items: [
         {
             itemId: 'p1',
            
 title: 'Panel 1',
             height: 150
         },
         {
             itemId: 'p2',
             title: 'Panel 2',
  
 height: 150
         }
     ]
 })
 p1 = c.getComponent('p1'); // not the same as Ext.getCmp()
 p2 =
 p1.ownerCt.getComponent('p2'); // reference via a sibling Also see id and ref. Note: to access the container of an item
 see ownerCt.]]></description><name>itemId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The separator to display after the text of each fieldLabel. This property may be configured at various levels. The order
 of precedence is: field / component level container level layout level (defaults to colon ':') To display no separator
 for this field's label specify empty string ''. Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 layoutConfig: {
         labelSeparator: '~'   // layout config has lowest priority (defaults to ':')
     },
    
 labelSeparator: '>>',     // config at container level
     items: [{
         xtype: 'textfield',
         fieldLabel:
 'Field 1',
         labelSeparator: '...' // field/component level config supersedes others
     },{
         xtype:
 'textfield',
         fieldLabel: 'Field 2' // labelSeparator will be '='
     }]
 });]]></description><name>labelSeparator</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS style specification string to apply directly to this field's label. Defaults to the container's labelStyle value
 if set (e.g., Ext.layout.FormLayout.labelStyle , or ''). Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         labelStyle: 'font-weight:bold;'
     }]
 });]]></description><name>labelStyle</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout or one of the two BoxLayout subclasses. An object containing margins to apply to this BoxComponent in the
 format: {
     top: (top margin),
     right: (right margin),
     bottom: (bottom margin),
     left: (left margin)
 } May
 also be a string containing space-separated, numeric margin values. The order of the sides associated with each value
 matches the way CSS processes margin values: If there is only one value, it applies to all sides. If there are two
 values, the top and bottom borders are set to the first value and the right and left are set to the second. If there are
 three values, the top is set to the first value, the left and right are set to the second, and the bottom is set to the
 third. If there are four values, they apply to the top, right, bottom, and left, respectively. Defaults to: {top:0,
 right:0, bottom:0, left:0}]]></description><name>margins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element when the mouse moves over the Element, and
 removed when the mouse moves out. (defaults to ''). This can be useful for adding customized 'active' or 'hover' styles
 to the component or any of its children using standard CSS rules.]]></description><name>overCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level x coordinate for this component if contained within a positioning container.]]></description><name>pageX</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level y coordinate for this component if contained within a positioning container.]]></description><name>pageY</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered ptype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a Plugin is being specified not as a fully
 instantiated Component, but as a Component config object. The ptype will be looked up at render time up to determine
 what type of Plugin to create. If you create your own Plugins, you may register them using
 Ext.ComponentMgr.registerPlugin in order to be able to take advantage of lazy instantiation and rendering.]]></description><name>ptype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A path specification, relative to the Component's ownerCt specifying into which ancestor Container to place a named
 reference to this Component. The ancestor axis can be traversed by using '/' characters in the path. For example, to put
 a reference to a Toolbar Button into the Panel which owns the Toolbar: var myGrid = new Ext.grid.EditorGridPanel({
    
 title: 'My EditorGridPanel',
     store: myStore,
     colModel: myColModel,
     tbar: [{
         text: 'Save',
        
 handler: saveChanges,
         disabled: true,
         ref: '../saveButton'
     }],
     listeners: {
         afteredit:
 function() {
 //          The button reference is in the GridPanel
             myGrid.saveButton.enable();
         }
    
 }
 }); In the code above, if the ref had been 'saveButton' the reference would have been placed into the Toolbar. Each
 '/' in the ref moves up one level from the Component's ownerCt. Also see the added and removed events.]]></description><name>ref</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout layout manager (e.g. specifying layout:'border'). See Ext.layout.BorderLayout also.]]></description><name>region</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should trigger this component to save its state (defaults to none). stateEvents may
 be any type of event supported by this component, including browser or custom events (e.g., ['click',
 'customerchange']). See stateful for an explanation of saving and restoring Component state.]]></description><name>stateEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id for this component to use for state management purposes (defaults to the component id if one was set,
 otherwise null if the component is using a generated id). See stateful for an explanation of saving and restoring
 Component state.]]></description><name>stateId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A flag which causes the Component to attempt to restore the state of internal properties from a saved state on startup.
 The component must have either a stateId or id assigned for state to be managed. Auto-generated ids are not guaranteed
 to be stable across page loads and cannot be relied upon to save and restore the same state for a component. For state
 saving to work, the state manager's provider must have been set to an implementation of Ext.state.Provider which
 overrides the set and get methods to save and recall name/value pairs. A built-in implementation,
 Ext.state.CookieProvider is available. To set the state provider for the current page: Ext.state.Manager.setProvider(new
 Ext.state.CookieProvider({
     expires: new Date(new Date().getTime()+(1000*60*60*24*7)), //7 days from now
 })); A
 stateful Component attempts to save state when one of the events listed in the stateEvents configuration fires. To save
 state, a stateful Component first serializes its state by calling getState. By default, this function does nothing. The
 developer must provide an implementation which returns an object hash which represents the Component's restorable state.
 The value yielded by getState is passed to Ext.state.Manager.set which uses the configured Ext.state.Provider to save
 the object keyed by the Component's stateId, or, if that is not specified, its id. During construction, a stateful
 Component attempts to restore its state by calling Ext.state.Manager.get passing the stateId, or, if that is not
 specified, the id. The resulting object is passed to applyState. The default implementation of applyState simply copies
 properties into the object, but a developer may override this to support more behaviour. You can perform extra
 processing on state save and restore by attaching handlers to the beforestaterestore, staterestore, beforestatesave and
 statesave events.]]></description><name>stateful</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
     title: 'Some Title',
     renderTo: Ext.getBody(),
     width: 400, height:
 300,
     layout: 'form',
     items: [{
         xtype: 'textarea',
         style: {
             width: '95%',
            
 marginBottom: '10px'
         }
     },
         new Ext.Button({
             text: 'Send',
             minWidth: '100',
   
          style: {
                 marginBottom: '10px'
             }
         })
     ]
 });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is a child item of a TabPanel. A string to be used as innerHTML
 (html tags are accepted) to show in a tooltip when mousing over the associated tab selector element.
 Ext.QuickTips.init() must be called in order for the tips to render.]]></description><name>tabTip</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local x (left) coordinate for this component if contained within a positioning container.]]></description><name>x</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered xtype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a child item of a Container is being specified not
 as a fully instantiated Component, but as a Component config object. The xtype will be looked up at render time up to
 determine what type of child Component to create. The predefined xtypes are listed here. If you subclass Components to
 create your own Components, you may register them using Ext.ComponentMgr.registerType in order to be able to take
 advantage of lazy instantiation and rendering.]]></description><name>xtype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local y (top) coordinate for this component if contained within a positioning container.]]></description><name>y</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 Simple Button class]]></description><name>button</name><tag-class>org.brushingbits.jnap.ui.extjs3.Button</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[False to not allow a pressed Button to be depressed (defaults to undefined). Only valid when enableToggle is true.]]></description><name>allowDepress</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Whether the component can move the Dom node when rendering (defaults to true).]]></description><name>allowDomMove</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use an
 AnchorLayout (or subclass thereof). based layout manager, for example: Ext.form.FormPanel specifying layout: 'anchor' //
 or 'form', or 'absolute' See Ext.layout.AnchorLayout.anchor also.]]></description><name>anchor</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element corresponding to a DIV that is already present in
 the document that specifies some structural markup for this component. Description : When applyTo is used, constituent
 parts of the component can also be specified by id or CSS class name within the main element, and the component being
 created may attempt to create its subcomponents from that markup if applicable. Notes : When using this config, a call
 to render() is not required. If applyTo is specified, any value passed for renderTo will be ignored and the target
 element's parent node will automatically be used as the component's container.]]></description><name>applyTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[(Optional) The side of the Button box to render the arrow if the button has an associated menu. Two values are allowed:
 'right' 'bottom' Defaults to 'right' .]]></description><name>arrowAlign</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A tag name or DomHelper spec used to create the Element which will encapsulate this Component. You do not normally need
 to specify this. For the base classes Ext.Component, Ext.BoxComponent, and Ext.Container, this defaults to 'div'. The
 more complex Ext classes use a more complex DOM structure created by their own onRender methods. This is intended to
 allow the developer to create application-specific utility Components encapsulated by different DOM elements. Example
 usage: <pre><code>{
     xtype: 'box',
     autoEl: {
         tag: 'img',
         src: 'http://www.example.com/example.jpg'
     }
 },
 {
     xtype: 'box',
     autoEl: {
         tag: 'blockquote',
         html: 'autoEl is cool!'
     }
 }, {
     xtype: 'container',
     autoEl: 'ul',
     cls: 'ux-unordered-list',
     items: {
         xtype: 'box',
         autoEl: 'li',
   
      html: 'First list item'
     }
 }</pre></code>]]></description><name>autoEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to use height:'auto', false to use fixed height (or allow it to be managed by its parent Container's layout
 manager. Defaults to false. Note: Although many components inherit this config option, not all will function as expected
 with a height of 'auto'. Setting autoHeight:true means that the browser will manage height based on the element's
 contents, and that Ext will not manage it at all. If the browser is managing the height, be aware that resizes performed
 by the browser in response to changes within the structure of the Component cannot be detected. Therefore changes to the
 height might result in elements needing to be synchronized with the new height. Example: var w = new Ext.Window({
    
 title: 'Window',
     width: 600,
     autoHeight: true,
     items: {
         title: 'Collapse Me',
         height: 400,
  
 collapsible: true,
         border: false,
         listeners: {
             beforecollapse: function() {
                w.el.shadow.hide();
             },
             beforeexpand: function() {
                w.el.shadow.hide();
             },
             collapse: function() {
                w.syncShadow();
             },
             expand: function() {
                w.syncShadow();
             }
         }
     }
 }).show();]]></description><name>autoHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to use overflow:'auto' on the components layout element and show scroll bars automatically when necessary, false to
 clip any overflowing content (defaults to false).]]></description><name>autoScroll</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True if the component should check for hidden classes (e.g. 'x-hidden' or 'x-hide-display') and remove them on render
 (defaults to false).]]></description><name>autoShow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[By default, if a width is not specified the button will attempt to stretch horizontally to fit its content. If the
 button is being managed by a width sizing layout (hbox, fit, anchor), set this to false to prevent the button from doing
 this automatic sizing. Defaults to undefined .]]></description><name>autoWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to [].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[(Optional) A DomQuery selector which is used to extract the active, clickable element from the DOM structure created.
 When a custom template is used, you must ensure that this selector results in the selection of a focussable element.
 Defaults to 'button:first-child' .]]></description><name>buttonSelector</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class used to to apply to the special clearing div rendered directly after each form field wrapper to provide
 field clearing (defaults to 'x-form-clear-left'). Note: this config is only used when this Component is rendered by a
 Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or specifying
 layout:'form') and either a fieldLabel is specified or isFormField=true is specified. See Ext.layout.FormLayout.fieldTpl
 also.]]></description><name>clearCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The DOM event that will fire the handler of the button. This can be any valid event name (dblclick, contextmenu).
 Defaults to 'click' .]]></description><name>clickEvent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS class string to apply to the button's main element.]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's container. This can be useful for adding customized
 styles to the container or any of its children using standard CSS rules. See Ext.layout.ContainerLayout.extraCls also.
 Note: ctCls defaults to '' except for the following class which assigns a value by default: Box Layout :
 'x-box-layout-ct' To configure the above Class with an extra CSS class append to the default. For example, for BoxLayout
 (Hbox and Vbox): ctCls: 'x-box-layout-ct custom-class']]></description><name>ctCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to start disabled (defaults to false)]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class added to the component when it is disabled (defaults to 'x-item-disabled').]]></description><name>disabledClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to enable pressed/not pressed toggling (defaults to false)]]></description><name>enableToggle</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The label text to display next to this Component (defaults to ''). Note: this config is only used when this Component is
 rendered by a Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or
 specifying layout:'form'). Also see hideLabel and Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
    
 height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name'
    
 }]
 });]]></description><name>fieldLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use a
 BoxLayout. Each child Component with a flex property will be flexed either vertically (by a VBoxLayout) or horizontally
 (by an HBoxLayout) according to the item's relative flex value compared to the sum of all Components with flex value
 specified. Any child items that have either a flex = 0 or flex = undefined will not be 'flexed' (the initial size will
 not be changed).]]></description><name>flex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[False to disable visual cues on mouseover, mouseout and mousedown (defaults to true)]]></description><name>handleMouseEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A function called when the button is clicked (can be used instead of click event). The handler is passed the following
 parameters: b : Button This Button. e : EventObject The click event.]]></description><name>handler</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to start hidden (defaults to false)]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to completely hide the label element (label and separator). Defaults to false. By default, even if you do not
 specify a fieldLabel the space will still be reserved so that the field will line up with other fields that do have
 labels. Setting this to true will cause the field to not reserve that space. Note: see the note for clearCls. Example
 use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield'
        
 hideLabel: true
     }]
 });]]></description><name>hideLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[How this component should be hidden. Supported values are 'visibility' (css visibility), 'offsets' (negative offset
 position) and 'display' (css display). Note: the default of 'display' is generally preferred since items are
 automatically laid out when they are first shown (no sizing is done while hidden).]]></description><name>hideMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide and show the component's container when hide/show is called on the component, false to hide and show the
 component itself (defaults to false). For example, this can be used as a shortcut for a hide button on a window by
 setting hide:true on the button when adding it to its parent container.]]></description><name>hideParent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The path to an image to display in the button (the image will be set as the background-image CSS property of the button
 by default, so if you want a mixed icon/text button, set cls:'x-btn-text-icon')]]></description><name>icon</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[(Optional) The side of the Button box to render the icon. Four values are allowed: 'top' 'right' 'bottom' 'left'
 Defaults to 'left' .]]></description><name>iconAlign</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A css class which sets a background image to be used as the icon for this button]]></description><name>iconCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id of this component (defaults to an auto-assigned id). You should assign an id if you need to be able to
 access the component later and you do not have an object reference available (e.g., using Ext.getCmp). Note that this id
 will also be used as the element id for the containing HTML element that is rendered to the page for this component.
 This allows you to write id-based CSS rules to style the specific instance of this component uniquely, and also to
 select sub-elements using this component's id as the parent. Note: to avoid complications imposed by a unique id also
 see itemId and ref. Note: to access the container of an item see ownerCt.]]></description><name>id</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use the
 FormLayout layout manager (e.g. Ext.form.FormPanel or specifying layout:'form'). An additional CSS class to apply to the
 div wrapping the form item element of this field. If supplied, itemCls at the field level will override the default
 itemCls supplied at the container level. The value specified for itemCls will be added to the default class
 ('x-form-item'). Since it is applied to the item wrapper (see Ext.layout.FormLayout.fieldTpl), it allows you to write
 standard CSS rules that can apply to the field, the label (if specified), or any other element within the markup for the
 field. Note: see the note for fieldLabel. Example use: // Apply a style to the field's label:
 <style>
     .required
 .x-form-item-label {font-weight:bold;color:red;}
 </style>
 
 new Ext.FormPanel({
     height: 100,
     renderTo:
 Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         itemCls: 'required' //this
 label will be styled
     },{
         xtype: 'textfield',
         fieldLabel: 'Favorite Color'
     }]
 });]]></description><name>itemCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An itemId can be used as an alternative way to get a reference to a component when no object reference is available.
 Instead of using an id with Ext.getCmp, use itemId with Ext.Container.getComponent which will retrieve itemId's or id's.
 Since itemId's are an index to the container's internal MixedCollection, the itemId is scoped locally to the container
 -- avoiding potential conflicts with Ext.ComponentMgr which requires a unique id. var c = new Ext.Panel({ //
     height:
 300,
     renderTo: document.body,
     layout: 'auto',
     items: [
         {
             itemId: 'p1',
            
 title: 'Panel 1',
             height: 150
         },
         {
             itemId: 'p2',
             title: 'Panel 2',
  
 height: 150
         }
     ]
 })
 p1 = c.getComponent('p1'); // not the same as Ext.getCmp()
 p2 =
 p1.ownerCt.getComponent('p2'); // reference via a sibling Also see id and ref. Note: to access the container of an item
 see ownerCt.]]></description><name>itemId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The separator to display after the text of each fieldLabel. This property may be configured at various levels. The order
 of precedence is: field / component level container level layout level (defaults to colon ':') To display no separator
 for this field's label specify empty string ''. Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 layoutConfig: {
         labelSeparator: '~'   // layout config has lowest priority (defaults to ':')
     },
    
 labelSeparator: '>>',     // config at container level
     items: [{
         xtype: 'textfield',
         fieldLabel:
 'Field 1',
         labelSeparator: '...' // field/component level config supersedes others
     },{
         xtype:
 'textfield',
         fieldLabel: 'Field 2' // labelSeparator will be '='
     }]
 });]]></description><name>labelSeparator</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS style specification string to apply directly to this field's label. Defaults to the container's labelStyle value
 if set (e.g., Ext.layout.FormLayout.labelStyle , or ''). Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         labelStyle: 'font-weight:bold;'
     }]
 });]]></description><name>labelStyle</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout or one of the two BoxLayout subclasses. An object containing margins to apply to this BoxComponent in the
 format: {
     top: (top margin),
     right: (right margin),
     bottom: (bottom margin),
     left: (left margin)
 } May
 also be a string containing space-separated, numeric margin values. The order of the sides associated with each value
 matches the way CSS processes margin values: If there is only one value, it applies to all sides. If there are two
 values, the top and bottom borders are set to the first value and the right and left are set to the second. If there are
 three values, the top is set to the first value, the left and right are set to the second, and the bottom is set to the
 third. If there are four values, they apply to the top, right, bottom, and left, respectively. Defaults to: {top:0,
 right:0, bottom:0, left:0}]]></description><name>margins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Standard menu attribute consisting of a reference to a menu object, a menu id or a menu config blob (defaults to
 undefined).]]></description><name>menu</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The position to align the menu to (see Ext.Element.alignTo for more details, defaults to 'tl-bl?').]]></description><name>menuAlign</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum width for this button (used to give a set of buttons a common width). See also Ext.Panel. minButtonWidth .]]></description><name>minWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element when the mouse moves over the Element, and
 removed when the mouse moves out. (defaults to ''). This can be useful for adding customized 'active' or 'hover' styles
 to the component or any of its children using standard CSS rules.]]></description><name>overCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If used in a Toolbar, the text to be used if this item is shown in the overflow menu. See also Ext.Toolbar.Item.
 overflowText .]]></description><name>overflowText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level x coordinate for this component if contained within a positioning container.]]></description><name>pageX</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level y coordinate for this component if contained within a positioning container.]]></description><name>pageY</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to start pressed (only if enableToggle = true)]]></description><name>pressed</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered ptype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a Plugin is being specified not as a fully
 instantiated Component, but as a Component config object. The ptype will be looked up at render time up to determine
 what type of Plugin to create. If you create your own Plugins, you may register them using
 Ext.ComponentMgr.registerPlugin in order to be able to take advantage of lazy instantiation and rendering.]]></description><name>ptype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A path specification, relative to the Component's ownerCt specifying into which ancestor Container to place a named
 reference to this Component. The ancestor axis can be traversed by using '/' characters in the path. For example, to put
 a reference to a Toolbar Button into the Panel which owns the Toolbar: var myGrid = new Ext.grid.EditorGridPanel({
    
 title: 'My EditorGridPanel',
     store: myStore,
     colModel: myColModel,
     tbar: [{
         text: 'Save',
        
 handler: saveChanges,
         disabled: true,
         ref: '../saveButton'
     }],
     listeners: {
         afteredit:
 function() {
 //          The button reference is in the GridPanel
             myGrid.saveButton.enable();
         }
    
 }
 }); In the code above, if the ref had been 'saveButton' the reference would have been placed into the Toolbar. Each
 '/' in the ref moves up one level from the Component's ownerCt. Also see the added and removed events.]]></description><name>ref</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout layout manager (e.g. specifying layout:'border'). See Ext.layout.BorderLayout also.]]></description><name>region</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to repeat fire the click event while the mouse is down. This can also be a ClickRepeater config object (defaults to
 false).]]></description><name>repeat</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[(Optional) The size of the Button. Three values are allowed: 'small' Results in the button element being 16px high.
 'medium' Results in the button element being 24px high. 'large' Results in the button element being 32px high. Defaults
 to 'small' .]]></description><name>scale</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The scope ( this reference) in which the handler and toggleHandler is executed. Defaults to this Button.]]></description><name>scope</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should trigger this component to save its state (defaults to none). stateEvents may
 be any type of event supported by this component, including browser or custom events (e.g., ['click',
 'customerchange']). See stateful for an explanation of saving and restoring Component state.]]></description><name>stateEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id for this component to use for state management purposes (defaults to the component id if one was set,
 otherwise null if the component is using a generated id). See stateful for an explanation of saving and restoring
 Component state.]]></description><name>stateId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A flag which causes the Component to attempt to restore the state of internal properties from a saved state on startup.
 The component must have either a stateId or id assigned for state to be managed. Auto-generated ids are not guaranteed
 to be stable across page loads and cannot be relied upon to save and restore the same state for a component. For state
 saving to work, the state manager's provider must have been set to an implementation of Ext.state.Provider which
 overrides the set and get methods to save and recall name/value pairs. A built-in implementation,
 Ext.state.CookieProvider is available. To set the state provider for the current page: Ext.state.Manager.setProvider(new
 Ext.state.CookieProvider({
     expires: new Date(new Date().getTime()+(1000*60*60*24*7)), //7 days from now
 })); A
 stateful Component attempts to save state when one of the events listed in the stateEvents configuration fires. To save
 state, a stateful Component first serializes its state by calling getState. By default, this function does nothing. The
 developer must provide an implementation which returns an object hash which represents the Component's restorable state.
 The value yielded by getState is passed to Ext.state.Manager.set which uses the configured Ext.state.Provider to save
 the object keyed by the Component's stateId, or, if that is not specified, its id. During construction, a stateful
 Component attempts to restore its state by calling Ext.state.Manager.get passing the stateId, or, if that is not
 specified, the id. The resulting object is passed to applyState. The default implementation of applyState simply copies
 properties into the object, but a developer may override this to support more behaviour. You can perform extra
 processing on state save and restore by attaching handlers to the beforestaterestore, staterestore, beforestatesave and
 statesave events.]]></description><name>stateful</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
     title: 'Some Title',
     renderTo: Ext.getBody(),
     width: 400, height:
 300,
     layout: 'form',
     items: [{
         xtype: 'textarea',
         style: {
             width: '95%',
            
 marginBottom: '10px'
         }
     },
         new Ext.Button({
             text: 'Send',
             minWidth: '100',
   
          style: {
                 marginBottom: '10px'
             }
         })
     ]
 });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Set a DOM tabIndex for this button (defaults to undefined)]]></description><name>tabIndex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is a child item of a TabPanel. A string to be used as innerHTML
 (html tags are accepted) to show in a tooltip when mousing over the associated tab selector element.
 Ext.QuickTips.init() must be called in order for the tips to render.]]></description><name>tabTip</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A Template used to create the Button's DOM structure. Instances, or subclasses which need a different DOM structure may
 provide a different template layout in conjunction with an implementation of getTemplateArgs.]]></description><name>template</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The button text to be used as innerHTML (html tags are accepted)]]></description><name>text</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The group this toggle button is a member of (only 1 per group can be pressed)]]></description><name>toggleGroup</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Function called when a Button with enableToggle set to true is clicked. Two arguments are passed: button : Ext.Button
 this Button object state : Boolean The next state of the Button, true means pressed.]]></description><name>toggleHandler</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The tooltip for the button - can be a string to be used as innerHTML (html tags are accepted) or QuickTips config object]]></description><name>tooltip</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The type of tooltip to use. Either 'qtip' (default) for QuickTips or 'title' for title attribute.]]></description><name>tooltipType</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[submit, reset or button - defaults to 'button']]></description><name>type</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local x (left) coordinate for this component if contained within a positioning container.]]></description><name>x</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered xtype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a child item of a Container is being specified not
 as a fully instantiated Component, but as a Component config object. The xtype will be looked up at render time up to
 determine what type of child Component to create. The predefined xtypes are listed here. If you subclass Components to
 create your own Components, you may register them using Ext.ComponentMgr.registerType in order to be able to take
 advantage of lazy instantiation and rendering.]]></description><name>xtype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local y (top) coordinate for this component if contained within a positioning container.]]></description><name>y</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 Container for a group of buttons. Example usage: 
 <pre><code><b>var</b> p = <b>new</b> Ext.Panel({
     title: <em>'Panel
 <b>with</b> Button Group'</em>,
     width: 300,
     height:200,
     renderTo: document.body,
     html:
 <em>'whatever'</em>,
     tbar: [{
         xtype: <em>'buttongroup'</em>,
         <a
 href="output/Ext.ButtonGroup.html#Ext.ButtonGroup-columns" ext:member="columns" ext:cls="Ext.ButtonGroup">columns</a>:
 3,
         title: <em>'Clipboard'</em>,
         items: [{
             text: <em>'Paste'</em>,
             scale:
 <em>'large'</em>,
             rowspan: 3, iconCls: <em>'add'</em>,
             iconAlign: <em>'top'</em>,
            
 cls: <em>'x-btn-as-arrow'</em>
         },{
             xtype:<em>'splitbutton'</em>,
             text: <em>'Menu
 Button'</em>,
             scale: <em>'large'</em>,
             rowspan: 3,
             iconCls: <em>'add'</em>,
         
 iconAlign: <em>'top'</em>,
             arrowAlign:<em>'bottom'</em>,
             menu: [{text: <em>'Menu Item 1'</em>}]
 
 },{
             xtype:<em>'splitbutton'</em>, text: <em>'Cut'</em>, iconCls: <em>'add16'</em>, menu: [{text: <em>'Cut
 Menu Item'</em>}]
         },{
             text: <em>'Copy'</em>, iconCls: <em>'add16'</em>
         },{
             text:
 <em>'Format'</em>, iconCls: <em>'add16'</em>
         }]
     }]
 });</code></pre>]]></description><name>buttonGroup</name><tag-class>org.brushingbits.jnap.ui.extjs3.ButtonGroup</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[A string component id or the numeric index of the component that should be initially activated within the container's
 layout on render. For example, activeItem: 'item-1' or activeItem: 0 (index 0 = the first item in the container's
 collection). activeItem only applies to layout styles that can display items one at a time (like
 Ext.layout.AccordionLayout, Ext.layout.CardLayout and Ext.layout.FitLayout). Related to
 Ext.layout.ContainerLayout.activeItem.]]></description><name>activeItem</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Whether the component can move the Dom node when rendering (defaults to true).]]></description><name>allowDomMove</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use an
 AnchorLayout (or subclass thereof). based layout manager, for example: Ext.form.FormPanel specifying layout: 'anchor' //
 or 'form', or 'absolute' See Ext.layout.AnchorLayout.anchor also.]]></description><name>anchor</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to animate the transition when the panel is collapsed, false to skip the animation (defaults to true if the Ext.Fx
 class is available, otherwise false).]]></description><name>animCollapse</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The id of the node, a DOM node or an existing Element corresponding to a DIV that is already present in the document
 that specifies some panel-specific structural markup. When applyTo is used, constituent parts of the panel can be
 specified by CSS class name within the main element, and the panel will automatically create those components from that
 markup. Any required components not specified in the markup will be autogenerated if necessary. The following class
 names are supported (baseCls will be replaced by baseCls): baseCls + '-header' baseCls + '-header-text' baseCls +
 '-bwrap' baseCls + '-tbar' baseCls + '-body' baseCls + '-bbar' baseCls + '-footer' Using this config, a call to render()
 is not required. If applyTo is specified, any value passed for renderTo will be ignored and the target element's parent
 node will automatically be used as the panel's container.]]></description><name>applyTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If true the container will automatically destroy any contained component that is removed from it, else destruction must
 be handled manually (defaults to true).]]></description><name>autoDestroy</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A tag name or DomHelper spec used to create the Element which will encapsulate this Component. You do not normally need
 to specify this. For the base classes Ext.Component, Ext.BoxComponent, and Ext.Container, this defaults to 'div'. The
 more complex Ext classes use a more complex DOM structure created by their own onRender methods. This is intended to
 allow the developer to create application-specific utility Components encapsulated by different DOM elements. Example
 usage: <pre><code>{
     xtype: 'box',
     autoEl: {
         tag: 'img',
         src: 'http://www.example.com/example.jpg'
     }
 },
 {
     xtype: 'box',
     autoEl: {
         tag: 'blockquote',
         html: 'autoEl is cool!'
     }
 }, {
     xtype: 'container',
     autoEl: 'ul',
     cls: 'ux-unordered-list',
     items: {
         xtype: 'box',
         autoEl: 'li',
   
      html: 'First list item'
     }
 }</pre></code>]]></description><name>autoEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to use height:'auto', false to use fixed height (defaults to false). Note: Setting autoHeight: true means that the
 browser will manage the panel's height based on its contents, and that Ext will not manage it at all. If the panel is
 within a layout that manages dimensions (fit, border, etc.) then setting autoHeight: true can cause issues with
 scrolling and will not generally work as expected since the panel will take on the height of its contents rather than
 the height required by the Ext layout.]]></description><name>autoHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A valid url spec according to the Updater Ext.Updater.update method. If autoLoad is not null, the panel will attempt to
 load its contents immediately upon render. The URL will become the default URL for this panel's body element, so it may
 be refreshed at any time.]]></description><name>autoLoad</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to use overflow:'auto' on the components layout element and show scroll bars automatically when necessary, false to
 clip any overflowing content (defaults to false).]]></description><name>autoScroll</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True if the component should check for hidden classes (e.g. 'x-hidden' or 'x-hide-display') and remove them on render
 (defaults to false).]]></description><name>autoShow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to use width:'auto', false to use fixed width (or allow it to be managed by its parent Container's layout manager.
 Defaults to false. Note: Although many components inherit this config option, not all will function as expected with a
 width of 'auto'. Setting autoWidth:true means that the browser will manage width based on the element's contents, and
 that Ext will not manage it at all. If the browser is managing the width, be aware that resizes performed by the browser
 in response to changes within the structure of the Component cannot be detected. Therefore changes to the width might
 result in elements needing to be synchronized with the new width. For example, where the target element is: <div
 id='grid-container' style='margin-left:25%;width:50%'></div> A Panel rendered into that target element must listen for
 browser window resize in order to relay its child items when the browser changes its width: var myPanel = new
 Ext.Panel({
     renderTo: 'grid-container',
     monitorResize: true, // relay on browser resize
     title: 'Panel',
    
 height: 400,
     autoWidth: true,
     layout: 'hbox',
     layoutConfig: {
         align: 'stretch'
     },
     defaults: {
         flex: 1
     },
     items: [{
         title: 'Box 1',
     }, {
         title: 'Box 2'
     }, {
         title:
 'Box 3'
     }],
 });]]></description><name>autoWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to 'x-btn-group'. See Ext.Panel.baseCls.]]></description><name>baseCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to display an interior border on the body element of the panel, false to hide it (defaults to true). This only
 applies when border == true. If border == true and bodyBorder == false, the border will display as a 1px wide inset
 border, giving the entire body element an inset appearance.]]></description><name>bodyBorder</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A DomHelper element specification object may be specified for any Panel Element. By default, the Default element in the
 table below will be used for the html markup to create a child element with the commensurate Default class name (baseCls
 will be replaced by baseCls): 
 Panel      Default  Default             Custom      Additional       Additional
 Element  
 element  class               element     class            style
 ========   ==========================   =========  
 ==============   ===========
 header     div      baseCls+'-header'   headerCfg   headerCssClass   headerStyle
 bwrap     
 div      baseCls+'-bwrap'     bwrapCfg    bwrapCssClass    bwrapStyle
 + tbar     div      baseCls+'-tbar'       tbarCfg 
 tbarCssClass     tbarStyle
 + body     div      baseCls+'-body'       bodyCfg     bodyCssClass     bodyStyle
 + bbar    
 div      baseCls+'-bbar'       bbarCfg     bbarCssClass     bbarStyle
 + footer   div      baseCls+'-footer'   footerCfg 
 footerCssClass   footerStyle
  Configuring a Custom element may be used, for example, to force the body Element to use a
 different form of markup than is created by default. An example of this might be to create a child Panel containing a
 custom content, such as a header, or forcing centering of all Panel content by having the body be a <center> element:
 new Ext.Panel({
     title: 'Message Title',
     renderTo: Ext.getBody(),
     width: 200, height: 130,
     bodyCfg: {
    
 tag: 'center',
         cls: 'x-panel-body',  // Default class not applied if Custom element specified
         html:
 'Message'
     },
     footerCfg: {
         tag: 'h2',
         cls: 'x-panel-footer',        // same as the Default class
 
 html: 'footer html'
     },
     footerCssClass: 'custom-footer', // additional css class, see addClass
     footerStyle:  
 'background-color:red' // see bodyStyle
 }); The example above also explicitly creates a footer with custom markup and
 styling applied.]]></description><name>bodyCfg</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Additional css class selector to be applied to the body element in the format expected by Ext.Element.addClass (defaults
 to null). See bodyCfg.]]></description><name>bodyCssClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Custom CSS styles to be applied to the body element in the format expected by Ext.Element.applyStyles (defaults to
 null). See bodyCfg.]]></description><name>bodyStyle</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to display the borders of the panel's body element, false to hide them (defaults to true). By default, the border
 is a 2px wide inset border, but this can be further altered by setting bodyBorder to false.]]></description><name>border</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to ['add', 'remove'].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[When set to true (50 milliseconds) or a number of milliseconds, the layout assigned for this container will buffer the
 frequency it calculates and does a re-layout of components. This is useful for heavy containers or containers with a
 large quantity of sub-components for which frequent layout calls would be expensive. Defaults to 50.]]></description><name>bufferResize</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The alignment of any buttons added to this panel. Valid values are 'right', 'left' and 'center' (defaults to 'right').]]></description><name>buttonAlign</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A DomHelper element specification object specifying the element structure of this Panel's bwrap Element. See bodyCfg
 also.]]></description><name>bwrapCfg</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class used to to apply to the special clearing div rendered directly after each form field wrapper to provide
 field clearing (defaults to 'x-form-clear-left'). Note: this config is only used when this Component is rendered by a
 Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or specifying
 layout:'form') and either a fieldLabel is specified or isFormField=true is specified. See Ext.layout.FormLayout.fieldTpl
 also.]]></description><name>clearCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Panels themselves do not directly support being closed, but some Panel subclasses do (like Ext.Window) or a Panel Class
 within an Ext.TabPanel. Specify true to enable closing in such situations. Defaults to false.]]></description><name>closable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element (defaults to ''). This can be useful for
 adding customized styles to the component or any of its children using standard CSS rules.]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to make sure the collapse/expand toggle button always renders first (to the left of) any other tools in the panel's
 title bar, false to render it last (defaults to true).]]></description><name>collapseFirst</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to render the panel collapsed, false to render it expanded (defaults to false).]]></description><name>collapsed</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS class to add to the panel's element after it has been collapsed (defaults to 'x-panel-collapsed').]]></description><name>collapsedCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to make the panel collapsible and have the expand/collapse toggle button automatically rendered into the header
 tool button area, false to keep the panel statically sized with no button (defaults to false).]]></description><name>collapsible</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The columns configuration property passed to the configured layout manager. See Ext.layout.TableLayout.columns.]]></description><name>columns</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's container. This can be useful for adding customized
 styles to the container or any of its children using standard CSS rules. See Ext.layout.ContainerLayout.extraCls also.
 Note: ctCls defaults to '' except for the following class which assigns a value by default: Box Layout :
 'x-box-layout-ct' To configure the above Class with an extra CSS class append to the default. For example, for BoxLayout
 (Hbox and Vbox): ctCls: 'x-box-layout-ct custom-class']]></description><name>ctCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default xtype of child Components to create in this Container when a child item is specified as a raw configuration
 object, rather than as an instantiated Component. Defaults to 'panel', except Ext.menu.Menu which defaults to
 'menuitem', and Ext.Toolbar and Ext.ButtonGroup which default to 'button'.]]></description><name>defaultType</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[This option is a means of applying default settings to all added items whether added through the items config or via the
 add or insert methods. If an added item is a config object, and not an instantiated Component, then the default
 properties are unconditionally applied. If the added item is an instantiated Component, then the default properties are
 applied conditionally so as not to override existing properties in the item. If the defaults option is specified as a
 function, then the function will be called using this Container as the scope (this reference) and passing the added item
 as the first parameter. Any resulting object from that call is then applied to the item as default properties. For
 example, to automatically apply padding to the body of each of a set of contained Ext.Panel items, you could pass:
 defaults: {bodyStyle:'padding:15px'}. Usage: defaults: {               // defaults are applied to items, not the
 container
     autoScroll:true
 },
 items: [
     {
         xtype: 'panel',   // defaults do not have precedence over
       
 id: 'panel1',     // options in config objects, so the defaults
         autoScroll: false // will not be applied here,
 panel1 will be autoScroll:false
     },
     new Ext.Panel({       // defaults do have precedence over options
         id:
 'panel2',     // options in components, so the defaults
         autoScroll: false // will be applied here, panel2 will
 be autoScroll:true.
     })
 ]]]></description><name>defaults</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this panel disabled (default is false). An important note when using the disabled config on panels is that IE
 will often fail to initialize the disabled mask element correectly if the panel's layout has not yet completed by the
 time the Panel is disabled during the render process. If you experience this issue, you may need to instead use the
 afterlayout event to initialize the disabled state: new Ext.Panel({
     ...
     listeners: {
         'afterlayout': {
   
 fn: function(p){
                 p.disable();
             },
             single: true // important, as many layouts can
 occur
         }
     }
 });]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class added to the component when it is disabled (defaults to 'x-item-disabled').]]></description><name>disabledClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to enable dragging of this Panel (defaults to false). For custom drag/drop implementations, an Ext.Panel.DD config
 could also be passed in this config instead of true. Ext.Panel.DD is an internal, undocumented class which moves a proxy
 Element around in place of the Panel's element, but provides no other behaviour during dragging or on drop. It is a
 subclass of Ext.dd.DragSource, so behaviour may be added by implementing the interface methods of Ext.dd.DragDrop e.g.:
 new Ext.Panel({
     title: 'Drag me',
     x: 100,
     y: 100,
     renderTo: Ext.getBody(),
     floating: true,
    
 frame: true,
     width: 400,
     height: 200,
     draggable: {
 //      Config option of Ext.Panel.DD class.
 //      It's
 a floating Panel, so do not show a placeholder proxy in the original position.
         insertProxy: false,
 
 //     
 Called for each mousemove event while dragging the DD object.
         onDrag : function(e){
 //          Record the x,y
 position of the drag proxy so that we can
 //          position the Panel at end of drag.
             var pel =
 this.proxy.getEl();
             this.x = pel.getLeft(true);
             this.y = pel.getTop(true);
 
 //          Keep the
 Shadow aligned if there is one.
             var s = this.panel.getEl().shadow;
             if (s) {
                
 s.realign(this.x, this.y, pel.getWidth(), pel.getHeight());
             }
         },
 
 //      Called on the mouseup
 event.
         endDrag : function(e){
             this.panel.setPosition(this.x, this.y);
         }
     }
 }).show();]]></description><name>draggable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A comma-delimited list of panel elements to initialize when the panel is rendered. Normally, this list will be generated
 automatically based on the items added to the panel at config time, but sometimes it might be useful to make sure a
 structural element is rendered even if not specified at config time (for example, you may want to add a button or
 toolbar dynamically after the panel has been rendered). Adding those elements to this list will allocate the required
 placeholders in the panel when it is rendered. Valid values are header tbar (top bar) body bbar (bottom bar) footer
 Defaults to 'body'.]]></description><name>elements</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A Toolbar object, a Toolbar config, or an array of Buttons/Button configs, describing a Toolbar to be rendered into this
 Panel's footer element. After render, the fbar property will be an Toolbar instance. If buttons are specified, they will
 supersede the fbar configuration property. The Panel's buttonAlign configuration affects the layout of these items, for
 example: var w = new Ext.Window({
     height: 250,
     width: 500,
     bbar: new Ext.Toolbar({
         items: [{
        
 text: 'bbar Left'
         },'->',{
             text: 'bbar Right'
         }]
     }),
     buttonAlign: 'left', //
 anything but 'center' or 'right' and you can use '-', and '->'
                                   // to control the
 alignment of fbar items
     fbar: [{
         text: 'fbar Left'
     },'->',{
         text: 'fbar Right'
     }]
 }).show();
 Note: Although a Toolbar may contain Field components, these will not be updated by a load of an ancestor FormPanel. A
 Panel's toolbars are not part of the standard Container->Component hierarchy, and so are not scanned to collect form
 items. However, the values will be submitted because form submission parameters are collected from the DOM tree.]]></description><name>fbar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The label text to display next to this Component (defaults to ''). Note: this config is only used when this Component is
 rendered by a Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or
 specifying layout:'form'). Also see hideLabel and Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
    
 height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name'
    
 }]
 });]]></description><name>fieldLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use a
 BoxLayout. Each child Component with a flex property will be flexed either vertically (by a VBoxLayout) or horizontally
 (by an HBoxLayout) according to the item's relative flex value compared to the sum of all Components with flex value
 specified. Any child items that have either a flex = 0 or flex = undefined will not be 'flexed' (the initial size will
 not be changed).]]></description><name>flex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[This property is used to configure the underlying Ext.Layer. Acceptable values for this configuration property are:
 false : Default. Display the panel inline where it is rendered. true : Float the panel (absolute position it with
 automatic shimming and shadow). Setting floating to true will create an Ext.Layer for this panel and display the panel
 at negative offsets so that it is hidden. Since the panel will be absolute positioned, the position must be set
 explicitly after render (e.g., myPanel.setPosition(100,100);). Note: when floating a panel you should always assign a
 fixed width, otherwise it will be auto width and will expand to fill to the right edge of the viewport. object : The
 specified object will be used as the configuration object for the Ext.Layer that will be created.]]></description><name>floating</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to create the footer element explicitly, false to skip creating it. The footer will be created automatically if
 buttons or a fbar have been configured. See bodyCfg for an example.]]></description><name>footer</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A DomHelper element specification object specifying the element structure of this Panel's footer Element. See bodyCfg
 also.]]></description><name>footerCfg</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If true the container will force a layout initially even if hidden or collapsed. This option is useful for forcing forms
 to render in collapsed or hidden containers. (defaults to false).]]></description><name>forceLayout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to true. See Ext.Panel.frame.]]></description><name>frame</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to create the Panel's header element explicitly, false to skip creating it. If a title is set the header will be
 created automatically, otherwise it will not. If a title is set but header is explicitly set to false, the header will
 not be rendered.]]></description><name>header</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to display the panel title in the header, false to hide it (defaults to true).]]></description><name>headerAsText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A DomHelper element specification object specifying the element structure of this Panel's header Element. See bodyCfg
 also.]]></description><name>headerCfg</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component hidden (default is false). If true, the hide method will be called internally.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide the borders of each contained component, false to defer to the component's existing border settings
 (defaults to false).]]></description><name>hideBorders</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to hide the expand/collapse toggle button when collapsible == true, false to display it (defaults to false).]]></description><name>hideCollapseTool</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to completely hide the label element (label and separator). Defaults to false. By default, even if you do not
 specify a fieldLabel the space will still be reserved so that the field will line up with other fields that do have
 labels. Setting this to true will cause the field to not reserve that space. Note: see the note for clearCls. Example
 use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield'
        
 hideLabel: true
     }]
 });]]></description><name>hideLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[How this component should be hidden. Supported values are 'visibility' (css visibility), 'offsets' (negative offset
 position) and 'display' (css display). Note: the default of 'display' is generally preferred since items are
 automatically laid out when they are first shown (no sizing is done while hidden).]]></description><name>hideMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide and show the component's container when hide/show is called on the component, false to hide and show the
 component itself (defaults to false). For example, this can be used as a shortcut for a hide button on a window by
 setting hide:true on the button when adding it to its parent container.]]></description><name>hideParent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class selector that specifies a background image to be used as the header icon (defaults to ''). An example of
 specifying a custom icon class would be something like: // specify the property in the config for the class:
      ...
   
 iconCls: 'my-icon'
 
 // css class that specifies background image to be used as the icon image:
 .my-icon {
 background-image: url(../images/my-icon.gif) 0 6px no-repeat !important; }]]></description><name>iconCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id of this component (defaults to an auto-assigned id). You should assign an id if you need to be able to
 access the component later and you do not have an object reference available (e.g., using Ext.getCmp). Note that this id
 will also be used as the element id for the containing HTML element that is rendered to the page for this component.
 This allows you to write id-based CSS rules to style the specific instance of this component uniquely, and also to
 select sub-elements using this component's id as the parent. Note: to avoid complications imposed by a unique id also
 see itemId and ref. Note: to access the container of an item see ownerCt.]]></description><name>id</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use the
 FormLayout layout manager (e.g. Ext.form.FormPanel or specifying layout:'form'). An additional CSS class to apply to the
 div wrapping the form item element of this field. If supplied, itemCls at the field level will override the default
 itemCls supplied at the container level. The value specified for itemCls will be added to the default class
 ('x-form-item'). Since it is applied to the item wrapper (see Ext.layout.FormLayout.fieldTpl), it allows you to write
 standard CSS rules that can apply to the field, the label (if specified), or any other element within the markup for the
 field. Note: see the note for fieldLabel. Example use: // Apply a style to the field's label:
 <style>
     .required
 .x-form-item-label {font-weight:bold;color:red;}
 </style>
 
 new Ext.FormPanel({
     height: 100,
     renderTo:
 Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         itemCls: 'required' //this
 label will be styled
     },{
         xtype: 'textfield',
         fieldLabel: 'Favorite Color'
     }]
 });]]></description><name>itemCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An itemId can be used as an alternative way to get a reference to a component when no object reference is available.
 Instead of using an id with Ext.getCmp, use itemId with Ext.Container.getComponent which will retrieve itemId's or id's.
 Since itemId's are an index to the container's internal MixedCollection, the itemId is scoped locally to the container
 -- avoiding potential conflicts with Ext.ComponentMgr which requires a unique id. var c = new Ext.Panel({ //
     height:
 300,
     renderTo: document.body,
     layout: 'auto',
     items: [
         {
             itemId: 'p1',
            
 title: 'Panel 1',
             height: 150
         },
         {
             itemId: 'p2',
             title: 'Panel 2',
  
 height: 150
         }
     ]
 })
 p1 = c.getComponent('p1'); // not the same as Ext.getCmp()
 p2 =
 p1.ownerCt.getComponent('p2'); // reference via a sibling Also see id and ref. Note: to access the container of an item
 see ownerCt.]]></description><name>itemId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A Ext.KeyMap config object (in the format expected by Ext.KeyMap.addBinding used to assign custom key handling to this
 panel (defaults to null).]]></description><name>keys</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The separator to display after the text of each fieldLabel. This property may be configured at various levels. The order
 of precedence is: field / component level container level layout level (defaults to colon ':') To display no separator
 for this field's label specify empty string ''. Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 layoutConfig: {
         labelSeparator: '~'   // layout config has lowest priority (defaults to ':')
     },
    
 labelSeparator: '>>',     // config at container level
     items: [{
         xtype: 'textfield',
         fieldLabel:
 'Field 1',
         labelSeparator: '...' // field/component level config supersedes others
     },{
         xtype:
 'textfield',
         fieldLabel: 'Field 2' // labelSeparator will be '='
     }]
 });]]></description><name>labelSeparator</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS style specification string to apply directly to this field's label. Defaults to the container's labelStyle value
 if set (e.g., Ext.layout.FormLayout.labelStyle , or ''). Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         labelStyle: 'font-weight:bold;'
     }]
 });]]></description><name>labelStyle</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to 'table'. See Ext.Container.layout.]]></description><name>layout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout or one of the two BoxLayout subclasses. An object containing margins to apply to this BoxComponent in the
 format: {
     top: (top margin),
     right: (right margin),
     bottom: (bottom margin),
     left: (left margin)
 } May
 also be a string containing space-separated, numeric margin values. The order of the sides associated with each value
 matches the way CSS processes margin values: If there is only one value, it applies to all sides. If there are two
 values, the top and bottom borders are set to the first value and the right and left are set to the second. If there are
 three values, the top is set to the first value, the left and right are set to the second, and the bottom is set to the
 third. If there are four values, they apply to the top, right, bottom, and left, respectively. Defaults to: {top:0,
 right:0, bottom:0, left:0}]]></description><name>margins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to mask the panel when it is disabled, false to not mask it (defaults to true). Either way, the panel will always
 tell its contained elements to disable themselves when it is disabled, but masking the panel can provide an additional
 visual cue that the panel is disabled.]]></description><name>maskDisabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Minimum width in pixels of all buttons in this panel (defaults to 75)]]></description><name>minButtonWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically monitor window resize events to handle anything that is sensitive to the current size of the
 viewport. This value is typically managed by the chosen layout and should not need to be set manually.]]></description><name>monitorResize</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element when the mouse moves over the Element, and
 removed when the mouse moves out. (defaults to ''). This can be useful for adding customized 'active' or 'hover' styles
 to the component or any of its children using standard CSS rules.]]></description><name>overCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A shortcut for setting a padding style on the body element. The value can either be a number to be applied to all sides,
 or a normal css string describing padding. Defaults to undefined.]]></description><name>padding</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level x coordinate for this component if contained within a positioning container.]]></description><name>pageX</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level y coordinate for this component if contained within a positioning container.]]></description><name>pageY</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to false. When set to true, an extra css class 'x-panel-normal' will be added to the panel's element,
 effectively applying css styles suggested by the W3C (see http://www.w3.org/TR/CSS21/sample.html) to the Panel's body
 element (not the header, footer, etc.).]]></description><name>preventBodyReset</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered ptype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a Plugin is being specified not as a fully
 instantiated Component, but as a Component config object. The ptype will be looked up at render time up to determine
 what type of Plugin to create. If you create your own Plugins, you may register them using
 Ext.ComponentMgr.registerPlugin in order to be able to take advantage of lazy instantiation and rendering.]]></description><name>ptype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A path specification, relative to the Component's ownerCt specifying into which ancestor Container to place a named
 reference to this Component. The ancestor axis can be traversed by using '/' characters in the path. For example, to put
 a reference to a Toolbar Button into the Panel which owns the Toolbar: var myGrid = new Ext.grid.EditorGridPanel({
    
 title: 'My EditorGridPanel',
     store: myStore,
     colModel: myColModel,
     tbar: [{
         text: 'Save',
        
 handler: saveChanges,
         disabled: true,
         ref: '../saveButton'
     }],
     listeners: {
         afteredit:
 function() {
 //          The button reference is in the GridPanel
             myGrid.saveButton.enable();
         }
    
 }
 }); In the code above, if the ref had been 'saveButton' the reference would have been placed into the Toolbar. Each
 '/' in the ref moves up one level from the Component's ownerCt. Also see the added and removed events.]]></description><name>ref</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout layout manager (e.g. specifying layout:'border'). See Ext.layout.BorderLayout also.]]></description><name>region</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The event to listen to for resizing in layouts. Defaults to 'bodyresize'.]]></description><name>resizeEvent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true (or a valid Ext.Shadow Ext.Shadow.mode value) to display a shadow behind the panel, false to display no shadow
 (defaults to 'sides'). Note that this option only applies when floating = true.]]></description><name>shadow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The number of pixels to offset the shadow if displayed (defaults to 4). Note that this option only applies when floating
 = true.]]></description><name>shadowOffset</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[false to disable the iframe shim in browsers which need one (defaults to true). Note that this option only applies when
 floating = true.]]></description><name>shim</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should trigger this component to save its state (defaults to none). stateEvents may
 be any type of event supported by this component, including browser or custom events (e.g., ['click',
 'customerchange']). See stateful for an explanation of saving and restoring Component state.]]></description><name>stateEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id for this component to use for state management purposes (defaults to the component id if one was set,
 otherwise null if the component is using a generated id). See stateful for an explanation of saving and restoring
 Component state.]]></description><name>stateId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A flag which causes the Component to attempt to restore the state of internal properties from a saved state on startup.
 The component must have either a stateId or id assigned for state to be managed. Auto-generated ids are not guaranteed
 to be stable across page loads and cannot be relied upon to save and restore the same state for a component. For state
 saving to work, the state manager's provider must have been set to an implementation of Ext.state.Provider which
 overrides the set and get methods to save and recall name/value pairs. A built-in implementation,
 Ext.state.CookieProvider is available. To set the state provider for the current page: Ext.state.Manager.setProvider(new
 Ext.state.CookieProvider({
     expires: new Date(new Date().getTime()+(1000*60*60*24*7)), //7 days from now
 })); A
 stateful Component attempts to save state when one of the events listed in the stateEvents configuration fires. To save
 state, a stateful Component first serializes its state by calling getState. By default, this function does nothing. The
 developer must provide an implementation which returns an object hash which represents the Component's restorable state.
 The value yielded by getState is passed to Ext.state.Manager.set which uses the configured Ext.state.Provider to save
 the object keyed by the Component's stateId, or, if that is not specified, its id. During construction, a stateful
 Component attempts to restore its state by calling Ext.state.Manager.get passing the stateId, or, if that is not
 specified, the id. The resulting object is passed to applyState. The default implementation of applyState simply copies
 properties into the object, but a developer may override this to support more behaviour. You can perform extra
 processing on state save and restore by attaching handlers to the beforestaterestore, staterestore, beforestatesave and
 statesave events.]]></description><name>stateful</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
     title: 'Some Title',
     renderTo: Ext.getBody(),
     width: 400, height:
 300,
     layout: 'form',
     items: [{
         xtype: 'textarea',
         style: {
             width: '95%',
            
 marginBottom: '10px'
         }
     },
         new Ext.Button({
             text: 'Send',
             minWidth: '100',
   
          style: {
                 marginBottom: '10px'
             }
         })
     ]
 });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is a child item of a TabPanel. A string to be used as innerHTML
 (html tags are accepted) to show in a tooltip when mousing over the associated tab selector element.
 Ext.QuickTips.init() must be called in order for the tips to render.]]></description><name>tabTip</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The title text to be used as innerHTML (html tags are accepted) to display in the panel header (defaults to ''). When a
 title is specified the header element will automatically be created and displayed unless header is explicitly set to
 false. If you do not want to specify a title at config time, but you may want one later, you must either specify a
 non-empty title (a blank space ' ' will do) or header:true so that the container element will get created.]]></description><name>title</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to allow expanding and collapsing the panel (when collapsible = true) by clicking anywhere in the header bar,
 false) to allow it only by clicking to tool button (defaults to false)). If this panel is a child item of a border
 layout also see the BorderLayout.Region floatable config option.]]></description><name>titleCollapse</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A Template used to create tools in the header Element. Defaults to: new Ext.Template('<div class="x-tool
 x-tool-{id}">&#160;</div>') This may may be overridden to provide a custom DOM structure for tools based upon a more
 complex XTemplate. The template's data is a single tool configuration object (Not the entire Array) as specified in
 tools. In the following example an <a> tag is used to provide a visual indication when hovering over the tool: var win =
 new Ext.Window({
     tools: [{
         id: 'download',
         href: '/MyPdfDoc.pdf'
     }],
     toolTemplate: new
 Ext.XTemplate(
         '<tpl if="id==\'download\'">',
             '<a class="x-tool x-tool-pdf" href="{href}"></a>',
    
 '</tpl>',
         '<tpl if="id!=\'download\'">',
             '<div class="x-tool x-tool-{id}">&#160;</div>',
        
 '</tpl>'
     ),
     width:500,
     height:300,
     closeAction:'hide'
 }); Note that the CSS class 'x-tool-pdf' should
 have an associated style rule which provides an appropriate background image, something like: a.x-tool-pdf
 {background-image: url(../shared/extjs/images/pdf.gif)!important;}]]></description><name>toolTemplate</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of tool button configs to be added to the header tool area. When rendered, each tool is stored as an Element
 referenced by a public property called tools.<tool-type> Each tool config may contain the following properties: id :
 String Required. The type of tool to create. By default, this assigns a CSS class of the form x-tool-<tool-type> to the
 resulting tool Element. Ext provides CSS rules, and an icon sprite containing images for the tool types listed below.
 The developer may implement custom tools by supplying alternate CSS rules and background images: toggle (Created by
 default when collapsible is true) close minimize maximize restore gear pin unpin right left up down refresh minus plus
 help search save print handler : Function Required. The function to call when clicked. Arguments passed are: event :
 Ext.EventObject The click event. toolEl : Ext.Element The tool Element. panel : Ext.Panel The host Panel tc : Object The
 tool configuration object stopEvent : Boolean Defaults to true. Specify as false to allow click event to propagate.
 scope : Object The scope in which to call the handler. qtip : String/Object A tip string, or a config argument to
 Ext.QuickTip.register hidden : Boolean True to initially render hidden. on : Object A listener config object specifiying
 event listeners in the format of an argument to addListener Note that, apart from the toggle tool which is provided when
 a panel is collapsible, these tools only provide the visual button. Any required functionality must be provided by
 adding handlers that implement the necessary behavior. Example usage: tools:[{
     id:'refresh',
     qtip: 'Refresh form
 Data',
     // hidden:true,
     handler: function(event, toolEl, panel){
         // refresh logic
     }
 },
 {
    
 id:'help',
     qtip: 'Get Help',
     handler: function(event, toolEl, panel){
         // whatever
     }
 }] For the
 custom id of 'help' define two relevant css classes with a link to a 15x15 image: .x-tool-help {background-image:
 url(images/help.png);}
 .x-tool-help-over {background-image: url(images/help_over.png);}
 // if using an image
 sprite:
 .x-tool-help {background-image: url(images/help.png) no-repeat 0 0;}
 .x-tool-help-over
 {background-position:-15px 0;}]]></description><name>tools</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Overrides the baseCls setting to baseCls = 'x-plain' which renders the panel unstyled except for required attributes for
 Ext layouts to function (e.g. overflow:hidden).]]></description><name>unstyled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local x (left) coordinate for this component if contained within a positioning container.]]></description><name>x</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered xtype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a child item of a Container is being specified not
 as a fully instantiated Component, but as a Component config object. The xtype will be looked up at render time up to
 determine what type of child Component to create. The predefined xtypes are listed here. If you subclass Components to
 create your own Components, you may register them using Ext.ComponentMgr.registerType in order to be able to take
 advantage of lazy instantiation and rendering.]]></description><name>xtype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local y (top) coordinate for this component if contained within a positioning container.]]></description><name>y</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><name>cfg</name><tag-class>org.brushingbits.jnap.ui.extjs3.Config</tag-class><body-content>JSP</body-content><attribute><name>name</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>type</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>value</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 Simple color palette class for choosing colors. The palette can be rendered to any container.
 <br /> Here's an example
 of typical usage: 
 <pre><code><b>var</b> cp = <b>new</b> Ext.ColorPalette({value:<em>'993300'</em>});  <i>// initial
 selected color</i>
 cp.render(<em>'my-div'</em>);
 
 cp.on(<em>'select'</em>, <b>function</b>(palette, selColor){
     <i>//
 <b>do</b> something <b>with</b> selColor</i>
 });</code></pre>]]></description><name>colorPalette</name><tag-class>org.brushingbits.jnap.ui.extjs3.ColorPalette</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[Whether the component can move the Dom node when rendering (defaults to true).]]></description><name>allowDomMove</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If set to true then reselecting a color that is already selected fires the select event]]></description><name>allowReselect</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element corresponding to a DIV that is already present in
 the document that specifies some structural markup for this component. Description : When applyTo is used, constituent
 parts of the component can also be specified by id or CSS class name within the main element, and the component being
 created may attempt to create its subcomponents from that markup if applicable. Notes : When using this config, a call
 to render() is not required. If applyTo is specified, any value passed for renderTo will be ignored and the target
 element's parent node will automatically be used as the component's container.]]></description><name>applyTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A tag name or DomHelper spec used to create the Element which will encapsulate this Component. You do not normally need
 to specify this. For the base classes Ext.Component, Ext.BoxComponent, and Ext.Container, this defaults to 'div'. The
 more complex Ext classes use a more complex DOM structure created by their own onRender methods. This is intended to
 allow the developer to create application-specific utility Components encapsulated by different DOM elements. Example
 usage: <pre><code>{
     xtype: 'box',
     autoEl: {
         tag: 'img',
         src: 'http://www.example.com/example.jpg'
     }
 },
 {
     xtype: 'box',
     autoEl: {
         tag: 'blockquote',
         html: 'autoEl is cool!'
     }
 }, {
     xtype: 'container',
     autoEl: 'ul',
     cls: 'ux-unordered-list',
     items: {
         xtype: 'box',
         autoEl: 'li',
   
      html: 'First list item'
     }
 }</pre></code>]]></description><name>autoEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True if the component should check for hidden classes (e.g. 'x-hidden' or 'x-hide-display') and remove them on render
 (defaults to false).]]></description><name>autoShow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to [].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class used to to apply to the special clearing div rendered directly after each form field wrapper to provide
 field clearing (defaults to 'x-form-clear-left'). Note: this config is only used when this Component is rendered by a
 Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or specifying
 layout:'form') and either a fieldLabel is specified or isFormField=true is specified. See Ext.layout.FormLayout.fieldTpl
 also.]]></description><name>clearCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The DOM event that will cause a color to be selected. This can be any valid event name (dblclick, contextmenu). Defaults
 to 'click'.]]></description><name>clickEvent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element (defaults to ''). This can be useful for
 adding customized styles to the component or any of its children using standard CSS rules.]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's container. This can be useful for adding customized
 styles to the container or any of its children using standard CSS rules. See Ext.layout.ContainerLayout.extraCls also.
 Note: ctCls defaults to '' except for the following class which assigns a value by default: Box Layout :
 'x-box-layout-ct' To configure the above Class with an extra CSS class append to the default. For example, for BoxLayout
 (Hbox and Vbox): ctCls: 'x-box-layout-ct custom-class']]></description><name>ctCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component disabled (default is false).]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class added to the component when it is disabled (defaults to 'x-item-disabled').]]></description><name>disabledClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The label text to display next to this Component (defaults to ''). Note: this config is only used when this Component is
 rendered by a Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or
 specifying layout:'form'). Also see hideLabel and Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
    
 height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name'
    
 }]
 });]]></description><name>fieldLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. A function that will handle the select event of this palette. The handler is passed the following parameters:
 palette : ColorPalette The Ext.ColorPalette. color : String The 6-digit color hex code (without the # symbol).]]></description><name>handler</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component hidden (default is false). If true, the hide method will be called internally.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to completely hide the label element (label and separator). Defaults to false. By default, even if you do not
 specify a fieldLabel the space will still be reserved so that the field will line up with other fields that do have
 labels. Setting this to true will cause the field to not reserve that space. Note: see the note for clearCls. Example
 use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield'
        
 hideLabel: true
     }]
 });]]></description><name>hideLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[How this component should be hidden. Supported values are 'visibility' (css visibility), 'offsets' (negative offset
 position) and 'display' (css display). Note: the default of 'display' is generally preferred since items are
 automatically laid out when they are first shown (no sizing is done while hidden).]]></description><name>hideMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide and show the component's container when hide/show is called on the component, false to hide and show the
 component itself (defaults to false). For example, this can be used as a shortcut for a hide button on a window by
 setting hide:true on the button when adding it to its parent container.]]></description><name>hideParent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id of this component (defaults to an auto-assigned id). You should assign an id if you need to be able to
 access the component later and you do not have an object reference available (e.g., using Ext.getCmp). Note that this id
 will also be used as the element id for the containing HTML element that is rendered to the page for this component.
 This allows you to write id-based CSS rules to style the specific instance of this component uniquely, and also to
 select sub-elements using this component's id as the parent. Note: to avoid complications imposed by a unique id also
 see itemId and ref. Note: to access the container of an item see ownerCt.]]></description><name>id</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class to apply to the containing element (defaults to 'x-color-palette')]]></description><name>itemCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An itemId can be used as an alternative way to get a reference to a component when no object reference is available.
 Instead of using an id with Ext.getCmp, use itemId with Ext.Container.getComponent which will retrieve itemId's or id's.
 Since itemId's are an index to the container's internal MixedCollection, the itemId is scoped locally to the container
 -- avoiding potential conflicts with Ext.ComponentMgr which requires a unique id. var c = new Ext.Panel({ //
     height:
 300,
     renderTo: document.body,
     layout: 'auto',
     items: [
         {
             itemId: 'p1',
            
 title: 'Panel 1',
             height: 150
         },
         {
             itemId: 'p2',
             title: 'Panel 2',
  
 height: 150
         }
     ]
 })
 p1 = c.getComponent('p1'); // not the same as Ext.getCmp()
 p2 =
 p1.ownerCt.getComponent('p2'); // reference via a sibling Also see id and ref. Note: to access the container of an item
 see ownerCt.]]></description><name>itemId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The separator to display after the text of each fieldLabel. This property may be configured at various levels. The order
 of precedence is: field / component level container level layout level (defaults to colon ':') To display no separator
 for this field's label specify empty string ''. Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 layoutConfig: {
         labelSeparator: '~'   // layout config has lowest priority (defaults to ':')
     },
    
 labelSeparator: '>>',     // config at container level
     items: [{
         xtype: 'textfield',
         fieldLabel:
 'Field 1',
         labelSeparator: '...' // field/component level config supersedes others
     },{
         xtype:
 'textfield',
         fieldLabel: 'Field 2' // labelSeparator will be '='
     }]
 });]]></description><name>labelSeparator</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS style specification string to apply directly to this field's label. Defaults to the container's labelStyle value
 if set (e.g., Ext.layout.FormLayout.labelStyle , or ''). Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         labelStyle: 'font-weight:bold;'
     }]
 });]]></description><name>labelStyle</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element when the mouse moves over the Element, and
 removed when the mouse moves out. (defaults to ''). This can be useful for adding customized 'active' or 'hover' styles
 to the component or any of its children using standard CSS rules.]]></description><name>overCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered ptype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a Plugin is being specified not as a fully
 instantiated Component, but as a Component config object. The ptype will be looked up at render time up to determine
 what type of Plugin to create. If you create your own Plugins, you may register them using
 Ext.ComponentMgr.registerPlugin in order to be able to take advantage of lazy instantiation and rendering.]]></description><name>ptype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A path specification, relative to the Component's ownerCt specifying into which ancestor Container to place a named
 reference to this Component. The ancestor axis can be traversed by using '/' characters in the path. For example, to put
 a reference to a Toolbar Button into the Panel which owns the Toolbar: var myGrid = new Ext.grid.EditorGridPanel({
    
 title: 'My EditorGridPanel',
     store: myStore,
     colModel: myColModel,
     tbar: [{
         text: 'Save',
        
 handler: saveChanges,
         disabled: true,
         ref: '../saveButton'
     }],
     listeners: {
         afteredit:
 function() {
 //          The button reference is in the GridPanel
             myGrid.saveButton.enable();
         }
    
 }
 }); In the code above, if the ref had been 'saveButton' the reference would have been placed into the Toolbar. Each
 '/' in the ref moves up one level from the Component's ownerCt. Also see the added and removed events.]]></description><name>ref</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The scope (this reference) in which the handler function will be called. Defaults to this ColorPalette instance.]]></description><name>scope</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should trigger this component to save its state (defaults to none). stateEvents may
 be any type of event supported by this component, including browser or custom events (e.g., ['click',
 'customerchange']). See stateful for an explanation of saving and restoring Component state.]]></description><name>stateEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id for this component to use for state management purposes (defaults to the component id if one was set,
 otherwise null if the component is using a generated id). See stateful for an explanation of saving and restoring
 Component state.]]></description><name>stateId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A flag which causes the Component to attempt to restore the state of internal properties from a saved state on startup.
 The component must have either a stateId or id assigned for state to be managed. Auto-generated ids are not guaranteed
 to be stable across page loads and cannot be relied upon to save and restore the same state for a component. For state
 saving to work, the state manager's provider must have been set to an implementation of Ext.state.Provider which
 overrides the set and get methods to save and recall name/value pairs. A built-in implementation,
 Ext.state.CookieProvider is available. To set the state provider for the current page: Ext.state.Manager.setProvider(new
 Ext.state.CookieProvider({
     expires: new Date(new Date().getTime()+(1000*60*60*24*7)), //7 days from now
 })); A
 stateful Component attempts to save state when one of the events listed in the stateEvents configuration fires. To save
 state, a stateful Component first serializes its state by calling getState. By default, this function does nothing. The
 developer must provide an implementation which returns an object hash which represents the Component's restorable state.
 The value yielded by getState is passed to Ext.state.Manager.set which uses the configured Ext.state.Provider to save
 the object keyed by the Component's stateId, or, if that is not specified, its id. During construction, a stateful
 Component attempts to restore its state by calling Ext.state.Manager.get passing the stateId, or, if that is not
 specified, the id. The resulting object is passed to applyState. The default implementation of applyState simply copies
 properties into the object, but a developer may override this to support more behaviour. You can perform extra
 processing on state save and restore by attaching handlers to the beforestaterestore, staterestore, beforestatesave and
 statesave events.]]></description><name>stateful</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
     title: 'Some Title',
     renderTo: Ext.getBody(),
     width: 400, height:
 300,
     layout: 'form',
     items: [{
         xtype: 'textarea',
         style: {
             width: '95%',
            
 marginBottom: '10px'
         }
     },
         new Ext.Button({
             text: 'Send',
             minWidth: '100',
   
          style: {
                 marginBottom: '10px'
             }
         })
     ]
 });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial color to highlight (should be a valid 6-digit color hex code without the # symbol). Note that the hex codes
 are case-sensitive.]]></description><name>value</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered xtype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a child item of a Container is being specified not
 as a fully instantiated Component, but as a Component config object. The xtype will be looked up at render time up to
 determine what type of child Component to create. The predefined xtypes are listed here. If you subclass Components to
 create your own Components, you may register them using Ext.ComponentMgr.registerType in order to be able to take
 advantage of lazy instantiation and rendering.]]></description><name>xtype</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 <p>Base class for any <a href="output/Ext.BoxComponent.html" ext:cls="Ext.BoxComponent">Ext.BoxComponent</a> that may
 contain other Components. Containers handle the basic behavior of containing items, namely adding, inserting and
 removing items.</p> 
 <p>The most commonly used Container classes are <a href="output/Ext.Panel.html"
 ext:cls="Ext.Panel">Ext.Panel</a>, <a href="output/Ext.Window.html" ext:cls="Ext.Window">Ext.Window</a> and <a
 href="output/Ext.TabPanel.html" ext:cls="Ext.TabPanel">Ext.TabPanel</a>. If you do not need the capabilities offered by
 the aforementioned classes you can create a lightweight Container to be encapsulated by an HTML element to your
 specifications by using the <code><b><a href="output/Ext.Component.html#Ext.Component-autoEl" ext:member="autoEl"
 ext:cls="Ext.Component">autoEl</a></b></code> config option. This is a useful technique when creating embedded <a
 href="output/Ext.layout.ColumnLayout.html" ext:cls="Ext.layout.ColumnLayout">column</a> layouts inside <a
 href="output/Ext.form.FormPanel.html" ext:cls="Ext.form.FormPanel">FormPanels</a> for example.</p> 
 <p>The code below
 illustrates both how to explicitly create a Container, and how to implicitly create one using the
 <b><code><em>'container'</em></code></b> xtype:</p>
 <pre><code><i>// explicitly create a Container</i>
 <b>var</b>
 embeddedColumns = <b>new</b> Ext.Container({
     autoEl: <em>'div'</em>,  <i>// This is the <b>default</b></i>
    
 layout: <em>'column'</em>,
     defaults: {
         <i>// implicitly create Container by specifying xtype</i>
        
 xtype: <em>'container'</em>,
         autoEl: <em>'div'</em>, <i>// This is the <b>default</b>.</i>
         layout:
 <em>'form'</em>,
         columnWidth: 0.5,
         style: {
             padding: <em>'10px'</em>
         }
     },
 <i>// 
 The two items below will be Ext.Containers, each encapsulated by a &lt;DIV&gt; element.</i>
     items: [{
         items:
 {
             xtype: <em>'datefield'</em>,
             name: <em>'startDate'</em>,
             fieldLabel: <em>'Start
 date'</em>
         }
     }, {
         items: {
             xtype: <em>'datefield'</em>,
             name:
 <em>'endDate'</em>,
             fieldLabel: <em>'End date'</em>
         }
     }]
 });</code></pre>
 <p></p>
 
 <p><u><b>Layout</b></u></p> 
 <p>Container classes delegate the rendering of child Components to a layout manager class
 which must be configured into the Container using the <code><b><a href="output/Ext.Container.html#Ext.Container-layout"
 ext:member="layout" ext:cls="Ext.Container">layout</a></b></code> configuration property.</p> 
 <p>When either specifying
 child <code><a href="output/Ext.Container.html#Ext.Container-items" ext:member="items"
 ext:cls="Ext.Container">items</a></code> of a Container, or dynamically <a
 href="output/Ext.Container.html#Ext.Container-add" ext:member="add" ext:cls="Ext.Container">adding</a> Components to a
 Container, remember to consider how you wish the Container to arrange those child elements, and whether those child
 elements need to be sized using one of Ext's built-in <b><code><a href="output/Ext.Container.html#Ext.Container-layout"
 ext:member="layout" ext:cls="Ext.Container">layout</a></code></b> schemes. By default, Containers use the <a
 href="output/Ext.layout.ContainerLayout.html" ext:cls="Ext.layout.ContainerLayout">ContainerLayout</a> scheme which only
 renders child components, appending them one after the other inside the Container, and <b>does not apply any sizing</b>
 at all.</p> 
 <p>A common mistake is when a developer neglects to specify a <b><code><a
 href="output/Ext.Container.html#Ext.Container-layout" ext:member="layout" ext:cls="Ext.Container">layout</a></code></b>
 (e.g. widgets like GridPanels or TreePanels are added to Containers for which no <code><b><a
 href="output/Ext.Container.html#Ext.Container-layout" ext:member="layout" ext:cls="Ext.Container">layout</a></b></code>
 has been specified). If a Container is left to use the default <a href="output/Ext.layout.ContainerLayout.html"
 ext:cls="Ext.layout.ContainerLayout">ContainerLayout</a> scheme, none of its child components will be resized, or
 changed in any way when the Container is resized.</p> 
 <p>Certain layout managers allow dynamic addition of child
 components. Those that do include <a href="output/Ext.layout.CardLayout.html"
 ext:cls="Ext.layout.CardLayout">Ext.layout.CardLayout</a>, <a href="output/Ext.layout.AnchorLayout.html"
 ext:cls="Ext.layout.AnchorLayout">Ext.layout.AnchorLayout</a>, <a href="output/Ext.layout.FormLayout.html"
 ext:cls="Ext.layout.FormLayout">Ext.layout.FormLayout</a>, and <a href="output/Ext.layout.TableLayout.html"
 ext:cls="Ext.layout.TableLayout">Ext.layout.TableLayout</a>. For example:</p>
 <pre><code><i>//  Create the
 GridPanel.</i>
 <b>var</b> myNewGrid = <b>new</b> Ext.grid.GridPanel({
     store: myStore,
     columns: myColumnModel,
   
 title: <em>'Results'</em>, <i>// the title becomes the title of the tab</i>
 });
 
 myTabPanel.add(myNewGrid); <i>// <a
 href="output/Ext.TabPanel.html" ext:cls="Ext.TabPanel">Ext.TabPanel</a> implicitly uses <a
 href="output/Ext.layout.CardLayout.html" ext:cls="Ext.layout.CardLayout">CardLayout</a></i>
 myTabPanel.<a
 href="output/Ext.TabPanel.html#Ext.TabPanel-setActiveTab" ext:member="setActiveTab"
 ext:cls="Ext.TabPanel">setActiveTab</a>(myNewGrid);</code></pre>
 <p></p> 
 <p>The example above adds a newly created
 GridPanel to a TabPanel. Note that a TabPanel uses <a href="output/Ext.layout.CardLayout.html"
 ext:cls="Ext.layout.CardLayout">Ext.layout.CardLayout</a> as its layout manager which means all its child items are
 sized to <a href="output/Ext.layout.FitLayout.html" ext:cls="Ext.layout.FitLayout">fit</a> exactly into its client area.
 </p>
 <p><b><u>Overnesting is a common problem</u></b>. An example of overnesting occurs when a GridPanel is added to a
 TabPanel by wrapping the GridPanel <i>inside</i> a wrapping Panel (that has no <code><b><a
 href="output/Ext.Container.html#Ext.Container-layout" ext:member="layout" ext:cls="Ext.Container">layout</a></b></code>
 specified) and then add that wrapping Panel to the TabPanel. The point to realize is that a GridPanel <b>is</b> a
 Component which can be added directly to a Container. If the wrapping Panel has no <code><b><a
 href="output/Ext.Container.html#Ext.Container-layout" ext:member="layout" ext:cls="Ext.Container">layout</a></b></code>
 configuration, then the overnested GridPanel will not be sized as expected.</p>
 <p> </p>
 <p><u><b>Adding via remote
 configuration</b></u></p> 
 <p>A server side script can be used to add Components which are generated dynamically on the
 server. An example of adding a GridPanel to a TabPanel where the GridPanel is generated by the server based on certain
 parameters: </p>
 <pre><code><i>// execute an Ajax request to invoke server side script:</i>
 Ext.Ajax.request({
     url:
 <em>'gen-invoice-grid.php'</em>,
     <i>// send additional parameters to instruct server script</i>
     params: {
       
 startDate: Ext.getCmp(<em>'start-date'</em>).getValue(),
         endDate: Ext.getCmp(<em>'end-date'</em>).getValue()
    
 },
     <i>// process the response object to add it to the TabPanel:</i>
     success: <b>function</b>(xhr) {
        
 <b>var</b> newComponent = eval(xhr.responseText); <i>// see discussion below</i>
         myTabPanel.add(newComponent);
 <i>// add the component to the TabPanel</i>
         myTabPanel.setActiveTab(newComponent);
     },
     failure:
 <b>function</b>() {
         Ext.Msg.alert(<em>&quot;Grid create failed&quot;</em>, <em>&quot;Server communication
 failure&quot;</em>);
     }
 });</code></pre> 
 <p>The server script needs to return an executable Javascript statement
 which, when processed using <code>eval()</code>, will return either a config object with an <a
 href="output/Ext.Component.html#Ext.Component-xtype" ext:member="xtype" ext:cls="Ext.Component">xtype</a>, or an
 instantiated Component. The server might return this for example:</p>
 <pre><code>(<b>function</b>() {
    
 <b>function</b> formatDate(value){
         <b>return</b> value ? value.dateFormat(<em>'M d, Y'</em>) : <em>''</em>;
    
 };
 
     <b>var</b> store = <b>new</b> Ext.data.Store({
         url: <em>'get-invoice-data.php'</em>,
         baseParams:
 {
             startDate: <em>'01/01/2008'</em>,
             endDate: <em>'01/31/2008'</em>
         },
         reader:
 <b>new</b> Ext.data.JsonReader({
             record: <em>'transaction'</em>,
             idProperty: <em>'id'</em>,
     
 totalRecords: <em>'total'</em>
         }, [
            <em>'customer'</em>,
            <em>'invNo'</em>,
           
 {name: <em>'date'</em>, type: <em>'date'</em>, dateFormat: <em>'m/d/Y'</em>},
            {name: <em>'value'</em>, type:
 <em>'float'</em>}
         ])
     });
 
     <b>var</b> grid = <b>new</b> Ext.grid.GridPanel({
         title: <em>'Invoice
 Report'</em>,
         bbar: <b>new</b> Ext.PagingToolbar(store),
         store: store,
         columns: [
            
 {header: <em>&quot;Customer&quot;</em>, width: 250, dataIndex: <em>'customer'</em>, sortable: true},
            
 {header: <em>&quot;Invoice Number&quot;</em>, width: 120, dataIndex: <em>'invNo'</em>, sortable: true},
            
 {header: <em>&quot;Invoice Date&quot;</em>, width: 100, dataIndex: <em>'date'</em>, renderer: formatDate, sortable:
 true},
             {header: <em>&quot;Value&quot;</em>, width: 120, dataIndex: <em>'value'</em>, renderer:
 <em>'usMoney'</em>, sortable: true}
         ],
     });
     store.load();
     <b>return</b> grid;  <i>// <b>return</b>
 instantiated component</i>
 })();</code></pre> 
 <p>When the above code fragment is passed through the <code>eval</code>
 function in the success handler of the Ajax request, the code is executed by the Javascript processor, and the anonymous
 function runs, and returns the instantiated grid component.</p> 
 <p>Note: since the code above is <i>generated</i> by a
 server script, the <code>baseParams</code> for the Store, the metadata to allow generation of the Record layout, and the
 ColumnModel can all be generated into the code since these are all known on the server.</p>]]></description><name>container</name><tag-class>org.brushingbits.jnap.ui.extjs3.Container</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[A string component id or the numeric index of the component that should be initially activated within the container's
 layout on render. For example, activeItem: 'item-1' or activeItem: 0 (index 0 = the first item in the container's
 collection). activeItem only applies to layout styles that can display items one at a time (like
 Ext.layout.AccordionLayout, Ext.layout.CardLayout and Ext.layout.FitLayout). Related to
 Ext.layout.ContainerLayout.activeItem.]]></description><name>activeItem</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Whether the component can move the Dom node when rendering (defaults to true).]]></description><name>allowDomMove</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use an
 AnchorLayout (or subclass thereof). based layout manager, for example: Ext.form.FormPanel specifying layout: 'anchor' //
 or 'form', or 'absolute' See Ext.layout.AnchorLayout.anchor also.]]></description><name>anchor</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element corresponding to a DIV that is already present in
 the document that specifies some structural markup for this component. Description : When applyTo is used, constituent
 parts of the component can also be specified by id or CSS class name within the main element, and the component being
 created may attempt to create its subcomponents from that markup if applicable. Notes : When using this config, a call
 to render() is not required. If applyTo is specified, any value passed for renderTo will be ignored and the target
 element's parent node will automatically be used as the component's container.]]></description><name>applyTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If true the container will automatically destroy any contained component that is removed from it, else destruction must
 be handled manually (defaults to true).]]></description><name>autoDestroy</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A tag name or DomHelper spec used to create the Element which will encapsulate this Component. You do not normally need
 to specify this. For the base classes Ext.Component, Ext.BoxComponent, and Ext.Container, this defaults to 'div'. The
 more complex Ext classes use a more complex DOM structure created by their own onRender methods. This is intended to
 allow the developer to create application-specific utility Components encapsulated by different DOM elements. Example
 usage: <pre><code>{
     xtype: 'box',
     autoEl: {
         tag: 'img',
         src: 'http://www.example.com/example.jpg'
     }
 },
 {
     xtype: 'box',
     autoEl: {
         tag: 'blockquote',
         html: 'autoEl is cool!'
     }
 }, {
     xtype: 'container',
     autoEl: 'ul',
     cls: 'ux-unordered-list',
     items: {
         xtype: 'box',
         autoEl: 'li',
   
      html: 'First list item'
     }
 }</pre></code>]]></description><name>autoEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to use height:'auto', false to use fixed height (or allow it to be managed by its parent Container's layout
 manager. Defaults to false. Note: Although many components inherit this config option, not all will function as expected
 with a height of 'auto'. Setting autoHeight:true means that the browser will manage height based on the element's
 contents, and that Ext will not manage it at all. If the browser is managing the height, be aware that resizes performed
 by the browser in response to changes within the structure of the Component cannot be detected. Therefore changes to the
 height might result in elements needing to be synchronized with the new height. Example: var w = new Ext.Window({
    
 title: 'Window',
     width: 600,
     autoHeight: true,
     items: {
         title: 'Collapse Me',
         height: 400,
  
 collapsible: true,
         border: false,
         listeners: {
             beforecollapse: function() {
                w.el.shadow.hide();
             },
             beforeexpand: function() {
                w.el.shadow.hide();
             },
             collapse: function() {
                w.syncShadow();
             },
             expand: function() {
                w.syncShadow();
             }
         }
     }
 }).show();]]></description><name>autoHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to use overflow:'auto' on the components layout element and show scroll bars automatically when necessary, false to
 clip any overflowing content (defaults to false).]]></description><name>autoScroll</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True if the component should check for hidden classes (e.g. 'x-hidden' or 'x-hide-display') and remove them on render
 (defaults to false).]]></description><name>autoShow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to use width:'auto', false to use fixed width (or allow it to be managed by its parent Container's layout manager.
 Defaults to false. Note: Although many components inherit this config option, not all will function as expected with a
 width of 'auto'. Setting autoWidth:true means that the browser will manage width based on the element's contents, and
 that Ext will not manage it at all. If the browser is managing the width, be aware that resizes performed by the browser
 in response to changes within the structure of the Component cannot be detected. Therefore changes to the width might
 result in elements needing to be synchronized with the new width. For example, where the target element is: <div
 id='grid-container' style='margin-left:25%;width:50%'></div> A Panel rendered into that target element must listen for
 browser window resize in order to relay its child items when the browser changes its width: var myPanel = new
 Ext.Panel({
     renderTo: 'grid-container',
     monitorResize: true, // relay on browser resize
     title: 'Panel',
    
 height: 400,
     autoWidth: true,
     layout: 'hbox',
     layoutConfig: {
         align: 'stretch'
     },
     defaults: {
         flex: 1
     },
     items: [{
         title: 'Box 1',
     }, {
         title: 'Box 2'
     }, {
         title:
 'Box 3'
     }],
 });]]></description><name>autoWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to ['add', 'remove'].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[When set to true (50 milliseconds) or a number of milliseconds, the layout assigned for this container will buffer the
 frequency it calculates and does a re-layout of components. This is useful for heavy containers or containers with a
 large quantity of sub-components for which frequent layout calls would be expensive. Defaults to 50.]]></description><name>bufferResize</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class used to to apply to the special clearing div rendered directly after each form field wrapper to provide
 field clearing (defaults to 'x-form-clear-left'). Note: this config is only used when this Component is rendered by a
 Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or specifying
 layout:'form') and either a fieldLabel is specified or isFormField=true is specified. See Ext.layout.FormLayout.fieldTpl
 also.]]></description><name>clearCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element (defaults to ''). This can be useful for
 adding customized styles to the component or any of its children using standard CSS rules.]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's container. This can be useful for adding customized
 styles to the container or any of its children using standard CSS rules. See Ext.layout.ContainerLayout.extraCls also.
 Note: ctCls defaults to '' except for the following class which assigns a value by default: Box Layout :
 'x-box-layout-ct' To configure the above Class with an extra CSS class append to the default. For example, for BoxLayout
 (Hbox and Vbox): ctCls: 'x-box-layout-ct custom-class']]></description><name>ctCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default xtype of child Components to create in this Container when a child item is specified as a raw configuration
 object, rather than as an instantiated Component. Defaults to 'panel', except Ext.menu.Menu which defaults to
 'menuitem', and Ext.Toolbar and Ext.ButtonGroup which default to 'button'.]]></description><name>defaultType</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[This option is a means of applying default settings to all added items whether added through the items config or via the
 add or insert methods. If an added item is a config object, and not an instantiated Component, then the default
 properties are unconditionally applied. If the added item is an instantiated Component, then the default properties are
 applied conditionally so as not to override existing properties in the item. If the defaults option is specified as a
 function, then the function will be called using this Container as the scope (this reference) and passing the added item
 as the first parameter. Any resulting object from that call is then applied to the item as default properties. For
 example, to automatically apply padding to the body of each of a set of contained Ext.Panel items, you could pass:
 defaults: {bodyStyle:'padding:15px'}. Usage: defaults: {               // defaults are applied to items, not the
 container
     autoScroll:true
 },
 items: [
     {
         xtype: 'panel',   // defaults do not have precedence over
       
 id: 'panel1',     // options in config objects, so the defaults
         autoScroll: false // will not be applied here,
 panel1 will be autoScroll:false
     },
     new Ext.Panel({       // defaults do have precedence over options
         id:
 'panel2',     // options in components, so the defaults
         autoScroll: false // will be applied here, panel2 will
 be autoScroll:true.
     })
 ]]]></description><name>defaults</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component disabled (default is false).]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class added to the component when it is disabled (defaults to 'x-item-disabled').]]></description><name>disabledClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The label text to display next to this Component (defaults to ''). Note: this config is only used when this Component is
 rendered by a Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or
 specifying layout:'form'). Also see hideLabel and Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
    
 height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name'
    
 }]
 });]]></description><name>fieldLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use a
 BoxLayout. Each child Component with a flex property will be flexed either vertically (by a VBoxLayout) or horizontally
 (by an HBoxLayout) according to the item's relative flex value compared to the sum of all Components with flex value
 specified. Any child items that have either a flex = 0 or flex = undefined will not be 'flexed' (the initial size will
 not be changed).]]></description><name>flex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If true the container will force a layout initially even if hidden or collapsed. This option is useful for forcing forms
 to render in collapsed or hidden containers. (defaults to false).]]></description><name>forceLayout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component hidden (default is false). If true, the hide method will be called internally.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide the borders of each contained component, false to defer to the component's existing border settings
 (defaults to false).]]></description><name>hideBorders</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to completely hide the label element (label and separator). Defaults to false. By default, even if you do not
 specify a fieldLabel the space will still be reserved so that the field will line up with other fields that do have
 labels. Setting this to true will cause the field to not reserve that space. Note: see the note for clearCls. Example
 use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield'
        
 hideLabel: true
     }]
 });]]></description><name>hideLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[How this component should be hidden. Supported values are 'visibility' (css visibility), 'offsets' (negative offset
 position) and 'display' (css display). Note: the default of 'display' is generally preferred since items are
 automatically laid out when they are first shown (no sizing is done while hidden).]]></description><name>hideMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide and show the component's container when hide/show is called on the component, false to hide and show the
 component itself (defaults to false). For example, this can be used as a shortcut for a hide button on a window by
 setting hide:true on the button when adding it to its parent container.]]></description><name>hideParent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id of this component (defaults to an auto-assigned id). You should assign an id if you need to be able to
 access the component later and you do not have an object reference available (e.g., using Ext.getCmp). Note that this id
 will also be used as the element id for the containing HTML element that is rendered to the page for this component.
 This allows you to write id-based CSS rules to style the specific instance of this component uniquely, and also to
 select sub-elements using this component's id as the parent. Note: to avoid complications imposed by a unique id also
 see itemId and ref. Note: to access the container of an item see ownerCt.]]></description><name>id</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use the
 FormLayout layout manager (e.g. Ext.form.FormPanel or specifying layout:'form'). An additional CSS class to apply to the
 div wrapping the form item element of this field. If supplied, itemCls at the field level will override the default
 itemCls supplied at the container level. The value specified for itemCls will be added to the default class
 ('x-form-item'). Since it is applied to the item wrapper (see Ext.layout.FormLayout.fieldTpl), it allows you to write
 standard CSS rules that can apply to the field, the label (if specified), or any other element within the markup for the
 field. Note: see the note for fieldLabel. Example use: // Apply a style to the field's label:
 <style>
     .required
 .x-form-item-label {font-weight:bold;color:red;}
 </style>
 
 new Ext.FormPanel({
     height: 100,
     renderTo:
 Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         itemCls: 'required' //this
 label will be styled
     },{
         xtype: 'textfield',
         fieldLabel: 'Favorite Color'
     }]
 });]]></description><name>itemCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An itemId can be used as an alternative way to get a reference to a component when no object reference is available.
 Instead of using an id with Ext.getCmp, use itemId with Ext.Container.getComponent which will retrieve itemId's or id's.
 Since itemId's are an index to the container's internal MixedCollection, the itemId is scoped locally to the container
 -- avoiding potential conflicts with Ext.ComponentMgr which requires a unique id. var c = new Ext.Panel({ //
     height:
 300,
     renderTo: document.body,
     layout: 'auto',
     items: [
         {
             itemId: 'p1',
            
 title: 'Panel 1',
             height: 150
         },
         {
             itemId: 'p2',
             title: 'Panel 2',
  
 height: 150
         }
     ]
 })
 p1 = c.getComponent('p1'); // not the same as Ext.getCmp()
 p2 =
 p1.ownerCt.getComponent('p2'); // reference via a sibling Also see id and ref. Note: to access the container of an item
 see ownerCt.]]></description><name>itemId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The separator to display after the text of each fieldLabel. This property may be configured at various levels. The order
 of precedence is: field / component level container level layout level (defaults to colon ':') To display no separator
 for this field's label specify empty string ''. Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 layoutConfig: {
         labelSeparator: '~'   // layout config has lowest priority (defaults to ':')
     },
    
 labelSeparator: '>>',     // config at container level
     items: [{
         xtype: 'textfield',
         fieldLabel:
 'Field 1',
         labelSeparator: '...' // field/component level config supersedes others
     },{
         xtype:
 'textfield',
         fieldLabel: 'Field 2' // labelSeparator will be '='
     }]
 });]]></description><name>labelSeparator</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS style specification string to apply directly to this field's label. Defaults to the container's labelStyle value
 if set (e.g., Ext.layout.FormLayout.labelStyle , or ''). Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         labelStyle: 'font-weight:bold;'
     }]
 });]]></description><name>labelStyle</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[*Important: In order for child items to be correctly sized and positioned, typically a layout manager must be specified
 through the layout configuration option. The sizing and positioning of child items is the responsibility of the
 Container's layout manager which creates and manages the type of layout you have in mind. For example:
 <pre><code>
 new Ext.Window({
 
 width:300, height: 300,
     layout: 'fit', // explicitly set layout manager: override the default (layout:'auto')
    
 items: [{
         title: 'Panel inside a Window'
     }]
 }).show();</pre></code>
 If the layout configuration is not explicitly
 specified for a general purpose container (e.g. Container or Panel) the default layout manager will be used which does
 nothing but render child components sequentially into the Container (no sizing or positioning will be performed in this
 situation). Some container classes implicitly specify a default layout (e.g. FormPanel specifies layout:'form'). Other
 specific purpose classes internally specify/manage their internal layout (e.g. GridPanel, TabPanel, TreePanel, Toolbar,
 Menu, etc.). layout may be specified as either as an Object or as a String: Specify as an Object Example usage: layout:
 {
     type: 'vbox',
     padding: '5',
     align: 'left'
 } type The layout type to be used for this container. If not
 specified, a default Ext.layout.ContainerLayout will be created and used. Valid layout type values are: absolute
 accordion anchor auto Default border card column fit form hbox menu table toolbar vbox Layout specific configuration
 properties Additional layout specific configuration properties may also be specified. For complete details regarding the
 valid config options for each layout type, see the layout class corresponding to the type specified. Specify as a String
 Example usage: layout: 'vbox',
 layoutConfig: {
     padding: '5',
     align: 'left'
 } layout The layout type to be used
 for this container (see list of valid layout type values above). layoutConfig Additional layout specific configuration
 properties. For complete details regarding the valid config options for each layout type, see the layout class
 corresponding to the layout specified.]]></description><name>layout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout or one of the two BoxLayout subclasses. An object containing margins to apply to this BoxComponent in the
 format: {
     top: (top margin),
     right: (right margin),
     bottom: (bottom margin),
     left: (left margin)
 } May
 also be a string containing space-separated, numeric margin values. The order of the sides associated with each value
 matches the way CSS processes margin values: If there is only one value, it applies to all sides. If there are two
 values, the top and bottom borders are set to the first value and the right and left are set to the second. If there are
 three values, the top is set to the first value, the left and right are set to the second, and the bottom is set to the
 third. If there are four values, they apply to the top, right, bottom, and left, respectively. Defaults to: {top:0,
 right:0, bottom:0, left:0}]]></description><name>margins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically monitor window resize events to handle anything that is sensitive to the current size of the
 viewport. This value is typically managed by the chosen layout and should not need to be set manually.]]></description><name>monitorResize</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element when the mouse moves over the Element, and
 removed when the mouse moves out. (defaults to ''). This can be useful for adding customized 'active' or 'hover' styles
 to the component or any of its children using standard CSS rules.]]></description><name>overCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level x coordinate for this component if contained within a positioning container.]]></description><name>pageX</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level y coordinate for this component if contained within a positioning container.]]></description><name>pageY</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered ptype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a Plugin is being specified not as a fully
 instantiated Component, but as a Component config object. The ptype will be looked up at render time up to determine
 what type of Plugin to create. If you create your own Plugins, you may register them using
 Ext.ComponentMgr.registerPlugin in order to be able to take advantage of lazy instantiation and rendering.]]></description><name>ptype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A path specification, relative to the Component's ownerCt specifying into which ancestor Container to place a named
 reference to this Component. The ancestor axis can be traversed by using '/' characters in the path. For example, to put
 a reference to a Toolbar Button into the Panel which owns the Toolbar: var myGrid = new Ext.grid.EditorGridPanel({
    
 title: 'My EditorGridPanel',
     store: myStore,
     colModel: myColModel,
     tbar: [{
         text: 'Save',
        
 handler: saveChanges,
         disabled: true,
         ref: '../saveButton'
     }],
     listeners: {
         afteredit:
 function() {
 //          The button reference is in the GridPanel
             myGrid.saveButton.enable();
         }
    
 }
 }); In the code above, if the ref had been 'saveButton' the reference would have been placed into the Toolbar. Each
 '/' in the ref moves up one level from the Component's ownerCt. Also see the added and removed events.]]></description><name>ref</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout layout manager (e.g. specifying layout:'border'). See Ext.layout.BorderLayout also.]]></description><name>region</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The event to listen to for resizing in layouts. Defaults to 'resize'.]]></description><name>resizeEvent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should trigger this component to save its state (defaults to none). stateEvents may
 be any type of event supported by this component, including browser or custom events (e.g., ['click',
 'customerchange']). See stateful for an explanation of saving and restoring Component state.]]></description><name>stateEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id for this component to use for state management purposes (defaults to the component id if one was set,
 otherwise null if the component is using a generated id). See stateful for an explanation of saving and restoring
 Component state.]]></description><name>stateId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A flag which causes the Component to attempt to restore the state of internal properties from a saved state on startup.
 The component must have either a stateId or id assigned for state to be managed. Auto-generated ids are not guaranteed
 to be stable across page loads and cannot be relied upon to save and restore the same state for a component. For state
 saving to work, the state manager's provider must have been set to an implementation of Ext.state.Provider which
 overrides the set and get methods to save and recall name/value pairs. A built-in implementation,
 Ext.state.CookieProvider is available. To set the state provider for the current page: Ext.state.Manager.setProvider(new
 Ext.state.CookieProvider({
     expires: new Date(new Date().getTime()+(1000*60*60*24*7)), //7 days from now
 })); A
 stateful Component attempts to save state when one of the events listed in the stateEvents configuration fires. To save
 state, a stateful Component first serializes its state by calling getState. By default, this function does nothing. The
 developer must provide an implementation which returns an object hash which represents the Component's restorable state.
 The value yielded by getState is passed to Ext.state.Manager.set which uses the configured Ext.state.Provider to save
 the object keyed by the Component's stateId, or, if that is not specified, its id. During construction, a stateful
 Component attempts to restore its state by calling Ext.state.Manager.get passing the stateId, or, if that is not
 specified, the id. The resulting object is passed to applyState. The default implementation of applyState simply copies
 properties into the object, but a developer may override this to support more behaviour. You can perform extra
 processing on state save and restore by attaching handlers to the beforestaterestore, staterestore, beforestatesave and
 statesave events.]]></description><name>stateful</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
     title: 'Some Title',
     renderTo: Ext.getBody(),
     width: 400, height:
 300,
     layout: 'form',
     items: [{
         xtype: 'textarea',
         style: {
             width: '95%',
            
 marginBottom: '10px'
         }
     },
         new Ext.Button({
             text: 'Send',
             minWidth: '100',
   
          style: {
                 marginBottom: '10px'
             }
         })
     ]
 });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is a child item of a TabPanel. A string to be used as innerHTML
 (html tags are accepted) to show in a tooltip when mousing over the associated tab selector element.
 Ext.QuickTips.init() must be called in order for the tips to render.]]></description><name>tabTip</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local x (left) coordinate for this component if contained within a positioning container.]]></description><name>x</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered xtype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a child item of a Container is being specified not
 as a fully instantiated Component, but as a Component config object. The xtype will be looked up at render time up to
 determine what type of child Component to create. The predefined xtypes are listed here. If you subclass Components to
 create your own Components, you may register them using Ext.ComponentMgr.registerType in order to be able to take
 advantage of lazy instantiation and rendering.]]></description><name>xtype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local y (top) coordinate for this component if contained within a positioning container.]]></description><name>y</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 A specialized SplitButton that contains a menu of 
 <a href="output/Ext.menu.CheckItem.html"
 ext:cls="Ext.menu.CheckItem">Ext.menu.CheckItem</a> elements. The button automatically cycles through each menu item on
 click, raising the button's 
 <a href="output/Ext.CycleButton.html#Ext.CycleButton-change" ext:member="change"
 ext:cls="Ext.CycleButton">change</a> event (or calling the button's 
 <a
 href="output/Ext.CycleButton.html#Ext.CycleButton-changeHandler" ext:member="changeHandler"
 ext:cls="Ext.CycleButton">changeHandler</a> function, if supplied) for the active menu item. Clicking on the arrow
 section of the button displays the dropdown menu just like a normal SplitButton. Example usage: 
 <pre><code><b>var</b>
 btn = <b>new</b> Ext.CycleButton({
     showText: true,
     prependText: <em>'View as '</em>,
     items: [{
        
 text:<em>'text only'</em>,
         iconCls:<em>'view-text'</em>,
         checked:true
     },{
        
 text:<em>'HTML'</em>,
         iconCls:<em>'view-html'</em>
     }],
     changeHandler:<b>function</b>(btn, item){
        
 Ext.Msg.alert(<em>'Change View'</em>, item.text);
     }
 });</code></pre>]]></description><name>cycleButton</name><tag-class>org.brushingbits.jnap.ui.extjs3.CycleButton</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[False to not allow a pressed Button to be depressed (defaults to undefined). Only valid when enableToggle is true.]]></description><name>allowDepress</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Whether the component can move the Dom node when rendering (defaults to true).]]></description><name>allowDomMove</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use an
 AnchorLayout (or subclass thereof). based layout manager, for example: Ext.form.FormPanel specifying layout: 'anchor' //
 or 'form', or 'absolute' See Ext.layout.AnchorLayout.anchor also.]]></description><name>anchor</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element corresponding to a DIV that is already present in
 the document that specifies some structural markup for this component. Description : When applyTo is used, constituent
 parts of the component can also be specified by id or CSS class name within the main element, and the component being
 created may attempt to create its subcomponents from that markup if applicable. Notes : When using this config, a call
 to render() is not required. If applyTo is specified, any value passed for renderTo will be ignored and the target
 element's parent node will automatically be used as the component's container.]]></description><name>applyTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[(Optional) The side of the Button box to render the arrow if the button has an associated menu. Two values are allowed:
 'right' 'bottom' Defaults to 'right' .]]></description><name>arrowAlign</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A function called when the arrow button is clicked (can be used instead of click event)]]></description><name>arrowHandler</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The title attribute of the arrow]]></description><name>arrowTooltip</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A tag name or DomHelper spec used to create the Element which will encapsulate this Component. You do not normally need
 to specify this. For the base classes Ext.Component, Ext.BoxComponent, and Ext.Container, this defaults to 'div'. The
 more complex Ext classes use a more complex DOM structure created by their own onRender methods. This is intended to
 allow the developer to create application-specific utility Components encapsulated by different DOM elements. Example
 usage: <pre><code>{
     xtype: 'box',
     autoEl: {
         tag: 'img',
         src: 'http://www.example.com/example.jpg'
     }
 },
 {
     xtype: 'box',
     autoEl: {
         tag: 'blockquote',
         html: 'autoEl is cool!'
     }
 }, {
     xtype: 'container',
     autoEl: 'ul',
     cls: 'ux-unordered-list',
     items: {
         xtype: 'box',
         autoEl: 'li',
   
      html: 'First list item'
     }
 }</pre></code>]]></description><name>autoEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to use height:'auto', false to use fixed height (or allow it to be managed by its parent Container's layout
 manager. Defaults to false. Note: Although many components inherit this config option, not all will function as expected
 with a height of 'auto'. Setting autoHeight:true means that the browser will manage height based on the element's
 contents, and that Ext will not manage it at all. If the browser is managing the height, be aware that resizes performed
 by the browser in response to changes within the structure of the Component cannot be detected. Therefore changes to the
 height might result in elements needing to be synchronized with the new height. Example: var w = new Ext.Window({
    
 title: 'Window',
     width: 600,
     autoHeight: true,
     items: {
         title: 'Collapse Me',
         height: 400,
  
 collapsible: true,
         border: false,
         listeners: {
             beforecollapse: function() {
                w.el.shadow.hide();
             },
             beforeexpand: function() {
                w.el.shadow.hide();
             },
             collapse: function() {
                w.syncShadow();
             },
             expand: function() {
                w.syncShadow();
             }
         }
     }
 }).show();]]></description><name>autoHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to use overflow:'auto' on the components layout element and show scroll bars automatically when necessary, false to
 clip any overflowing content (defaults to false).]]></description><name>autoScroll</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True if the component should check for hidden classes (e.g. 'x-hidden' or 'x-hide-display') and remove them on render
 (defaults to false).]]></description><name>autoShow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[By default, if a width is not specified the button will attempt to stretch horizontally to fit its content. If the
 button is being managed by a width sizing layout (hbox, fit, anchor), set this to false to prevent the button from doing
 this automatic sizing. Defaults to undefined .]]></description><name>autoWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to [].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[(Optional) A DomQuery selector which is used to extract the active, clickable element from the DOM structure created.
 When a custom template is used, you must ensure that this selector results in the selection of a focussable element.
 Defaults to 'button:first-child' .]]></description><name>buttonSelector</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A callback function that will be invoked each time the active menu item in the button's menu has changed. If this
 callback is not supplied, the SplitButton will instead fire the change event on active item change. The changeHandler
 function will be called with the following argument list: (SplitButton this, Ext.menu.CheckItem item)]]></description><name>changeHandler</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class used to to apply to the special clearing div rendered directly after each form field wrapper to provide
 field clearing (defaults to 'x-form-clear-left'). Note: this config is only used when this Component is rendered by a
 Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or specifying
 layout:'form') and either a fieldLabel is specified or isFormField=true is specified. See Ext.layout.FormLayout.fieldTpl
 also.]]></description><name>clearCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The DOM event that will fire the handler of the button. This can be any valid event name (dblclick, contextmenu).
 Defaults to 'click' .]]></description><name>clickEvent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS class string to apply to the button's main element.]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's container. This can be useful for adding customized
 styles to the container or any of its children using standard CSS rules. See Ext.layout.ContainerLayout.extraCls also.
 Note: ctCls defaults to '' except for the following class which assigns a value by default: Box Layout :
 'x-box-layout-ct' To configure the above Class with an extra CSS class append to the default. For example, for BoxLayout
 (Hbox and Vbox): ctCls: 'x-box-layout-ct custom-class']]></description><name>ctCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to start disabled (defaults to false)]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class added to the component when it is disabled (defaults to 'x-item-disabled').]]></description><name>disabledClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to enable pressed/not pressed toggling (defaults to false)]]></description><name>enableToggle</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The label text to display next to this Component (defaults to ''). Note: this config is only used when this Component is
 rendered by a Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or
 specifying layout:'form'). Also see hideLabel and Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
    
 height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name'
    
 }]
 });]]></description><name>fieldLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use a
 BoxLayout. Each child Component with a flex property will be flexed either vertically (by a VBoxLayout) or horizontally
 (by an HBoxLayout) according to the item's relative flex value compared to the sum of all Components with flex value
 specified. Any child items that have either a flex = 0 or flex = undefined will not be 'flexed' (the initial size will
 not be changed).]]></description><name>flex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A css class which sets an image to be used as the static icon for this button. This icon will always be displayed
 regardless of which item is selected in the dropdown list. This overrides the default behavior of changing the button's
 icon to match the selected item's icon on change.]]></description><name>forceIcon</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[False to disable visual cues on mouseover, mouseout and mousedown (defaults to true)]]></description><name>handleMouseEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A function called when the button is clicked (can be used instead of click event). The handler is passed the following
 parameters: b : Button This Button. e : EventObject The click event.]]></description><name>handler</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to start hidden (defaults to false)]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to completely hide the label element (label and separator). Defaults to false. By default, even if you do not
 specify a fieldLabel the space will still be reserved so that the field will line up with other fields that do have
 labels. Setting this to true will cause the field to not reserve that space. Note: see the note for clearCls. Example
 use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield'
        
 hideLabel: true
     }]
 });]]></description><name>hideLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[How this component should be hidden. Supported values are 'visibility' (css visibility), 'offsets' (negative offset
 position) and 'display' (css display). Note: the default of 'display' is generally preferred since items are
 automatically laid out when they are first shown (no sizing is done while hidden).]]></description><name>hideMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide and show the component's container when hide/show is called on the component, false to hide and show the
 component itself (defaults to false). For example, this can be used as a shortcut for a hide button on a window by
 setting hide:true on the button when adding it to its parent container.]]></description><name>hideParent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The path to an image to display in the button (the image will be set as the background-image CSS property of the button
 by default, so if you want a mixed icon/text button, set cls:'x-btn-text-icon')]]></description><name>icon</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[(Optional) The side of the Button box to render the icon. Four values are allowed: 'top' 'right' 'bottom' 'left'
 Defaults to 'left' .]]></description><name>iconAlign</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A css class which sets a background image to be used as the icon for this button]]></description><name>iconCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id of this component (defaults to an auto-assigned id). You should assign an id if you need to be able to
 access the component later and you do not have an object reference available (e.g., using Ext.getCmp). Note that this id
 will also be used as the element id for the containing HTML element that is rendered to the page for this component.
 This allows you to write id-based CSS rules to style the specific instance of this component uniquely, and also to
 select sub-elements using this component's id as the parent. Note: to avoid complications imposed by a unique id also
 see itemId and ref. Note: to access the container of an item see ownerCt.]]></description><name>id</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use the
 FormLayout layout manager (e.g. Ext.form.FormPanel or specifying layout:'form'). An additional CSS class to apply to the
 div wrapping the form item element of this field. If supplied, itemCls at the field level will override the default
 itemCls supplied at the container level. The value specified for itemCls will be added to the default class
 ('x-form-item'). Since it is applied to the item wrapper (see Ext.layout.FormLayout.fieldTpl), it allows you to write
 standard CSS rules that can apply to the field, the label (if specified), or any other element within the markup for the
 field. Note: see the note for fieldLabel. Example use: // Apply a style to the field's label:
 <style>
     .required
 .x-form-item-label {font-weight:bold;color:red;}
 </style>
 
 new Ext.FormPanel({
     height: 100,
     renderTo:
 Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         itemCls: 'required' //this
 label will be styled
     },{
         xtype: 'textfield',
         fieldLabel: 'Favorite Color'
     }]
 });]]></description><name>itemCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An itemId can be used as an alternative way to get a reference to a component when no object reference is available.
 Instead of using an id with Ext.getCmp, use itemId with Ext.Container.getComponent which will retrieve itemId's or id's.
 Since itemId's are an index to the container's internal MixedCollection, the itemId is scoped locally to the container
 -- avoiding potential conflicts with Ext.ComponentMgr which requires a unique id. var c = new Ext.Panel({ //
     height:
 300,
     renderTo: document.body,
     layout: 'auto',
     items: [
         {
             itemId: 'p1',
            
 title: 'Panel 1',
             height: 150
         },
         {
             itemId: 'p2',
             title: 'Panel 2',
  
 height: 150
         }
     ]
 })
 p1 = c.getComponent('p1'); // not the same as Ext.getCmp()
 p2 =
 p1.ownerCt.getComponent('p2'); // reference via a sibling Also see id and ref. Note: to access the container of an item
 see ownerCt.]]></description><name>itemId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of Ext.menu.CheckItem config objects to be used when creating the button's menu items (e.g., {text:'Foo',
 iconCls:'foo-icon'})]]></description><name>items</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The separator to display after the text of each fieldLabel. This property may be configured at various levels. The order
 of precedence is: field / component level container level layout level (defaults to colon ':') To display no separator
 for this field's label specify empty string ''. Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 layoutConfig: {
         labelSeparator: '~'   // layout config has lowest priority (defaults to ':')
     },
    
 labelSeparator: '>>',     // config at container level
     items: [{
         xtype: 'textfield',
         fieldLabel:
 'Field 1',
         labelSeparator: '...' // field/component level config supersedes others
     },{
         xtype:
 'textfield',
         fieldLabel: 'Field 2' // labelSeparator will be '='
     }]
 });]]></description><name>labelSeparator</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS style specification string to apply directly to this field's label. Defaults to the container's labelStyle value
 if set (e.g., Ext.layout.FormLayout.labelStyle , or ''). Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         labelStyle: 'font-weight:bold;'
     }]
 });]]></description><name>labelStyle</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout or one of the two BoxLayout subclasses. An object containing margins to apply to this BoxComponent in the
 format: {
     top: (top margin),
     right: (right margin),
     bottom: (bottom margin),
     left: (left margin)
 } May
 also be a string containing space-separated, numeric margin values. The order of the sides associated with each value
 matches the way CSS processes margin values: If there is only one value, it applies to all sides. If there are two
 values, the top and bottom borders are set to the first value and the right and left are set to the second. If there are
 three values, the top is set to the first value, the left and right are set to the second, and the bottom is set to the
 third. If there are four values, they apply to the top, right, bottom, and left, respectively. Defaults to: {top:0,
 right:0, bottom:0, left:0}]]></description><name>margins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Standard menu attribute consisting of a reference to a menu object, a menu id or a menu config blob (defaults to
 undefined).]]></description><name>menu</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The position to align the menu to (see Ext.Element.alignTo for more details, defaults to 'tl-bl?').]]></description><name>menuAlign</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum width for this button (used to give a set of buttons a common width). See also Ext.Panel. minButtonWidth .]]></description><name>minWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element when the mouse moves over the Element, and
 removed when the mouse moves out. (defaults to ''). This can be useful for adding customized 'active' or 'hover' styles
 to the component or any of its children using standard CSS rules.]]></description><name>overCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If used in a Toolbar, the text to be used if this item is shown in the overflow menu. See also Ext.Toolbar.Item.
 overflowText .]]></description><name>overflowText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level x coordinate for this component if contained within a positioning container.]]></description><name>pageX</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level y coordinate for this component if contained within a positioning container.]]></description><name>pageY</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A static string to prepend before the active item's text when displayed as the button's text (only applies when showText
 = true, defaults to '')]]></description><name>prependText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to start pressed (only if enableToggle = true)]]></description><name>pressed</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered ptype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a Plugin is being specified not as a fully
 instantiated Component, but as a Component config object. The ptype will be looked up at render time up to determine
 what type of Plugin to create. If you create your own Plugins, you may register them using
 Ext.ComponentMgr.registerPlugin in order to be able to take advantage of lazy instantiation and rendering.]]></description><name>ptype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A path specification, relative to the Component's ownerCt specifying into which ancestor Container to place a named
 reference to this Component. The ancestor axis can be traversed by using '/' characters in the path. For example, to put
 a reference to a Toolbar Button into the Panel which owns the Toolbar: var myGrid = new Ext.grid.EditorGridPanel({
    
 title: 'My EditorGridPanel',
     store: myStore,
     colModel: myColModel,
     tbar: [{
         text: 'Save',
        
 handler: saveChanges,
         disabled: true,
         ref: '../saveButton'
     }],
     listeners: {
         afteredit:
 function() {
 //          The button reference is in the GridPanel
             myGrid.saveButton.enable();
         }
    
 }
 }); In the code above, if the ref had been 'saveButton' the reference would have been placed into the Toolbar. Each
 '/' in the ref moves up one level from the Component's ownerCt. Also see the added and removed events.]]></description><name>ref</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout layout manager (e.g. specifying layout:'border'). See Ext.layout.BorderLayout also.]]></description><name>region</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to repeat fire the click event while the mouse is down. This can also be a ClickRepeater config object (defaults to
 false).]]></description><name>repeat</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[(Optional) The size of the Button. Three values are allowed: 'small' Results in the button element being 16px high.
 'medium' Results in the button element being 24px high. 'large' Results in the button element being 32px high. Defaults
 to 'small' .]]></description><name>scale</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The scope ( this reference) in which the handler and toggleHandler is executed. Defaults to this Button.]]></description><name>scope</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to display the active item's text as the button text (defaults to false)]]></description><name>showText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should trigger this component to save its state (defaults to none). stateEvents may
 be any type of event supported by this component, including browser or custom events (e.g., ['click',
 'customerchange']). See stateful for an explanation of saving and restoring Component state.]]></description><name>stateEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id for this component to use for state management purposes (defaults to the component id if one was set,
 otherwise null if the component is using a generated id). See stateful for an explanation of saving and restoring
 Component state.]]></description><name>stateId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A flag which causes the Component to attempt to restore the state of internal properties from a saved state on startup.
 The component must have either a stateId or id assigned for state to be managed. Auto-generated ids are not guaranteed
 to be stable across page loads and cannot be relied upon to save and restore the same state for a component. For state
 saving to work, the state manager's provider must have been set to an implementation of Ext.state.Provider which
 overrides the set and get methods to save and recall name/value pairs. A built-in implementation,
 Ext.state.CookieProvider is available. To set the state provider for the current page: Ext.state.Manager.setProvider(new
 Ext.state.CookieProvider({
     expires: new Date(new Date().getTime()+(1000*60*60*24*7)), //7 days from now
 })); A
 stateful Component attempts to save state when one of the events listed in the stateEvents configuration fires. To save
 state, a stateful Component first serializes its state by calling getState. By default, this function does nothing. The
 developer must provide an implementation which returns an object hash which represents the Component's restorable state.
 The value yielded by getState is passed to Ext.state.Manager.set which uses the configured Ext.state.Provider to save
 the object keyed by the Component's stateId, or, if that is not specified, its id. During construction, a stateful
 Component attempts to restore its state by calling Ext.state.Manager.get passing the stateId, or, if that is not
 specified, the id. The resulting object is passed to applyState. The default implementation of applyState simply copies
 properties into the object, but a developer may override this to support more behaviour. You can perform extra
 processing on state save and restore by attaching handlers to the beforestaterestore, staterestore, beforestatesave and
 statesave events.]]></description><name>stateful</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
     title: 'Some Title',
     renderTo: Ext.getBody(),
     width: 400, height:
 300,
     layout: 'form',
     items: [{
         xtype: 'textarea',
         style: {
             width: '95%',
            
 marginBottom: '10px'
         }
     },
         new Ext.Button({
             text: 'Send',
             minWidth: '100',
   
          style: {
                 marginBottom: '10px'
             }
         })
     ]
 });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Set a DOM tabIndex for this button (defaults to undefined)]]></description><name>tabIndex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is a child item of a TabPanel. A string to be used as innerHTML
 (html tags are accepted) to show in a tooltip when mousing over the associated tab selector element.
 Ext.QuickTips.init() must be called in order for the tips to render.]]></description><name>tabTip</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A Template used to create the Button's DOM structure. Instances, or subclasses which need a different DOM structure may
 provide a different template layout in conjunction with an implementation of getTemplateArgs.]]></description><name>template</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The button text to be used as innerHTML (html tags are accepted)]]></description><name>text</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The group this toggle button is a member of (only 1 per group can be pressed)]]></description><name>toggleGroup</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Function called when a Button with enableToggle set to true is clicked. Two arguments are passed: button : Ext.Button
 this Button object state : Boolean The next state of the Button, true means pressed.]]></description><name>toggleHandler</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The tooltip for the button - can be a string to be used as innerHTML (html tags are accepted) or QuickTips config object]]></description><name>tooltip</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The type of tooltip to use. Either 'qtip' (default) for QuickTips or 'title' for title attribute.]]></description><name>tooltipType</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[submit, reset or button - defaults to 'button']]></description><name>type</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local x (left) coordinate for this component if contained within a positioning container.]]></description><name>x</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered xtype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a child item of a Container is being specified not
 as a fully instantiated Component, but as a Component config object. The xtype will be looked up at render time up to
 determine what type of child Component to create. The predefined xtypes are listed here. If you subclass Components to
 create your own Components, you may register them using Ext.ComponentMgr.registerType in order to be able to take
 advantage of lazy instantiation and rendering.]]></description><name>xtype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local y (top) coordinate for this component if contained within a positioning container.]]></description><name>y</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 <p>Data reader class to create an Array of <a href="output/Ext.data.Record.html"
 ext:cls="Ext.data.Record">Ext.data.Record</a> objects from an Array. Each element of that Array represents a row of data
 fields. The fields are pulled into a Record object using as a subscript, the <code>mapping</code> property of the field
 definition if it exists, or the field's ordinal position in the definition.</p> 
 <p>Example code:</p>
 
 <pre><code><b>var</b> Employee = Ext.data.Record.create([
     {name: <em>'name'</em>, mapping: 1},         <i>//
 <em>&quot;mapping&quot;</em> only needed <b>if</b> an <em>&quot;id&quot;</em> field is present which</i>
     {name:
 <em>'occupation'</em>, mapping: 2}    <i>// precludes using the ordinal position as the index.</i>
 ]);
 <b>var</b>
 myReader = <b>new</b> Ext.data.ArrayReader({
     <a href="output/Ext.data.ArrayReader.html#Ext.data.ArrayReader-idIndex"
 ext:member="idIndex" ext:cls="Ext.data.ArrayReader">idIndex</a>: 0
 }, Employee);</code></pre> 
 <p>This would consume an
 Array like this:</p> 
 <pre><code>[ [1, <em>'Bill'</em>, <em>'Gardener'</em>], [2, <em>'Ben'</em>,
 <em>'Horticulturalist'</em>] ]</code></pre>]]></description><name>data.arrayReader</name><tag-class>org.brushingbits.jnap.ui.extjs3.data.ArrayReader</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[TODO]]></description><name>excludeModelProperties</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The subscript within row Array that provides an ID for the Record.]]></description><name>idIndex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[[id] Name of the property within a row object that contains a record identifier value. Defaults to id]]></description><name>idProperty</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[TODO]]></description><name>includeModelAssociation</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[[undefined] Optional name of a property within a server-response that represents a user-feedback message.]]></description><name>messageProperty</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[TODO]]></description><name>modelClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[[undefined] Required. The name of the property which contains the Array of row objects. Defaults to undefined. An
 exception will be thrown if the root property is undefined. The data packet value for this property should be an empty
 array to clear the data or show no data.]]></description><name>root</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[[success] Name of the property from which to retrieve the success attribute. Defaults to success. See
 Ext.data.DataProxy.exception for additional information.]]></description><name>successProperty</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[[total] Name of the property from which to retrieve the total number of records in the dataset. This is only needed if
 the whole dataset is not passed in one go, but is being paged from the remote server. Defaults to total.]]></description><name>totalProperty</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 <p>Abstract base class for implementations which provide retrieval of unformatted data objects. This class is intended
 to be extended and should not be created directly. For existing implementations, see <a
 href="output/Ext.data.DirectProxy.html" ext:cls="Ext.data.DirectProxy">Ext.data.DirectProxy</a>, <a
 href="output/Ext.data.HttpProxy.html" ext:cls="Ext.data.HttpProxy">Ext.data.HttpProxy</a>, <a
 href="output/Ext.data.ScriptTagProxy.html" ext:cls="Ext.data.ScriptTagProxy">Ext.data.ScriptTagProxy</a> and <a
 href="output/Ext.data.MemoryProxy.html" ext:cls="Ext.data.MemoryProxy">Ext.data.MemoryProxy</a>.</p> 
 <p>DataProxy
 implementations are usually used in conjunction with an implementation of <a href="output/Ext.data.DataReader.html"
 ext:cls="Ext.data.DataReader">Ext.data.DataReader</a> (of the appropriate type which knows how to parse the data object)
 to provide a block of <a href="output/Ext.data.Records.html" ext:cls="Ext.data.Records">Ext.data.Records</a> to an <a
 href="output/Ext.data.Store.html" ext:cls="Ext.data.Store">Ext.data.Store</a>.</p> 
 <p>The parameter to a DataProxy
 constructor may be an <a href="output/Ext.data.Connection.html" ext:cls="Ext.data.Connection">Ext.data.Connection</a> or
 can also be the config object to an <a href="output/Ext.data.Connection.html"
 ext:cls="Ext.data.Connection">Ext.data.Connection</a>.</p> 
 <p>Custom implementations must implement either the
 <code><b>doRequest</b></code> method (preferred) or the <code>load</code> method (deprecated). See <a
 href="output/Ext.data.HttpProxy.html" ext:cls="Ext.data.HttpProxy">Ext.data.HttpProxy</a>.<a
 href="output/Ext.data.HttpProxy.html#Ext.data.HttpProxy-doRequest" ext:member="doRequest"
 ext:cls="Ext.data.HttpProxy">doRequest</a> or <a href="output/Ext.data.HttpProxy.html"
 ext:cls="Ext.data.HttpProxy">Ext.data.HttpProxy</a>.<a href="output/Ext.data.HttpProxy.html#Ext.data.HttpProxy-load"
 ext:member="load" ext:cls="Ext.data.HttpProxy">load</a> for additional details.</p> 
 <p><b><u>Example 1</u></b></p>
 
 <pre><code>proxy: <b>new</b> Ext.data.ScriptTagProxy({
     <a
 href="output/Ext.data.Connection.html#Ext.data.Connection-url" ext:member="url" ext:cls="Ext.data.Connection">url</a>:
 <em>'http:<i>//extjs.com/forum/topics-remote.php'</i></em>
 }),</code></pre> 
 <p><b><u>Example 2</u></b></p>
 
 <pre><code>proxy : <b>new</b> Ext.data.HttpProxy({
     <a
 href="output/Ext.data.Connection.html#Ext.data.Connection-method" ext:member="method"
 ext:cls="Ext.data.Connection">method</a>: <em>'GET'</em>,
     <a
 href="output/Ext.data.HttpProxy.html#Ext.data.HttpProxy-prettyUrls" ext:member="prettyUrls"
 ext:cls="Ext.data.HttpProxy">prettyUrls</a>: false,
     <a
 href="output/Ext.data.Connection.html#Ext.data.Connection-url" ext:member="url" ext:cls="Ext.data.Connection">url</a>:
 <em>'local/<b>default</b>.php'</em>, <i>// see options parameter <b>for</b> <a
 href="output/Ext.Ajax.html#Ext.Ajax-request" ext:member="request" ext:cls="Ext.Ajax">Ext.Ajax.request</a></i>
     <a
 href="output/Ext.data.DataProxy.html#Ext.data.DataProxy-api" ext:member="api" ext:cls="Ext.data.DataProxy">api</a>: {
   
 <i>// all actions except the following will use above url</i>
         create  : <em>'local/<b>new</b>.php'</em>,
        
 update  : <em>'local/update.php'</em>
     }
 }),</code></pre> 
 <p>And <b>new in Ext version 3</b>, attach centralized
 event-listeners upon the DataProxy class itself! This is a great place to implement a <i>messaging system</i> to
 centralize your application's user-feedback and error-handling.</p> 
 <pre><code><i>// Listen to all
 <em>&quot;beforewrite&quot;</em> event fired by all proxies.</i>
 Ext.data.DataProxy.on(<em>'beforewrite'</em>,
 <b>function</b>(proxy, action) {
     console.log(<em>'beforewrite: '</em>, action);
 });
 
 <i>// Listen to
 <em>&quot;write&quot;</em> event fired by all proxies</i>
 Ext.data.DataProxy.on(<em>'write'</em>, <b>function</b>(proxy,
 action, data, res, rs) {
     console.info(<em>'write: '</em>, action);
 });
 
 <i>// Listen to
 <em>&quot;exception&quot;</em> event fired by all proxies</i>
 Ext.data.DataProxy.on(<em>'exception'</em>,
 <b>function</b>(proxy, type, action, exception) {
     console.error(type + action + <em>'
 exception);
 });</em></code></pre>
 <em> <b>Note:</b> These three events are all fired with the signature of the
 corresponding <i>DataProxy instance</i> event <a href="output/Ext.data.DataProxy.html#Ext.data.DataProxy-beforewrite"
 ext:member="beforewrite" ext:cls="Ext.data.DataProxy">beforewrite</a>, <a
 href="output/Ext.data.DataProxy.html#Ext.data.DataProxy-write" ext:member="write" ext:cls="Ext.data.DataProxy">write</a>
 and <a href="output/Ext.data.DataProxy.html#Ext.data.DataProxy-exception" ext:member="exception"
 ext:cls="Ext.data.DataProxy">exception</a>.</em>]]></description><name>data.dataProxy</name><tag-class>org.brushingbits.jnap.ui.extjs3.data.DataProxy</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[Specific urls to call on CRUD action methods "read", "create", "update" and "destroy". Defaults to: api: {
     read    :
 undefined,
     create  : undefined,
     update  : undefined,
     destroy : undefined
 } The url is built based upon the
 action being executed [load|create|save|destroy] using the commensurate api property, or if undefined default to the
 configured Ext.data.Store.url. For example: api: {
     load :    '/controller/load',
     create :  '/controller/new', 
 // Server MUST return idProperty of new record
     save :    '/controller/update',
     destroy :
 '/controller/destroy_action'
 }
 
 // Alternatively, one can use the object-form to specify each API-action
 api: {
    
 load: {url: 'read.php', method: 'GET'},
     create: 'create.php',
     destroy: 'destroy.php',
     save: 'update.php'
 }
 If the specific URL for a given CRUD action is undefined, the CRUD action request will be directed to the configured
 url. Note: To modify the URL for an action dynamically the appropriate API property should be modified before the action
 is requested using the corresponding before action event. For example to modify the URL associated with the load action:
 // modify the url for the action
 myStore.on({
     beforeload: {
         fn: function (store, options) {
             //
 use setUrl to change the URL for *just* this request.
             store.proxy.setUrl('changed1.php');
 
             //
 set optional second parameter to true to make this URL change
             // permanent, applying this URL for all
 subsequent requests.
             store.proxy.setUrl('changed1.php', true);
 
             // Altering the proxy API should
 be done using the public
             // method setApi.
             store.proxy.setApi('read', 'changed2.php');
 
         
 // Or set the entire API with a config-object.
             // When using the config-object option, you must redefine the
 entire
             // API -- not just a specific action of it.
             store.proxy.setApi({
                 read   
 : 'changed_read.php',
                 create  : 'changed_create.php',
                 update  : 'changed_update.php',
   
              destroy : 'changed_destroy.php'
             });
         }
     }
 });]]></description><name>api</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Abstract method that should be implemented in all subclasses. Note: Should only be used by custom-proxy developers.
 (e.g.: HttpProxy.doRequest, DirectProxy.doRequest).]]></description><name>doRequest</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Abstract method that should be implemented in all subclasses. Note: Should only be used by custom-proxy developers.
 Callback for read action.]]></description><name>onRead</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Abstract method that should be implemented in all subclasses. Note: Should only be used by custom-proxy developers.
 Callback for create, update and destroy actions.]]></description><name>onWrite</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to false. Set to true to operate in a RESTful manner. Note: this parameter will automatically be set to true if
 the Ext.data.Store it is plugged into is set to restful: true. If the Store is RESTful, there is no need to set this
 option on the proxy. RESTful implementations enable the serverside framework to automatically route actions sent to one
 url based upon the HTTP method, for example: store: new Ext.data.Store({
     restful: true,
     proxy: new
 Ext.data.HttpProxy({url:'/users'}); // all requests sent to /users
     ...
 )} If there is no api specified in the
 configuration of the proxy, all requests will be marshalled to a single RESTful url (/users) so the serverside framework
 can inspect the HTTP Method and act accordingly: 
 Method   url        action
 POST     /users     create
 GET      /users 
 read
 PUT      /users/23  update
 DESTROY  /users/23  delete
  If set to true, a non-phantom record's id will be appended
 to the url. Some MVC (e.g., Ruby on Rails, Merb and Django) support segment based urls where the segments in the URL
 follow the Model-View-Controller approach: someSite.com/controller/action/id Where the segments in the url are
 typically: The first segment : represents the controller class that should be invoked. The second segment : represents
 the class function, or method, that should be called. The third segment : represents the ID (a variable typically passed
 to the method). Refer to Ext.data.DataProxy.api for additional information.]]></description><name>restful</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>]]></description><name>data.directProxy</name><tag-class>org.brushingbits.jnap.ui.extjs3.data.DirectProxy</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[Specific urls to call on CRUD action methods "read", "create", "update" and "destroy". Defaults to: api: {
     read    :
 undefined,
     create  : undefined,
     update  : undefined,
     destroy : undefined
 } The url is built based upon the
 action being executed [load|create|save|destroy] using the commensurate api property, or if undefined default to the
 configured Ext.data.Store.url. For example: api: {
     load :    '/controller/load',
     create :  '/controller/new', 
 // Server MUST return idProperty of new record
     save :    '/controller/update',
     destroy :
 '/controller/destroy_action'
 }
 
 // Alternatively, one can use the object-form to specify each API-action
 api: {
    
 load: {url: 'read.php', method: 'GET'},
     create: 'create.php',
     destroy: 'destroy.php',
     save: 'update.php'
 }
 If the specific URL for a given CRUD action is undefined, the CRUD action request will be directed to the configured
 url. Note: To modify the URL for an action dynamically the appropriate API property should be modified before the action
 is requested using the corresponding before action event. For example to modify the URL associated with the load action:
 // modify the url for the action
 myStore.on({
     beforeload: {
         fn: function (store, options) {
             //
 use setUrl to change the URL for *just* this request.
             store.proxy.setUrl('changed1.php');
 
             //
 set optional second parameter to true to make this URL change
             // permanent, applying this URL for all
 subsequent requests.
             store.proxy.setUrl('changed1.php', true);
 
             // Altering the proxy API should
 be done using the public
             // method setApi.
             store.proxy.setApi('read', 'changed2.php');
 
         
 // Or set the entire API with a config-object.
             // When using the config-object option, you must redefine the
 entire
             // API -- not just a specific action of it.
             store.proxy.setApi({
                 read   
 : 'changed_read.php',
                 create  : 'changed_create.php',
                 update  : 'changed_update.php',
   
              destroy : 'changed_destroy.php'
             });
         }
     }
 });]]></description><name>api</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Function to call when executing a request. directFn is a simple alternative to defining the api configuration-parameter
 for Store's which will not implement a full CRUD api.]]></description><name>directFn</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Abstract method that should be implemented in all subclasses. Note: Should only be used by custom-proxy developers.
 (e.g.: HttpProxy.doRequest, DirectProxy.doRequest).]]></description><name>doRequest</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Abstract method that should be implemented in all subclasses. Note: Should only be used by custom-proxy developers.
 Callback for read action.]]></description><name>onRead</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Abstract method that should be implemented in all subclasses. Note: Should only be used by custom-proxy developers.
 Callback for create, update and destroy actions.]]></description><name>onWrite</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to undefined. A list of params to be executed server side. Specify the params in the order in which they must
 be executed on the server-side as either (1) an Array of String values, or (2) a String of params delimited by either
 whitespace, comma, or pipe. For example, any of the following would be acceptable: paramOrder:
 ['param1','param2','param3']
 paramOrder: 'param1 param2 param3'
 paramOrder: 'param1,param2,param3'
 paramOrder:
 'param1|param2|param']]></description><name>paramOrder</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Send parameters as a collection of named arguments (defaults to true). Providing a paramOrder nullifies this
 configuration.]]></description><name>paramsAsHash</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to false. Set to true to operate in a RESTful manner. Note: this parameter will automatically be set to true if
 the Ext.data.Store it is plugged into is set to restful: true. If the Store is RESTful, there is no need to set this
 option on the proxy. RESTful implementations enable the serverside framework to automatically route actions sent to one
 url based upon the HTTP method, for example: store: new Ext.data.Store({
     restful: true,
     proxy: new
 Ext.data.HttpProxy({url:'/users'}); // all requests sent to /users
     ...
 )} If there is no api specified in the
 configuration of the proxy, all requests will be marshalled to a single RESTful url (/users) so the serverside framework
 can inspect the HTTP Method and act accordingly: 
 Method   url        action
 POST     /users     create
 GET      /users 
 read
 PUT      /users/23  update
 DESTROY  /users/23  delete
  If set to true, a non-phantom record's id will be appended
 to the url. Some MVC (e.g., Ruby on Rails, Merb and Django) support segment based urls where the segments in the URL
 follow the Model-View-Controller approach: someSite.com/controller/action/id Where the segments in the url are
 typically: The first segment : represents the controller class that should be invoked. The second segment : represents
 the class function, or method, that should be called. The third segment : represents the ID (a variable typically passed
 to the method). Refer to Ext.data.DataProxy.api for additional information.]]></description><name>restful</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 <p>This class encapsulates the field definition information specified in the field definition objects passed to <a
 href="output/Ext.data.Record.html#Ext.data.Record-create" ext:member="create"
 ext:cls="Ext.data.Record">Ext.data.Record.create</a>.</p> 
 <p>Developers do not need to instantiate this class.
 Instances are created by <a href="output/Ext.data.Record.create.html"
 ext:cls="Ext.data.Record.create">Ext.data.Record.create</a> and cached in the <a
 href="output/Ext.data.Record.html#Ext.data.Record-fields" ext:member="fields" ext:cls="Ext.data.Record">fields</a>
 property of the created Record constructor's <b>prototype.</b></p>]]></description><name>data.field</name><tag-class>org.brushingbits.jnap.ui.extjs3.data.Field</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[Used for validating a record, defaults to true. An empty value here will cause Ext.data.Record.isValid to evaluate to
 false.]]></description><name>allowBlank</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A function which converts the value provided by the Reader into an object that will be stored in the Record. It is
 passed the following parameters: v : Mixed The data value as read by the Reader, if undefined will use the configured
 defaultValue. rec : Mixed The data object containing the row as read by the Reader. Depending on the Reader type, this
 could be an Array (ArrayReader), an object (JsonReader), or an XML element (XMLReader). // example of convert
 function
 function fullName(v, record){
     return record.name.last + ', ' + record.name.first;
 }
 
 function location(v,
 record){
     return !record.city ? '' : (record.city + ', ' + record.state);
 }
 
 var Dude = Ext.data.Record.create([
    
 {name: 'fullname',  convert: fullName},
     {name: 'firstname', mapping: 'name.first'},
     {name: 'lastname',  mapping:
 'name.last'},
     {name: 'city', defaultValue: 'homeless'},
     'state',
     {name: 'location',  convert:
 location}
 ]);
 
 // create the data store
 var store = new Ext.data.Store({
     reader: new Ext.data.JsonReader(
         {
 
 idProperty: 'key',
             root: 'daRoot',
             totalProperty: 'total'
         },
         Dude  //
 recordType
     )
 });
 
 var myData = [
     { key: 1,
       name: { first: 'Fat',    last:  'Albert' }
       // notice no
 city, state provided in data object
     },
     { key: 2,
       name: { first: 'Barney', last:  'Rubble' },
       city:
 'Bedrock', state: 'Stoneridge'
     },
     { key: 3,
       name: { first: 'Cliff',  last:  'Claven' },
       city:
 'Boston',  state: 'MA'
     }
 ];]]></description><name>convert</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[(Optional) Used when converting received data into a Date when the type is specified as "date". A format string for the
 Date.parseDate function, or "timestamp" if the value provided by the Reader is a UNIX timestamp, or "time" if the value
 provided by the Reader is a javascript millisecond timestamp. See Date]]></description><name>dateFormat</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default value used when a Record is being created by a Reader when the item referenced by the mapping does not exist
 in the data object (i.e. undefined). (defaults to "")]]></description><name>defaultValue</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[(Optional) A path expression for use by the Ext.data.DataReader implementation that is creating the Record to extract
 the Field value from the data object. If the path expression is the same as the field name, the mapping may be omitted.
 The form of the mapping expression depends on the Reader being used. Ext.data.JsonReader The mapping is a string
 containing the javascript expression to reference the data from an element of the data item's root Array. Defaults to
 the field name. Ext.data.XmlReader The mapping is an Ext.DomQuery path to the data item relative to the DOM element that
 represents the record. Defaults to the field name. Ext.data.ArrayReader The mapping is a number indicating the Array
 index of the field's value. Defaults to the field specification's Array position. If a more complex value extraction
 strategy is required, then configure the Field with a convert function. This is passed the whole row object, and may
 interrogate it in whatever way is necessary in order to return the desired data.]]></description><name>mapping</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The name by which the field is referenced within the Record. This is referenced by, for example, the dataIndex property
 in column definition objects passed to Ext.grid.ColumnModel. Note: In the simplest case, if no properties other than
 name are required, a field definition may consist of just a String for the field name.]]></description><name>name</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Initial direction to sort ("ASC" or "DESC"). Defaults to "ASC".]]></description><name>sortDir</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A function which converts a Field's value to a comparable value in order to ensure correct sort ordering. Predefined
 functions are provided in Ext.data.SortTypes. A custom sort example: // current sort     after sort we want
 //
 +-+------+          +-+------+
 // |1|First |          |1|First |
 // |2|Last  |          |3|Second|
 // |3|Second|        
 |2|Last  |
 // +-+------+          +-+------+
 
 sortType: function(value) {
    switch (value.toLowerCase()) // native
 toLowerCase():
    {
       case 'first': return 1;
       case 'second': return 2;
       default: return 3;
    }
 }]]></description><name>sortType</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The data type for automatic conversion from received data to the stored value if convert has not been specified. This
 may be specified as a string value. Possible values are auto (Default, implies no conversion) string int float boolean
 date This may also be specified by referencing a member of the Ext.data.Types class. Developers may create their own
 application-specific data types by defining new members of the Ext.data.Types class.]]></description><name>type</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[(Optional) Use when converting received data into a Number type (either int or float). If the value cannot be parsed,
 null will be used if useNull is true, otherwise the value will be 0. Defaults to false]]></description><name>useNull</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 A specialized store implementation that provides for grouping records by one of the available fields. This is usually
 used in conjunction with an 
 <a href="output/Ext.grid.GroupingView.html"
 ext:cls="Ext.grid.GroupingView">Ext.grid.GroupingView</a> to provide the data model for a grouped GridPanel. Internally,
 GroupingStore is simply a normal Store with multi sorting enabled from the start. The grouping field and direction are
 always injected as the first sorter pair. GroupingView picks up on the configured groupField and builds grid rows
 appropriately.]]></description><name>data.groupingStore</name><tag-class>org.brushingbits.jnap.ui.extjs3.data.GroupingStore</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[true to destroy the store when the component the store is bound to is destroyed (defaults to false). Note: this should
 be set to true when using stores that are bound to only 1 component.]]></description><name>autoDestroy</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If data is not specified, and if autoLoad is true or an Object, this store's load method is automatically called after
 creation. If the value of autoLoad is an Object, this Object will be passed to the store's load method.]]></description><name>autoLoad</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to true causing the store to automatically save records to the server when a record is modified (ie: becomes
 'dirty'). Specify false to manually call save to send all modifiedRecords to the server. Note: each CRUD action will be
 sent as a separate request.]]></description><name>autoSave</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object containing properties which are to be sent as parameters for every HTTP request. Parameters are encoded as
 standard HTTP parameters using Ext.urlEncode. Note: baseParams may be superseded by any params specified in a load
 request, see load for more details. This property may be modified after creation using the setBaseParam method.]]></description><name>baseParams</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to true (unless restful:true). Multiple requests for each CRUD action (CREATE, READ, UPDATE and DESTROY) will
 be combined and sent as one transaction. Only applies when autoSave is set to false. If Store is RESTful, the DataProxy
 is also RESTful, and a unique transaction is generated for each record.]]></description><name>batch</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An inline data object readable by the reader. Typically this option, or the url option will be specified.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Provides the default values for the paramNames property. To globally modify the parameters for all stores, this object
 should be changed on the store prototype.]]></description><name>defaultParamNames</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The direction to sort the groups. Defaults to 'ASC'.]]></description><name>groupDir</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The field name by which to sort the store's data (defaults to '').]]></description><name>groupField</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to sort the data on the grouping field when a grouping operation occurs, false to sort based on the existing sort
 info (defaults to false).]]></description><name>groupOnSort</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object containing properties which specify the names of the paging and sorting parameters passed to remote servers
 when loading blocks of data. By default, this object takes the following form:
 <pre><code>{
     start : 'start',  // The parameter name which specifies the start row
     limit : 'limit',  // The parameter name which specifies number of rows to return
     sort : 'sort',    // The parameter name which specifies the column to sort on
     dir : 'dir'       // The parameter name which specifies the sort direction
 }</code></pre> The server must produce the requested data block upon receipt of these
 parameter names. If different parameter names are required, this property can be overriden using a configuration
 property. A PagingToolbar bound to this Store uses this property to determine the parameter names to use in its
 requests.]]></description><name>paramNames</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The DataProxy object which provides access to a data object. See url.]]></description><name>proxy</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to clear all modified record information each time the store is loaded or when a record is removed (defaults to
 false). See getModifiedRecords for the accessor method to retrieve the modified records.]]></description><name>pruneModifiedRecords</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True if the grouping should apply on the server side, false if it is local only (defaults to false). If the grouping is
 local, it can be applied immediately to the data. If it is remote, then it will simply act as a helper, automatically
 sending the grouping field name as the 'groupBy' param with each XHR call.]]></description><name>remoteGroup</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true if sorting is to be handled by requesting the Proxy to provide a refreshed version of the data object in sorted
 order, as opposed to sorting the Record cache in place (defaults to false). If remoteSort is true, then clicking on a
 Grid Column's header causes the current page to be requested from the server appending the following two parameters to
 the params: sort : String The name (as specified in the Record's Field definition) of the field to sort on. dir : String
 The direction of the sort, 'ASC' or 'DESC' (case-sensitive).]]></description><name>remoteSort</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to true. The Store and the set Proxy operate in a RESTful manner. The store will
 automatically generate GET, POST, PUT and DELETE requests to the server. The HTTP method used for any given CRUD action
 is described in Ext.data.Api.restActions. For additional information see Ext.data.DataProxy.restful. Note: if
 restful:true batch will internally be set to false.]]></description><name>restful</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A config object to specify the sort order in the request of a Store's load operation. Note that for local sorting, the
 direction property is case-sensitive. See also remoteSort and paramNames. For example: sortInfo: {
     field:
 'fieldName',
     direction: 'ASC' // or 'DESC' (case sensitive for local sorting)
 }]]></description><name>sortInfo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If passed, the id to use to register with the StoreMgr. Note: if a (deprecated) id is specified it will supersede the
 storeId assignment.]]></description><name>storeId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If a proxy is not specified the url will be used to implicitly configure a HttpProxy if an url is specified. Typically
 this option, or the data option will be specified.]]></description><name>url</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 <p>Data reader class to create an Array of <a href="output/Ext.data.Record.html"
 ext:cls="Ext.data.Record">Ext.data.Record</a> objects from a JSON packet based on mappings in a provided <a
 href="output/Ext.data.Record.html" ext:cls="Ext.data.Record">Ext.data.Record</a> constructor.</p> 
 <p>Example code:</p>
 
 <pre><code><b>var</b> myReader = <b>new</b> Ext.data.JsonReader({
     <i>// metadata configuration options:</i>
     <a
 href="output/Ext.data.JsonReader.html#Ext.data.JsonReader-idProperty" ext:member="idProperty"
 ext:cls="Ext.data.JsonReader">idProperty</a>: <em>'id'</em>
     <a
 href="output/Ext.data.JsonReader.html#Ext.data.JsonReader-root" ext:member="root"
 ext:cls="Ext.data.JsonReader">root</a>: <em>'rows'</em>,
     <a
 href="output/Ext.data.JsonReader.html#Ext.data.JsonReader-totalProperty" ext:member="totalProperty"
 ext:cls="Ext.data.JsonReader">totalProperty</a>: <em>'results'</em>,
     <a
 href="output/Ext.data.DataReader.html#Ext.data.DataReader-messageProperty" ext:member="messageProperty"
 ext:cls="Ext.data.DataReader">Ext.data.DataReader.messageProperty</a>: <em>&quot;msg&quot;</em>  <i>// The element
 within the response that provides a user-feedback message (optional)</i>
 
     <i>// the fields config option will
 internally create an <a href="output/Ext.data.Record.html" ext:cls="Ext.data.Record">Ext.data.Record</a></i>
     <i>//
 constructor that provides mapping <b>for</b> reading the record data objects</i>
     <a
 href="output/Ext.data.DataReader.html#Ext.data.DataReader-fields" ext:member="fields"
 ext:cls="Ext.data.DataReader">fields</a>: [
         <i>// map Record's <em>'firstname'</em> field to data object's key
 of same name</i>
         {name: <em>'name'</em>, mapping: <em>'firstname'</em>},
         <i>// map Record's
 <em>'job'</em> field to data object's <em>'occupation'</em> key</i>
         {name: <em>'job'</em>, mapping:
 <em>'occupation'</em>}
     ]
 });</code></pre> 
 <p>This would consume a JSON data object of the form:</p>
 <pre><code>{
   
 results: 2000, <i>// Reader's configured <a href="output/Ext.data.JsonReader.html#Ext.data.JsonReader-totalProperty"
 ext:member="totalProperty" ext:cls="Ext.data.JsonReader">totalProperty</a></i>
     rows: [        <i>// Reader's
 configured <a href="output/Ext.data.JsonReader.html#Ext.data.JsonReader-root" ext:member="root"
 ext:cls="Ext.data.JsonReader">root</a></i>
         <i>// record data objects:</i>
         { <a
 href="output/Ext.data.JsonReader.html#Ext.data.JsonReader-idProperty" ext:member="idProperty"
 ext:cls="Ext.data.JsonReader">id</a>: 1, firstname: <em>'Bill'</em>, occupation: <em>'Gardener'</em> },
         { <a
 href="output/Ext.data.JsonReader.html#Ext.data.JsonReader-idProperty" ext:member="idProperty"
 ext:cls="Ext.data.JsonReader">id</a>: 2, firstname: <em>'Ben'</em> , occupation: <em>'Horticulturalist'</em> },
        
 ...
     ]
 }</code></pre> 
 <p><b><u>Automatic configuration using metaData</u></b></p> 
 <p>It is possible to change a
 JsonReader's metadata at any time by including a <b><tt>metaData</tt></b> property in the JSON data object. If the JSON
 data object has a <b><tt>metaData</tt></b> property, a <a href="output/Ext.data.Store.html"
 ext:cls="Ext.data.Store">Store</a> object using this Reader will reconfigure itself to use the newly provided field
 definition and fire its <a href="output/Ext.data.Store.html#Ext.data.Store-metachange" ext:member="metachange"
 ext:cls="Ext.data.Store">metachange</a> event. The metachange event handler may interrogate the <b><tt>metaData</tt></b>
 property to perform any configuration required.</p> 
 <p>Note that reconfiguring a Store potentially invalidates objects
 which may refer to Fields or Records which no longer exist.</p> 
 <p>To use this facility you would create the JsonReader
 like this:</p>
 <pre><code><b>var</b> myReader = <b>new</b> Ext.data.JsonReader();</code></pre> 
 <p>The first data packet
 from the server would configure the reader by containing a <b><tt>metaData</tt></b> property <b>and</b> the data. For
 example, the JSON data object might take the form:</p>
 <pre><code>{
     metaData: {
         <em>&quot;<a
 href="output/Ext.data.JsonReader.html#Ext.data.JsonReader-idProperty" ext:member="idProperty"
 ext:cls="Ext.data.JsonReader">idProperty</a>&quot;</em>: <em>&quot;id&quot;</em>,
         <em>&quot;<a
 href="output/Ext.data.JsonReader.html#Ext.data.JsonReader-root" ext:member="root"
 ext:cls="Ext.data.JsonReader">root</a>&quot;</em>: <em>&quot;rows&quot;</em>,
         <em>&quot;<a
 href="output/Ext.data.JsonReader.html#Ext.data.JsonReader-totalProperty" ext:member="totalProperty"
 ext:cls="Ext.data.JsonReader">totalProperty</a>&quot;</em>: <em>&quot;results&quot;</em>
         <em>&quot;<a
 href="output/Ext.data.JsonReader.html#Ext.data.JsonReader-successProperty" ext:member="successProperty"
 ext:cls="Ext.data.JsonReader">successProperty</a>&quot;</em>: <em>&quot;success&quot;</em>,
         <em>&quot;<a
 href="output/Ext.data.DataReader.html#Ext.data.DataReader-fields" ext:member="fields"
 ext:cls="Ext.data.DataReader">fields</a>&quot;</em>: [
             {<em>&quot;name&quot;</em>:
 <em>&quot;name&quot;</em>},
             {<em>&quot;name&quot;</em>: <em>&quot;job&quot;</em>,
 <em>&quot;mapping&quot;</em>: <em>&quot;occupation&quot;</em>}
         ],
         <i>// used by store to set its
 sortInfo</i>
         <em>&quot;sortInfo&quot;</em>:{
            <em>&quot;field&quot;</em>: <em>&quot;name&quot;</em>,
  
 <em>&quot;direction&quot;</em>: <em>&quot;ASC&quot;</em>
         },
         <i>// <a
 href="output/Ext.PagingToolbar.html" ext:cls="Ext.PagingToolbar">paging data</a> (<b>if</b> applicable)</i>
        
 <em>&quot;start&quot;</em>: 0,
         <em>&quot;limit&quot;</em>: 2,
         <i>// custom property</i>
        
 <em>&quot;foo&quot;</em>: <em>&quot;bar&quot;</em>
     },
     <i>// Reader's configured <a
 href="output/Ext.data.JsonReader.html#Ext.data.JsonReader-successProperty" ext:member="successProperty"
 ext:cls="Ext.data.JsonReader">successProperty</a></i>
     <em>&quot;success&quot;</em>: true,
     <i>// Reader's
 configured <a href="output/Ext.data.JsonReader.html#Ext.data.JsonReader-totalProperty" ext:member="totalProperty"
 ext:cls="Ext.data.JsonReader">totalProperty</a></i>
     <em>&quot;results&quot;</em>: 2000,
     <i>// Reader's
 configured <a href="output/Ext.data.JsonReader.html#Ext.data.JsonReader-root" ext:member="root"
 ext:cls="Ext.data.JsonReader">root</a></i>
     <i>// (this data simulates 2 results <a
 href="output/Ext.PagingToolbar.html" ext:cls="Ext.PagingToolbar">per page</a>)</i>
     <em>&quot;rows&quot;</em>: [
 <i>// <b>*Note:</b> this must be an Array</i>
         { <em>&quot;id&quot;</em>: 1, <em>&quot;name&quot;</em>:
 <em>&quot;Bill&quot;</em>, <em>&quot;occupation&quot;</em>: <em>&quot;Gardener&quot;</em> },
         {
 <em>&quot;id&quot;</em>: 2, <em>&quot;name&quot;</em>:  <em>&quot;Ben&quot;</em>, <em>&quot;occupation&quot;</em>:
 <em>&quot;Horticulturalist&quot;</em> }
     ]
 }</code></pre> 
 <p>The <b><tt>metaData</tt></b> property in the JSON data
 object should contain:</p> 
 <div class="mdetail-params">
  <ul> 
   <li>any of the configuration options for this
 class</li> 
   <li>a <b><tt><a href="output/Ext.data.Record.html#Ext.data.Record-fields" ext:member="fields"
 ext:cls="Ext.data.Record">fields</a></tt></b> property which the JsonReader will use as an argument to the <a
 href="output/Ext.data.Record.html#Ext.data.Record-create" ext:member="create" ext:cls="Ext.data.Record">data Record
 create method</a> in order to configure the layout of the Records it will produce.</li> 
   <li>a <b><tt><a
 href="output/Ext.data.Store.html#Ext.data.Store-sortInfo" ext:member="sortInfo"
 ext:cls="Ext.data.Store">sortInfo</a></tt></b> property which the JsonReader will use to set the <a
 href="output/Ext.data.Store.html" ext:cls="Ext.data.Store">Ext.data.Store</a>'s <a
 href="output/Ext.data.Store.html#Ext.data.Store-sortInfo" ext:member="sortInfo" ext:cls="Ext.data.Store">sortInfo</a>
 property</li> 
   <li>any custom properties needed</li> 
  </ul>
 </div>]]></description><name>data.jsonReader</name><tag-class>org.brushingbits.jnap.ui.extjs3.data.JsonReader</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[TODO]]></description><name>excludeModelProperties</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[[id] Name of the property within a row object that contains a record identifier value. Defaults to id]]></description><name>idProperty</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[TODO]]></description><name>includeModelAssociation</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[[undefined] Optional name of a property within a server-response that represents a user-feedback message.]]></description><name>messageProperty</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[TODO]]></description><name>modelClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[[undefined] Required. The name of the property which contains the Array of row objects. Defaults to undefined. An
 exception will be thrown if the root property is undefined. The data packet value for this property should be an empty
 array to clear the data or show no data.]]></description><name>root</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[[success] Name of the property from which to retrieve the success attribute. Defaults to success. See
 Ext.data.DataProxy.exception for additional information.]]></description><name>successProperty</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[[total] Name of the property from which to retrieve the total number of records in the dataset. This is only needed if
 the whole dataset is not passed in one go, but is being paged from the remote server. Defaults to total.]]></description><name>totalProperty</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 DataWriter extension for writing an array or single 
 <a href="output/Ext.data.Record.html"
 ext:cls="Ext.data.Record">Ext.data.Record</a> object(s) in preparation for executing a remote CRUD action.]]></description><name>data.jsonWriter</name><tag-class>org.brushingbits.jnap.ui.extjs3.data.JsonWriter</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[true to JSON encode the hashed data into a standard HTTP parameter named after this Reader's meta.root property which,
 by default is imported from the associated Reader. Defaults to true. If set to false, the hashed data is JSON encoded,
 along with the associated Ext.data.Store's baseParams, into the POST body. When using Ext.data.DirectProxy, set this to
 false since Ext.Direct.JsonProvider will perform its own json-encoding. In addition, if you're using Ext.data.HttpProxy,
 setting to false will cause HttpProxy to transmit data using the jsonData configuration-params of Ext.Ajax.request
 instead of params. When using a Ext.data.Store.restful Store, some serverside frameworks are tuned to expect data
 through the jsonData mechanism. In those cases, one will want to set encode: false, as in let the lower-level connection
 object (eg: Ext.Ajax) do the encoding.]]></description><name>encode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[False to send only the id to the server on delete, true to encode it in an object literal, eg: {id: 1} Defaults to false]]></description><name>encodeDelete</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[false by default. Set true to have the DataWriter always write HTTP params as a list, even when acting upon a single
 record.]]></description><name>listful</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[false by default. Set true to have DataWriter return ALL fields of a modified record -- not just those that changed.
 false to have DataWriter only request modified fields from a record.]]></description><name>writeAllFields</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>]]></description><name>data.node</name><tag-class>org.brushingbits.jnap.ui.extjs3.data.Node</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[The id for this node. If one is not specified, one is generated.]]></description><name>id</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true if this node is a leaf and does not have children]]></description><name>leaf</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 An implementation of Ext.data.DataProxy that reads a data object from a URL which may be in a domain other than the
 originating domain of the running page.
 <br /> 
 <p> <b>Note that if you are retrieving data from a page that is in a
 domain that is NOT the same as the originating domain of the running page, you must use this class, rather than
 HttpProxy.</b><br /> </p>
 <p> The content passed back from a server resource requested by a ScriptTagProxy <b>must</b>
 be executable JavaScript source code because it is used as the source inside a &lt;script&gt; tag.<br /> </p>
 <p> In
 order for the browser to process the returned data, the server must wrap the data object with a call to a callback
 function, the name of which is passed as a parameter by the ScriptTagProxy. Below is a Java example for a servlet which
 returns data for either a ScriptTagProxy, or an HttpProxy depending on whether the callback name was passed: </p>
 <p>
 </p>
 <pre><code>boolean scriptTag = false;
 String cb = request.getParameter(<em>&quot;callback&quot;</em>);
 <b>if</b>
 (cb != null) {
     scriptTag = true;
     response.setContentType(<em>&quot;text/javascript&quot;</em>);
 } <b>else</b> {
 
 response.setContentType(<em>&quot;application/x-json&quot;</em>);
 }
 Writer out = response.getWriter();
 <b>if</b>
 (scriptTag) {
     out.write(cb + <em>&quot;(&quot;</em>);
 }
 out.print(dataBlock.toJsonString());
 <b>if</b> (scriptTag)
 {
     out.write(<em>&quot;);&quot;</em>);
 }</code></pre> 
 <p>Below is a PHP example to do the same
 thing:</p>
 <pre><code>$callback = $_REQUEST[<em>'callback'</em>];
 
 <i>// Create the output object.</i>
 $output =
 array(<em>'a'</em> =&gt; <em>'Apple'</em>, <em>'b'</em> =&gt; <em>'Banana'</em>);
 
 <i>//start output</i>
 <b>if</b>
 ($callback) {
     header(<em>'Content-Type: text/javascript'</em>);
     echo $callback . <em>'('</em> .
 json_encode($output) . <em>');'</em>;
 } <b>else</b> {
     header(<em>'Content-Type: application/x-json'</em>);
     echo
 json_encode($output);
 }</code></pre> 
 <p>Below is the ASP.Net code to do the same thing:</p>
 <pre><code>String
 jsonString = <em>&quot;{success: true}&quot;</em>;
 String cb = Request.Params.Get(<em>&quot;callback&quot;</em>);
 String
 responseString = <em>&quot;&quot;</em>;
 <b>if</b> (!String.IsNullOrEmpty(cb)) {
     responseString = cb +
 <em>&quot;(&quot;</em> + jsonString + <em>&quot;)&quot;</em>;
 } <b>else</b> {
     responseString =
 jsonString;
 }
 Response.Write(responseString);</code></pre>]]></description><name>data.scriptTagProxy</name><tag-class>org.brushingbits.jnap.ui.extjs3.data.ScriptTagProxy</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[Specific urls to call on CRUD action methods "read", "create", "update" and "destroy". Defaults to: api: {
     read    :
 undefined,
     create  : undefined,
     update  : undefined,
     destroy : undefined
 } The url is built based upon the
 action being executed [load|create|save|destroy] using the commensurate api property, or if undefined default to the
 configured Ext.data.Store.url. For example: api: {
     load :    '/controller/load',
     create :  '/controller/new', 
 // Server MUST return idProperty of new record
     save :    '/controller/update',
     destroy :
 '/controller/destroy_action'
 }
 
 // Alternatively, one can use the object-form to specify each API-action
 api: {
    
 load: {url: 'read.php', method: 'GET'},
     create: 'create.php',
     destroy: 'destroy.php',
     save: 'update.php'
 }
 If the specific URL for a given CRUD action is undefined, the CRUD action request will be directed to the configured
 url. Note: To modify the URL for an action dynamically the appropriate API property should be modified before the action
 is requested using the corresponding before action event. For example to modify the URL associated with the load action:
 // modify the url for the action
 myStore.on({
     beforeload: {
         fn: function (store, options) {
             //
 use setUrl to change the URL for *just* this request.
             store.proxy.setUrl('changed1.php');
 
             //
 set optional second parameter to true to make this URL change
             // permanent, applying this URL for all
 subsequent requests.
             store.proxy.setUrl('changed1.php', true);
 
             // Altering the proxy API should
 be done using the public
             // method setApi.
             store.proxy.setApi('read', 'changed2.php');
 
         
 // Or set the entire API with a config-object.
             // When using the config-object option, you must redefine the
 entire
             // API -- not just a specific action of it.
             store.proxy.setApi({
                 read   
 : 'changed_read.php',
                 create  : 'changed_create.php',
                 update  : 'changed_update.php',
   
              destroy : 'changed_destroy.php'
             });
         }
     }
 });]]></description><name>api</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The name of the parameter to pass to the server which tells the server the name of the callback function set up by the
 load call to process the returned data object. Defaults to "callback". The server-side processing must read this
 parameter value, and generate javascript output which calls this named function passing the data object as its only
 parameter.]]></description><name>callbackParam</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Abstract method that should be implemented in all subclasses. Note: Should only be used by custom-proxy developers.
 (e.g.: HttpProxy.doRequest, DirectProxy.doRequest).]]></description><name>doRequest</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to true. Disable caching by adding a unique parameter name to the request.]]></description><name>nocache</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Abstract method that should be implemented in all subclasses. Note: Should only be used by custom-proxy developers.
 Callback for read action.]]></description><name>onRead</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Abstract method that should be implemented in all subclasses. Note: Should only be used by custom-proxy developers.
 Callback for create, update and destroy actions.]]></description><name>onWrite</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to false. Set to true to operate in a RESTful manner. Note: this parameter will automatically be set to true if
 the Ext.data.Store it is plugged into is set to restful: true. If the Store is RESTful, there is no need to set this
 option on the proxy. RESTful implementations enable the serverside framework to automatically route actions sent to one
 url based upon the HTTP method, for example: store: new Ext.data.Store({
     restful: true,
     proxy: new
 Ext.data.HttpProxy({url:'/users'}); // all requests sent to /users
     ...
 )} If there is no api specified in the
 configuration of the proxy, all requests will be marshalled to a single RESTful url (/users) so the serverside framework
 can inspect the HTTP Method and act accordingly: 
 Method   url        action
 POST     /users     create
 GET      /users 
 read
 PUT      /users/23  update
 DESTROY  /users/23  delete
  If set to true, a non-phantom record's id will be appended
 to the url. Some MVC (e.g., Ruby on Rails, Merb and Django) support segment based urls where the segments in the URL
 follow the Model-View-Controller approach: someSite.com/controller/action/id Where the segments in the url are
 typically: The first segment : represents the controller class that should be invoked. The second segment : represents
 the class function, or method, that should be called. The third segment : represents the ID (a variable typically passed
 to the method). Refer to Ext.data.DataProxy.api for additional information.]]></description><name>restful</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The number of milliseconds to wait for a response. Defaults to 30 seconds.]]></description><name>timeout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The URL from which to request the data object.]]></description><name>url</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 <p>The Store class encapsulates a client side cache of <a href="output/Ext.data.Record.html"
 ext:cls="Ext.data.Record">Record</a> objects which provide input data for Components such as the <a
 href="output/Ext.grid.GridPanel.html" ext:cls="Ext.grid.GridPanel">GridPanel</a>, the <a
 href="output/Ext.form.ComboBox.html" ext:cls="Ext.form.ComboBox">ComboBox</a>, or the <a href="output/Ext.DataView.html"
 ext:cls="Ext.DataView">DataView</a>.</p> 
 <p><u>Retrieving Data</u></p> 
 <p>A Store object may access a data object
 using:</p>
 <div class="mdetail-params">
  <ul> 
   <li><a href="output/Ext.data.Store.html#Ext.data.Store-proxy"
 ext:member="proxy" ext:cls="Ext.data.Store">configured implementation</a> of <a href="output/Ext.data.DataProxy.html"
 ext:cls="Ext.data.DataProxy">DataProxy</a></li> 
   <li><a href="output/Ext.data.Store.html#Ext.data.Store-data"
 ext:member="data" ext:cls="Ext.data.Store">data</a> to automatically pass in data</li> 
   <li><a
 href="output/Ext.data.Store.html#Ext.data.Store-loadData" ext:member="loadData" ext:cls="Ext.data.Store">loadData</a> to
 manually pass in data</li> 
  </ul>
 </div>
 <p></p> 
 <p><u>Reading Data</u></p> 
 <p>A Store object has no inherent
 knowledge of the format of the data object (it could be an Array, XML, or JSON). A Store object uses an appropriate <a
 href="output/Ext.data.Store.html#Ext.data.Store-reader" ext:member="reader" ext:cls="Ext.data.Store">configured
 implementation</a> of a <a href="output/Ext.data.DataReader.html" ext:cls="Ext.data.DataReader">DataReader</a> to create
 <a href="output/Ext.data.Record.html" ext:cls="Ext.data.Record">Record</a> instances from the data object.</p>
 
 <p><u>Store Types</u></p> 
 <p>There are several implementations of Store available which are customized for use with a
 specific DataReader implementation. Here is an example using an ArrayStore which implicitly creates a reader
 commensurate to an Array data object.</p> 
 <pre><code><b>var</b> myStore = <b>new</b> Ext.data.ArrayStore({
     fields:
 [<em>'fullname'</em>, <em>'first'</em>],
     idIndex: 0 <i>// id <b>for</b> each record will be the first
 element</i>
 });</code></pre> 
 <p>For custom implementations create a basic <a href="output/Ext.data.Store.html"
 ext:cls="Ext.data.Store">Ext.data.Store</a> configured as needed:</p> 
 <pre><code><i>// create a <a
 href="output/Ext.data.Record.html" ext:cls="Ext.data.Record">Record</a> constructor:</i>
 <b>var</b> rt =
 Ext.data.Record.create([
     {name: <em>'fullname'</em>},
     {name: <em>'first'</em>}
 ]);
 <b>var</b> myStore =
 <b>new</b> Ext.data.Store({
     <i>// explicitly create reader</i>
     reader: <b>new</b> Ext.data.ArrayReader(
        
 {
             idIndex: 0  <i>// id <b>for</b> each record will be the first element</i>
         },
         rt <i>//
 recordType</i>
     )
 });</code></pre> 
 <p>Load some data into store (note the data object is an array which corresponds
 to the reader):</p> 
 <pre><code><b>var</b> myData = [
     [1, <em>'Fred Flintstone'</em>, <em>'Fred'</em>],  <i>// note
 that id <b>for</b> the record is the first element</i>
     [2, <em>'Barney Rubble'</em>,
 <em>'Barney'</em>]
 ];
 myStore.loadData(myData);</code></pre> 
 <p>Records are cached and made available through accessor
 functions. An example of adding a record to the store:</p> 
 <pre><code><b>var</b> defaultData = {
     fullname:
 <em>'Full Name'</em>,
     first: <em>'First Name'</em>
 };
 <b>var</b> recId = 100; <i>// provide unique id <b>for</b> the
 record</i>
 <b>var</b> r = <b>new</b> myStore.recordType(defaultData, ++recId); <i>// create <b>new</b>
 record</i>
 myStore.<a href="output/Ext.data.Store.html#Ext.data.Store-insert" ext:member="insert"
 ext:cls="Ext.data.Store">insert</a>(0, r); <i>// insert a <b>new</b> record into the store (also see <a
 href="output/Ext.data.Store.html#Ext.data.Store-add" ext:member="add" ext:cls="Ext.data.Store">add</a>)</i></code></pre>
 
 <p><u>Writing Data</u></p> 
 <p>And <b>new in Ext version 3</b>, use the new <a href="output/Ext.data.DataWriter.html"
 ext:cls="Ext.data.DataWriter">DataWriter</a> to create an automated, <a
 href="http://extjs.com/deploy/dev/examples/writer/writer.html">Writable Store</a> along with <a
 href="http://extjs.com/deploy/dev/examples/restful/restful.html">RESTful features.</a></p>]]></description><name>data.store</name><tag-class>org.brushingbits.jnap.ui.extjs3.data.Store</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[true to destroy the store when the component the store is bound to is destroyed (defaults to false). Note: this should
 be set to true when using stores that are bound to only 1 component.]]></description><name>autoDestroy</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If data is not specified, and if autoLoad is true or an Object, this store's load method is automatically called after
 creation. If the value of autoLoad is an Object, this Object will be passed to the store's load method.]]></description><name>autoLoad</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to true causing the store to automatically save records to the server when a record is modified (ie: becomes
 'dirty'). Specify false to manually call save to send all modifiedRecords to the server. Note: each CRUD action will be
 sent as a separate request.]]></description><name>autoSave</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object containing properties which are to be sent as parameters for every HTTP request. Parameters are encoded as
 standard HTTP parameters using Ext.urlEncode. Note: baseParams may be superseded by any params specified in a load
 request, see load for more details. This property may be modified after creation using the setBaseParam method.]]></description><name>baseParams</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to true (unless restful:true). Multiple requests for each CRUD action (CREATE, READ, UPDATE and DESTROY) will
 be combined and sent as one transaction. Only applies when autoSave is set to false. If Store is RESTful, the DataProxy
 is also RESTful, and a unique transaction is generated for each record.]]></description><name>batch</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An inline data object readable by the reader. Typically this option, or the url option will be specified.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Provides the default values for the paramNames property. To globally modify the parameters for all stores, this object
 should be changed on the store prototype.]]></description><name>defaultParamNames</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object containing properties which specify the names of the paging and sorting parameters passed to remote servers
 when loading blocks of data. By default, this object takes the following form:
 <pre><code>{
     start : 'start',  // The parameter name which specifies the start row
     limit : 'limit',  // The parameter name which specifies number of rows to return
     sort : 'sort',    // The parameter name which specifies the column to sort on
     dir : 'dir'       // The parameter name which specifies the sort direction
 }</code></pre> The server must produce the requested data block upon receipt of these
 parameter names. If different parameter names are required, this property can be overriden using a configuration
 property. A PagingToolbar bound to this Store uses this property to determine the parameter names to use in its
 requests.]]></description><name>paramNames</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The DataProxy object which provides access to a data object. See url.]]></description><name>proxy</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to clear all modified record information each time the store is loaded or when a record is removed (defaults to
 false). See getModifiedRecords for the accessor method to retrieve the modified records.]]></description><name>pruneModifiedRecords</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true if sorting is to be handled by requesting the Proxy to provide a refreshed version of the data object in sorted
 order, as opposed to sorting the Record cache in place (defaults to false). If remoteSort is true, then clicking on a
 Grid Column's header causes the current page to be requested from the server appending the following two parameters to
 the params: sort : String The name (as specified in the Record's Field definition) of the field to sort on. dir : String
 The direction of the sort, 'ASC' or 'DESC' (case-sensitive).]]></description><name>remoteSort</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to true. The Store and the set Proxy operate in a RESTful manner. The store will
 automatically generate GET, POST, PUT and DELETE requests to the server. The HTTP method used for any given CRUD action
 is described in Ext.data.Api.restActions. For additional information see Ext.data.DataProxy.restful. Note: if
 restful:true batch will internally be set to false.]]></description><name>restful</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A config object to specify the sort order in the request of a Store's load operation. Note that for local sorting, the
 direction property is case-sensitive. See also remoteSort and paramNames. For example: sortInfo: {
     field:
 'fieldName',
     direction: 'ASC' // or 'DESC' (case sensitive for local sorting)
 }]]></description><name>sortInfo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If passed, the id to use to register with the StoreMgr. Note: if a (deprecated) id is specified it will supersede the
 storeId assignment.]]></description><name>storeId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If a proxy is not specified the url will be used to implicitly configure a HttpProxy if an url is specified. Typically
 this option, or the data option will be specified.]]></description><name>url</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 <p>Data reader class to create an Array of <a href="output/Ext.data.Record.html"
 ext:cls="Ext.data.Record">Ext.data.Record</a> objects from an XML document based on mappings in a provided <a
 href="output/Ext.data.Record.html" ext:cls="Ext.data.Record">Ext.data.Record</a> constructor.</p> 
 <p><b>Note</b>: that
 in order for the browser to parse a returned XML document, the Content-Type header in the HTTP response must be set to
 &quot;text/xml&quot; or &quot;application/xml&quot;.</p> 
 <p>Example code:</p> 
 <pre><code><b>var</b> Employee =
 Ext.data.Record.create([
    {name: <em>'name'</em>, mapping: <em>'name'</em>},     <i>// <em>&quot;mapping&quot;</em>
 property not needed <b>if</b> it is the same as <em>&quot;name&quot;</em></i>
    {name: <em>'occupation'</em>}          
 <i>// This field will use <em>&quot;occupation&quot;</em> as the mapping.</i>
 ]);
 <b>var</b> myReader = <b>new</b>
 Ext.data.XmlReader({
    totalProperty: <em>&quot;results&quot;</em>, <i>// The element which contains the total dataset
 size (optional)</i>
    record: <em>&quot;row&quot;</em>,           <i>// The repeated element which contains row
 information</i>
    idProperty: <em>&quot;id&quot;</em>         <i>// The element within the row that provides an ID
 <b>for</b> the record (optional)</i>
    messageProperty: <em>&quot;msg&quot;</em>   <i>// The element within the
 response that provides a user-feedback message (optional)</i>
 }, Employee);</code></pre> 
 <p> This would consume an XML
 file like this: </p>
 <pre><code>&lt;?xml version=<em>&quot;1.0&quot;</em>
 encoding=<em>&quot;UTF-8&quot;</em>?&gt;
 &lt;dataset&gt;
  &lt;results&gt;2&lt;/results&gt;
  &lt;row&gt;
   
 &lt;id&gt;1&lt;/id&gt;
    &lt;name&gt;Bill&lt;/name&gt;
    &lt;occupation&gt;Gardener&lt;/occupation&gt;
  &lt;/row&gt;
 
 &lt;row&gt;
    &lt;id&gt;2&lt;/id&gt;
    &lt;name&gt;Ben&lt;/name&gt;
   
 &lt;occupation&gt;Horticulturalist&lt;/occupation&gt;
  &lt;/row&gt;
 &lt;/dataset&gt;</code></pre>]]></description><name>data.xmlReader</name><tag-class>org.brushingbits.jnap.ui.extjs3.data.XmlReader</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[TODO]]></description><name>excludeModelProperties</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The DomQuery path relative from the record element to the element that contains a record identifier value.]]></description><name>idPath</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[TODO]]></description><name>includeModelAssociation</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[[undefined] Optional name of a property within a server-response that represents a user-feedback message.]]></description><name>messageProperty</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[TODO]]></description><name>modelClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The DomQuery path to the repeated element which contains record information.]]></description><name>record</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The DomQuery path to the success attribute used by forms.]]></description><name>successProperty</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The DomQuery path from which to retrieve the total number of records in the dataset. This is only needed if the whole
 dataset is not passed in one go, but is being paged from the remote server.]]></description><name>totalProperty</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 DataWriter extension for writing an array or single 
 <a href="output/Ext.data.Record.html"
 ext:cls="Ext.data.Record">Ext.data.Record</a> object(s) in preparation for executing a remote CRUD action via XML.
 XmlWriter uses an instance of 
 <a href="output/Ext.XTemplate.html" ext:cls="Ext.XTemplate">Ext.XTemplate</a> for maximum
 flexibility in defining your own custom XML schema if the default schema is not appropriate for your needs. See the 
 <a
 href="output/Ext.data.XmlWriter.html#Ext.data.XmlWriter-tpl" ext:member="tpl" ext:cls="Ext.data.XmlWriter">tpl</a>
 configuration-property.]]></description><name>data.xmlWriter</name><tag-class>org.brushingbits.jnap.ui.extjs3.data.XmlWriter</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[[xrequest] (Optional) The name of the XML document root-node. Note: this parameter is required only when sending extra
 baseParams to the server during a write-request -- if no baseParams are set, the Ext.data.XmlReader.record meta-property
 can suffice as the XML document root-node for write-actions involving just a single record. For requests involving
 multiple records and NO baseParams, the Ext.data.XmlWriter.root property can act as the XML document root.]]></description><name>documentRoot</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[[false] Set to true to force XML documents having a root-node as defined by documentRoot, even with no baseParams
 defined.]]></description><name>forceDocumentRoot</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[false by default. Set true to have the DataWriter always write HTTP params as a list, even when acting upon a single
 record.]]></description><name>listful</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[[records] The name of the containing element which will contain the nodes of an write-action involving multiple records.
 Each xml-record written to the server will be wrapped in an element named after Ext.data.XmlReader.record property. eg:
 
 <?xml version="1.0" encoding="UTF-8"?>
 <user><first>Barney</first></user> However, when multiple records are written in
 a batch-operation, these records must be wrapped in a containing Element. eg: 
 <?xml version="1.0" encoding="UTF-8"?>
   
 <records>
         <first>Barney</first></user>
         <records><first>Barney</first></user>
     </records> Defaults to
 records. Do not confuse the nature of this property with that of documentRoot]]></description><name>root</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The XML template used to render write-actions to your server. One can easily provide his/her own custom
 template-definition if the default does not suffice. Defaults to: 
 <?xml version="{version}" encoding="{encoding}"?>
    
 <tpl if="documentRoot"><{documentRoot}>
     <tpl for="baseParams">
         <tpl for=".">
            
 <{name}>{value}</{name}>
         </tpl>
     </tpl>
     <tpl if="records.length > 1"><{root}>',
     <tpl for="records">
  
 <{parent.record}>
         <tpl for=".">
             <{name}>{value}</{name}>
         </tpl>
         </{parent.record}>
  
 </tpl>
     <tpl if="records.length > 1"></{root}></tpl>
     <tpl if="documentRoot"></{documentRoot}></tpl>
  Templates
 will be called with the following API {String} version [1.0] The xml version. {String} encoding [ISO-8859-15] The xml
 encoding. {String/false} documentRoot The XML document root-node name or false if not required. See documentRoot and
 forceDocumentRoot. {String} record The meta-data parameter defined on your Ext.data.XmlReader.record configuration
 represents the name of the xml-tag containing each record. {String} root The meta-data parameter defined by
 Ext.data.XmlWriter.root configuration-parameter. Represents the name of the xml root-tag when sending multiple records
 to the server. {Array} records The records being sent to the server, ie: the subject of the write-action being
 performed. The records parameter will be always be an array, even when only a single record is being acted upon. Each
 item within the records array will contain an array of field objects having the following properties: {String} name The
 field-name of the record as defined by your Ext.data.Record definition. The "mapping" property will be used, otherwise
 it will match the "name" property. Use this parameter to define the XML tag-name of the property. {Mixed} value The
 record value of the field enclosed within XML tags specified by name property above. {Array} baseParams. The baseParams
 as defined upon Ext.data.Store.baseParams. Note that the baseParams have been converted into an array of [{name : "foo",
 value: "bar"}, ...] pairs in the same manner as the records parameter above. See documentRoot and forceDocumentRoot.]]></description><name>tpl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[false by default. Set true to have DataWriter return ALL fields of a modified record -- not just those that changed.
 false to have DataWriter only request modified fields from a record.]]></description><name>writeAllFields</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[[ISO-8859-15] The encoding written to header of xml documents. <?xml version="1.0" encoding="ISO-8859-15"?>]]></description><name>xmlEncoding</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[[1.0] The version written to header of xml documents. <?xml version="1.0" encoding="ISO-8859-15"?>]]></description><name>xmlVersion</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 A mechanism for displaying data using custom layout templates and formatting. DataView uses an 
 <a
 href="output/Ext.XTemplate.html" ext:cls="Ext.XTemplate">Ext.XTemplate</a> as its internal templating mechanism, and is
 bound to an 
 <a href="output/Ext.data.Store.html" ext:cls="Ext.data.Store">Ext.data.Store</a> so that as the data in the
 store changes the view is automatically updated to reflect the changes. The view also provides built-in behavior for
 many common events that can occur for its contained items including click, doubleclick, mouseover, mouseout, etc. as
 well as a built-in selection model. 
 <b>In order to use these features, an <a
 href="output/Ext.DataView.html#Ext.DataView-itemSelector" ext:member="itemSelector"
 ext:cls="Ext.DataView">itemSelector</a> config must be provided for the DataView to determine what nodes it will be
 working with.</b> 
 <p>The example below binds a DataView to a <a href="output/Ext.data.Store.html"
 ext:cls="Ext.data.Store">Ext.data.Store</a> and renders it into an <a href="output/Ext.Panel.html"
 ext:cls="Ext.Panel">Ext.Panel</a>.</p> 
 <pre><code><b>var</b> store = <b>new</b> Ext.data.JsonStore({
     url: <em>'get-images.php'</em>,
     root: <em>'images'</em>,
     fields: [
         <em>'name'</em>, <em>'url'</em>,
         {name:<em>'size'</em>, type: <em>'float'</em>},
         {name:<em>'lastmod'</em>, type:<em>'date'</em>, dateFormat:<em>'timestamp'</em>}
     ]
 });
 store.load();
 
 <b>var</b> tpl = <b>new</b> Ext.XTemplate(
     <em>'&lt;tpl <b>for</b>=<em>&quot;.&quot;</em>&gt;'</em>,
         <em>'&lt;div class=<em>&quot;thumb-wrap&quot;</em> id=<em>&quot;{name}&quot;</em>&gt;'</em>,
         <em>'&lt;div class=<em>&quot;thumb&quot;</em>&gt;&lt;img src=<em>&quot;{url}&quot;</em> title=<em>&quot;{name}&quot;</em>&gt;&lt;/div&gt;'</em>,
         <em>'&lt;span class=<em>&quot;x-editable&quot;</em>&gt;{shortName}&lt;/span&gt;&lt;/div&gt;'</em>,
     <em>'&lt;/tpl&gt;'</em>,
     <em>'&lt;div class=<em>&quot;x-clear&quot;</em>&gt;&lt;/div&gt;'</em>
 );
 
 <b>var</b> panel = <b>new</b> Ext.Panel({
    
 id:<em>'images-view'</em>,
     frame:true,
     width:535,
     autoHeight:true,
     collapsible:true,
     layout:<em>'fit'</em>,
     title:<em>'Simple DataView'</em>,
     items: <b>new</b> Ext.DataView({
         store: store,
         tpl: tpl,
         autoHeight:true,
         multiSelect: true,
         overClass:<em>'x-view-over'</em>,
         itemSelector:<em>'div.thumb-wrap'</em>,
         emptyText: <em>'No images to display'</em>
     })
 });
 panel.render(document.body);</code></pre>]]></description><name>dataView</name><tag-class>org.brushingbits.jnap.ui.extjs3.DataView</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[Whether the component can move the Dom node when rendering (defaults to true).]]></description><name>allowDomMove</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use an
 AnchorLayout (or subclass thereof). based layout manager, for example: Ext.form.FormPanel specifying layout: 'anchor' //
 or 'form', or 'absolute' See Ext.layout.AnchorLayout.anchor also.]]></description><name>anchor</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element corresponding to a DIV that is already present in
 the document that specifies some structural markup for this component. Description : When applyTo is used, constituent
 parts of the component can also be specified by id or CSS class name within the main element, and the component being
 created may attempt to create its subcomponents from that markup if applicable. Notes : When using this config, a call
 to render() is not required. If applyTo is specified, any value passed for renderTo will be ignored and the target
 element's parent node will automatically be used as the component's container.]]></description><name>applyTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A tag name or DomHelper spec used to create the Element which will encapsulate this Component. You do not normally need
 to specify this. For the base classes Ext.Component, Ext.BoxComponent, and Ext.Container, this defaults to 'div'. The
 more complex Ext classes use a more complex DOM structure created by their own onRender methods. This is intended to
 allow the developer to create application-specific utility Components encapsulated by different DOM elements. Example
 usage: <pre><code>{
     xtype: 'box',
     autoEl: {
         tag: 'img',
         src: 'http://www.example.com/example.jpg'
     }
 },
 {
     xtype: 'box',
     autoEl: {
         tag: 'blockquote',
         html: 'autoEl is cool!'
     }
 }, {
     xtype: 'container',
     autoEl: 'ul',
     cls: 'ux-unordered-list',
     items: {
         xtype: 'box',
         autoEl: 'li',
   
      html: 'First list item'
     }
 }</pre></code>]]></description><name>autoEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to use height:'auto', false to use fixed height (or allow it to be managed by its parent Container's layout
 manager. Defaults to false. Note: Although many components inherit this config option, not all will function as expected
 with a height of 'auto'. Setting autoHeight:true means that the browser will manage height based on the element's
 contents, and that Ext will not manage it at all. If the browser is managing the height, be aware that resizes performed
 by the browser in response to changes within the structure of the Component cannot be detected. Therefore changes to the
 height might result in elements needing to be synchronized with the new height. Example: var w = new Ext.Window({
    
 title: 'Window',
     width: 600,
     autoHeight: true,
     items: {
         title: 'Collapse Me',
         height: 400,
  
 collapsible: true,
         border: false,
         listeners: {
             beforecollapse: function() {
                w.el.shadow.hide();
             },
             beforeexpand: function() {
                w.el.shadow.hide();
             },
             collapse: function() {
                w.syncShadow();
             },
             expand: function() {
                w.syncShadow();
             }
         }
     }
 }).show();]]></description><name>autoHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to use overflow:'auto' on the components layout element and show scroll bars automatically when necessary, false to
 clip any overflowing content (defaults to false).]]></description><name>autoScroll</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True if the component should check for hidden classes (e.g. 'x-hidden' or 'x-hide-display') and remove them on render
 (defaults to false).]]></description><name>autoShow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to use width:'auto', false to use fixed width (or allow it to be managed by its parent Container's layout manager.
 Defaults to false. Note: Although many components inherit this config option, not all will function as expected with a
 width of 'auto'. Setting autoWidth:true means that the browser will manage width based on the element's contents, and
 that Ext will not manage it at all. If the browser is managing the width, be aware that resizes performed by the browser
 in response to changes within the structure of the Component cannot be detected. Therefore changes to the width might
 result in elements needing to be synchronized with the new width. For example, where the target element is: <div
 id='grid-container' style='margin-left:25%;width:50%'></div> A Panel rendered into that target element must listen for
 browser window resize in order to relay its child items when the browser changes its width: var myPanel = new
 Ext.Panel({
     renderTo: 'grid-container',
     monitorResize: true, // relay on browser resize
     title: 'Panel',
    
 height: 400,
     autoWidth: true,
     layout: 'hbox',
     layoutConfig: {
         align: 'stretch'
     },
     defaults: {
         flex: 1
     },
     items: [{
         title: 'Box 1',
     }, {
         title: 'Box 2'
     }, {
         title:
 'Box 3'
     }],
 });]]></description><name>autoWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Set this to true to ignore datachanged events on the bound store. This is useful if you wish to provide custom
 transition animations via a plugin (defaults to false)]]></description><name>blockRefresh</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to [].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class used to to apply to the special clearing div rendered directly after each form field wrapper to provide
 field clearing (defaults to 'x-form-clear-left'). Note: this config is only used when this Component is rendered by a
 Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or specifying
 layout:'form') and either a fieldLabel is specified or isFormField=true is specified. See Ext.layout.FormLayout.fieldTpl
 also.]]></description><name>clearCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element (defaults to ''). This can be useful for
 adding customized styles to the component or any of its children using standard CSS rules.]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's container. This can be useful for adding customized
 styles to the container or any of its children using standard CSS rules. See Ext.layout.ContainerLayout.extraCls also.
 Note: ctCls defaults to '' except for the following class which assigns a value by default: Box Layout :
 'x-box-layout-ct' To configure the above Class with an extra CSS class append to the default. For example, for BoxLayout
 (Hbox and Vbox): ctCls: 'x-box-layout-ct custom-class']]></description><name>ctCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to defer emptyText being applied until the store's first load]]></description><name>deferEmptyText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component disabled (default is false).]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class added to the component when it is disabled (defaults to 'x-item-disabled').]]></description><name>disabledClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The text to display in the view when there is no data to display (defaults to '').]]></description><name>emptyText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The label text to display next to this Component (defaults to ''). Note: this config is only used when this Component is
 rendered by a Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or
 specifying layout:'form'). Also see hideLabel and Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
    
 height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name'
    
 }]
 });]]></description><name>fieldLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use a
 BoxLayout. Each child Component with a flex property will be flexed either vertically (by a VBoxLayout) or horizontally
 (by an HBoxLayout) according to the item's relative flex value compared to the sum of all Components with flex value
 specified. Any child items that have either a flex = 0 or flex = undefined will not be 'flexed' (the initial size will
 not be changed).]]></description><name>flex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component hidden (default is false). If true, the hide method will be called internally.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to completely hide the label element (label and separator). Defaults to false. By default, even if you do not
 specify a fieldLabel the space will still be reserved so that the field will line up with other fields that do have
 labels. Setting this to true will cause the field to not reserve that space. Note: see the note for clearCls. Example
 use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield'
        
 hideLabel: true
     }]
 });]]></description><name>hideLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[How this component should be hidden. Supported values are 'visibility' (css visibility), 'offsets' (negative offset
 position) and 'display' (css display). Note: the default of 'display' is generally preferred since items are
 automatically laid out when they are first shown (no sizing is done while hidden).]]></description><name>hideMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide and show the component's container when hide/show is called on the component, false to hide and show the
 component itself (defaults to false). For example, this can be used as a shortcut for a hide button on a window by
 setting hide:true on the button when adding it to its parent container.]]></description><name>hideParent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id of this component (defaults to an auto-assigned id). You should assign an id if you need to be able to
 access the component later and you do not have an object reference available (e.g., using Ext.getCmp). Note that this id
 will also be used as the element id for the containing HTML element that is rendered to the page for this component.
 This allows you to write id-based CSS rules to style the specific instance of this component uniquely, and also to
 select sub-elements using this component's id as the parent. Note: to avoid complications imposed by a unique id also
 see itemId and ref. Note: to access the container of an item see ownerCt.]]></description><name>id</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use the
 FormLayout layout manager (e.g. Ext.form.FormPanel or specifying layout:'form'). An additional CSS class to apply to the
 div wrapping the form item element of this field. If supplied, itemCls at the field level will override the default
 itemCls supplied at the container level. The value specified for itemCls will be added to the default class
 ('x-form-item'). Since it is applied to the item wrapper (see Ext.layout.FormLayout.fieldTpl), it allows you to write
 standard CSS rules that can apply to the field, the label (if specified), or any other element within the markup for the
 field. Note: see the note for fieldLabel. Example use: // Apply a style to the field's label:
 <style>
     .required
 .x-form-item-label {font-weight:bold;color:red;}
 </style>
 
 new Ext.FormPanel({
     height: 100,
     renderTo:
 Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         itemCls: 'required' //this
 label will be styled
     },{
         xtype: 'textfield',
         fieldLabel: 'Favorite Color'
     }]
 });]]></description><name>itemCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An itemId can be used as an alternative way to get a reference to a component when no object reference is available.
 Instead of using an id with Ext.getCmp, use itemId with Ext.Container.getComponent which will retrieve itemId's or id's.
 Since itemId's are an index to the container's internal MixedCollection, the itemId is scoped locally to the container
 -- avoiding potential conflicts with Ext.ComponentMgr which requires a unique id. var c = new Ext.Panel({ //
     height:
 300,
     renderTo: document.body,
     layout: 'auto',
     items: [
         {
             itemId: 'p1',
            
 title: 'Panel 1',
             height: 150
         },
         {
             itemId: 'p2',
             title: 'Panel 2',
  
 height: 150
         }
     ]
 })
 p1 = c.getComponent('p1'); // not the same as Ext.getCmp()
 p2 =
 p1.ownerCt.getComponent('p2'); // reference via a sibling Also see id and ref. Note: to access the container of an item
 see ownerCt.]]></description><name>itemId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[This is a required setting. A simple CSS selector (e.g. div.some-class or span:first-child) that will be used to
 determine what nodes this DataView will be working with.]]></description><name>itemSelector</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The separator to display after the text of each fieldLabel. This property may be configured at various levels. The order
 of precedence is: field / component level container level layout level (defaults to colon ':') To display no separator
 for this field's label specify empty string ''. Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 layoutConfig: {
         labelSeparator: '~'   // layout config has lowest priority (defaults to ':')
     },
    
 labelSeparator: '>>',     // config at container level
     items: [{
         xtype: 'textfield',
         fieldLabel:
 'Field 1',
         labelSeparator: '...' // field/component level config supersedes others
     },{
         xtype:
 'textfield',
         fieldLabel: 'Field 2' // labelSeparator will be '='
     }]
 });]]></description><name>labelSeparator</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS style specification string to apply directly to this field's label. Defaults to the container's labelStyle value
 if set (e.g., Ext.layout.FormLayout.labelStyle , or ''). Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         labelStyle: 'font-weight:bold;'
     }]
 });]]></description><name>labelStyle</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A string to display during data load operations (defaults to undefined). If specified, this text will be displayed in a
 loading div and the view's contents will be cleared while loading, otherwise the view's contents will continue to
 display normally until the new data is loaded and the contents are replaced.]]></description><name>loadingText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout or one of the two BoxLayout subclasses. An object containing margins to apply to this BoxComponent in the
 format: {
     top: (top margin),
     right: (right margin),
     bottom: (bottom margin),
     left: (left margin)
 } May
 also be a string containing space-separated, numeric margin values. The order of the sides associated with each value
 matches the way CSS processes margin values: If there is only one value, it applies to all sides. If there are two
 values, the top and bottom borders are set to the first value and the right and left are set to the second. If there are
 three values, the top is set to the first value, the left and right are set to the second, and the bottom is set to the
 third. If there are four values, they apply to the top, right, bottom, and left, respectively. Defaults to: {top:0,
 right:0, bottom:0, left:0}]]></description><name>margins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to allow selection of more than one item at a time, false to allow selection of only a single item at a time or no
 selection at all, depending on the value of singleSelect (defaults to false).]]></description><name>multiSelect</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS class to apply to each item in the view on mouseover (defaults to undefined).]]></description><name>overClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element when the mouse moves over the Element, and
 removed when the mouse moves out. (defaults to ''). This can be useful for adding customized 'active' or 'hover' styles
 to the component or any of its children using standard CSS rules.]]></description><name>overCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level x coordinate for this component if contained within a positioning container.]]></description><name>pageX</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level y coordinate for this component if contained within a positioning container.]]></description><name>pageY</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered ptype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a Plugin is being specified not as a fully
 instantiated Component, but as a Component config object. The ptype will be looked up at render time up to determine
 what type of Plugin to create. If you create your own Plugins, you may register them using
 Ext.ComponentMgr.registerPlugin in order to be able to take advantage of lazy instantiation and rendering.]]></description><name>ptype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A path specification, relative to the Component's ownerCt specifying into which ancestor Container to place a named
 reference to this Component. The ancestor axis can be traversed by using '/' characters in the path. For example, to put
 a reference to a Toolbar Button into the Panel which owns the Toolbar: var myGrid = new Ext.grid.EditorGridPanel({
    
 title: 'My EditorGridPanel',
     store: myStore,
     colModel: myColModel,
     tbar: [{
         text: 'Save',
        
 handler: saveChanges,
         disabled: true,
         ref: '../saveButton'
     }],
     listeners: {
         afteredit:
 function() {
 //          The button reference is in the GridPanel
             myGrid.saveButton.enable();
         }
    
 }
 }); In the code above, if the ref had been 'saveButton' the reference would have been placed into the Toolbar. Each
 '/' in the ref moves up one level from the Component's ownerCt. Also see the added and removed events.]]></description><name>ref</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout layout manager (e.g. specifying layout:'border'). See Ext.layout.BorderLayout also.]]></description><name>region</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS class to apply to each selected item in the view (defaults to 'x-view-selected').]]></description><name>selectedClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to enable multiselection by clicking on multiple items without requiring the user to hold Shift or Ctrl, false to
 force the user to hold Ctrl or Shift to select more than on item (defaults to false).]]></description><name>simpleSelect</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to allow selection of exactly one item at a time, false to allow no selection at all (defaults to false). Note that
 if multiSelect = true, this value will be ignored.]]></description><name>singleSelect</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should trigger this component to save its state (defaults to none). stateEvents may
 be any type of event supported by this component, including browser or custom events (e.g., ['click',
 'customerchange']). See stateful for an explanation of saving and restoring Component state.]]></description><name>stateEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id for this component to use for state management purposes (defaults to the component id if one was set,
 otherwise null if the component is using a generated id). See stateful for an explanation of saving and restoring
 Component state.]]></description><name>stateId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A flag which causes the Component to attempt to restore the state of internal properties from a saved state on startup.
 The component must have either a stateId or id assigned for state to be managed. Auto-generated ids are not guaranteed
 to be stable across page loads and cannot be relied upon to save and restore the same state for a component. For state
 saving to work, the state manager's provider must have been set to an implementation of Ext.state.Provider which
 overrides the set and get methods to save and recall name/value pairs. A built-in implementation,
 Ext.state.CookieProvider is available. To set the state provider for the current page: Ext.state.Manager.setProvider(new
 Ext.state.CookieProvider({
     expires: new Date(new Date().getTime()+(1000*60*60*24*7)), //7 days from now
 })); A
 stateful Component attempts to save state when one of the events listed in the stateEvents configuration fires. To save
 state, a stateful Component first serializes its state by calling getState. By default, this function does nothing. The
 developer must provide an implementation which returns an object hash which represents the Component's restorable state.
 The value yielded by getState is passed to Ext.state.Manager.set which uses the configured Ext.state.Provider to save
 the object keyed by the Component's stateId, or, if that is not specified, its id. During construction, a stateful
 Component attempts to restore its state by calling Ext.state.Manager.get passing the stateId, or, if that is not
 specified, the id. The resulting object is passed to applyState. The default implementation of applyState simply copies
 properties into the object, but a developer may override this to support more behaviour. You can perform extra
 processing on state save and restore by attaching handlers to the beforestaterestore, staterestore, beforestatesave and
 statesave events.]]></description><name>stateful</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
     title: 'Some Title',
     renderTo: Ext.getBody(),
     width: 400, height:
 300,
     layout: 'form',
     items: [{
         xtype: 'textarea',
         style: {
             width: '95%',
            
 marginBottom: '10px'
         }
     },
         new Ext.Button({
             text: 'Send',
             minWidth: '100',
   
          style: {
                 marginBottom: '10px'
             }
         })
     ]
 });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is a child item of a TabPanel. A string to be used as innerHTML
 (html tags are accepted) to show in a tooltip when mousing over the associated tab selector element.
 Ext.QuickTips.init() must be called in order for the tips to render.]]></description><name>tabTip</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to enable mouseenter and mouseleave events]]></description><name>trackOver</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local x (left) coordinate for this component if contained within a positioning container.]]></description><name>x</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered xtype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a child item of a Container is being specified not
 as a fully instantiated Component, but as a Component config object. The xtype will be looked up at render time up to
 determine what type of child Component to create. The predefined xtypes are listed here. If you subclass Components to
 create your own Components, you may register them using Ext.ComponentMgr.registerType in order to be able to take
 advantage of lazy instantiation and rendering.]]></description><name>xtype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local y (top) coordinate for this component if contained within a positioning container.]]></description><name>y</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 <p>A popup date picker. This class is used by the <a href="output/Ext.form.DateField.html"
 ext:cls="Ext.form.DateField">DateField</a> class to allow browsing and selection of valid dates.</p> 
 <p>All the string
 values documented below may be overridden by including an Ext locale file in your page.</p>]]></description><name>datePicker</name><tag-class>org.brushingbits.jnap.ui.extjs3.DatePicker</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[Whether the component can move the Dom node when rendering (defaults to true).]]></description><name>allowDomMove</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element corresponding to a DIV that is already present in
 the document that specifies some structural markup for this component. Description : When applyTo is used, constituent
 parts of the component can also be specified by id or CSS class name within the main element, and the component being
 created may attempt to create its subcomponents from that markup if applicable. Notes : When using this config, a call
 to render() is not required. If applyTo is specified, any value passed for renderTo will be ignored and the target
 element's parent node will automatically be used as the component's container.]]></description><name>applyTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A tag name or DomHelper spec used to create the Element which will encapsulate this Component. You do not normally need
 to specify this. For the base classes Ext.Component, Ext.BoxComponent, and Ext.Container, this defaults to 'div'. The
 more complex Ext classes use a more complex DOM structure created by their own onRender methods. This is intended to
 allow the developer to create application-specific utility Components encapsulated by different DOM elements. Example
 usage: <pre><code>{
     xtype: 'box',
     autoEl: {
         tag: 'img',
         src: 'http://www.example.com/example.jpg'
     }
 },
 {
     xtype: 'box',
     autoEl: {
         tag: 'blockquote',
         html: 'autoEl is cool!'
     }
 }, {
     xtype: 'container',
     autoEl: 'ul',
     cls: 'ux-unordered-list',
     items: {
         xtype: 'box',
         autoEl: 'li',
   
      html: 'First list item'
     }
 }</pre></code>]]></description><name>autoEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True if the component should check for hidden classes (e.g. 'x-hidden' or 'x-hide-display') and remove them on render
 (defaults to false).]]></description><name>autoShow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to [].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The text to display on the cancel button (defaults to 'Cancel')]]></description><name>cancelText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class used to to apply to the special clearing div rendered directly after each form field wrapper to provide
 field clearing (defaults to 'x-form-clear-left'). Note: this config is only used when this Component is rendered by a
 Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or specifying
 layout:'form') and either a fieldLabel is specified or isFormField=true is specified. See Ext.layout.FormLayout.fieldTpl
 also.]]></description><name>clearCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element (defaults to ''). This can be useful for
 adding customized styles to the component or any of its children using standard CSS rules.]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's container. This can be useful for adding customized
 styles to the container or any of its children using standard CSS rules. See Ext.layout.ContainerLayout.extraCls also.
 Note: ctCls defaults to '' except for the following class which assigns a value by default: Box Layout :
 'x-box-layout-ct' To configure the above Class with an extra CSS class append to the default. For example, for BoxLayout
 (Hbox and Vbox): ctCls: 'x-box-layout-ct custom-class']]></description><name>ctCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of textual day names which can be overriden for localization support (defaults to Date.dayNames)]]></description><name>dayNames</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component disabled (default is false).]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class added to the component when it is disabled (defaults to 'x-item-disabled').]]></description><name>disabledClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of 'dates' to disable, as strings. These strings will be used to build a dynamic regular expression so they are
 very powerful. Some examples: ['03/08/2003', '09/16/2003'] would disable those exact dates ['03/08', '09/16'] would
 disable those days for every year ['^03/08'] would only match the beginning (useful if you are using short years)
 ['03/../2006'] would disable every day in March 2006 ['^03'] would disable every day in every March Note that the format
 of the dates included in the array should exactly match the format config. In order to support regular expressions, if
 you are using a date format that has '.' in it, you will have to escape the dot when restricting dates. For example:
 ['03\\.08\\.03'].]]></description><name>disabledDates</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[JavaScript regular expression used to disable a pattern of dates (defaults to null). The disabledDates config will
 generate this regex internally, but if you specify disabledDatesRE it will take precedence over the disabledDates value.]]></description><name>disabledDatesRE</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The tooltip text to display when the date falls on a disabled date (defaults to 'Disabled')]]></description><name>disabledDatesText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of days to disable, 0-based. For example, [0, 6] disables Sunday and Saturday (defaults to null).]]></description><name>disabledDays</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The tooltip to display when the date falls on a disabled day (defaults to 'Disabled')]]></description><name>disabledDaysText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The label text to display next to this Component (defaults to ''). Note: this config is only used when this Component is
 rendered by a Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or
 specifying layout:'form'). Also see hideLabel and Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
    
 height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name'
    
 }]
 });]]></description><name>fieldLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default date format string which can be overriden for localization support. The format must be valid according to
 Date.parseDate (defaults to 'm/d/y').]]></description><name>format</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. A function that will handle the select event of this picker. The handler is passed the following parameters:
 picker : DatePicker This DatePicker. date : Date The selected date.]]></description><name>handler</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component hidden (default is false). If true, the hide method will be called internally.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to completely hide the label element (label and separator). Defaults to false. By default, even if you do not
 specify a fieldLabel the space will still be reserved so that the field will line up with other fields that do have
 labels. Setting this to true will cause the field to not reserve that space. Note: see the note for clearCls. Example
 use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield'
        
 hideLabel: true
     }]
 });]]></description><name>hideLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[How this component should be hidden. Supported values are 'visibility' (css visibility), 'offsets' (negative offset
 position) and 'display' (css display). Note: the default of 'display' is generally preferred since items are
 automatically laid out when they are first shown (no sizing is done while hidden).]]></description><name>hideMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide and show the component's container when hide/show is called on the component, false to hide and show the
 component itself (defaults to false). For example, this can be used as a shortcut for a hide button on a window by
 setting hide:true on the button when adding it to its parent container.]]></description><name>hideParent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id of this component (defaults to an auto-assigned id). You should assign an id if you need to be able to
 access the component later and you do not have an object reference available (e.g., using Ext.getCmp). Note that this id
 will also be used as the element id for the containing HTML element that is rendered to the page for this component.
 This allows you to write id-based CSS rules to style the specific instance of this component uniquely, and also to
 select sub-elements using this component's id as the parent. Note: to avoid complications imposed by a unique id also
 see itemId and ref. Note: to access the container of an item see ownerCt.]]></description><name>id</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use the
 FormLayout layout manager (e.g. Ext.form.FormPanel or specifying layout:'form'). An additional CSS class to apply to the
 div wrapping the form item element of this field. If supplied, itemCls at the field level will override the default
 itemCls supplied at the container level. The value specified for itemCls will be added to the default class
 ('x-form-item'). Since it is applied to the item wrapper (see Ext.layout.FormLayout.fieldTpl), it allows you to write
 standard CSS rules that can apply to the field, the label (if specified), or any other element within the markup for the
 field. Note: see the note for fieldLabel. Example use: // Apply a style to the field's label:
 <style>
     .required
 .x-form-item-label {font-weight:bold;color:red;}
 </style>
 
 new Ext.FormPanel({
     height: 100,
     renderTo:
 Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         itemCls: 'required' //this
 label will be styled
     },{
         xtype: 'textfield',
         fieldLabel: 'Favorite Color'
     }]
 });]]></description><name>itemCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An itemId can be used as an alternative way to get a reference to a component when no object reference is available.
 Instead of using an id with Ext.getCmp, use itemId with Ext.Container.getComponent which will retrieve itemId's or id's.
 Since itemId's are an index to the container's internal MixedCollection, the itemId is scoped locally to the container
 -- avoiding potential conflicts with Ext.ComponentMgr which requires a unique id. var c = new Ext.Panel({ //
     height:
 300,
     renderTo: document.body,
     layout: 'auto',
     items: [
         {
             itemId: 'p1',
            
 title: 'Panel 1',
             height: 150
         },
         {
             itemId: 'p2',
             title: 'Panel 2',
  
 height: 150
         }
     ]
 })
 p1 = c.getComponent('p1'); // not the same as Ext.getCmp()
 p2 =
 p1.ownerCt.getComponent('p2'); // reference via a sibling Also see id and ref. Note: to access the container of an item
 see ownerCt.]]></description><name>itemId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The separator to display after the text of each fieldLabel. This property may be configured at various levels. The order
 of precedence is: field / component level container level layout level (defaults to colon ':') To display no separator
 for this field's label specify empty string ''. Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 layoutConfig: {
         labelSeparator: '~'   // layout config has lowest priority (defaults to ':')
     },
    
 labelSeparator: '>>',     // config at container level
     items: [{
         xtype: 'textfield',
         fieldLabel:
 'Field 1',
         labelSeparator: '...' // field/component level config supersedes others
     },{
         xtype:
 'textfield',
         fieldLabel: 'Field 2' // labelSeparator will be '='
     }]
 });]]></description><name>labelSeparator</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS style specification string to apply directly to this field's label. Defaults to the container's labelStyle value
 if set (e.g., Ext.layout.FormLayout.labelStyle , or ''). Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         labelStyle: 'font-weight:bold;'
     }]
 });]]></description><name>labelStyle</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Maximum allowable date (JavaScript date object, defaults to null)]]></description><name>maxDate</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The error text to display if the maxDate validation fails (defaults to 'This date is after the maximum date')]]></description><name>maxText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Minimum allowable date (JavaScript date object, defaults to null)]]></description><name>minDate</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The error text to display if the minDate validation fails (defaults to 'This date is before the minimum date')]]></description><name>minText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of textual month names which can be overriden for localization support (defaults to Date.monthNames)]]></description><name>monthNames</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The header month selector tooltip (defaults to 'Choose a month (Control+Up/Down to move years)')]]></description><name>monthYearText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The next month navigation button tooltip (defaults to 'Next Month (Control+Right)')]]></description><name>nextText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The text to display on the ok button (defaults to 'OK' to give the user extra clicking room)]]></description><name>okText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element when the mouse moves over the Element, and
 removed when the mouse moves out. (defaults to ''). This can be useful for adding customized 'active' or 'hover' styles
 to the component or any of its children using standard CSS rules.]]></description><name>overCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The previous month navigation button tooltip (defaults to 'Previous Month (Control+Left)')]]></description><name>prevText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered ptype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a Plugin is being specified not as a fully
 instantiated Component, but as a Component config object. The ptype will be looked up at render time up to determine
 what type of Plugin to create. If you create your own Plugins, you may register them using
 Ext.ComponentMgr.registerPlugin in order to be able to take advantage of lazy instantiation and rendering.]]></description><name>ptype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A path specification, relative to the Component's ownerCt specifying into which ancestor Container to place a named
 reference to this Component. The ancestor axis can be traversed by using '/' characters in the path. For example, to put
 a reference to a Toolbar Button into the Panel which owns the Toolbar: var myGrid = new Ext.grid.EditorGridPanel({
    
 title: 'My EditorGridPanel',
     store: myStore,
     colModel: myColModel,
     tbar: [{
         text: 'Save',
        
 handler: saveChanges,
         disabled: true,
         ref: '../saveButton'
     }],
     listeners: {
         afteredit:
 function() {
 //          The button reference is in the GridPanel
             myGrid.saveButton.enable();
         }
    
 }
 }); In the code above, if the ref had been 'saveButton' the reference would have been placed into the Toolbar. Each
 '/' in the ref moves up one level from the Component's ownerCt. Also see the added and removed events.]]></description><name>ref</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The scope (this reference) in which the handler function will be called. Defaults to this DatePicker instance.]]></description><name>scope</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[False to hide the footer area containing the Today button and disable the keyboard handler for spacebar that selects the
 current date (defaults to true).]]></description><name>showToday</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Day index at which the week should begin, 0-based (defaults to 0, which is Sunday)]]></description><name>startDay</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should trigger this component to save its state (defaults to none). stateEvents may
 be any type of event supported by this component, including browser or custom events (e.g., ['click',
 'customerchange']). See stateful for an explanation of saving and restoring Component state.]]></description><name>stateEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id for this component to use for state management purposes (defaults to the component id if one was set,
 otherwise null if the component is using a generated id). See stateful for an explanation of saving and restoring
 Component state.]]></description><name>stateId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A flag which causes the Component to attempt to restore the state of internal properties from a saved state on startup.
 The component must have either a stateId or id assigned for state to be managed. Auto-generated ids are not guaranteed
 to be stable across page loads and cannot be relied upon to save and restore the same state for a component. For state
 saving to work, the state manager's provider must have been set to an implementation of Ext.state.Provider which
 overrides the set and get methods to save and recall name/value pairs. A built-in implementation,
 Ext.state.CookieProvider is available. To set the state provider for the current page: Ext.state.Manager.setProvider(new
 Ext.state.CookieProvider({
     expires: new Date(new Date().getTime()+(1000*60*60*24*7)), //7 days from now
 })); A
 stateful Component attempts to save state when one of the events listed in the stateEvents configuration fires. To save
 state, a stateful Component first serializes its state by calling getState. By default, this function does nothing. The
 developer must provide an implementation which returns an object hash which represents the Component's restorable state.
 The value yielded by getState is passed to Ext.state.Manager.set which uses the configured Ext.state.Provider to save
 the object keyed by the Component's stateId, or, if that is not specified, its id. During construction, a stateful
 Component attempts to restore its state by calling Ext.state.Manager.get passing the stateId, or, if that is not
 specified, the id. The resulting object is passed to applyState. The default implementation of applyState simply copies
 properties into the object, but a developer may override this to support more behaviour. You can perform extra
 processing on state save and restore by attaching handlers to the beforestaterestore, staterestore, beforestatesave and
 statesave events.]]></description><name>stateful</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
     title: 'Some Title',
     renderTo: Ext.getBody(),
     width: 400, height:
 300,
     layout: 'form',
     items: [{
         xtype: 'textarea',
         style: {
             width: '95%',
            
 marginBottom: '10px'
         }
     },
         new Ext.Button({
             text: 'Send',
             minWidth: '100',
   
          style: {
                 marginBottom: '10px'
             }
         })
     ]
 });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The text to display on the button that selects the current date (defaults to 'Today')]]></description><name>todayText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A string used to format the message for displaying in a tooltip over the button that selects the current date. Defaults
 to '{0} (Spacebar)' where the {0} token is replaced by today's date.]]></description><name>todayTip</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered xtype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a child item of a Container is being specified not
 as a fully instantiated Component, but as a Component config object. The xtype will be looked up at render time up to
 determine what type of child Component to create. The predefined xtypes are listed here. If you subclass Components to
 create your own Components, you may register them using Ext.ComponentMgr.registerType in order to be able to take
 advantage of lazy instantiation and rendering.]]></description><name>xtype</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 A base editor field that handles displaying/hiding on demand and has some built-in sizing and event handling logic.]]></description><name>editor</name><tag-class>org.brushingbits.jnap.ui.extjs3.Editor</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[The position to align to (see Ext.Element.alignTo for more details, defaults to "c-c?").]]></description><name>alignment</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to complete the editing process if in edit mode when the field is blurred. Defaults to true.]]></description><name>allowBlur</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Whether the component can move the Dom node when rendering (defaults to true).]]></description><name>allowDomMove</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element corresponding to a DIV that is already present in
 the document that specifies some structural markup for this component. Description : When applyTo is used, constituent
 parts of the component can also be specified by id or CSS class name within the main element, and the component being
 created may attempt to create its subcomponents from that markup if applicable. Notes : When using this config, a call
 to render() is not required. If applyTo is specified, any value passed for renderTo will be ignored and the target
 element's parent node will automatically be used as the component's container.]]></description><name>applyTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A tag name or DomHelper spec used to create the Element which will encapsulate this Component. You do not normally need
 to specify this. For the base classes Ext.Component, Ext.BoxComponent, and Ext.Container, this defaults to 'div'. The
 more complex Ext classes use a more complex DOM structure created by their own onRender methods. This is intended to
 allow the developer to create application-specific utility Components encapsulated by different DOM elements. Example
 usage: <pre><code>{
     xtype: 'box',
     autoEl: {
         tag: 'img',
         src: 'http://www.example.com/example.jpg'
     }
 },
 {
     xtype: 'box',
     autoEl: {
         tag: 'blockquote',
         html: 'autoEl is cool!'
     }
 }, {
     xtype: 'container',
     autoEl: 'ul',
     cls: 'ux-unordered-list',
     items: {
         xtype: 'box',
         autoEl: 'li',
   
      html: 'First list item'
     }
 }</pre></code>]]></description><name>autoEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True if the component should check for hidden classes (e.g. 'x-hidden' or 'x-hide-display') and remove them on render
 (defaults to false).]]></description><name>autoShow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True for the editor to automatically adopt the size of the underlying field, "width" to adopt the width only, or
 "height" to adopt the height only, "none" to always use the field dimensions. (defaults to false)]]></description><name>autoSize</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to [].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to cancel the edit when the escape key is pressed. Defaults to true.]]></description><name>cancelOnEsc</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class used to to apply to the special clearing div rendered directly after each form field wrapper to provide
 field clearing (defaults to 'x-form-clear-left'). Note: this config is only used when this Component is rendered by a
 Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or specifying
 layout:'form') and either a fieldLabel is specified or isFormField=true is specified. See Ext.layout.FormLayout.fieldTpl
 also.]]></description><name>clearCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element (defaults to ''). This can be useful for
 adding customized styles to the component or any of its children using standard CSS rules.]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to complete the edit when the enter key is pressed. Defaults to true.]]></description><name>completeOnEnter</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to constrain the editor to the viewport]]></description><name>constrain</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's container. This can be useful for adding customized
 styles to the container or any of its children using standard CSS rules. See Ext.layout.ContainerLayout.extraCls also.
 Note: ctCls defaults to '' except for the following class which assigns a value by default: Box Layout :
 'x-box-layout-ct' To configure the above Class with an extra CSS class append to the default. For example, for BoxLayout
 (Hbox and Vbox): ctCls: 'x-box-layout-ct custom-class']]></description><name>ctCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component disabled (default is false).]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class added to the component when it is disabled (defaults to 'x-item-disabled').]]></description><name>disabledClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Field object (or descendant) or config object for field]]></description><name>field</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The label text to display next to this Component (defaults to ''). Note: this config is only used when this Component is
 rendered by a Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or
 specifying layout:'form'). Also see hideLabel and Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
    
 height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name'
    
 }]
 });]]></description><name>fieldLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component hidden (default is false). If true, the hide method will be called internally.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[False to keep the bound element visible while the editor is displayed (defaults to true)]]></description><name>hideEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to completely hide the label element (label and separator). Defaults to false. By default, even if you do not
 specify a fieldLabel the space will still be reserved so that the field will line up with other fields that do have
 labels. Setting this to true will cause the field to not reserve that space. Note: see the note for clearCls. Example
 use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield'
        
 hideLabel: true
     }]
 });]]></description><name>hideLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[How this component should be hidden. Supported values are 'visibility' (css visibility), 'offsets' (negative offset
 position) and 'display' (css display). Note: the default of 'display' is generally preferred since items are
 automatically laid out when they are first shown (no sizing is done while hidden).]]></description><name>hideMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide and show the component's container when hide/show is called on the component, false to hide and show the
 component itself (defaults to false). For example, this can be used as a shortcut for a hide button on a window by
 setting hide:true on the button when adding it to its parent container.]]></description><name>hideParent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id of this component (defaults to an auto-assigned id). You should assign an id if you need to be able to
 access the component later and you do not have an object reference available (e.g., using Ext.getCmp). Note that this id
 will also be used as the element id for the containing HTML element that is rendered to the page for this component.
 This allows you to write id-based CSS rules to style the specific instance of this component uniquely, and also to
 select sub-elements using this component's id as the parent. Note: to avoid complications imposed by a unique id also
 see itemId and ref. Note: to access the container of an item see ownerCt.]]></description><name>id</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to skip the edit completion process (no save, no events fired) if the user completes an edit and the value has not
 changed (defaults to false). Applies only to string values - edits for other data types will never be ignored.]]></description><name>ignoreNoChange</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use the
 FormLayout layout manager (e.g. Ext.form.FormPanel or specifying layout:'form'). An additional CSS class to apply to the
 div wrapping the form item element of this field. If supplied, itemCls at the field level will override the default
 itemCls supplied at the container level. The value specified for itemCls will be added to the default class
 ('x-form-item'). Since it is applied to the item wrapper (see Ext.layout.FormLayout.fieldTpl), it allows you to write
 standard CSS rules that can apply to the field, the label (if specified), or any other element within the markup for the
 field. Note: see the note for fieldLabel. Example use: // Apply a style to the field's label:
 <style>
     .required
 .x-form-item-label {font-weight:bold;color:red;}
 </style>
 
 new Ext.FormPanel({
     height: 100,
     renderTo:
 Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         itemCls: 'required' //this
 label will be styled
     },{
         xtype: 'textfield',
         fieldLabel: 'Favorite Color'
     }]
 });]]></description><name>itemCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An itemId can be used as an alternative way to get a reference to a component when no object reference is available.
 Instead of using an id with Ext.getCmp, use itemId with Ext.Container.getComponent which will retrieve itemId's or id's.
 Since itemId's are an index to the container's internal MixedCollection, the itemId is scoped locally to the container
 -- avoiding potential conflicts with Ext.ComponentMgr which requires a unique id. var c = new Ext.Panel({ //
     height:
 300,
     renderTo: document.body,
     layout: 'auto',
     items: [
         {
             itemId: 'p1',
            
 title: 'Panel 1',
             height: 150
         },
         {
             itemId: 'p2',
             title: 'Panel 2',
  
 height: 150
         }
     ]
 })
 p1 = c.getComponent('p1'); // not the same as Ext.getCmp()
 p2 =
 p1.ownerCt.getComponent('p2'); // reference via a sibling Also see id and ref. Note: to access the container of an item
 see ownerCt.]]></description><name>itemId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The separator to display after the text of each fieldLabel. This property may be configured at various levels. The order
 of precedence is: field / component level container level layout level (defaults to colon ':') To display no separator
 for this field's label specify empty string ''. Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 layoutConfig: {
         labelSeparator: '~'   // layout config has lowest priority (defaults to ':')
     },
    
 labelSeparator: '>>',     // config at container level
     items: [{
         xtype: 'textfield',
         fieldLabel:
 'Field 1',
         labelSeparator: '...' // field/component level config supersedes others
     },{
         xtype:
 'textfield',
         fieldLabel: 'Field 2' // labelSeparator will be '='
     }]
 });]]></description><name>labelSeparator</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS style specification string to apply directly to this field's label. Defaults to the container's labelStyle value
 if set (e.g., Ext.layout.FormLayout.labelStyle , or ''). Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         labelStyle: 'font-weight:bold;'
     }]
 });]]></description><name>labelStyle</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The offsets to use when aligning (see Ext.Element.alignTo for more details. Defaults to [0, 0].]]></description><name>offsets</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element when the mouse moves over the Element, and
 removed when the mouse moves out. (defaults to ''). This can be useful for adding customized 'active' or 'hover' styles
 to the component or any of its children using standard CSS rules.]]></description><name>overCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered ptype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a Plugin is being specified not as a fully
 instantiated Component, but as a Component config object. The ptype will be looked up at render time up to determine
 what type of Plugin to create. If you create your own Plugins, you may register them using
 Ext.ComponentMgr.registerPlugin in order to be able to take advantage of lazy instantiation and rendering.]]></description><name>ptype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A path specification, relative to the Component's ownerCt specifying into which ancestor Container to place a named
 reference to this Component. The ancestor axis can be traversed by using '/' characters in the path. For example, to put
 a reference to a Toolbar Button into the Panel which owns the Toolbar: var myGrid = new Ext.grid.EditorGridPanel({
    
 title: 'My EditorGridPanel',
     store: myStore,
     colModel: myColModel,
     tbar: [{
         text: 'Save',
        
 handler: saveChanges,
         disabled: true,
         ref: '../saveButton'
     }],
     listeners: {
         afteredit:
 function() {
 //          The button reference is in the GridPanel
             myGrid.saveButton.enable();
         }
    
 }
 }); In the code above, if the ref had been 'saveButton' the reference would have been placed into the Toolbar. Each
 '/' in the ref moves up one level from the Component's ownerCt. Also see the added and removed events.]]></description><name>ref</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically revert the field value and cancel the edit when the user completes an edit and the field
 validation fails (defaults to true)]]></description><name>revertInvalid</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA["sides" for sides/bottom only, "frame" for 4-way shadow, and "drop" for bottom-right shadow (defaults to "frame")]]></description><name>shadow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should trigger this component to save its state (defaults to none). stateEvents may
 be any type of event supported by this component, including browser or custom events (e.g., ['click',
 'customerchange']). See stateful for an explanation of saving and restoring Component state.]]></description><name>stateEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id for this component to use for state management purposes (defaults to the component id if one was set,
 otherwise null if the component is using a generated id). See stateful for an explanation of saving and restoring
 Component state.]]></description><name>stateId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A flag which causes the Component to attempt to restore the state of internal properties from a saved state on startup.
 The component must have either a stateId or id assigned for state to be managed. Auto-generated ids are not guaranteed
 to be stable across page loads and cannot be relied upon to save and restore the same state for a component. For state
 saving to work, the state manager's provider must have been set to an implementation of Ext.state.Provider which
 overrides the set and get methods to save and recall name/value pairs. A built-in implementation,
 Ext.state.CookieProvider is available. To set the state provider for the current page: Ext.state.Manager.setProvider(new
 Ext.state.CookieProvider({
     expires: new Date(new Date().getTime()+(1000*60*60*24*7)), //7 days from now
 })); A
 stateful Component attempts to save state when one of the events listed in the stateEvents configuration fires. To save
 state, a stateful Component first serializes its state by calling getState. By default, this function does nothing. The
 developer must provide an implementation which returns an object hash which represents the Component's restorable state.
 The value yielded by getState is passed to Ext.state.Manager.set which uses the configured Ext.state.Provider to save
 the object keyed by the Component's stateId, or, if that is not specified, its id. During construction, a stateful
 Component attempts to restore its state by calling Ext.state.Manager.get passing the stateId, or, if that is not
 specified, the id. The resulting object is passed to applyState. The default implementation of applyState simply copies
 properties into the object, but a developer may override this to support more behaviour. You can perform extra
 processing on state save and restore by attaching handlers to the beforestaterestore, staterestore, beforestatesave and
 statesave events.]]></description><name>stateful</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
     title: 'Some Title',
     renderTo: Ext.getBody(),
     width: 400, height:
 300,
     layout: 'form',
     items: [{
         xtype: 'textarea',
         style: {
             width: '95%',
            
 marginBottom: '10px'
         }
     },
         new Ext.Button({
             text: 'Send',
             minWidth: '100',
   
          style: {
                 marginBottom: '10px'
             }
         })
     ]
 });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Handle the keydown/keypress events so they don't propagate (defaults to true)]]></description><name>swallowKeys</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to update the innerHTML of the bound element when the update completes (defaults to false)]]></description><name>updateEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The data value of the underlying field (defaults to "")]]></description><name>value</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered xtype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a child item of a Container is being specified not
 as a fully instantiated Component, but as a Component config object. The xtype will be looked up at render time up to
 determine what type of child Component to create. The predefined xtypes are listed here. If you subclass Components to
 create your own Components, you may register them using Ext.ComponentMgr.registerType in order to be able to take
 advantage of lazy instantiation and rendering.]]></description><name>xtype</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>]]></description><name>flashComponent</name><tag-class>org.brushingbits.jnap.ui.extjs3.FlashComponent</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[Whether the component can move the Dom node when rendering (defaults to true).]]></description><name>allowDomMove</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use an
 AnchorLayout (or subclass thereof). based layout manager, for example: Ext.form.FormPanel specifying layout: 'anchor' //
 or 'form', or 'absolute' See Ext.layout.AnchorLayout.anchor also.]]></description><name>anchor</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element corresponding to a DIV that is already present in
 the document that specifies some structural markup for this component. Description : When applyTo is used, constituent
 parts of the component can also be specified by id or CSS class name within the main element, and the component being
 created may attempt to create its subcomponents from that markup if applicable. Notes : When using this config, a call
 to render() is not required. If applyTo is specified, any value passed for renderTo will be ignored and the target
 element's parent node will automatically be used as the component's container.]]></description><name>applyTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A tag name or DomHelper spec used to create the Element which will encapsulate this Component. You do not normally need
 to specify this. For the base classes Ext.Component, Ext.BoxComponent, and Ext.Container, this defaults to 'div'. The
 more complex Ext classes use a more complex DOM structure created by their own onRender methods. This is intended to
 allow the developer to create application-specific utility Components encapsulated by different DOM elements. Example
 usage: <pre><code>{
     xtype: 'box',
     autoEl: {
         tag: 'img',
         src: 'http://www.example.com/example.jpg'
     }
 },
 {
     xtype: 'box',
     autoEl: {
         tag: 'blockquote',
         html: 'autoEl is cool!'
     }
 }, {
     xtype: 'container',
     autoEl: 'ul',
     cls: 'ux-unordered-list',
     items: {
         xtype: 'box',
         autoEl: 'li',
   
      html: 'First list item'
     }
 }</pre></code>]]></description><name>autoEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to use height:'auto', false to use fixed height (or allow it to be managed by its parent Container's layout
 manager. Defaults to false. Note: Although many components inherit this config option, not all will function as expected
 with a height of 'auto'. Setting autoHeight:true means that the browser will manage height based on the element's
 contents, and that Ext will not manage it at all. If the browser is managing the height, be aware that resizes performed
 by the browser in response to changes within the structure of the Component cannot be detected. Therefore changes to the
 height might result in elements needing to be synchronized with the new height. Example: var w = new Ext.Window({
    
 title: 'Window',
     width: 600,
     autoHeight: true,
     items: {
         title: 'Collapse Me',
         height: 400,
  
 collapsible: true,
         border: false,
         listeners: {
             beforecollapse: function() {
                w.el.shadow.hide();
             },
             beforeexpand: function() {
                w.el.shadow.hide();
             },
             collapse: function() {
                w.syncShadow();
             },
             expand: function() {
                w.syncShadow();
             }
         }
     }
 }).show();]]></description><name>autoHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to use overflow:'auto' on the components layout element and show scroll bars automatically when necessary, false to
 clip any overflowing content (defaults to false).]]></description><name>autoScroll</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True if the component should check for hidden classes (e.g. 'x-hidden' or 'x-hide-display') and remove them on render
 (defaults to false).]]></description><name>autoShow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to use width:'auto', false to use fixed width (or allow it to be managed by its parent Container's layout manager.
 Defaults to false. Note: Although many components inherit this config option, not all will function as expected with a
 width of 'auto'. Setting autoWidth:true means that the browser will manage width based on the element's contents, and
 that Ext will not manage it at all. If the browser is managing the width, be aware that resizes performed by the browser
 in response to changes within the structure of the Component cannot be detected. Therefore changes to the width might
 result in elements needing to be synchronized with the new width. For example, where the target element is: <div
 id='grid-container' style='margin-left:25%;width:50%'></div> A Panel rendered into that target element must listen for
 browser window resize in order to relay its child items when the browser changes its width: var myPanel = new
 Ext.Panel({
     renderTo: 'grid-container',
     monitorResize: true, // relay on browser resize
     title: 'Panel',
    
 height: 400,
     autoWidth: true,
     layout: 'hbox',
     layoutConfig: {
         align: 'stretch'
     },
     defaults: {
         flex: 1
     },
     items: [{
         title: 'Box 1',
     }, {
         title: 'Box 2'
     }, {
         title:
 'Box 3'
     }],
 });]]></description><name>autoWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The background color of the chart. Defaults to '#ffffff'.]]></description><name>backgroundColor</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to [].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class used to to apply to the special clearing div rendered directly after each form field wrapper to provide
 field clearing (defaults to 'x-form-clear-left'). Note: this config is only used when this Component is rendered by a
 Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or specifying
 layout:'form') and either a fieldLabel is specified or isFormField=true is specified. See Ext.layout.FormLayout.fieldTpl
 also.]]></description><name>clearCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element (defaults to ''). This can be useful for
 adding customized styles to the component or any of its children using standard CSS rules.]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's container. This can be useful for adding customized
 styles to the container or any of its children using standard CSS rules. See Ext.layout.ContainerLayout.extraCls also.
 Note: ctCls defaults to '' except for the following class which assigns a value by default: Box Layout :
 'x-box-layout-ct' To configure the above Class with an extra CSS class append to the default. For example, for BoxLayout
 (Hbox and Vbox): ctCls: 'x-box-layout-ct custom-class']]></description><name>ctCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component disabled (default is false).]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class added to the component when it is disabled (defaults to 'x-item-disabled').]]></description><name>disabledClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to prompt the user to install flash if not installed. Note that this uses Ext.FlashComponent.EXPRESS_INSTALL_URL,
 which should be set to the local resource. Defaults to false.]]></description><name>expressInstall</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The label text to display next to this Component (defaults to ''). Note: this config is only used when this Component is
 rendered by a Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or
 specifying layout:'form'). Also see hideLabel and Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
    
 height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name'
    
 }]
 });]]></description><name>fieldLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A set of key value pairs to be passed to the flash object as parameters. Possible parameters can be found here:
 http://kb2.adobe.com/cps/127/tn_12701.html Defaults to undefined.]]></description><name>flashParams</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A set of key value pairs to be passed to the flash object as flash variables. Defaults to undefined.]]></description><name>flashVars</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Indicates the version the flash content was published for. Defaults to '9.0.115'.]]></description><name>flashVersion</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use a
 BoxLayout. Each child Component with a flex property will be flexed either vertically (by a VBoxLayout) or horizontally
 (by an HBoxLayout) according to the item's relative flex value compared to the sum of all Components with flex value
 specified. Any child items that have either a flex = 0 or flex = undefined will not be 'flexed' (the initial size will
 not be changed).]]></description><name>flex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component hidden (default is false). If true, the hide method will be called internally.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to completely hide the label element (label and separator). Defaults to false. By default, even if you do not
 specify a fieldLabel the space will still be reserved so that the field will line up with other fields that do have
 labels. Setting this to true will cause the field to not reserve that space. Note: see the note for clearCls. Example
 use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield'
        
 hideLabel: true
     }]
 });]]></description><name>hideLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[How this component should be hidden. Supported values are 'visibility' (css visibility), 'offsets' (negative offset
 position) and 'display' (css display). Note: the default of 'display' is generally preferred since items are
 automatically laid out when they are first shown (no sizing is done while hidden).]]></description><name>hideMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide and show the component's container when hide/show is called on the component, false to hide and show the
 component itself (defaults to false). For example, this can be used as a shortcut for a hide button on a window by
 setting hide:true on the button when adding it to its parent container.]]></description><name>hideParent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id of this component (defaults to an auto-assigned id). You should assign an id if you need to be able to
 access the component later and you do not have an object reference available (e.g., using Ext.getCmp). Note that this id
 will also be used as the element id for the containing HTML element that is rendered to the page for this component.
 This allows you to write id-based CSS rules to style the specific instance of this component uniquely, and also to
 select sub-elements using this component's id as the parent. Note: to avoid complications imposed by a unique id also
 see itemId and ref. Note: to access the container of an item see ownerCt.]]></description><name>id</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use the
 FormLayout layout manager (e.g. Ext.form.FormPanel or specifying layout:'form'). An additional CSS class to apply to the
 div wrapping the form item element of this field. If supplied, itemCls at the field level will override the default
 itemCls supplied at the container level. The value specified for itemCls will be added to the default class
 ('x-form-item'). Since it is applied to the item wrapper (see Ext.layout.FormLayout.fieldTpl), it allows you to write
 standard CSS rules that can apply to the field, the label (if specified), or any other element within the markup for the
 field. Note: see the note for fieldLabel. Example use: // Apply a style to the field's label:
 <style>
     .required
 .x-form-item-label {font-weight:bold;color:red;}
 </style>
 
 new Ext.FormPanel({
     height: 100,
     renderTo:
 Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         itemCls: 'required' //this
 label will be styled
     },{
         xtype: 'textfield',
         fieldLabel: 'Favorite Color'
     }]
 });]]></description><name>itemCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An itemId can be used as an alternative way to get a reference to a component when no object reference is available.
 Instead of using an id with Ext.getCmp, use itemId with Ext.Container.getComponent which will retrieve itemId's or id's.
 Since itemId's are an index to the container's internal MixedCollection, the itemId is scoped locally to the container
 -- avoiding potential conflicts with Ext.ComponentMgr which requires a unique id. var c = new Ext.Panel({ //
     height:
 300,
     renderTo: document.body,
     layout: 'auto',
     items: [
         {
             itemId: 'p1',
            
 title: 'Panel 1',
             height: 150
         },
         {
             itemId: 'p2',
             title: 'Panel 2',
  
 height: 150
         }
     ]
 })
 p1 = c.getComponent('p1'); // not the same as Ext.getCmp()
 p2 =
 p1.ownerCt.getComponent('p2'); // reference via a sibling Also see id and ref. Note: to access the container of an item
 see ownerCt.]]></description><name>itemId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The separator to display after the text of each fieldLabel. This property may be configured at various levels. The order
 of precedence is: field / component level container level layout level (defaults to colon ':') To display no separator
 for this field's label specify empty string ''. Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 layoutConfig: {
         labelSeparator: '~'   // layout config has lowest priority (defaults to ':')
     },
    
 labelSeparator: '>>',     // config at container level
     items: [{
         xtype: 'textfield',
         fieldLabel:
 'Field 1',
         labelSeparator: '...' // field/component level config supersedes others
     },{
         xtype:
 'textfield',
         fieldLabel: 'Field 2' // labelSeparator will be '='
     }]
 });]]></description><name>labelSeparator</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS style specification string to apply directly to this field's label. Defaults to the container's labelStyle value
 if set (e.g., Ext.layout.FormLayout.labelStyle , or ''). Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         labelStyle: 'font-weight:bold;'
     }]
 });]]></description><name>labelStyle</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout or one of the two BoxLayout subclasses. An object containing margins to apply to this BoxComponent in the
 format: {
     top: (top margin),
     right: (right margin),
     bottom: (bottom margin),
     left: (left margin)
 } May
 also be a string containing space-separated, numeric margin values. The order of the sides associated with each value
 matches the way CSS processes margin values: If there is only one value, it applies to all sides. If there are two
 values, the top and bottom borders are set to the first value and the right and left are set to the second. If there are
 three values, the top is set to the first value, the left and right are set to the second, and the bottom is set to the
 third. If there are four values, they apply to the top, right, bottom, and left, respectively. Defaults to: {top:0,
 right:0, bottom:0, left:0}]]></description><name>margins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element when the mouse moves over the Element, and
 removed when the mouse moves out. (defaults to ''). This can be useful for adding customized 'active' or 'hover' styles
 to the component or any of its children using standard CSS rules.]]></description><name>overCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level x coordinate for this component if contained within a positioning container.]]></description><name>pageX</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level y coordinate for this component if contained within a positioning container.]]></description><name>pageY</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered ptype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a Plugin is being specified not as a fully
 instantiated Component, but as a Component config object. The ptype will be looked up at render time up to determine
 what type of Plugin to create. If you create your own Plugins, you may register them using
 Ext.ComponentMgr.registerPlugin in order to be able to take advantage of lazy instantiation and rendering.]]></description><name>ptype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A path specification, relative to the Component's ownerCt specifying into which ancestor Container to place a named
 reference to this Component. The ancestor axis can be traversed by using '/' characters in the path. For example, to put
 a reference to a Toolbar Button into the Panel which owns the Toolbar: var myGrid = new Ext.grid.EditorGridPanel({
    
 title: 'My EditorGridPanel',
     store: myStore,
     colModel: myColModel,
     tbar: [{
         text: 'Save',
        
 handler: saveChanges,
         disabled: true,
         ref: '../saveButton'
     }],
     listeners: {
         afteredit:
 function() {
 //          The button reference is in the GridPanel
             myGrid.saveButton.enable();
         }
    
 }
 }); In the code above, if the ref had been 'saveButton' the reference would have been placed into the Toolbar. Each
 '/' in the ref moves up one level from the Component's ownerCt. Also see the added and removed events.]]></description><name>ref</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout layout manager (e.g. specifying layout:'border'). See Ext.layout.BorderLayout also.]]></description><name>region</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should trigger this component to save its state (defaults to none). stateEvents may
 be any type of event supported by this component, including browser or custom events (e.g., ['click',
 'customerchange']). See stateful for an explanation of saving and restoring Component state.]]></description><name>stateEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id for this component to use for state management purposes (defaults to the component id if one was set,
 otherwise null if the component is using a generated id). See stateful for an explanation of saving and restoring
 Component state.]]></description><name>stateId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A flag which causes the Component to attempt to restore the state of internal properties from a saved state on startup.
 The component must have either a stateId or id assigned for state to be managed. Auto-generated ids are not guaranteed
 to be stable across page loads and cannot be relied upon to save and restore the same state for a component. For state
 saving to work, the state manager's provider must have been set to an implementation of Ext.state.Provider which
 overrides the set and get methods to save and recall name/value pairs. A built-in implementation,
 Ext.state.CookieProvider is available. To set the state provider for the current page: Ext.state.Manager.setProvider(new
 Ext.state.CookieProvider({
     expires: new Date(new Date().getTime()+(1000*60*60*24*7)), //7 days from now
 })); A
 stateful Component attempts to save state when one of the events listed in the stateEvents configuration fires. To save
 state, a stateful Component first serializes its state by calling getState. By default, this function does nothing. The
 developer must provide an implementation which returns an object hash which represents the Component's restorable state.
 The value yielded by getState is passed to Ext.state.Manager.set which uses the configured Ext.state.Provider to save
 the object keyed by the Component's stateId, or, if that is not specified, its id. During construction, a stateful
 Component attempts to restore its state by calling Ext.state.Manager.get passing the stateId, or, if that is not
 specified, the id. The resulting object is passed to applyState. The default implementation of applyState simply copies
 properties into the object, but a developer may override this to support more behaviour. You can perform extra
 processing on state save and restore by attaching handlers to the beforestaterestore, staterestore, beforestatesave and
 statesave events.]]></description><name>stateful</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
     title: 'Some Title',
     renderTo: Ext.getBody(),
     width: 400, height:
 300,
     layout: 'form',
     items: [{
         xtype: 'textarea',
         style: {
             width: '95%',
            
 marginBottom: '10px'
         }
     },
         new Ext.Button({
             text: 'Send',
             minWidth: '100',
   
          style: {
                 marginBottom: '10px'
             }
         })
     ]
 });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is a child item of a TabPanel. A string to be used as innerHTML
 (html tags are accepted) to show in a tooltip when mousing over the associated tab selector element.
 Ext.QuickTips.init() must be called in order for the tips to render.]]></description><name>tabTip</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The URL of the chart to include. Defaults to undefined.]]></description><name>url</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The wmode of the flash object. This can be used to control layering. Defaults to 'opaque'.]]></description><name>wmode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local x (left) coordinate for this component if contained within a positioning container.]]></description><name>x</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered xtype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a child item of a Container is being specified not
 as a fully instantiated Component, but as a Component config object. The xtype will be looked up at render time up to
 determine what type of child Component to create. The predefined xtypes are listed here. If you subclass Components to
 create your own Components, you may register them using Ext.ComponentMgr.registerType in order to be able to take
 advantage of lazy instantiation and rendering.]]></description><name>xtype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local y (top) coordinate for this component if contained within a positioning container.]]></description><name>y</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 Single checkbox field. Can be used as a direct replacement for traditional checkbox fields.]]></description><name>form.checkbox</name><tag-class>org.brushingbits.jnap.ui.extjs3.form.Checkbox</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[The field's HTML name attribute (defaults to ''). Note: this property must be set if this field is to be automatically
 included with form submit().]]></description><name>name</name><required>true</required><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Whether the component can move the Dom node when rendering (defaults to true).]]></description><name>allowDomMove</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use an
 AnchorLayout (or subclass thereof). based layout manager, for example: Ext.form.FormPanel specifying layout: 'anchor' //
 or 'form', or 'absolute' See Ext.layout.AnchorLayout.anchor also.]]></description><name>anchor</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element corresponding to a DIV that is already present in
 the document that specifies some structural markup for this component. Description : When applyTo is used, constituent
 parts of the component can also be specified by id or CSS class name within the main element, and the component being
 created may attempt to create its subcomponents from that markup if applicable. Notes : When using this config, a call
 to render() is not required. If applyTo is specified, any value passed for renderTo will be ignored and the target
 element's parent node will automatically be used as the component's container.]]></description><name>applyTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A DomHelper element spec, or true for a default element spec (defaults to {tag: 'input', type: 'checkbox', autocomplete:
 'off'})]]></description><name>autoCreate</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A tag name or DomHelper spec used to create the Element which will encapsulate this Component. You do not normally need
 to specify this. For the base classes Ext.Component, Ext.BoxComponent, and Ext.Container, this defaults to 'div'. The
 more complex Ext classes use a more complex DOM structure created by their own onRender methods. This is intended to
 allow the developer to create application-specific utility Components encapsulated by different DOM elements. Example
 usage: <pre><code>{
     xtype: 'box',
     autoEl: {
         tag: 'img',
         src: 'http://www.example.com/example.jpg'
     }
 },
 {
     xtype: 'box',
     autoEl: {
         tag: 'blockquote',
         html: 'autoEl is cool!'
     }
 }, {
     xtype: 'container',
     autoEl: 'ul',
     cls: 'ux-unordered-list',
     items: {
         xtype: 'box',
         autoEl: 'li',
   
      html: 'First list item'
     }
 }</pre></code>]]></description><name>autoEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to use height:'auto', false to use fixed height (or allow it to be managed by its parent Container's layout
 manager. Defaults to false. Note: Although many components inherit this config option, not all will function as expected
 with a height of 'auto'. Setting autoHeight:true means that the browser will manage height based on the element's
 contents, and that Ext will not manage it at all. If the browser is managing the height, be aware that resizes performed
 by the browser in response to changes within the structure of the Component cannot be detected. Therefore changes to the
 height might result in elements needing to be synchronized with the new height. Example: var w = new Ext.Window({
    
 title: 'Window',
     width: 600,
     autoHeight: true,
     items: {
         title: 'Collapse Me',
         height: 400,
  
 collapsible: true,
         border: false,
         listeners: {
             beforecollapse: function() {
                w.el.shadow.hide();
             },
             beforeexpand: function() {
                w.el.shadow.hide();
             },
             collapse: function() {
                w.syncShadow();
             },
             expand: function() {
                w.syncShadow();
             }
         }
     }
 }).show();]]></description><name>autoHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to use overflow:'auto' on the components layout element and show scroll bars automatically when necessary, false to
 clip any overflowing content (defaults to false).]]></description><name>autoScroll</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True if the component should check for hidden classes (e.g. 'x-hidden' or 'x-hide-display') and remove them on render
 (defaults to false).]]></description><name>autoShow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to use width:'auto', false to use fixed width (or allow it to be managed by its parent Container's layout manager.
 Defaults to false. Note: Although many components inherit this config option, not all will function as expected with a
 width of 'auto'. Setting autoWidth:true means that the browser will manage width based on the element's contents, and
 that Ext will not manage it at all. If the browser is managing the width, be aware that resizes performed by the browser
 in response to changes within the structure of the Component cannot be detected. Therefore changes to the width might
 result in elements needing to be synchronized with the new width. For example, where the target element is: <div
 id='grid-container' style='margin-left:25%;width:50%'></div> A Panel rendered into that target element must listen for
 browser window resize in order to relay its child items when the browser changes its width: var myPanel = new
 Ext.Panel({
     renderTo: 'grid-container',
     monitorResize: true, // relay on browser resize
     title: 'Panel',
    
 height: 400,
     autoWidth: true,
     layout: 'hbox',
     layoutConfig: {
         align: 'stretch'
     },
     defaults: {
         flex: 1
     },
     items: [{
         title: 'Box 1',
     }, {
         title: 'Box 2'
     }, {
         title:
 'Box 3'
     }],
 });]]></description><name>autoWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The text that appears beside the checkbox]]></description><name>boxLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to [].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true if the checkbox should render initially checked (defaults to false)]]></description><name>checked</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class used to to apply to the special clearing div rendered directly after each form field wrapper to provide
 field clearing (defaults to 'x-form-clear-left'). Note: this config is only used when this Component is rendered by a
 Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or specifying
 layout:'form') and either a fieldLabel is specified or isFormField=true is specified. See Ext.layout.FormLayout.fieldTpl
 also.]]></description><name>clearCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom CSS class to apply to the field's underlying element (defaults to '').]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's container. This can be useful for adding customized
 styles to the container or any of its children using standard CSS rules. See Ext.layout.ContainerLayout.extraCls also.
 Note: ctCls defaults to '' except for the following class which assigns a value by default: Box Layout :
 'x-box-layout-ct' To configure the above Class with an extra CSS class append to the default. For example, for BoxLayout
 (Hbox and Vbox): ctCls: 'x-box-layout-ct custom-class']]></description><name>ctCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to disable the field (defaults to false). Be aware that conformant with the HTML specification, disabled Fields
 will not be submitted.]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class added to the component when it is disabled (defaults to 'x-item-disabled').]]></description><name>disabledClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default CSS class for the checkbox (defaults to 'x-form-field')]]></description><name>fieldClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The label text to display next to this Component (defaults to ''). Note: this config is only used when this Component is
 rendered by a Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or
 specifying layout:'form'). Also see hideLabel and Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
    
 height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name'
    
 }]
 });]]></description><name>fieldLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use a
 BoxLayout. Each child Component with a flex property will be flexed either vertically (by a VBoxLayout) or horizontally
 (by an HBoxLayout) according to the item's relative flex value compared to the sum of all Components with flex value
 specified. Any child items that have either a flex = 0 or flex = undefined will not be 'flexed' (the initial size will
 not be changed).]]></description><name>flex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class to use when the checkbox receives focus (defaults to undefined)]]></description><name>focusClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A function called when the checked value changes (can be used instead of handling the check event). The handler is
 passed the following parameters: checkbox : Ext.form.Checkbox The Checkbox being toggled. checked : Boolean The new
 checked state of the checkbox.]]></description><name>handler</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component hidden (default is false). If true, the hide method will be called internally.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to completely hide the label element (label and separator). Defaults to false. By default, even if you do not
 specify a fieldLabel the space will still be reserved so that the field will line up with other fields that do have
 labels. Setting this to true will cause the field to not reserve that space. Note: see the note for clearCls. Example
 use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield'
        
 hideLabel: true
     }]
 });]]></description><name>hideLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[How this component should be hidden. Supported values are 'visibility' (css visibility), 'offsets' (negative offset
 position) and 'display' (css display). Note: the default of 'display' is generally preferred since items are
 automatically laid out when they are first shown (no sizing is done while hidden).]]></description><name>hideMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide and show the component's container when hide/show is called on the component, false to hide and show the
 component itself (defaults to false). For example, this can be used as a shortcut for a hide button on a window by
 setting hide:true on the button when adding it to its parent container.]]></description><name>hideParent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id of this component (defaults to an auto-assigned id). You should assign an id if you need to be able to
 access the component later and you do not have an object reference available (e.g., using Ext.getCmp). Note that this id
 will also be used as the element id for the containing HTML element that is rendered to the page for this component.
 This allows you to write id-based CSS rules to style the specific instance of this component uniquely, and also to
 select sub-elements using this component's id as the parent. Note: to avoid complications imposed by a unique id also
 see itemId and ref. Note: to access the container of an item see ownerCt.]]></description><name>id</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The type attribute for input fields -- e.g. radio, text, password, file (defaults to 'text'). The types 'file' and
 'password' must be used to render those field types currently -- there are no separate Ext components for those. Note
 that if you use inputType:'file', emptyText is not supported and should be avoided.]]></description><name>inputType</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The value that should go into the generated input element's value attribute]]></description><name>inputValue</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class to use when marking a field invalid (defaults to 'x-form-invalid')]]></description><name>invalidClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The error text to use when marking a field invalid and no message is provided (defaults to 'The value in this field is
 invalid')]]></description><name>invalidText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use the
 FormLayout layout manager (e.g. Ext.form.FormPanel or specifying layout:'form'). An additional CSS class to apply to the
 div wrapping the form item element of this field. If supplied, itemCls at the field level will override the default
 itemCls supplied at the container level. The value specified for itemCls will be added to the default class
 ('x-form-item'). Since it is applied to the item wrapper (see Ext.layout.FormLayout.fieldTpl), it allows you to write
 standard CSS rules that can apply to the field, the label (if specified), or any other element within the markup for the
 field. Note: see the note for fieldLabel. Example use: // Apply a style to the field's label:
 <style>
     .required
 .x-form-item-label {font-weight:bold;color:red;}
 </style>
 
 new Ext.FormPanel({
     height: 100,
     renderTo:
 Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         itemCls: 'required' //this
 label will be styled
     },{
         xtype: 'textfield',
         fieldLabel: 'Favorite Color'
     }]
 });]]></description><name>itemCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An itemId can be used as an alternative way to get a reference to a component when no object reference is available.
 Instead of using an id with Ext.getCmp, use itemId with Ext.Container.getComponent which will retrieve itemId's or id's.
 Since itemId's are an index to the container's internal MixedCollection, the itemId is scoped locally to the container
 -- avoiding potential conflicts with Ext.ComponentMgr which requires a unique id. var c = new Ext.Panel({ //
     height:
 300,
     renderTo: document.body,
     layout: 'auto',
     items: [
         {
             itemId: 'p1',
            
 title: 'Panel 1',
             height: 150
         },
         {
             itemId: 'p2',
             title: 'Panel 2',
  
 height: 150
         }
     ]
 })
 p1 = c.getComponent('p1'); // not the same as Ext.getCmp()
 p2 =
 p1.ownerCt.getComponent('p2'); // reference via a sibling Also see id and ref. Note: to access the container of an item
 see ownerCt.]]></description><name>itemId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The separator to display after the text of each fieldLabel. This property may be configured at various levels. The order
 of precedence is: field / component level container level layout level (defaults to colon ':') To display no separator
 for this field's label specify empty string ''. Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 layoutConfig: {
         labelSeparator: '~'   // layout config has lowest priority (defaults to ':')
     },
    
 labelSeparator: '>>',     // config at container level
     items: [{
         xtype: 'textfield',
         fieldLabel:
 'Field 1',
         labelSeparator: '...' // field/component level config supersedes others
     },{
         xtype:
 'textfield',
         fieldLabel: 'Field 2' // labelSeparator will be '='
     }]
 });]]></description><name>labelSeparator</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS style specification string to apply directly to this field's label. Defaults to the container's labelStyle value
 if set (e.g., Ext.layout.FormLayout.labelStyle , or ''). Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         labelStyle: 'font-weight:bold;'
     }]
 });]]></description><name>labelStyle</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout or one of the two BoxLayout subclasses. An object containing margins to apply to this BoxComponent in the
 format: {
     top: (top margin),
     right: (right margin),
     bottom: (bottom margin),
     left: (left margin)
 } May
 also be a string containing space-separated, numeric margin values. The order of the sides associated with each value
 matches the way CSS processes margin values: If there is only one value, it applies to all sides. If there are two
 values, the top and bottom borders are set to the first value and the right and left are set to the second. If there are
 three values, the top is set to the first value, the left and right are set to the second, and the bottom is set to the
 third. If there are four values, they apply to the top, right, bottom, and left, respectively. Defaults to: {top:0,
 right:0, bottom:0, left:0}]]></description><name>margins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Experimental The effect used when displaying a validation message under the field (defaults to 'normal').]]></description><name>msgFx</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The location where the message text set through markInvalid should display. Must be one of the following values: qtip
 Display a quick tip containing the message when the user hovers over the field. This is the default. Ext.QuickTips.init
 must have been called for this setting to work. title Display the message in a default browser title attribute popup.
 under Add a block div beneath the field containing the error message. side Add an error icon to the right of the field,
 displaying the message in a popup on hover. [element id] Add the error message directly to the innerHTML of the
 specified element.]]></description><name>msgTarget</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element when the mouse moves over the Element, and
 removed when the mouse moves out. (defaults to ''). This can be useful for adding customized 'active' or 'hover' styles
 to the component or any of its children using standard CSS rules.]]></description><name>overCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level x coordinate for this component if contained within a positioning container.]]></description><name>pageX</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level y coordinate for this component if contained within a positioning container.]]></description><name>pageY</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to disable marking the field invalid. Defaults to false.]]></description><name>preventMark</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered ptype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a Plugin is being specified not as a fully
 instantiated Component, but as a Component config object. The ptype will be looked up at render time up to determine
 what type of Plugin to create. If you create your own Plugins, you may register them using
 Ext.ComponentMgr.registerPlugin in order to be able to take advantage of lazy instantiation and rendering.]]></description><name>ptype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to mark the field as readOnly in HTML (defaults to false). Note: this only sets the element's readOnly DOM
 attribute. Setting readOnly=true, for example, will not disable triggering a ComboBox or DateField; it gives you the
 option of forcing the user to choose via the trigger without typing in the text box. To hide the trigger use
 hideTrigger.]]></description><name>readOnly</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A path specification, relative to the Component's ownerCt specifying into which ancestor Container to place a named
 reference to this Component. The ancestor axis can be traversed by using '/' characters in the path. For example, to put
 a reference to a Toolbar Button into the Panel which owns the Toolbar: var myGrid = new Ext.grid.EditorGridPanel({
    
 title: 'My EditorGridPanel',
     store: myStore,
     colModel: myColModel,
     tbar: [{
         text: 'Save',
        
 handler: saveChanges,
         disabled: true,
         ref: '../saveButton'
     }],
     listeners: {
         afteredit:
 function() {
 //          The button reference is in the GridPanel
             myGrid.saveButton.enable();
         }
    
 }
 }); In the code above, if the ref had been 'saveButton' the reference would have been placed into the Toolbar. Each
 '/' in the ref moves up one level from the Component's ownerCt. Also see the added and removed events.]]></description><name>ref</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout layout manager (e.g. specifying layout:'border'). See Ext.layout.BorderLayout also.]]></description><name>region</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object to use as the scope ('this' reference) of the handler function (defaults to this Checkbox).]]></description><name>scope</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should trigger this component to save its state (defaults to none). stateEvents may
 be any type of event supported by this component, including browser or custom events (e.g., ['click',
 'customerchange']). See stateful for an explanation of saving and restoring Component state.]]></description><name>stateEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id for this component to use for state management purposes (defaults to the component id if one was set,
 otherwise null if the component is using a generated id). See stateful for an explanation of saving and restoring
 Component state.]]></description><name>stateId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A flag which causes the Component to attempt to restore the state of internal properties from a saved state on startup.
 The component must have either a stateId or id assigned for state to be managed. Auto-generated ids are not guaranteed
 to be stable across page loads and cannot be relied upon to save and restore the same state for a component. For state
 saving to work, the state manager's provider must have been set to an implementation of Ext.state.Provider which
 overrides the set and get methods to save and recall name/value pairs. A built-in implementation,
 Ext.state.CookieProvider is available. To set the state provider for the current page: Ext.state.Manager.setProvider(new
 Ext.state.CookieProvider({
     expires: new Date(new Date().getTime()+(1000*60*60*24*7)), //7 days from now
 })); A
 stateful Component attempts to save state when one of the events listed in the stateEvents configuration fires. To save
 state, a stateful Component first serializes its state by calling getState. By default, this function does nothing. The
 developer must provide an implementation which returns an object hash which represents the Component's restorable state.
 The value yielded by getState is passed to Ext.state.Manager.set which uses the configured Ext.state.Provider to save
 the object keyed by the Component's stateId, or, if that is not specified, its id. During construction, a stateful
 Component attempts to restore its state by calling Ext.state.Manager.get passing the stateId, or, if that is not
 specified, the id. The resulting object is passed to applyState. The default implementation of applyState simply copies
 properties into the object, but a developer may override this to support more behaviour. You can perform extra
 processing on state save and restore by attaching handlers to the beforestaterestore, staterestore, beforestatesave and
 statesave events.]]></description><name>stateful</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
     title: 'Some Title',
     renderTo: Ext.getBody(),
     width: 400, height:
 300,
     layout: 'form',
     items: [{
         xtype: 'textarea',
         style: {
             width: '95%',
            
 marginBottom: '10px'
         }
     },
         new Ext.Button({
             text: 'Send',
             minWidth: '100',
   
          style: {
                 marginBottom: '10px'
             }
         })
     ]
 });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[False to clear the name attribute on the field so that it is not submitted during a form post. Defaults to true.]]></description><name>submitValue</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The tabIndex for this field. Note this only applies to fields that are rendered, not those which are built via applyTo
 (defaults to undefined).]]></description><name>tabIndex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is a child item of a TabPanel. A string to be used as innerHTML
 (html tags are accepted) to show in a tooltip when mousing over the associated tab selector element.
 Ext.QuickTips.init() must be called in order for the tips to render.]]></description><name>tabTip</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Whether the field should validate when it loses focus (defaults to true).]]></description><name>validateOnBlur</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The length of time in milliseconds after user input begins until validation is initiated (defaults to 250)]]></description><name>validationDelay</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The event that should initiate field validation. Set to false to disable automatic validation (defaults to 'keyup').]]></description><name>validationEvent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A value to initialize this field with (defaults to undefined).]]></description><name>value</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local x (left) coordinate for this component if contained within a positioning container.]]></description><name>x</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered xtype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a child item of a Container is being specified not
 as a fully instantiated Component, but as a Component config object. The xtype will be looked up at render time up to
 determine what type of child Component to create. The predefined xtypes are listed here. If you subclass Components to
 create your own Components, you may register them using Ext.ComponentMgr.registerType in order to be able to take
 advantage of lazy instantiation and rendering.]]></description><name>xtype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local y (top) coordinate for this component if contained within a positioning container.]]></description><name>y</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 <p>A grouping container for <a href="output/Ext.form.Checkbox.html" ext:cls="Ext.form.Checkbox">Ext.form.Checkbox</a>
 controls.</p> 
 <p>Sample usage:</p> 
 <pre><code><b>var</b> myCheckboxGroup = <b>new</b> Ext.form.CheckboxGroup({
    
 id:<em>'myGroup'</em>,
     xtype: <em>'checkboxgroup'</em>,
     fieldLabel: <em>'Single Column'</em>,
     itemCls:
 <em>'x-check-group-alt'</em>,
     <i>// Put all controls <b>in</b> a single column <b>with</b> width 100%</i>
    
 columns: 1,
     items: [
         {boxLabel: <em>'Item 1'</em>, name: <em>'cb-col-1'</em>},
         {boxLabel: <em>'Item
 2'</em>, name: <em>'cb-col-2'</em>, checked: true},
         {boxLabel: <em>'Item 3'</em>, name: <em>'cb-col-3'</em>}
    
 ]
 });</code></pre>]]></description><name>form.checkboxGroup</name><tag-class>org.brushingbits.jnap.ui.extjs3.form.CheckboxGroup</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[The field's HTML name attribute (defaults to ''). Note: this property must be set if this field is to be automatically
 included with form submit().]]></description><name>name</name><required>true</required><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[False to validate that at least one item in the group is checked (defaults to true). If no items are selected at
 validation time, {@link]]></description><name>allowBlank</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Whether the component can move the Dom node when rendering (defaults to true).]]></description><name>allowDomMove</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use an
 AnchorLayout (or subclass thereof). based layout manager, for example: Ext.form.FormPanel specifying layout: 'anchor' //
 or 'form', or 'absolute' See Ext.layout.AnchorLayout.anchor also.]]></description><name>anchor</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element corresponding to a DIV that is already present in
 the document that specifies some structural markup for this component. Description : When applyTo is used, constituent
 parts of the component can also be specified by id or CSS class name within the main element, and the component being
 created may attempt to create its subcomponents from that markup if applicable. Notes : When using this config, a call
 to render() is not required. If applyTo is specified, any value passed for renderTo will be ignored and the target
 element's parent node will automatically be used as the component's container.]]></description><name>applyTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A DomHelper element spec, or true for a default element spec. Used to create the Element which will encapsulate this
 Component. See autoEl for details. Defaults to: {tag: 'input', type: 'text', size: '20', autocomplete: 'off'}]]></description><name>autoCreate</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A tag name or DomHelper spec used to create the Element which will encapsulate this Component. You do not normally need
 to specify this. For the base classes Ext.Component, Ext.BoxComponent, and Ext.Container, this defaults to 'div'. The
 more complex Ext classes use a more complex DOM structure created by their own onRender methods. This is intended to
 allow the developer to create application-specific utility Components encapsulated by different DOM elements. Example
 usage: <pre><code>{
     xtype: 'box',
     autoEl: {
         tag: 'img',
         src: 'http://www.example.com/example.jpg'
     }
 },
 {
     xtype: 'box',
     autoEl: {
         tag: 'blockquote',
         html: 'autoEl is cool!'
     }
 }, {
     xtype: 'container',
     autoEl: 'ul',
     cls: 'ux-unordered-list',
     items: {
         xtype: 'box',
         autoEl: 'li',
   
      html: 'First list item'
     }
 }</pre></code>]]></description><name>autoEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to use height:'auto', false to use fixed height (or allow it to be managed by its parent Container's layout
 manager. Defaults to false. Note: Although many components inherit this config option, not all will function as expected
 with a height of 'auto'. Setting autoHeight:true means that the browser will manage height based on the element's
 contents, and that Ext will not manage it at all. If the browser is managing the height, be aware that resizes performed
 by the browser in response to changes within the structure of the Component cannot be detected. Therefore changes to the
 height might result in elements needing to be synchronized with the new height. Example: var w = new Ext.Window({
    
 title: 'Window',
     width: 600,
     autoHeight: true,
     items: {
         title: 'Collapse Me',
         height: 400,
  
 collapsible: true,
         border: false,
         listeners: {
             beforecollapse: function() {
                w.el.shadow.hide();
             },
             beforeexpand: function() {
                w.el.shadow.hide();
             },
             collapse: function() {
                w.syncShadow();
             },
             expand: function() {
                w.syncShadow();
             }
         }
     }
 }).show();]]></description><name>autoHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to use overflow:'auto' on the components layout element and show scroll bars automatically when necessary, false to
 clip any overflowing content (defaults to false).]]></description><name>autoScroll</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True if the component should check for hidden classes (e.g. 'x-hidden' or 'x-hide-display') and remove them on render
 (defaults to false).]]></description><name>autoShow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to use width:'auto', false to use fixed width (or allow it to be managed by its parent Container's layout manager.
 Defaults to false. Note: Although many components inherit this config option, not all will function as expected with a
 width of 'auto'. Setting autoWidth:true means that the browser will manage width based on the element's contents, and
 that Ext will not manage it at all. If the browser is managing the width, be aware that resizes performed by the browser
 in response to changes within the structure of the Component cannot be detected. Therefore changes to the width might
 result in elements needing to be synchronized with the new width. For example, where the target element is: <div
 id='grid-container' style='margin-left:25%;width:50%'></div> A Panel rendered into that target element must listen for
 browser window resize in order to relay its child items when the browser changes its width: var myPanel = new
 Ext.Panel({
     renderTo: 'grid-container',
     monitorResize: true, // relay on browser resize
     title: 'Panel',
    
 height: 400,
     autoWidth: true,
     layout: 'hbox',
     layoutConfig: {
         align: 'stretch'
     },
     defaults: {
         flex: 1
     },
     items: [{
         title: 'Box 1',
     }, {
         title: 'Box 2'
     }, {
         title:
 'Box 3'
     }],
 });]]></description><name>autoWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Error text to display if the allowBlank validation fails (defaults to "You must select at least one item in this group")]]></description><name>blankText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to [].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class used to to apply to the special clearing div rendered directly after each form field wrapper to provide
 field clearing (defaults to 'x-form-clear-left'). Note: this config is only used when this Component is rendered by a
 Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or specifying
 layout:'form') and either a fieldLabel is specified or isFormField=true is specified. See Ext.layout.FormLayout.fieldTpl
 also.]]></description><name>clearCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom CSS class to apply to the field's underlying element (defaults to '').]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the number of columns to use when displaying grouped checkbox/radio controls using automatic layout. This
 config can take several types of values: 'auto' : The controls will be rendered one per column on one row and the width
 of each column will be evenly distributed based on the width of the overall field container. This is the default. Number
 : If you specific a number (e.g., 3) that number of columns will be created and the contained controls will be
 automatically distributed based on the value of vertical. Array : Object You can also specify an array of column widths,
 mixing integer (fixed width) and float (percentage width) values as needed (e.g., [100, .25, .75]). Any integer values
 will be rendered first, then any float values will be calculated as a percentage of the remaining space. Float values do
 not have to add up to 1 (100%) although if you want the controls to take up the entire field container you should do so.]]></description><name>columns</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's container. This can be useful for adding customized
 styles to the container or any of its children using standard CSS rules. See Ext.layout.ContainerLayout.extraCls also.
 Note: ctCls defaults to '' except for the following class which assigns a value by default: Box Layout :
 'x-box-layout-ct' To configure the above Class with an extra CSS class append to the default. For example, for BoxLayout
 (Hbox and Vbox): ctCls: 'x-box-layout-ct custom-class']]></description><name>ctCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to disable the field (defaults to false). Be aware that conformant with the HTML specification, disabled Fields
 will not be submitted.]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class added to the component when it is disabled (defaults to 'x-item-disabled').]]></description><name>disabledClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default CSS class for the field (defaults to 'x-form-field')]]></description><name>fieldClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The label text to display next to this Component (defaults to ''). Note: this config is only used when this Component is
 rendered by a Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or
 specifying layout:'form'). Also see hideLabel and Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
    
 height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name'
    
 }]
 });]]></description><name>fieldLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use a
 BoxLayout. Each child Component with a flex property will be flexed either vertically (by a VBoxLayout) or horizontally
 (by an HBoxLayout) according to the item's relative flex value compared to the sum of all Components with flex value
 specified. Any child items that have either a flex = 0 or flex = undefined will not be 'flexed' (the initial size will
 not be changed).]]></description><name>flex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class to use when the field receives focus (defaults to 'x-form-focus')]]></description><name>focusClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component hidden (default is false). If true, the hide method will be called internally.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to completely hide the label element (label and separator). Defaults to false. By default, even if you do not
 specify a fieldLabel the space will still be reserved so that the field will line up with other fields that do have
 labels. Setting this to true will cause the field to not reserve that space. Note: see the note for clearCls. Example
 use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield'
        
 hideLabel: true
     }]
 });]]></description><name>hideLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[How this component should be hidden. Supported values are 'visibility' (css visibility), 'offsets' (negative offset
 position) and 'display' (css display). Note: the default of 'display' is generally preferred since items are
 automatically laid out when they are first shown (no sizing is done while hidden).]]></description><name>hideMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide and show the component's container when hide/show is called on the component, false to hide and show the
 component itself (defaults to false). For example, this can be used as a shortcut for a hide button on a window by
 setting hide:true on the button when adding it to its parent container.]]></description><name>hideParent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id of this component (defaults to an auto-assigned id). You should assign an id if you need to be able to
 access the component later and you do not have an object reference available (e.g., using Ext.getCmp). Note that this id
 will also be used as the element id for the containing HTML element that is rendered to the page for this component.
 This allows you to write id-based CSS rules to style the specific instance of this component uniquely, and also to
 select sub-elements using this component's id as the parent. Note: to avoid complications imposed by a unique id also
 see itemId and ref. Note: to access the container of an item see ownerCt.]]></description><name>id</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The type attribute for input fields -- e.g. radio, text, password, file (defaults to 'text'). The types 'file' and
 'password' must be used to render those field types currently -- there are no separate Ext components for those. Note
 that if you use inputType:'file', emptyText is not supported and should be avoided.]]></description><name>inputType</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class to use when marking a field invalid (defaults to 'x-form-invalid')]]></description><name>invalidClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The error text to use when marking a field invalid and no message is provided (defaults to 'The value in this field is
 invalid')]]></description><name>invalidText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use the
 FormLayout layout manager (e.g. Ext.form.FormPanel or specifying layout:'form'). An additional CSS class to apply to the
 div wrapping the form item element of this field. If supplied, itemCls at the field level will override the default
 itemCls supplied at the container level. The value specified for itemCls will be added to the default class
 ('x-form-item'). Since it is applied to the item wrapper (see Ext.layout.FormLayout.fieldTpl), it allows you to write
 standard CSS rules that can apply to the field, the label (if specified), or any other element within the markup for the
 field. Note: see the note for fieldLabel. Example use: // Apply a style to the field's label:
 <style>
     .required
 .x-form-item-label {font-weight:bold;color:red;}
 </style>
 
 new Ext.FormPanel({
     height: 100,
     renderTo:
 Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         itemCls: 'required' //this
 label will be styled
     },{
         xtype: 'textfield',
         fieldLabel: 'Favorite Color'
     }]
 });]]></description><name>itemCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An itemId can be used as an alternative way to get a reference to a component when no object reference is available.
 Instead of using an id with Ext.getCmp, use itemId with Ext.Container.getComponent which will retrieve itemId's or id's.
 Since itemId's are an index to the container's internal MixedCollection, the itemId is scoped locally to the container
 -- avoiding potential conflicts with Ext.ComponentMgr which requires a unique id. var c = new Ext.Panel({ //
     height:
 300,
     renderTo: document.body,
     layout: 'auto',
     items: [
         {
             itemId: 'p1',
            
 title: 'Panel 1',
             height: 150
         },
         {
             itemId: 'p2',
             title: 'Panel 2',
  
 height: 150
         }
     ]
 })
 p1 = c.getComponent('p1'); // not the same as Ext.getCmp()
 p2 =
 p1.ownerCt.getComponent('p2'); // reference via a sibling Also see id and ref. Note: to access the container of an item
 see ownerCt.]]></description><name>itemId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An Array of Checkboxes or Checkbox config objects to arrange in the group.]]></description><name>items</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The separator to display after the text of each fieldLabel. This property may be configured at various levels. The order
 of precedence is: field / component level container level layout level (defaults to colon ':') To display no separator
 for this field's label specify empty string ''. Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 layoutConfig: {
         labelSeparator: '~'   // layout config has lowest priority (defaults to ':')
     },
    
 labelSeparator: '>>',     // config at container level
     items: [{
         xtype: 'textfield',
         fieldLabel:
 'Field 1',
         labelSeparator: '...' // field/component level config supersedes others
     },{
         xtype:
 'textfield',
         fieldLabel: 'Field 2' // labelSeparator will be '='
     }]
 });]]></description><name>labelSeparator</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS style specification string to apply directly to this field's label. Defaults to the container's labelStyle value
 if set (e.g., Ext.layout.FormLayout.labelStyle , or ''). Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         labelStyle: 'font-weight:bold;'
     }]
 });]]></description><name>labelStyle</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout or one of the two BoxLayout subclasses. An object containing margins to apply to this BoxComponent in the
 format: {
     top: (top margin),
     right: (right margin),
     bottom: (bottom margin),
     left: (left margin)
 } May
 also be a string containing space-separated, numeric margin values. The order of the sides associated with each value
 matches the way CSS processes margin values: If there is only one value, it applies to all sides. If there are two
 values, the top and bottom borders are set to the first value and the right and left are set to the second. If there are
 three values, the top is set to the first value, the left and right are set to the second, and the bottom is set to the
 third. If there are four values, they apply to the top, right, bottom, and left, respectively. Defaults to: {top:0,
 right:0, bottom:0, left:0}]]></description><name>margins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Experimental The effect used when displaying a validation message under the field (defaults to 'normal').]]></description><name>msgFx</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The location where the message text set through markInvalid should display. Must be one of the following values: qtip
 Display a quick tip containing the message when the user hovers over the field. This is the default. Ext.QuickTips.init
 must have been called for this setting to work. title Display the message in a default browser title attribute popup.
 under Add a block div beneath the field containing the error message. side Add an error icon to the right of the field,
 displaying the message in a popup on hover. [element id] Add the error message directly to the innerHTML of the
 specified element.]]></description><name>msgTarget</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element when the mouse moves over the Element, and
 removed when the mouse moves out. (defaults to ''). This can be useful for adding customized 'active' or 'hover' styles
 to the component or any of its children using standard CSS rules.]]></description><name>overCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level x coordinate for this component if contained within a positioning container.]]></description><name>pageX</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level y coordinate for this component if contained within a positioning container.]]></description><name>pageY</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to disable marking the field invalid. Defaults to false.]]></description><name>preventMark</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered ptype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a Plugin is being specified not as a fully
 instantiated Component, but as a Component config object. The ptype will be looked up at render time up to determine
 what type of Plugin to create. If you create your own Plugins, you may register them using
 Ext.ComponentMgr.registerPlugin in order to be able to take advantage of lazy instantiation and rendering.]]></description><name>ptype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to mark the field as readOnly in HTML (defaults to false). Note: this only sets the element's readOnly DOM
 attribute. Setting readOnly=true, for example, will not disable triggering a ComboBox or DateField; it gives you the
 option of forcing the user to choose via the trigger without typing in the text box. To hide the trigger use
 hideTrigger.]]></description><name>readOnly</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A path specification, relative to the Component's ownerCt specifying into which ancestor Container to place a named
 reference to this Component. The ancestor axis can be traversed by using '/' characters in the path. For example, to put
 a reference to a Toolbar Button into the Panel which owns the Toolbar: var myGrid = new Ext.grid.EditorGridPanel({
    
 title: 'My EditorGridPanel',
     store: myStore,
     colModel: myColModel,
     tbar: [{
         text: 'Save',
        
 handler: saveChanges,
         disabled: true,
         ref: '../saveButton'
     }],
     listeners: {
         afteredit:
 function() {
 //          The button reference is in the GridPanel
             myGrid.saveButton.enable();
         }
    
 }
 }); In the code above, if the ref had been 'saveButton' the reference would have been placed into the Toolbar. Each
 '/' in the ref moves up one level from the Component's ownerCt. Also see the added and removed events.]]></description><name>ref</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout layout manager (e.g. specifying layout:'border'). See Ext.layout.BorderLayout also.]]></description><name>region</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should trigger this component to save its state (defaults to none). stateEvents may
 be any type of event supported by this component, including browser or custom events (e.g., ['click',
 'customerchange']). See stateful for an explanation of saving and restoring Component state.]]></description><name>stateEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id for this component to use for state management purposes (defaults to the component id if one was set,
 otherwise null if the component is using a generated id). See stateful for an explanation of saving and restoring
 Component state.]]></description><name>stateId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A flag which causes the Component to attempt to restore the state of internal properties from a saved state on startup.
 The component must have either a stateId or id assigned for state to be managed. Auto-generated ids are not guaranteed
 to be stable across page loads and cannot be relied upon to save and restore the same state for a component. For state
 saving to work, the state manager's provider must have been set to an implementation of Ext.state.Provider which
 overrides the set and get methods to save and recall name/value pairs. A built-in implementation,
 Ext.state.CookieProvider is available. To set the state provider for the current page: Ext.state.Manager.setProvider(new
 Ext.state.CookieProvider({
     expires: new Date(new Date().getTime()+(1000*60*60*24*7)), //7 days from now
 })); A
 stateful Component attempts to save state when one of the events listed in the stateEvents configuration fires. To save
 state, a stateful Component first serializes its state by calling getState. By default, this function does nothing. The
 developer must provide an implementation which returns an object hash which represents the Component's restorable state.
 The value yielded by getState is passed to Ext.state.Manager.set which uses the configured Ext.state.Provider to save
 the object keyed by the Component's stateId, or, if that is not specified, its id. During construction, a stateful
 Component attempts to restore its state by calling Ext.state.Manager.get passing the stateId, or, if that is not
 specified, the id. The resulting object is passed to applyState. The default implementation of applyState simply copies
 properties into the object, but a developer may override this to support more behaviour. You can perform extra
 processing on state save and restore by attaching handlers to the beforestaterestore, staterestore, beforestatesave and
 statesave events.]]></description><name>stateful</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
     title: 'Some Title',
     renderTo: Ext.getBody(),
     width: 400, height:
 300,
     layout: 'form',
     items: [{
         xtype: 'textarea',
         style: {
             width: '95%',
            
 marginBottom: '10px'
         }
     },
         new Ext.Button({
             text: 'Send',
             minWidth: '100',
   
          style: {
                 marginBottom: '10px'
             }
         })
     ]
 });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[False to clear the name attribute on the field so that it is not submitted during a form post. Defaults to true.]]></description><name>submitValue</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The tabIndex for this field. Note this only applies to fields that are rendered, not those which are built via applyTo
 (defaults to undefined).]]></description><name>tabIndex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is a child item of a TabPanel. A string to be used as innerHTML
 (html tags are accepted) to show in a tooltip when mousing over the associated tab selector element.
 Ext.QuickTips.init() must be called in order for the tips to render.]]></description><name>tabTip</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Whether the field should validate when it loses focus (defaults to true).]]></description><name>validateOnBlur</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The length of time in milliseconds after user input begins until validation is initiated (defaults to 250)]]></description><name>validationDelay</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The event that should initiate field validation. Set to false to disable automatic validation (defaults to 'keyup').]]></description><name>validationEvent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A value to initialize this field with (defaults to undefined).]]></description><name>value</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to distribute contained controls across columns, completely filling each column top to bottom before starting on
 the next column. The number of controls in each column will be automatically calculated to keep columns as even as
 possible. The default value is false, so that controls will be added to columns one at a time, completely filling each
 row left to right before starting on the next row.]]></description><name>vertical</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local x (left) coordinate for this component if contained within a positioning container.]]></description><name>x</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered xtype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a child item of a Container is being specified not
 as a fully instantiated Component, but as a Component config object. The xtype will be looked up at render time up to
 determine what type of child Component to create. The predefined xtypes are listed here. If you subclass Components to
 create your own Components, you may register them using Ext.ComponentMgr.registerType in order to be able to take
 advantage of lazy instantiation and rendering.]]></description><name>xtype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local y (top) coordinate for this component if contained within a positioning container.]]></description><name>y</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 <p>A combobox control with support for autocomplete, remote-loading, paging and many other features.</p> 
 <p>A ComboBox
 works in a similar manner to a traditional HTML &lt;select&gt; field. The difference is that to submit the <a
 href="output/Ext.form.ComboBox.html#Ext.form.ComboBox-valueField" ext:member="valueField"
 ext:cls="Ext.form.ComboBox">valueField</a>, you must specify a <a
 href="output/Ext.form.ComboBox.html#Ext.form.ComboBox-hiddenName" ext:member="hiddenName"
 ext:cls="Ext.form.ComboBox">hiddenName</a> to create a hidden input field to hold the value of the valueField. The <i><a
 href="output/Ext.form.ComboBox.html#Ext.form.ComboBox-displayField" ext:member="displayField"
 ext:cls="Ext.form.ComboBox">displayField</a></i> is shown in the text field which is named according to the <a
 href="output/Ext.form.ComboBox.html#Ext.form.ComboBox-name" ext:member="name" ext:cls="Ext.form.ComboBox">name</a>.</p>
 
 <p><b><u>Events</u></b></p> 
 <p>To do something when something in ComboBox is selected, configure the select
 event:</p>
 <pre><code><b>var</b> cb = <b>new</b> Ext.form.ComboBox({
     <i>// all of your config options</i>
    
 listeners:{
          scope: yourScope,
          <em>'select'</em>: yourFunction
     }
 });
 
 <i>// Alternatively, you can
 assign events after the object is created:</i>
 <b>var</b> cb = <b>new</b>
 Ext.form.ComboBox(yourOptions);
 cb.on(<em>'select'</em>, yourFunction, yourScope);</code></pre>
 <p></p>
 
 <p><b><u>ComboBox in Grid</u></b></p> 
 <p>If using a ComboBox in an <a href="output/Ext.grid.EditorGridPanel.html"
 ext:cls="Ext.grid.EditorGridPanel">Editor Grid</a> a <a href="output/Ext.grid.Column.html#Ext.grid.Column-renderer"
 ext:member="renderer" ext:cls="Ext.grid.Column">renderer</a> will be needed to show the displayField when the editor is
 not active. Set up the renderer manually, or implement a reusable render, for example:</p>
 <pre><code><i>// create
 reusable renderer</i>
 Ext.util.Format.comboRenderer = <b>function</b>(combo){
     <b>return</b> <b>function</b>(value){
 
 <b>var</b> record = combo.findRecord(combo.<a href="output/Ext.form.ComboBox.html#Ext.form.ComboBox-valueField"
 ext:member="valueField" ext:cls="Ext.form.ComboBox">valueField</a>, value);
         <b>return</b> record ?
 record.get(combo.<a href="output/Ext.form.ComboBox.html#Ext.form.ComboBox-displayField" ext:member="displayField"
 ext:cls="Ext.form.ComboBox">displayField</a>) : combo.<a
 href="output/Ext.form.ComboBox.html#Ext.form.ComboBox-valueNotFoundText" ext:member="valueNotFoundText"
 ext:cls="Ext.form.ComboBox">valueNotFoundText</a>;
     }
 }
 
 <i>// create the combo instance</i>
 <b>var</b> combo =
 <b>new</b> Ext.form.ComboBox({
     <a href="output/Ext.form.ComboBox.html#Ext.form.ComboBox-typeAhead"
 ext:member="typeAhead" ext:cls="Ext.form.ComboBox">typeAhead</a>: true,
     <a
 href="output/Ext.form.ComboBox.html#Ext.form.ComboBox-triggerAction" ext:member="triggerAction"
 ext:cls="Ext.form.ComboBox">triggerAction</a>: <em>'all'</em>,
     <a
 href="output/Ext.form.ComboBox.html#Ext.form.ComboBox-lazyRender" ext:member="lazyRender"
 ext:cls="Ext.form.ComboBox">lazyRender</a>:true,
     <a href="output/Ext.form.ComboBox.html#Ext.form.ComboBox-mode"
 ext:member="mode" ext:cls="Ext.form.ComboBox">mode</a>: <em>'local'</em>,
     <a
 href="output/Ext.form.ComboBox.html#Ext.form.ComboBox-store" ext:member="store" ext:cls="Ext.form.ComboBox">store</a>:
 <b>new</b> Ext.data.ArrayStore({
         id: 0,
         fields: [
             <em>'myId'</em>,
            
 <em>'displayText'</em>
         ],
         data: [[1, <em>'item1'</em>], [2, <em>'item2'</em>]]
     }),
     <a
 href="output/Ext.form.ComboBox.html#Ext.form.ComboBox-valueField" ext:member="valueField"
 ext:cls="Ext.form.ComboBox">valueField</a>: <em>'myId'</em>,
     <a
 href="output/Ext.form.ComboBox.html#Ext.form.ComboBox-displayField" ext:member="displayField"
 ext:cls="Ext.form.ComboBox">displayField</a>: <em>'displayText'</em>
 });
 
 <i>// snippet of column model used within
 grid</i>
 <b>var</b> cm = <b>new</b> Ext.grid.ColumnModel([{
        ...
     },{
        header: <em>&quot;Some
 Header&quot;</em>,
        dataIndex: <em>'whatever'</em>,
        width: 130,
        editor: combo, <i>// specify
 reference to combo instance</i>
        renderer: Ext.util.Format.comboRenderer(combo) <i>// pass combo instance to
 reusable renderer</i>
     },
     ...
 ]);</code></pre>
 <p></p> 
 <p><b><u>Filtering</u></b></p> 
 <p>A ComboBox <a
 href="output/Ext.form.ComboBox.html#Ext.form.ComboBox-doQuery" ext:member="doQuery" ext:cls="Ext.form.ComboBox">uses
 filtering itself</a>, for information about filtering the ComboBox store manually see <tt><a
 href="output/Ext.form.ComboBox.html#Ext.form.ComboBox-lastQuery" ext:member="lastQuery"
 ext:cls="Ext.form.ComboBox">lastQuery</a></tt>.</p>]]></description><name>form.comboBox</name><tag-class>org.brushingbits.jnap.ui.extjs3.form.ComboBox</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[The field's HTML name attribute (defaults to ''). Note: this property must be set if this field is to be automatically
 included with form submit().]]></description><name>name</name><required>true</required><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The text query to send to the server to return all records for the list with no filtering (defaults to '')]]></description><name>allQuery</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify false to validate that the value's length is > 0 (defaults to true)]]></description><name>allowBlank</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Whether the component can move the Dom node when rendering (defaults to true).]]></description><name>allowDomMove</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use an
 AnchorLayout (or subclass thereof). based layout manager, for example: Ext.form.FormPanel specifying layout: 'anchor' //
 or 'form', or 'absolute' See Ext.layout.AnchorLayout.anchor also.]]></description><name>anchor</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element corresponding to a DIV that is already present in
 the document that specifies some structural markup for this component. Description : When applyTo is used, constituent
 parts of the component can also be specified by id or CSS class name within the main element, and the component being
 created may attempt to create its subcomponents from that markup if applicable. Notes : When using this config, a call
 to render() is not required. If applyTo is specified, any value passed for renderTo will be ignored and the target
 element's parent node will automatically be used as the component's container.]]></description><name>applyTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A DomHelper element spec, or true for a default element spec. Used to create the Element which will encapsulate this
 Component. See autoEl for details. Defaults to: {tag: "input", type: "text", size: "24", autocomplete: "off"}]]></description><name>autoCreate</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A tag name or DomHelper spec used to create the Element which will encapsulate this Component. You do not normally need
 to specify this. For the base classes Ext.Component, Ext.BoxComponent, and Ext.Container, this defaults to 'div'. The
 more complex Ext classes use a more complex DOM structure created by their own onRender methods. This is intended to
 allow the developer to create application-specific utility Components encapsulated by different DOM elements. Example
 usage: <pre><code>{
     xtype: 'box',
     autoEl: {
         tag: 'img',
         src: 'http://www.example.com/example.jpg'
     }
 },
 {
     xtype: 'box',
     autoEl: {
         tag: 'blockquote',
         html: 'autoEl is cool!'
     }
 }, {
     xtype: 'container',
     autoEl: 'ul',
     cls: 'ux-unordered-list',
     items: {
         xtype: 'box',
         autoEl: 'li',
   
      html: 'First list item'
     }
 }</pre></code>]]></description><name>autoEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to use height:'auto', false to use fixed height (or allow it to be managed by its parent Container's layout
 manager. Defaults to false. Note: Although many components inherit this config option, not all will function as expected
 with a height of 'auto'. Setting autoHeight:true means that the browser will manage height based on the element's
 contents, and that Ext will not manage it at all. If the browser is managing the height, be aware that resizes performed
 by the browser in response to changes within the structure of the Component cannot be detected. Therefore changes to the
 height might result in elements needing to be synchronized with the new height. Example: var w = new Ext.Window({
    
 title: 'Window',
     width: 600,
     autoHeight: true,
     items: {
         title: 'Collapse Me',
         height: 400,
  
 collapsible: true,
         border: false,
         listeners: {
             beforecollapse: function() {
                w.el.shadow.hide();
             },
             beforeexpand: function() {
                w.el.shadow.hide();
             },
             collapse: function() {
                w.syncShadow();
             },
             expand: function() {
                w.syncShadow();
             }
         }
     }
 }).show();]]></description><name>autoHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to use overflow:'auto' on the components layout element and show scroll bars automatically when necessary, false to
 clip any overflowing content (defaults to false).]]></description><name>autoScroll</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to select the first result gathered by the data store (defaults to true). A false value would require a manual
 selection from the dropdown list to set the components value unless the value of (typeAheadDelay) were true.]]></description><name>autoSelect</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True if the component should check for hidden classes (e.g. 'x-hidden' or 'x-hide-display') and remove them on render
 (defaults to false).]]></description><name>autoShow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to use width:'auto', false to use fixed width (or allow it to be managed by its parent Container's layout manager.
 Defaults to false. Note: Although many components inherit this config option, not all will function as expected with a
 width of 'auto'. Setting autoWidth:true means that the browser will manage width based on the element's contents, and
 that Ext will not manage it at all. If the browser is managing the width, be aware that resizes performed by the browser
 in response to changes within the structure of the Component cannot be detected. Therefore changes to the width might
 result in elements needing to be synchronized with the new width. For example, where the target element is: <div
 id='grid-container' style='margin-left:25%;width:50%'></div> A Panel rendered into that target element must listen for
 browser window resize in order to relay its child items when the browser changes its width: var myPanel = new
 Ext.Panel({
     renderTo: 'grid-container',
     monitorResize: true, // relay on browser resize
     title: 'Panel',
    
 height: 400,
     autoWidth: true,
     layout: 'hbox',
     layoutConfig: {
         align: 'stretch'
     },
     defaults: {
         flex: 1
     },
     items: [{
         title: 'Box 1',
     }, {
         title: 'Box 2'
     }, {
         title:
 'Box 3'
     }],
 });]]></description><name>autoWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The error text to display if the allowBlank validation fails (defaults to 'This field is required')]]></description><name>blankText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to [].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class used to to apply to the special clearing div rendered directly after each form field wrapper to provide
 field clearing (defaults to 'x-form-clear-left'). Note: this config is only used when this Component is rendered by a
 Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or specifying
 layout:'form') and either a fieldLabel is specified or isFormField=true is specified. See Ext.layout.FormLayout.fieldTpl
 also.]]></description><name>clearCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to clear any filters on the store (when in local mode) when reset is called (defaults to true)]]></description><name>clearFilterOnReset</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom CSS class to apply to the field's underlying element (defaults to '').]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's container. This can be useful for adding customized
 styles to the container or any of its children using standard CSS rules. See Ext.layout.ContainerLayout.extraCls also.
 Note: ctCls defaults to '' except for the following class which assigns a value by default: Box Layout :
 'x-box-layout-ct' To configure the above Class with an extra CSS class append to the default. For example, for BoxLayout
 (Hbox and Vbox): ctCls: 'x-box-layout-ct custom-class']]></description><name>ctCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify true to disable input keystroke filtering (defaults to false)]]></description><name>disableKeyFilter</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to disable the field (defaults to false). Be aware that conformant with the HTML specification, disabled Fields
 will not be submitted.]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class added to the component when it is disabled (defaults to 'x-item-disabled').]]></description><name>disabledClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The underlying data field name to bind to this ComboBox (defaults to undefined if mode = 'remote' or 'field1' if
 transforming a select or if the field name is autogenerated based on the store configuration). See also valueField.
 Note: if using a ComboBox in an Editor Grid a renderer will be needed to show the displayField when the editor is not
 active.]]></description><name>displayField</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[false to prevent the user from typing text directly into the field, the field will only respond to a click on the
 trigger to set the value. (defaults to true).]]></description><name>editable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class to apply to an empty field to style the emptyText (defaults to 'x-form-empty-field'). This class is
 automatically added and removed as needed depending on the current field value.]]></description><name>emptyClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default text to place into an empty field (defaults to null). Note: that this value will be submitted to the server
 if this field is enabled and configured with a name.]]></description><name>emptyText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to enable the proxying of key events for the HTML input field (defaults to false)]]></description><name>enableKeyEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default CSS class for the field (defaults to 'x-form-field')]]></description><name>fieldClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The label text to display next to this Component (defaults to ''). Note: this config is only used when this Component is
 rendered by a Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or
 specifying layout:'form'). Also see hideLabel and Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
    
 height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name'
    
 }]
 });]]></description><name>fieldLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use a
 BoxLayout. Each child Component with a flex property will be flexed either vertically (by a VBoxLayout) or horizontally
 (by an HBoxLayout) according to the item's relative flex value compared to the sum of all Components with flex value
 specified. Any child items that have either a flex = 0 or flex = undefined will not be 'flexed' (the initial size will
 not be changed).]]></description><name>flex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class to use when the field receives focus (defaults to 'x-form-focus')]]></description><name>focusClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to restrict the selected value to one of the values in the list, false to allow the user to set arbitrary text into
 the field (defaults to false)]]></description><name>forceSelection</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true if this field should automatically grow and shrink to its content (defaults to false)]]></description><name>grow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum width to allow when grow = true (defaults to 800)]]></description><name>growMax</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum width to allow when grow = true (defaults to 30)]]></description><name>growMin</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height in pixels of the dropdown list resize handle if resizable = true (defaults to 8)]]></description><name>handleHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component hidden (default is false). If true, the hide method will be called internally.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If hiddenName is specified, hiddenId can also be provided to give the hidden field a unique id. The hiddenId and combo
 id should be different, since no two DOM nodes should share the same id.]]></description><name>hiddenId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If specified, a hidden form field with this name is dynamically generated to store the field's data value (defaults to
 the underlying DOM element's name). Required for the combo's value to automatically post during a form submission. See
 also valueField.]]></description><name>hiddenName</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Sets the initial value of the hidden field if hiddenName is specified to contain the selected valueField, from the
 Store. Defaults to the configured value.]]></description><name>hiddenValue</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to completely hide the label element (label and separator). Defaults to false. By default, even if you do not
 specify a fieldLabel the space will still be reserved so that the field will line up with other fields that do have
 labels. Setting this to true will cause the field to not reserve that space. Note: see the note for clearCls. Example
 use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield'
        
 hideLabel: true
     }]
 });]]></description><name>hideLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[How this component should be hidden. Supported values are 'visibility' (css visibility), 'offsets' (negative offset
 position) and 'display' (css display). Note: the default of 'display' is generally preferred since items are
 automatically laid out when they are first shown (no sizing is done while hidden).]]></description><name>hideMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide and show the component's container when hide/show is called on the component, false to hide and show the
 component itself (defaults to false). For example, this can be used as a shortcut for a hide button on a window by
 setting hide:true on the button when adding it to its parent container.]]></description><name>hideParent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to hide the trigger element and display only the base text field (defaults to false)]]></description><name>hideTrigger</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id of this component (defaults to an auto-assigned id). You should assign an id if you need to be able to
 access the component later and you do not have an object reference available (e.g., using Ext.getCmp). Note that this id
 will also be used as the element id for the containing HTML element that is rendered to the page for this component.
 This allows you to write id-based CSS rules to style the specific instance of this component uniquely, and also to
 select sub-elements using this component's id as the parent. Note: to avoid complications imposed by a unique id also
 see itemId and ref. Note: to access the container of an item see ownerCt.]]></description><name>id</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The type attribute for input fields -- e.g. radio, text, password, file (defaults to 'text'). The types 'file' and
 'password' must be used to render those field types currently -- there are no separate Ext components for those. Note
 that if you use inputType:'file', emptyText is not supported and should be avoided.]]></description><name>inputType</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class to use when marking a field invalid (defaults to 'x-form-invalid')]]></description><name>invalidClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The error text to use when marking a field invalid and no message is provided (defaults to 'The value in this field is
 invalid')]]></description><name>invalidText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use the
 FormLayout layout manager (e.g. Ext.form.FormPanel or specifying layout:'form'). An additional CSS class to apply to the
 div wrapping the form item element of this field. If supplied, itemCls at the field level will override the default
 itemCls supplied at the container level. The value specified for itemCls will be added to the default class
 ('x-form-item'). Since it is applied to the item wrapper (see Ext.layout.FormLayout.fieldTpl), it allows you to write
 standard CSS rules that can apply to the field, the label (if specified), or any other element within the markup for the
 field. Note: see the note for fieldLabel. Example use: // Apply a style to the field's label:
 <style>
     .required
 .x-form-item-label {font-weight:bold;color:red;}
 </style>
 
 new Ext.FormPanel({
     height: 100,
     renderTo:
 Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         itemCls: 'required' //this
 label will be styled
     },{
         xtype: 'textfield',
         fieldLabel: 'Favorite Color'
     }]
 });]]></description><name>itemCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An itemId can be used as an alternative way to get a reference to a component when no object reference is available.
 Instead of using an id with Ext.getCmp, use itemId with Ext.Container.getComponent which will retrieve itemId's or id's.
 Since itemId's are an index to the container's internal MixedCollection, the itemId is scoped locally to the container
 -- avoiding potential conflicts with Ext.ComponentMgr which requires a unique id. var c = new Ext.Panel({ //
     height:
 300,
     renderTo: document.body,
     layout: 'auto',
     items: [
         {
             itemId: 'p1',
            
 title: 'Panel 1',
             height: 150
         },
         {
             itemId: 'p2',
             title: 'Panel 2',
  
 height: 150
         }
     ]
 })
 p1 = c.getComponent('p1'); // not the same as Ext.getCmp()
 p2 =
 p1.ownerCt.getComponent('p2'); // reference via a sibling Also see id and ref. Note: to access the container of an item
 see ownerCt.]]></description><name>itemId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A simple CSS selector (e.g. div.some-class or span:first-child) that will be used to determine what nodes the
 Ext.DataView which handles the dropdown display will be working with. Note: this setting is required if a custom
 XTemplate has been specified in tpl which assigns a class other than 'x-combo-list-item' to dropdown list items]]></description><name>itemSelector</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The separator to display after the text of each fieldLabel. This property may be configured at various levels. The order
 of precedence is: field / component level container level layout level (defaults to colon ':') To display no separator
 for this field's label specify empty string ''. Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 layoutConfig: {
         labelSeparator: '~'   // layout config has lowest priority (defaults to ':')
     },
    
 labelSeparator: '>>',     // config at container level
     items: [{
         xtype: 'textfield',
         fieldLabel:
 'Field 1',
         labelSeparator: '...' // field/component level config supersedes others
     },{
         xtype:
 'textfield',
         fieldLabel: 'Field 2' // labelSeparator will be '='
     }]
 });]]></description><name>labelSeparator</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS style specification string to apply directly to this field's label. Defaults to the container's labelStyle value
 if set (e.g., Ext.layout.FormLayout.labelStyle , or ''). Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         labelStyle: 'font-weight:bold;'
     }]
 });]]></description><name>labelStyle</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to not initialize the list for this combo until the field is focused (defaults to true)]]></description><name>lazyInit</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to prevent the ComboBox from rendering until requested (should always be used when rendering into an Ext.Editor
 (e.g. Grids), defaults to false).]]></description><name>lazyRender</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A valid anchor position value. See Ext.Element.alignTo for details on supported anchor positions and offsets. To specify
 x/y offsets as well, this value may be specified as an Array of Ext.Element.alignTo method arguments. [ 'tl-bl?', [6,0]
 ](defaults to 'tl-bl?')]]></description><name>listAlign</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class to add to the predefined 'x-combo-list' class applied the dropdown list element (defaults to '').]]></description><name>listClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The empty text to display in the data view if no items are found. (defaults to '')]]></description><name>listEmptyText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width (used as a parameter to Ext.Element.setWidth) of the dropdown list (defaults to the width of the ComboBox
 field). See also minListWidth]]></description><name>listWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The text to display in the dropdown list while data is loading. Only applies when mode = 'remote' (defaults to
 'Loading...')]]></description><name>loadingText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout or one of the two BoxLayout subclasses. An object containing margins to apply to this BoxComponent in the
 format: {
     top: (top margin),
     right: (right margin),
     bottom: (bottom margin),
     left: (left margin)
 } May
 also be a string containing space-separated, numeric margin values. The order of the sides associated with each value
 matches the way CSS processes margin values: If there is only one value, it applies to all sides. If there are two
 values, the top and bottom borders are set to the first value and the right and left are set to the second. If there are
 three values, the top is set to the first value, the left and right are set to the second, and the bottom is set to the
 third. If there are four values, they apply to the top, right, bottom, and left, respectively. Defaults to: {top:0,
 right:0, bottom:0, left:0}]]></description><name>margins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An input mask regular expression that will be used to filter keystrokes that do not match (defaults to null). The maskRe
 will not operate on any paste events.]]></description><name>maskRe</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum height in pixels of the dropdown list before scrollbars are shown (defaults to 300)]]></description><name>maxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Maximum input field length allowed by validation (defaults to Number.MAX_VALUE). This behavior is intended to provide
 instant feedback to the user by improving usability to allow pasting and editing or overtyping and back tracking. To
 restrict the maximum number of characters that can be entered into the field use autoCreate to add any attributes you
 want to a field, for example: var myField = new Ext.form.NumberField({
     id: 'mobile',
     anchor:'90%',
    
 fieldLabel: 'Mobile',
     maxLength: 16, // for validation
     autoCreate: {tag: 'input', type: 'text', size: '20',
 autocomplete: 'off', maxlength: '10'}
 });]]></description><name>maxLength</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Error text to display if the maximum length validation fails (defaults to 'The maximum length for this field is
 {maxLength}')]]></description><name>maxLengthText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum number of characters the user must type before autocomplete and typeAhead activate (defaults to 4 if mode =
 'remote' or 0 if mode = 'local', does not apply if editable = false).]]></description><name>minChars</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum height in pixels of the dropdown list when the list is constrained by its distance to the viewport edges
 (defaults to 90)]]></description><name>minHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Minimum input field length required (defaults to 0)]]></description><name>minLength</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Error text to display if the minimum length validation fails (defaults to 'The minimum length for this field is
 {minLength}')]]></description><name>minLengthText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum width of the dropdown list in pixels (defaults to 70, will be ignored if listWidth has a higher value)]]></description><name>minListWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Acceptable values are: 'remote' : Default Automatically loads the store the first time the trigger is clicked. If you do
 not want the store to be automatically loaded the first time the trigger is clicked, set to 'local' and manually load
 the store. To force a requery of the store every time the trigger is clicked see lastQuery. 'local' : ComboBox loads
 local data var combo = new Ext.form.ComboBox({
     renderTo: document.body,
     mode: 'local',
     store: new
 Ext.data.ArrayStore({
         id: 0,
         fields: [
             'myId',  // numeric value is the key
            
 'displayText'
         ],
         data: [[1, 'item1'], [2, 'item2']]  // data is local
     }),
     valueField: 'myId',
   
  displayField: 'displayText',
     triggerAction: 'all'
 });]]></description><name>mode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Experimental The effect used when displaying a validation message under the field (defaults to 'normal').]]></description><name>msgFx</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The location where the message text set through markInvalid should display. Must be one of the following values: qtip
 Display a quick tip containing the message when the user hovers over the field. This is the default. Ext.QuickTips.init
 must have been called for this setting to work. title Display the message in a default browser title attribute popup.
 under Add a block div beneath the field containing the error message. side Add an error icon to the right of the field,
 displaying the message in a popup on hover. [element id] Add the error message directly to the innerHTML of the
 specified element.]]></description><name>msgTarget</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element when the mouse moves over the Element, and
 removed when the mouse moves out. (defaults to ''). This can be useful for adding customized 'active' or 'hover' styles
 to the component or any of its children using standard CSS rules.]]></description><name>overCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If greater than 0, a Ext.PagingToolbar is displayed in the footer of the dropdown list and the filter queries will
 execute with page start and limit parameters. Only applies when mode = 'remote' (defaults to 0).]]></description><name>pageSize</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level x coordinate for this component if contained within a positioning container.]]></description><name>pageX</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level y coordinate for this component if contained within a positioning container.]]></description><name>pageY</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to disable marking the field invalid. Defaults to false.]]></description><name>preventMark</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered ptype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a Plugin is being specified not as a fully
 instantiated Component, but as a Component config object. The ptype will be looked up at render time up to determine
 what type of Plugin to create. If you create your own Plugins, you may register them using
 Ext.ComponentMgr.registerPlugin in order to be able to take advantage of lazy instantiation and rendering.]]></description><name>ptype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The length of time in milliseconds to delay between the start of typing and sending the query to filter the dropdown
 list (defaults to 500 if mode = 'remote' or 10 if mode = 'local')]]></description><name>queryDelay</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Name of the query (baseParam name for the store) as it will be passed on the querystring (defaults to 'query')]]></description><name>queryParam</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to prevent the user from changing the field, and hides the trigger. Superceeds the editable and hideTrigger options
 if the value is true. (defaults to false)]]></description><name>readOnly</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A path specification, relative to the Component's ownerCt specifying into which ancestor Container to place a named
 reference to this Component. The ancestor axis can be traversed by using '/' characters in the path. For example, to put
 a reference to a Toolbar Button into the Panel which owns the Toolbar: var myGrid = new Ext.grid.EditorGridPanel({
    
 title: 'My EditorGridPanel',
     store: myStore,
     colModel: myColModel,
     tbar: [{
         text: 'Save',
        
 handler: saveChanges,
         disabled: true,
         ref: '../saveButton'
     }],
     listeners: {
         afteredit:
 function() {
 //          The button reference is in the GridPanel
             myGrid.saveButton.enable();
         }
    
 }
 }); In the code above, if the ref had been 'saveButton' the reference would have been placed into the Toolbar. Each
 '/' in the ref moves up one level from the Component's ownerCt. Also see the added and removed events.]]></description><name>ref</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A JavaScript RegExp object to be tested against the field value during validation (defaults to null). If the test fails,
 the field will be marked invalid using regexText.]]></description><name>regex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The error text to display if regex is used and the test fails during validation (defaults to '')]]></description><name>regexText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout layout manager (e.g. specifying layout:'border'). See Ext.layout.BorderLayout also.]]></description><name>region</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to add a resize handle to the bottom of the dropdown list (creates an Ext.Resizable with 'se' pinned handles).
 Defaults to false.]]></description><name>resizable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to select any existing text in the field immediately on focus. Only applies when editable = true (defaults to
 false).]]></description><name>selectOnFocus</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class to apply to the selected item in the dropdown list (defaults to 'x-combo-selected')]]></description><name>selectedClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true or "sides" for the default effect, "frame" for 4-way shadow, and "drop" for bottom-right]]></description><name>shadow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should trigger this component to save its state (defaults to none). stateEvents may
 be any type of event supported by this component, including browser or custom events (e.g., ['click',
 'customerchange']). See stateful for an explanation of saving and restoring Component state.]]></description><name>stateEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id for this component to use for state management purposes (defaults to the component id if one was set,
 otherwise null if the component is using a generated id). See stateful for an explanation of saving and restoring
 Component state.]]></description><name>stateId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A flag which causes the Component to attempt to restore the state of internal properties from a saved state on startup.
 The component must have either a stateId or id assigned for state to be managed. Auto-generated ids are not guaranteed
 to be stable across page loads and cannot be relied upon to save and restore the same state for a component. For state
 saving to work, the state manager's provider must have been set to an implementation of Ext.state.Provider which
 overrides the set and get methods to save and recall name/value pairs. A built-in implementation,
 Ext.state.CookieProvider is available. To set the state provider for the current page: Ext.state.Manager.setProvider(new
 Ext.state.CookieProvider({
     expires: new Date(new Date().getTime()+(1000*60*60*24*7)), //7 days from now
 })); A
 stateful Component attempts to save state when one of the events listed in the stateEvents configuration fires. To save
 state, a stateful Component first serializes its state by calling getState. By default, this function does nothing. The
 developer must provide an implementation which returns an object hash which represents the Component's restorable state.
 The value yielded by getState is passed to Ext.state.Manager.set which uses the configured Ext.state.Provider to save
 the object keyed by the Component's stateId, or, if that is not specified, its id. During construction, a stateful
 Component attempts to restore its state by calling Ext.state.Manager.get passing the stateId, or, if that is not
 specified, the id. The resulting object is passed to applyState. The default implementation of applyState simply copies
 properties into the object, but a developer may override this to support more behaviour. You can perform extra
 processing on state save and restore by attaching handlers to the beforestaterestore, staterestore, beforestatesave and
 statesave events.]]></description><name>stateful</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The data source to which this combo is bound (defaults to undefined). Acceptable values for this property are: any Store
 subclass an Array : Arrays will be converted to a Ext.data.ArrayStore internally, automatically generating field names
 to work with all data components. 1-dimensional array : (e.g., ['Foo','Bar']) A 1-dimensional array will automatically
 be expanded (each array item will be used for both the combo valueField and displayField) 2-dimensional array : (e.g.,
 [['f','Foo'],['b','Bar']]) For a multi-dimensional array, the value in index 0 of each item will be assumed to be the
 combo valueField, while the value at index 1 is assumed to be the combo displayField. See also mode.]]></description><name>store</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A JavaScript RegExp object used to strip unwanted content from the value before validation (defaults to null).]]></description><name>stripCharsRe</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
     title: 'Some Title',
     renderTo: Ext.getBody(),
     width: 400, height:
 300,
     layout: 'form',
     items: [{
         xtype: 'textarea',
         style: {
             width: '95%',
            
 marginBottom: '10px'
         }
     },
         new Ext.Button({
             text: 'Send',
             minWidth: '100',
   
          style: {
                 marginBottom: '10px'
             }
         })
     ]
 });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[False to clear the name attribute on the field so that it is not submitted during a form post. If a hiddenName is
 specified, setting this to true will cause both the hidden field and the element to be submitted. Defaults to undefined.]]></description><name>submitValue</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The tabIndex for this field. Note this only applies to fields that are rendered, not those which are built via applyTo
 (defaults to undefined).]]></description><name>tabIndex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is a child item of a TabPanel. A string to be used as innerHTML
 (html tags are accepted) to show in a tooltip when mousing over the associated tab selector element.
 Ext.QuickTips.init() must be called in order for the tips to render.]]></description><name>tabTip</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If supplied, a header element is created containing this text and added into the top of the dropdown list (defaults to
 undefined, with no header element)]]></description><name>title</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The id, DOM node or element of an existing HTML SELECT to convert to a ComboBox. Note that if you specify this and the
 combo is going to be in an Ext.form.BasicForm or Ext.form.FormPanel, you must also set lazyRender = true.]]></description><name>transform</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The action to execute when the trigger is clicked. 'query' : Default run the query using the raw value. 'all' : run the
 query specified by the allQuery config option See also queryParam.]]></description><name>triggerAction</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An additional CSS class used to style the trigger button. The trigger will always get the class 'x-form-trigger' and
 triggerClass will be appended if specified (defaults to 'x-form-arrow-trigger' which displays a downward arrow icon).]]></description><name>triggerClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A DomHelper config object specifying the structure of the trigger element for this Field. (Optional). Specify this when
 you need a customized element to act as the trigger button for a TriggerField. Note that when using this option, it is
 the developer's responsibility to ensure correct sizing, positioning and appearance of the trigger. Defaults to: {tag:
 "img", src: Ext.BLANK_IMAGE_URL, cls: "x-form-trigger " + this.triggerClass}]]></description><name>triggerConfig</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to populate and autoselect the remainder of the text being typed after a configurable delay (typeAheadDelay) if it
 matches a known value (defaults to false)]]></description><name>typeAhead</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The length of time in milliseconds to wait until the typeahead text is displayed if typeAhead = true (defaults to 250)]]></description><name>typeAheadDelay</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Whether the field should validate when it loses focus (defaults to true).]]></description><name>validateOnBlur</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The length of time in milliseconds after user input begins until validation is initiated (defaults to 250)]]></description><name>validationDelay</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The event that should initiate field validation. Set to false to disable automatic validation (defaults to 'keyup').]]></description><name>validationEvent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom validation function to be called during field validation (validateValue) (defaults to null). If specified, this
 function will be called first, allowing the developer to override the default validation process. This function will be
 passed the following Parameters: value: Mixed The current field value This function is to Return: true: Boolean true if
 the value is valid msg: String An error message if the value is invalid]]></description><name>validator</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A value to initialize this field with (defaults to undefined).]]></description><name>value</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The underlying data value name to bind to this ComboBox (defaults to undefined if mode = 'remote' or 'field2' if
 transforming a select or if the field name is autogenerated based on the store configuration). Note: use of a valueField
 requires the user to make a selection in order for a value to be mapped. See also hiddenName, hiddenValue, and
 displayField.]]></description><name>valueField</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[When using a name/value combo, if the value passed to setValue is not found in the store, valueNotFoundText will be
 displayed as the field text if defined (defaults to undefined). If this default text is used, it means there is no value
 set and no validation will occur on this field.]]></description><name>valueNotFoundText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A validation type name as defined in Ext.form.VTypes (defaults to null)]]></description><name>vtype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom error message to display in place of the default message provided for the vtype currently set for this field
 (defaults to ''). Note: only applies if vtype is set, else ignored.]]></description><name>vtypeText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The class added to the to the wrap of the trigger element. Defaults to x-trigger-wrap-focus.]]></description><name>wrapFocusClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local x (left) coordinate for this component if contained within a positioning container.]]></description><name>x</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered xtype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a child item of a Container is being specified not
 as a fully instantiated Component, but as a Component config object. The xtype will be looked up at render time up to
 determine what type of child Component to create. The predefined xtypes are listed here. If you subclass Components to
 create your own Components, you may register them using Ext.ComponentMgr.registerType in order to be able to take
 advantage of lazy instantiation and rendering.]]></description><name>xtype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local y (top) coordinate for this component if contained within a positioning container.]]></description><name>y</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 Composite field allowing a number of form Fields to be rendered on the same row. The fields are rendered using an hbox
 layout internally, so all of the normal HBox layout config items are available. Example usage: 
 <pre>
 {
     xtype:
 'compositefield',
     labelWidth: 120
     items: [
         {
             xtype     : 'textfield',
            
 fieldLabel: 'Title',
             width     : 20
         },
         {
             xtype     : 'textfield',
            
 fieldLabel: 'First',
             flex      : 1
         },
         {
             xtype     : 'textfield',
            
 fieldLabel: 'Last',
             flex      : 1
         }
     ]
 }
 </pre> In the example above the composite's fieldLabel
 will be set to 'Title, First, Last' as it groups the fieldLabels of each of its children. This can be overridden by
 setting a fieldLabel on the compositefield itself: 
 <pre>
 {
     xtype: 'compositefield',
     fieldLabel: 'Custom
 label',
     items: [...]
 }
 </pre> Any Ext.form.* component can be placed inside a composite field.]]></description><name>form.compositefield</name><tag-class>org.brushingbits.jnap.ui.extjs3.form.CompositeField</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[The field's HTML name attribute (defaults to ''). Note: this property must be set if this field is to be automatically
 included with form submit().]]></description><name>name</name><required>true</required><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Whether the component can move the Dom node when rendering (defaults to true).]]></description><name>allowDomMove</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use an
 AnchorLayout (or subclass thereof). based layout manager, for example: Ext.form.FormPanel specifying layout: 'anchor' //
 or 'form', or 'absolute' See Ext.layout.AnchorLayout.anchor also.]]></description><name>anchor</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element corresponding to a DIV that is already present in
 the document that specifies some structural markup for this component. Description : When applyTo is used, constituent
 parts of the component can also be specified by id or CSS class name within the main element, and the component being
 created may attempt to create its subcomponents from that markup if applicable. Notes : When using this config, a call
 to render() is not required. If applyTo is specified, any value passed for renderTo will be ignored and the target
 element's parent node will automatically be used as the component's container.]]></description><name>applyTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A DomHelper element spec, or true for a default element spec. Used to create the Element which will encapsulate this
 Component. See autoEl for details. Defaults to: {tag: 'input', type: 'text', size: '20', autocomplete: 'off'}]]></description><name>autoCreate</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A tag name or DomHelper spec used to create the Element which will encapsulate this Component. You do not normally need
 to specify this. For the base classes Ext.Component, Ext.BoxComponent, and Ext.Container, this defaults to 'div'. The
 more complex Ext classes use a more complex DOM structure created by their own onRender methods. This is intended to
 allow the developer to create application-specific utility Components encapsulated by different DOM elements. Example
 usage: <pre><code>{
     xtype: 'box',
     autoEl: {
         tag: 'img',
         src: 'http://www.example.com/example.jpg'
     }
 },
 {
     xtype: 'box',
     autoEl: {
         tag: 'blockquote',
         html: 'autoEl is cool!'
     }
 }, {
     xtype: 'container',
     autoEl: 'ul',
     cls: 'ux-unordered-list',
     items: {
         xtype: 'box',
         autoEl: 'li',
   
      html: 'First list item'
     }
 }</pre></code>]]></description><name>autoEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to use height:'auto', false to use fixed height (or allow it to be managed by its parent Container's layout
 manager. Defaults to false. Note: Although many components inherit this config option, not all will function as expected
 with a height of 'auto'. Setting autoHeight:true means that the browser will manage height based on the element's
 contents, and that Ext will not manage it at all. If the browser is managing the height, be aware that resizes performed
 by the browser in response to changes within the structure of the Component cannot be detected. Therefore changes to the
 height might result in elements needing to be synchronized with the new height. Example: var w = new Ext.Window({
    
 title: 'Window',
     width: 600,
     autoHeight: true,
     items: {
         title: 'Collapse Me',
         height: 400,
  
 collapsible: true,
         border: false,
         listeners: {
             beforecollapse: function() {
                w.el.shadow.hide();
             },
             beforeexpand: function() {
                w.el.shadow.hide();
             },
             collapse: function() {
                w.syncShadow();
             },
             expand: function() {
                w.syncShadow();
             }
         }
     }
 }).show();]]></description><name>autoHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to use overflow:'auto' on the components layout element and show scroll bars automatically when necessary, false to
 clip any overflowing content (defaults to false).]]></description><name>autoScroll</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True if the component should check for hidden classes (e.g. 'x-hidden' or 'x-hide-display') and remove them on render
 (defaults to false).]]></description><name>autoShow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to use width:'auto', false to use fixed width (or allow it to be managed by its parent Container's layout manager.
 Defaults to false. Note: Although many components inherit this config option, not all will function as expected with a
 width of 'auto'. Setting autoWidth:true means that the browser will manage width based on the element's contents, and
 that Ext will not manage it at all. If the browser is managing the width, be aware that resizes performed by the browser
 in response to changes within the structure of the Component cannot be detected. Therefore changes to the width might
 result in elements needing to be synchronized with the new width. For example, where the target element is: <div
 id='grid-container' style='margin-left:25%;width:50%'></div> A Panel rendered into that target element must listen for
 browser window resize in order to relay its child items when the browser changes its width: var myPanel = new
 Ext.Panel({
     renderTo: 'grid-container',
     monitorResize: true, // relay on browser resize
     title: 'Panel',
    
 height: 400,
     autoWidth: true,
     layout: 'hbox',
     layoutConfig: {
         align: 'stretch'
     },
     defaults: {
         flex: 1
     },
     items: [{
         title: 'Box 1',
     }, {
         title: 'Box 2'
     }, {
         title:
 'Box 3'
     }],
 });]]></description><name>autoWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to [].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class used to to apply to the special clearing div rendered directly after each form field wrapper to provide
 field clearing (defaults to 'x-form-clear-left'). Note: this config is only used when this Component is rendered by a
 Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or specifying
 layout:'form') and either a fieldLabel is specified or isFormField=true is specified. See Ext.layout.FormLayout.fieldTpl
 also.]]></description><name>clearCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom CSS class to apply to the field's underlying element (defaults to '').]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's container. This can be useful for adding customized
 styles to the container or any of its children using standard CSS rules. See Ext.layout.ContainerLayout.extraCls also.
 Note: ctCls defaults to '' except for the following class which assigns a value by default: Box Layout :
 'x-box-layout-ct' To configure the above Class with an extra CSS class append to the default. For example, for BoxLayout
 (Hbox and Vbox): ctCls: 'x-box-layout-ct custom-class']]></description><name>ctCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Any default properties to assign to the child fields.]]></description><name>defaults</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to disable the field (defaults to false). Be aware that conformant with the HTML specification, disabled Fields
 will not be submitted.]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class added to the component when it is disabled (defaults to 'x-item-disabled').]]></description><name>disabledClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default CSS class for the field (defaults to 'x-form-field')]]></description><name>fieldClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The label text to display next to this Component (defaults to ''). Note: this config is only used when this Component is
 rendered by a Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or
 specifying layout:'form'). Also see hideLabel and Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
    
 height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name'
    
 }]
 });]]></description><name>fieldLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use a
 BoxLayout. Each child Component with a flex property will be flexed either vertically (by a VBoxLayout) or horizontally
 (by an HBoxLayout) according to the item's relative flex value compared to the sum of all Components with flex value
 specified. Any child items that have either a flex = 0 or flex = undefined will not be 'flexed' (the initial size will
 not be changed).]]></description><name>flex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class to use when the field receives focus (defaults to 'x-form-focus')]]></description><name>focusClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component hidden (default is false). If true, the hide method will be called internally.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to completely hide the label element (label and separator). Defaults to false. By default, even if you do not
 specify a fieldLabel the space will still be reserved so that the field will line up with other fields that do have
 labels. Setting this to true will cause the field to not reserve that space. Note: see the note for clearCls. Example
 use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield'
        
 hideLabel: true
     }]
 });]]></description><name>hideLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[How this component should be hidden. Supported values are 'visibility' (css visibility), 'offsets' (negative offset
 position) and 'display' (css display). Note: the default of 'display' is generally preferred since items are
 automatically laid out when they are first shown (no sizing is done while hidden).]]></description><name>hideMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide and show the component's container when hide/show is called on the component, false to hide and show the
 component itself (defaults to false). For example, this can be used as a shortcut for a hide button on a window by
 setting hide:true on the button when adding it to its parent container.]]></description><name>hideParent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id of this component (defaults to an auto-assigned id). You should assign an id if you need to be able to
 access the component later and you do not have an object reference available (e.g., using Ext.getCmp). Note that this id
 will also be used as the element id for the containing HTML element that is rendered to the page for this component.
 This allows you to write id-based CSS rules to style the specific instance of this component uniquely, and also to
 select sub-elements using this component's id as the parent. Note: to avoid complications imposed by a unique id also
 see itemId and ref. Note: to access the container of an item see ownerCt.]]></description><name>id</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The type attribute for input fields -- e.g. radio, text, password, file (defaults to 'text'). The types 'file' and
 'password' must be used to render those field types currently -- there are no separate Ext components for those. Note
 that if you use inputType:'file', emptyText is not supported and should be avoided.]]></description><name>inputType</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class to use when marking a field invalid (defaults to 'x-form-invalid')]]></description><name>invalidClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The error text to use when marking a field invalid and no message is provided (defaults to 'The value in this field is
 invalid')]]></description><name>invalidText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use the
 FormLayout layout manager (e.g. Ext.form.FormPanel or specifying layout:'form'). An additional CSS class to apply to the
 div wrapping the form item element of this field. If supplied, itemCls at the field level will override the default
 itemCls supplied at the container level. The value specified for itemCls will be added to the default class
 ('x-form-item'). Since it is applied to the item wrapper (see Ext.layout.FormLayout.fieldTpl), it allows you to write
 standard CSS rules that can apply to the field, the label (if specified), or any other element within the markup for the
 field. Note: see the note for fieldLabel. Example use: // Apply a style to the field's label:
 <style>
     .required
 .x-form-item-label {font-weight:bold;color:red;}
 </style>
 
 new Ext.FormPanel({
     height: 100,
     renderTo:
 Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         itemCls: 'required' //this
 label will be styled
     },{
         xtype: 'textfield',
         fieldLabel: 'Favorite Color'
     }]
 });]]></description><name>itemCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An itemId can be used as an alternative way to get a reference to a component when no object reference is available.
 Instead of using an id with Ext.getCmp, use itemId with Ext.Container.getComponent which will retrieve itemId's or id's.
 Since itemId's are an index to the container's internal MixedCollection, the itemId is scoped locally to the container
 -- avoiding potential conflicts with Ext.ComponentMgr which requires a unique id. var c = new Ext.Panel({ //
     height:
 300,
     renderTo: document.body,
     layout: 'auto',
     items: [
         {
             itemId: 'p1',
            
 title: 'Panel 1',
             height: 150
         },
         {
             itemId: 'p2',
             title: 'Panel 2',
  
 height: 150
         }
     ]
 })
 p1 = c.getComponent('p1'); // not the same as Ext.getCmp()
 p2 =
 p1.ownerCt.getComponent('p2'); // reference via a sibling Also see id and ref. Note: to access the container of an item
 see ownerCt.]]></description><name>itemId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The string to use when joining segments of the built label together (defaults to ', ')]]></description><name>labelConnector</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The separator to display after the text of each fieldLabel. This property may be configured at various levels. The order
 of precedence is: field / component level container level layout level (defaults to colon ':') To display no separator
 for this field's label specify empty string ''. Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 layoutConfig: {
         labelSeparator: '~'   // layout config has lowest priority (defaults to ':')
     },
    
 labelSeparator: '>>',     // config at container level
     items: [{
         xtype: 'textfield',
         fieldLabel:
 'Field 1',
         labelSeparator: '...' // field/component level config supersedes others
     },{
         xtype:
 'textfield',
         fieldLabel: 'Field 2' // labelSeparator will be '='
     }]
 });]]></description><name>labelSeparator</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS style specification string to apply directly to this field's label. Defaults to the container's labelStyle value
 if set (e.g., Ext.layout.FormLayout.labelStyle , or ''). Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         labelStyle: 'font-weight:bold;'
     }]
 });]]></description><name>labelStyle</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout or one of the two BoxLayout subclasses. An object containing margins to apply to this BoxComponent in the
 format: {
     top: (top margin),
     right: (right margin),
     bottom: (bottom margin),
     left: (left margin)
 } May
 also be a string containing space-separated, numeric margin values. The order of the sides associated with each value
 matches the way CSS processes margin values: If there is only one value, it applies to all sides. If there are two
 values, the top and bottom borders are set to the first value and the right and left are set to the second. If there are
 three values, the top is set to the first value, the left and right are set to the second, and the bottom is set to the
 third. If there are four values, they apply to the top, right, bottom, and left, respectively. Defaults to: {top:0,
 right:0, bottom:0, left:0}]]></description><name>margins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Experimental The effect used when displaying a validation message under the field (defaults to 'normal').]]></description><name>msgFx</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The location where the message text set through markInvalid should display. Must be one of the following values: qtip
 Display a quick tip containing the message when the user hovers over the field. This is the default. Ext.QuickTips.init
 must have been called for this setting to work. title Display the message in a default browser title attribute popup.
 under Add a block div beneath the field containing the error message. side Add an error icon to the right of the field,
 displaying the message in a popup on hover. [element id] Add the error message directly to the innerHTML of the
 specified element.]]></description><name>msgTarget</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element when the mouse moves over the Element, and
 removed when the mouse moves out. (defaults to ''). This can be useful for adding customized 'active' or 'hover' styles
 to the component or any of its children using standard CSS rules.]]></description><name>overCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level x coordinate for this component if contained within a positioning container.]]></description><name>pageX</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level y coordinate for this component if contained within a positioning container.]]></description><name>pageY</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to disable marking the field invalid. Defaults to false.]]></description><name>preventMark</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered ptype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a Plugin is being specified not as a fully
 instantiated Component, but as a Component config object. The ptype will be looked up at render time up to determine
 what type of Plugin to create. If you create your own Plugins, you may register them using
 Ext.ComponentMgr.registerPlugin in order to be able to take advantage of lazy instantiation and rendering.]]></description><name>ptype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to mark the field as readOnly in HTML (defaults to false). Note: this only sets the element's readOnly DOM
 attribute. Setting readOnly=true, for example, will not disable triggering a ComboBox or DateField; it gives you the
 option of forcing the user to choose via the trigger without typing in the text box. To hide the trigger use
 hideTrigger.]]></description><name>readOnly</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A path specification, relative to the Component's ownerCt specifying into which ancestor Container to place a named
 reference to this Component. The ancestor axis can be traversed by using '/' characters in the path. For example, to put
 a reference to a Toolbar Button into the Panel which owns the Toolbar: var myGrid = new Ext.grid.EditorGridPanel({
    
 title: 'My EditorGridPanel',
     store: myStore,
     colModel: myColModel,
     tbar: [{
         text: 'Save',
        
 handler: saveChanges,
         disabled: true,
         ref: '../saveButton'
     }],
     listeners: {
         afteredit:
 function() {
 //          The button reference is in the GridPanel
             myGrid.saveButton.enable();
         }
    
 }
 }); In the code above, if the ref had been 'saveButton' the reference would have been placed into the Toolbar. Each
 '/' in the ref moves up one level from the Component's ownerCt. Also see the added and removed events.]]></description><name>ref</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout layout manager (e.g. specifying layout:'border'). See Ext.layout.BorderLayout also.]]></description><name>region</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should trigger this component to save its state (defaults to none). stateEvents may
 be any type of event supported by this component, including browser or custom events (e.g., ['click',
 'customerchange']). See stateful for an explanation of saving and restoring Component state.]]></description><name>stateEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id for this component to use for state management purposes (defaults to the component id if one was set,
 otherwise null if the component is using a generated id). See stateful for an explanation of saving and restoring
 Component state.]]></description><name>stateId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A flag which causes the Component to attempt to restore the state of internal properties from a saved state on startup.
 The component must have either a stateId or id assigned for state to be managed. Auto-generated ids are not guaranteed
 to be stable across page loads and cannot be relied upon to save and restore the same state for a component. For state
 saving to work, the state manager's provider must have been set to an implementation of Ext.state.Provider which
 overrides the set and get methods to save and recall name/value pairs. A built-in implementation,
 Ext.state.CookieProvider is available. To set the state provider for the current page: Ext.state.Manager.setProvider(new
 Ext.state.CookieProvider({
     expires: new Date(new Date().getTime()+(1000*60*60*24*7)), //7 days from now
 })); A
 stateful Component attempts to save state when one of the events listed in the stateEvents configuration fires. To save
 state, a stateful Component first serializes its state by calling getState. By default, this function does nothing. The
 developer must provide an implementation which returns an object hash which represents the Component's restorable state.
 The value yielded by getState is passed to Ext.state.Manager.set which uses the configured Ext.state.Provider to save
 the object keyed by the Component's stateId, or, if that is not specified, its id. During construction, a stateful
 Component attempts to restore its state by calling Ext.state.Manager.get passing the stateId, or, if that is not
 specified, the id. The resulting object is passed to applyState. The default implementation of applyState simply copies
 properties into the object, but a developer may override this to support more behaviour. You can perform extra
 processing on state save and restore by attaching handlers to the beforestaterestore, staterestore, beforestatesave and
 statesave events.]]></description><name>stateful</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
     title: 'Some Title',
     renderTo: Ext.getBody(),
     width: 400, height:
 300,
     layout: 'form',
     items: [{
         xtype: 'textarea',
         style: {
             width: '95%',
            
 marginBottom: '10px'
         }
     },
         new Ext.Button({
             text: 'Send',
             minWidth: '100',
   
          style: {
                 marginBottom: '10px'
             }
         })
     ]
 });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[False to clear the name attribute on the field so that it is not submitted during a form post. Defaults to true.]]></description><name>submitValue</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The tabIndex for this field. Note this only applies to fields that are rendered, not those which are built via applyTo
 (defaults to undefined).]]></description><name>tabIndex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is a child item of a TabPanel. A string to be used as innerHTML
 (html tags are accepted) to show in a tooltip when mousing over the associated tab selector element.
 Ext.QuickTips.init() must be called in order for the tips to render.]]></description><name>tabTip</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Whether the field should validate when it loses focus (defaults to true).]]></description><name>validateOnBlur</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The length of time in milliseconds after user input begins until validation is initiated (defaults to 250)]]></description><name>validationDelay</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The event that should initiate field validation. Set to false to disable automatic validation (defaults to 'keyup').]]></description><name>validationEvent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A value to initialize this field with (defaults to undefined).]]></description><name>value</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local x (left) coordinate for this component if contained within a positioning container.]]></description><name>x</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered xtype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a child item of a Container is being specified not
 as a fully instantiated Component, but as a Component config object. The xtype will be looked up at render time up to
 determine what type of child Component to create. The predefined xtypes are listed here. If you subclass Components to
 create your own Components, you may register them using Ext.ComponentMgr.registerType in order to be able to take
 advantage of lazy instantiation and rendering.]]></description><name>xtype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local y (top) coordinate for this component if contained within a positioning container.]]></description><name>y</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 Provides a date input field with a 
 <a href="output/Ext.DatePicker.html" ext:cls="Ext.DatePicker">Ext.DatePicker</a>
 dropdown and automatic date validation.]]></description><name>form.datefield</name><tag-class>org.brushingbits.jnap.ui.extjs3.form.DateField</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[The field's HTML name attribute (defaults to ''). Note: this property must be set if this field is to be automatically
 included with form submit().]]></description><name>name</name><required>true</required><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify false to validate that the value's length is > 0 (defaults to true)]]></description><name>allowBlank</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Whether the component can move the Dom node when rendering (defaults to true).]]></description><name>allowDomMove</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Multiple date formats separated by "|" to try when parsing a user input value and it does not match the defined format
 (defaults to 'm/d/Y|n/j/Y|n/j/y|m/j/y|n/d/y|m/j/Y|n/d/Y|m-d-y|m-d-Y|m/d|m-d|md|mdy|mdY|d|Y-m-d|n-j|n/j').]]></description><name>altFormats</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use an
 AnchorLayout (or subclass thereof). based layout manager, for example: Ext.form.FormPanel specifying layout: 'anchor' //
 or 'form', or 'absolute' See Ext.layout.AnchorLayout.anchor also.]]></description><name>anchor</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element corresponding to a DIV that is already present in
 the document that specifies some structural markup for this component. Description : When applyTo is used, constituent
 parts of the component can also be specified by id or CSS class name within the main element, and the component being
 created may attempt to create its subcomponents from that markup if applicable. Notes : When using this config, a call
 to render() is not required. If applyTo is specified, any value passed for renderTo will be ignored and the target
 element's parent node will automatically be used as the component's container.]]></description><name>applyTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A DomHelper element specification object, or true for the default element specification object: autoCreate: {tag:
 "input", type: "text", size: "10", autocomplete: "off"}]]></description><name>autoCreate</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A tag name or DomHelper spec used to create the Element which will encapsulate this Component. You do not normally need
 to specify this. For the base classes Ext.Component, Ext.BoxComponent, and Ext.Container, this defaults to 'div'. The
 more complex Ext classes use a more complex DOM structure created by their own onRender methods. This is intended to
 allow the developer to create application-specific utility Components encapsulated by different DOM elements. Example
 usage: <pre><code>{
     xtype: 'box',
     autoEl: {
         tag: 'img',
         src: 'http://www.example.com/example.jpg'
     }
 },
 {
     xtype: 'box',
     autoEl: {
         tag: 'blockquote',
         html: 'autoEl is cool!'
     }
 }, {
     xtype: 'container',
     autoEl: 'ul',
     cls: 'ux-unordered-list',
     items: {
         xtype: 'box',
         autoEl: 'li',
   
      html: 'First list item'
     }
 }</pre></code>]]></description><name>autoEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to use height:'auto', false to use fixed height (or allow it to be managed by its parent Container's layout
 manager. Defaults to false. Note: Although many components inherit this config option, not all will function as expected
 with a height of 'auto'. Setting autoHeight:true means that the browser will manage height based on the element's
 contents, and that Ext will not manage it at all. If the browser is managing the height, be aware that resizes performed
 by the browser in response to changes within the structure of the Component cannot be detected. Therefore changes to the
 height might result in elements needing to be synchronized with the new height. Example: var w = new Ext.Window({
    
 title: 'Window',
     width: 600,
     autoHeight: true,
     items: {
         title: 'Collapse Me',
         height: 400,
  
 collapsible: true,
         border: false,
         listeners: {
             beforecollapse: function() {
                w.el.shadow.hide();
             },
             beforeexpand: function() {
                w.el.shadow.hide();
             },
             collapse: function() {
                w.syncShadow();
             },
             expand: function() {
                w.syncShadow();
             }
         }
     }
 }).show();]]></description><name>autoHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to use overflow:'auto' on the components layout element and show scroll bars automatically when necessary, false to
 clip any overflowing content (defaults to false).]]></description><name>autoScroll</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True if the component should check for hidden classes (e.g. 'x-hidden' or 'x-hide-display') and remove them on render
 (defaults to false).]]></description><name>autoShow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to use width:'auto', false to use fixed width (or allow it to be managed by its parent Container's layout manager.
 Defaults to false. Note: Although many components inherit this config option, not all will function as expected with a
 width of 'auto'. Setting autoWidth:true means that the browser will manage width based on the element's contents, and
 that Ext will not manage it at all. If the browser is managing the width, be aware that resizes performed by the browser
 in response to changes within the structure of the Component cannot be detected. Therefore changes to the width might
 result in elements needing to be synchronized with the new width. For example, where the target element is: <div
 id='grid-container' style='margin-left:25%;width:50%'></div> A Panel rendered into that target element must listen for
 browser window resize in order to relay its child items when the browser changes its width: var myPanel = new
 Ext.Panel({
     renderTo: 'grid-container',
     monitorResize: true, // relay on browser resize
     title: 'Panel',
    
 height: 400,
     autoWidth: true,
     layout: 'hbox',
     layoutConfig: {
         align: 'stretch'
     },
     defaults: {
         flex: 1
     },
     items: [{
         title: 'Box 1',
     }, {
         title: 'Box 2'
     }, {
         title:
 'Box 3'
     }],
 });]]></description><name>autoWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The error text to display if the allowBlank validation fails (defaults to 'This field is required')]]></description><name>blankText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to [].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class used to to apply to the special clearing div rendered directly after each form field wrapper to provide
 field clearing (defaults to 'x-form-clear-left'). Note: this config is only used when this Component is rendered by a
 Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or specifying
 layout:'form') and either a fieldLabel is specified or isFormField=true is specified. See Ext.layout.FormLayout.fieldTpl
 also.]]></description><name>clearCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom CSS class to apply to the field's underlying element (defaults to '').]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's container. This can be useful for adding customized
 styles to the container or any of its children using standard CSS rules. See Ext.layout.ContainerLayout.extraCls also.
 Note: ctCls defaults to '' except for the following class which assigns a value by default: Box Layout :
 'x-box-layout-ct' To configure the above Class with an extra CSS class append to the default. For example, for BoxLayout
 (Hbox and Vbox): ctCls: 'x-box-layout-ct custom-class']]></description><name>ctCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify true to disable input keystroke filtering (defaults to false)]]></description><name>disableKeyFilter</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to disable the field (defaults to false). Be aware that conformant with the HTML specification, disabled Fields
 will not be submitted.]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class added to the component when it is disabled (defaults to 'x-item-disabled').]]></description><name>disabledClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of "dates" to disable, as strings. These strings will be used to build a dynamic regular expression so they are
 very powerful. Some examples: // disable these exact dates:
 disabledDates: ["03/08/2003", "09/16/2003"]
 // disable these
 days for every year:
 disabledDates: ["03/08", "09/16"]
 // only match the beginning (useful if you are using short
 years):
 disabledDates: ["^03/08"]
 // disable every day in March 2006:
 disabledDates: ["03/../2006"]
 // disable every day
 in every March:
 disabledDates: ["^03"] Note that the format of the dates included in the array should exactly match the
 format config. In order to support regular expressions, if you are using a date format that has "." in it, you will have
 to escape the dot when restricting dates. For example: ["03\\.08\\.03"].]]></description><name>disabledDates</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The tooltip text to display when the date falls on a disabled date (defaults to 'Disabled')]]></description><name>disabledDatesText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of days to disable, 0 based (defaults to null). Some examples: // disable Sunday and Saturday:
 disabledDays: 
 [0, 6]
 // disable weekdays:
 disabledDays: [1,2,3,4,5]]]></description><name>disabledDays</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The tooltip to display when the date falls on a disabled day (defaults to 'Disabled')]]></description><name>disabledDaysText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[false to prevent the user from typing text directly into the field, the field will only respond to a click on the
 trigger to set the value. (defaults to true).]]></description><name>editable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class to apply to an empty field to style the emptyText (defaults to 'x-form-empty-field'). This class is
 automatically added and removed as needed depending on the current field value.]]></description><name>emptyClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default text to place into an empty field (defaults to null). Note: that this value will be submitted to the server
 if this field is enabled and configured with a name.]]></description><name>emptyText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to enable the proxying of key events for the HTML input field (defaults to false)]]></description><name>enableKeyEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default CSS class for the field (defaults to 'x-form-field')]]></description><name>fieldClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The label text to display next to this Component (defaults to ''). Note: this config is only used when this Component is
 rendered by a Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or
 specifying layout:'form'). Also see hideLabel and Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
    
 height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name'
    
 }]
 });]]></description><name>fieldLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use a
 BoxLayout. Each child Component with a flex property will be flexed either vertically (by a VBoxLayout) or horizontally
 (by an HBoxLayout) according to the item's relative flex value compared to the sum of all Components with flex value
 specified. Any child items that have either a flex = 0 or flex = undefined will not be 'flexed' (the initial size will
 not be changed).]]></description><name>flex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class to use when the field receives focus (defaults to 'x-form-focus')]]></description><name>focusClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default date format string which can be overriden for localization support. The format must be valid according to
 Date.parseDate (defaults to 'm/d/Y').]]></description><name>format</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true if this field should automatically grow and shrink to its content (defaults to false)]]></description><name>grow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum width to allow when grow = true (defaults to 800)]]></description><name>growMax</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum width to allow when grow = true (defaults to 30)]]></description><name>growMin</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component hidden (default is false). If true, the hide method will be called internally.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to completely hide the label element (label and separator). Defaults to false. By default, even if you do not
 specify a fieldLabel the space will still be reserved so that the field will line up with other fields that do have
 labels. Setting this to true will cause the field to not reserve that space. Note: see the note for clearCls. Example
 use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield'
        
 hideLabel: true
     }]
 });]]></description><name>hideLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[How this component should be hidden. Supported values are 'visibility' (css visibility), 'offsets' (negative offset
 position) and 'display' (css display). Note: the default of 'display' is generally preferred since items are
 automatically laid out when they are first shown (no sizing is done while hidden).]]></description><name>hideMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide and show the component's container when hide/show is called on the component, false to hide and show the
 component itself (defaults to false). For example, this can be used as a shortcut for a hide button on a window by
 setting hide:true on the button when adding it to its parent container.]]></description><name>hideParent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to hide the trigger element and display only the base text field (defaults to false)]]></description><name>hideTrigger</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id of this component (defaults to an auto-assigned id). You should assign an id if you need to be able to
 access the component later and you do not have an object reference available (e.g., using Ext.getCmp). Note that this id
 will also be used as the element id for the containing HTML element that is rendered to the page for this component.
 This allows you to write id-based CSS rules to style the specific instance of this component uniquely, and also to
 select sub-elements using this component's id as the parent. Note: to avoid complications imposed by a unique id also
 see itemId and ref. Note: to access the container of an item see ownerCt.]]></description><name>id</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The type attribute for input fields -- e.g. radio, text, password, file (defaults to 'text'). The types 'file' and
 'password' must be used to render those field types currently -- there are no separate Ext components for those. Note
 that if you use inputType:'file', emptyText is not supported and should be avoided.]]></description><name>inputType</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class to use when marking a field invalid (defaults to 'x-form-invalid')]]></description><name>invalidClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The error text to display when the date in the field is invalid (defaults to '{value} is not a valid date - it must be
 in the format {format}').]]></description><name>invalidText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use the
 FormLayout layout manager (e.g. Ext.form.FormPanel or specifying layout:'form'). An additional CSS class to apply to the
 div wrapping the form item element of this field. If supplied, itemCls at the field level will override the default
 itemCls supplied at the container level. The value specified for itemCls will be added to the default class
 ('x-form-item'). Since it is applied to the item wrapper (see Ext.layout.FormLayout.fieldTpl), it allows you to write
 standard CSS rules that can apply to the field, the label (if specified), or any other element within the markup for the
 field. Note: see the note for fieldLabel. Example use: // Apply a style to the field's label:
 <style>
     .required
 .x-form-item-label {font-weight:bold;color:red;}
 </style>
 
 new Ext.FormPanel({
     height: 100,
     renderTo:
 Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         itemCls: 'required' //this
 label will be styled
     },{
         xtype: 'textfield',
         fieldLabel: 'Favorite Color'
     }]
 });]]></description><name>itemCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An itemId can be used as an alternative way to get a reference to a component when no object reference is available.
 Instead of using an id with Ext.getCmp, use itemId with Ext.Container.getComponent which will retrieve itemId's or id's.
 Since itemId's are an index to the container's internal MixedCollection, the itemId is scoped locally to the container
 -- avoiding potential conflicts with Ext.ComponentMgr which requires a unique id. var c = new Ext.Panel({ //
     height:
 300,
     renderTo: document.body,
     layout: 'auto',
     items: [
         {
             itemId: 'p1',
            
 title: 'Panel 1',
             height: 150
         },
         {
             itemId: 'p2',
             title: 'Panel 2',
  
 height: 150
         }
     ]
 })
 p1 = c.getComponent('p1'); // not the same as Ext.getCmp()
 p2 =
 p1.ownerCt.getComponent('p2'); // reference via a sibling Also see id and ref. Note: to access the container of an item
 see ownerCt.]]></description><name>itemId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The separator to display after the text of each fieldLabel. This property may be configured at various levels. The order
 of precedence is: field / component level container level layout level (defaults to colon ':') To display no separator
 for this field's label specify empty string ''. Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 layoutConfig: {
         labelSeparator: '~'   // layout config has lowest priority (defaults to ':')
     },
    
 labelSeparator: '>>',     // config at container level
     items: [{
         xtype: 'textfield',
         fieldLabel:
 'Field 1',
         labelSeparator: '...' // field/component level config supersedes others
     },{
         xtype:
 'textfield',
         fieldLabel: 'Field 2' // labelSeparator will be '='
     }]
 });]]></description><name>labelSeparator</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS style specification string to apply directly to this field's label. Defaults to the container's labelStyle value
 if set (e.g., Ext.layout.FormLayout.labelStyle , or ''). Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         labelStyle: 'font-weight:bold;'
     }]
 });]]></description><name>labelStyle</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout or one of the two BoxLayout subclasses. An object containing margins to apply to this BoxComponent in the
 format: {
     top: (top margin),
     right: (right margin),
     bottom: (bottom margin),
     left: (left margin)
 } May
 also be a string containing space-separated, numeric margin values. The order of the sides associated with each value
 matches the way CSS processes margin values: If there is only one value, it applies to all sides. If there are two
 values, the top and bottom borders are set to the first value and the right and left are set to the second. If there are
 three values, the top is set to the first value, the left and right are set to the second, and the bottom is set to the
 third. If there are four values, they apply to the top, right, bottom, and left, respectively. Defaults to: {top:0,
 right:0, bottom:0, left:0}]]></description><name>margins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An input mask regular expression that will be used to filter keystrokes that do not match (defaults to null). The maskRe
 will not operate on any paste events.]]></description><name>maskRe</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Maximum input field length allowed by validation (defaults to Number.MAX_VALUE). This behavior is intended to provide
 instant feedback to the user by improving usability to allow pasting and editing or overtyping and back tracking. To
 restrict the maximum number of characters that can be entered into the field use autoCreate to add any attributes you
 want to a field, for example: var myField = new Ext.form.NumberField({
     id: 'mobile',
     anchor:'90%',
    
 fieldLabel: 'Mobile',
     maxLength: 16, // for validation
     autoCreate: {tag: 'input', type: 'text', size: '20',
 autocomplete: 'off', maxlength: '10'}
 });]]></description><name>maxLength</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Error text to display if the maximum length validation fails (defaults to 'The maximum length for this field is
 {maxLength}')]]></description><name>maxLengthText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The error text to display when the date in the cell is after maxValue (defaults to 'The date in this field must be
 before {maxValue}').]]></description><name>maxText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum allowed date. Can be either a Javascript date object or a string date in a valid format (defaults to null).]]></description><name>maxValue</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Minimum input field length required (defaults to 0)]]></description><name>minLength</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Error text to display if the minimum length validation fails (defaults to 'The minimum length for this field is
 {minLength}')]]></description><name>minLengthText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The error text to display when the date in the cell is before minValue (defaults to 'The date in this field must be
 after {minValue}').]]></description><name>minText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum allowed date. Can be either a Javascript date object or a string date in a valid format (defaults to null).]]></description><name>minValue</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Experimental The effect used when displaying a validation message under the field (defaults to 'normal').]]></description><name>msgFx</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The location where the message text set through markInvalid should display. Must be one of the following values: qtip
 Display a quick tip containing the message when the user hovers over the field. This is the default. Ext.QuickTips.init
 must have been called for this setting to work. title Display the message in a default browser title attribute popup.
 under Add a block div beneath the field containing the error message. side Add an error icon to the right of the field,
 displaying the message in a popup on hover. [element id] Add the error message directly to the innerHTML of the
 specified element.]]></description><name>msgTarget</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element when the mouse moves over the Element, and
 removed when the mouse moves out. (defaults to ''). This can be useful for adding customized 'active' or 'hover' styles
 to the component or any of its children using standard CSS rules.]]></description><name>overCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level x coordinate for this component if contained within a positioning container.]]></description><name>pageX</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level y coordinate for this component if contained within a positioning container.]]></description><name>pageY</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to disable marking the field invalid. Defaults to false.]]></description><name>preventMark</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered ptype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a Plugin is being specified not as a fully
 instantiated Component, but as a Component config object. The ptype will be looked up at render time up to determine
 what type of Plugin to create. If you create your own Plugins, you may register them using
 Ext.ComponentMgr.registerPlugin in order to be able to take advantage of lazy instantiation and rendering.]]></description><name>ptype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to prevent the user from changing the field, and hides the trigger. Superceeds the editable and hideTrigger options
 if the value is true. (defaults to false)]]></description><name>readOnly</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A path specification, relative to the Component's ownerCt specifying into which ancestor Container to place a named
 reference to this Component. The ancestor axis can be traversed by using '/' characters in the path. For example, to put
 a reference to a Toolbar Button into the Panel which owns the Toolbar: var myGrid = new Ext.grid.EditorGridPanel({
    
 title: 'My EditorGridPanel',
     store: myStore,
     colModel: myColModel,
     tbar: [{
         text: 'Save',
        
 handler: saveChanges,
         disabled: true,
         ref: '../saveButton'
     }],
     listeners: {
         afteredit:
 function() {
 //          The button reference is in the GridPanel
             myGrid.saveButton.enable();
         }
    
 }
 }); In the code above, if the ref had been 'saveButton' the reference would have been placed into the Toolbar. Each
 '/' in the ref moves up one level from the Component's ownerCt. Also see the added and removed events.]]></description><name>ref</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A JavaScript RegExp object to be tested against the field value during validation (defaults to null). If the test fails,
 the field will be marked invalid using regexText.]]></description><name>regex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The error text to display if regex is used and the test fails during validation (defaults to '')]]></description><name>regexText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout layout manager (e.g. specifying layout:'border'). See Ext.layout.BorderLayout also.]]></description><name>region</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to automatically select any existing field text when the field receives input focus (defaults to false)]]></description><name>selectOnFocus</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[false to hide the footer area of the DatePicker containing the Today button and disable the keyboard handler for
 spacebar that selects the current date (defaults to true).]]></description><name>showToday</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Day index at which the week should begin, 0-based (defaults to 0, which is Sunday)]]></description><name>startDay</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should trigger this component to save its state (defaults to none). stateEvents may
 be any type of event supported by this component, including browser or custom events (e.g., ['click',
 'customerchange']). See stateful for an explanation of saving and restoring Component state.]]></description><name>stateEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id for this component to use for state management purposes (defaults to the component id if one was set,
 otherwise null if the component is using a generated id). See stateful for an explanation of saving and restoring
 Component state.]]></description><name>stateId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A flag which causes the Component to attempt to restore the state of internal properties from a saved state on startup.
 The component must have either a stateId or id assigned for state to be managed. Auto-generated ids are not guaranteed
 to be stable across page loads and cannot be relied upon to save and restore the same state for a component. For state
 saving to work, the state manager's provider must have been set to an implementation of Ext.state.Provider which
 overrides the set and get methods to save and recall name/value pairs. A built-in implementation,
 Ext.state.CookieProvider is available. To set the state provider for the current page: Ext.state.Manager.setProvider(new
 Ext.state.CookieProvider({
     expires: new Date(new Date().getTime()+(1000*60*60*24*7)), //7 days from now
 })); A
 stateful Component attempts to save state when one of the events listed in the stateEvents configuration fires. To save
 state, a stateful Component first serializes its state by calling getState. By default, this function does nothing. The
 developer must provide an implementation which returns an object hash which represents the Component's restorable state.
 The value yielded by getState is passed to Ext.state.Manager.set which uses the configured Ext.state.Provider to save
 the object keyed by the Component's stateId, or, if that is not specified, its id. During construction, a stateful
 Component attempts to restore its state by calling Ext.state.Manager.get passing the stateId, or, if that is not
 specified, the id. The resulting object is passed to applyState. The default implementation of applyState simply copies
 properties into the object, but a developer may override this to support more behaviour. You can perform extra
 processing on state save and restore by attaching handlers to the beforestaterestore, staterestore, beforestatesave and
 statesave events.]]></description><name>stateful</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A JavaScript RegExp object used to strip unwanted content from the value before validation (defaults to null).]]></description><name>stripCharsRe</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
     title: 'Some Title',
     renderTo: Ext.getBody(),
     width: 400, height:
 300,
     layout: 'form',
     items: [{
         xtype: 'textarea',
         style: {
             width: '95%',
            
 marginBottom: '10px'
         }
     },
         new Ext.Button({
             text: 'Send',
             minWidth: '100',
   
          style: {
                 marginBottom: '10px'
             }
         })
     ]
 });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[False to clear the name attribute on the field so that it is not submitted during a form post. Defaults to true.]]></description><name>submitValue</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The tabIndex for this field. Note this only applies to fields that are rendered, not those which are built via applyTo
 (defaults to undefined).]]></description><name>tabIndex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is a child item of a TabPanel. A string to be used as innerHTML
 (html tags are accepted) to show in a tooltip when mousing over the associated tab selector element.
 Ext.QuickTips.init() must be called in order for the tips to render.]]></description><name>tabTip</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An additional CSS class used to style the trigger button. The trigger will always get the class 'x-form-trigger' and
 triggerClass will be appended if specified (defaults to 'x-form-date-trigger' which displays a calendar icon).]]></description><name>triggerClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A DomHelper config object specifying the structure of the trigger element for this Field. (Optional). Specify this when
 you need a customized element to act as the trigger button for a TriggerField. Note that when using this option, it is
 the developer's responsibility to ensure correct sizing, positioning and appearance of the trigger. Defaults to: {tag:
 "img", src: Ext.BLANK_IMAGE_URL, cls: "x-form-trigger " + this.triggerClass}]]></description><name>triggerConfig</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Whether the field should validate when it loses focus (defaults to true).]]></description><name>validateOnBlur</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The length of time in milliseconds after user input begins until validation is initiated (defaults to 250)]]></description><name>validationDelay</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The event that should initiate field validation. Set to false to disable automatic validation (defaults to 'keyup').]]></description><name>validationEvent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom validation function to be called during field validation (validateValue) (defaults to null). If specified, this
 function will be called first, allowing the developer to override the default validation process. This function will be
 passed the following Parameters: value: Mixed The current field value This function is to Return: true: Boolean true if
 the value is valid msg: String An error message if the value is invalid]]></description><name>validator</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A value to initialize this field with (defaults to undefined).]]></description><name>value</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A validation type name as defined in Ext.form.VTypes (defaults to null)]]></description><name>vtype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom error message to display in place of the default message provided for the vtype currently set for this field
 (defaults to ''). Note: only applies if vtype is set, else ignored.]]></description><name>vtypeText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The class added to the to the wrap of the trigger element. Defaults to x-trigger-wrap-focus.]]></description><name>wrapFocusClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local x (left) coordinate for this component if contained within a positioning container.]]></description><name>x</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered xtype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a child item of a Container is being specified not
 as a fully instantiated Component, but as a Component config object. The xtype will be looked up at render time up to
 determine what type of child Component to create. The predefined xtypes are listed here. If you subclass Components to
 create your own Components, you may register them using Ext.ComponentMgr.registerType in order to be able to take
 advantage of lazy instantiation and rendering.]]></description><name>xtype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local y (top) coordinate for this component if contained within a positioning container.]]></description><name>y</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 A display-only text field which is not validated and not submitted.]]></description><name>form.displayfield</name><tag-class>org.brushingbits.jnap.ui.extjs3.form.DisplayField</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[The field's HTML name attribute (defaults to ''). Note: this property must be set if this field is to be automatically
 included with form submit().]]></description><name>name</name><required>true</required><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Whether the component can move the Dom node when rendering (defaults to true).]]></description><name>allowDomMove</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use an
 AnchorLayout (or subclass thereof). based layout manager, for example: Ext.form.FormPanel specifying layout: 'anchor' //
 or 'form', or 'absolute' See Ext.layout.AnchorLayout.anchor also.]]></description><name>anchor</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element corresponding to a DIV that is already present in
 the document that specifies some structural markup for this component. Description : When applyTo is used, constituent
 parts of the component can also be specified by id or CSS class name within the main element, and the component being
 created may attempt to create its subcomponents from that markup if applicable. Notes : When using this config, a call
 to render() is not required. If applyTo is specified, any value passed for renderTo will be ignored and the target
 element's parent node will automatically be used as the component's container.]]></description><name>applyTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A DomHelper element spec, or true for a default element spec. Used to create the Element which will encapsulate this
 Component. See autoEl for details. Defaults to: {tag: 'input', type: 'text', size: '20', autocomplete: 'off'}]]></description><name>autoCreate</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A tag name or DomHelper spec used to create the Element which will encapsulate this Component. You do not normally need
 to specify this. For the base classes Ext.Component, Ext.BoxComponent, and Ext.Container, this defaults to 'div'. The
 more complex Ext classes use a more complex DOM structure created by their own onRender methods. This is intended to
 allow the developer to create application-specific utility Components encapsulated by different DOM elements. Example
 usage: <pre><code>{
     xtype: 'box',
     autoEl: {
         tag: 'img',
         src: 'http://www.example.com/example.jpg'
     }
 },
 {
     xtype: 'box',
     autoEl: {
         tag: 'blockquote',
         html: 'autoEl is cool!'
     }
 }, {
     xtype: 'container',
     autoEl: 'ul',
     cls: 'ux-unordered-list',
     items: {
         xtype: 'box',
         autoEl: 'li',
   
      html: 'First list item'
     }
 }</pre></code>]]></description><name>autoEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to use height:'auto', false to use fixed height (or allow it to be managed by its parent Container's layout
 manager. Defaults to false. Note: Although many components inherit this config option, not all will function as expected
 with a height of 'auto'. Setting autoHeight:true means that the browser will manage height based on the element's
 contents, and that Ext will not manage it at all. If the browser is managing the height, be aware that resizes performed
 by the browser in response to changes within the structure of the Component cannot be detected. Therefore changes to the
 height might result in elements needing to be synchronized with the new height. Example: var w = new Ext.Window({
    
 title: 'Window',
     width: 600,
     autoHeight: true,
     items: {
         title: 'Collapse Me',
         height: 400,
  
 collapsible: true,
         border: false,
         listeners: {
             beforecollapse: function() {
                w.el.shadow.hide();
             },
             beforeexpand: function() {
                w.el.shadow.hide();
             },
             collapse: function() {
                w.syncShadow();
             },
             expand: function() {
                w.syncShadow();
             }
         }
     }
 }).show();]]></description><name>autoHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to use overflow:'auto' on the components layout element and show scroll bars automatically when necessary, false to
 clip any overflowing content (defaults to false).]]></description><name>autoScroll</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True if the component should check for hidden classes (e.g. 'x-hidden' or 'x-hide-display') and remove them on render
 (defaults to false).]]></description><name>autoShow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to use width:'auto', false to use fixed width (or allow it to be managed by its parent Container's layout manager.
 Defaults to false. Note: Although many components inherit this config option, not all will function as expected with a
 width of 'auto'. Setting autoWidth:true means that the browser will manage width based on the element's contents, and
 that Ext will not manage it at all. If the browser is managing the width, be aware that resizes performed by the browser
 in response to changes within the structure of the Component cannot be detected. Therefore changes to the width might
 result in elements needing to be synchronized with the new width. For example, where the target element is: <div
 id='grid-container' style='margin-left:25%;width:50%'></div> A Panel rendered into that target element must listen for
 browser window resize in order to relay its child items when the browser changes its width: var myPanel = new
 Ext.Panel({
     renderTo: 'grid-container',
     monitorResize: true, // relay on browser resize
     title: 'Panel',
    
 height: 400,
     autoWidth: true,
     layout: 'hbox',
     layoutConfig: {
         align: 'stretch'
     },
     defaults: {
         flex: 1
     },
     items: [{
         title: 'Box 1',
     }, {
         title: 'Box 2'
     }, {
         title:
 'Box 3'
     }],
 });]]></description><name>autoWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to [].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class used to to apply to the special clearing div rendered directly after each form field wrapper to provide
 field clearing (defaults to 'x-form-clear-left'). Note: this config is only used when this Component is rendered by a
 Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or specifying
 layout:'form') and either a fieldLabel is specified or isFormField=true is specified. See Ext.layout.FormLayout.fieldTpl
 also.]]></description><name>clearCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom CSS class to apply to the field's underlying element (defaults to '').]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's container. This can be useful for adding customized
 styles to the container or any of its children using standard CSS rules. See Ext.layout.ContainerLayout.extraCls also.
 Note: ctCls defaults to '' except for the following class which assigns a value by default: Box Layout :
 'x-box-layout-ct' To configure the above Class with an extra CSS class append to the default. For example, for BoxLayout
 (Hbox and Vbox): ctCls: 'x-box-layout-ct custom-class']]></description><name>ctCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to disable the field (defaults to false). Be aware that conformant with the HTML specification, disabled Fields
 will not be submitted.]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class added to the component when it is disabled (defaults to 'x-item-disabled').]]></description><name>disabledClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default CSS class for the field (defaults to "x-form-display-field")]]></description><name>fieldClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The label text to display next to this Component (defaults to ''). Note: this config is only used when this Component is
 rendered by a Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or
 specifying layout:'form'). Also see hideLabel and Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
    
 height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name'
    
 }]
 });]]></description><name>fieldLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use a
 BoxLayout. Each child Component with a flex property will be flexed either vertically (by a VBoxLayout) or horizontally
 (by an HBoxLayout) according to the item's relative flex value compared to the sum of all Components with flex value
 specified. Any child items that have either a flex = 0 or flex = undefined will not be 'flexed' (the initial size will
 not be changed).]]></description><name>flex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class to use when the field receives focus (defaults to 'x-form-focus')]]></description><name>focusClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component hidden (default is false). If true, the hide method will be called internally.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to completely hide the label element (label and separator). Defaults to false. By default, even if you do not
 specify a fieldLabel the space will still be reserved so that the field will line up with other fields that do have
 labels. Setting this to true will cause the field to not reserve that space. Note: see the note for clearCls. Example
 use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield'
        
 hideLabel: true
     }]
 });]]></description><name>hideLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[How this component should be hidden. Supported values are 'visibility' (css visibility), 'offsets' (negative offset
 position) and 'display' (css display). Note: the default of 'display' is generally preferred since items are
 automatically laid out when they are first shown (no sizing is done while hidden).]]></description><name>hideMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide and show the component's container when hide/show is called on the component, false to hide and show the
 component itself (defaults to false). For example, this can be used as a shortcut for a hide button on a window by
 setting hide:true on the button when adding it to its parent container.]]></description><name>hideParent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[false to skip HTML-encoding the text when rendering it (defaults to false). This might be useful if you want to include
 tags in the field's innerHTML rather than rendering them as string literals per the default logic.]]></description><name>htmlEncode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id of this component (defaults to an auto-assigned id). You should assign an id if you need to be able to
 access the component later and you do not have an object reference available (e.g., using Ext.getCmp). Note that this id
 will also be used as the element id for the containing HTML element that is rendered to the page for this component.
 This allows you to write id-based CSS rules to style the specific instance of this component uniquely, and also to
 select sub-elements using this component's id as the parent. Note: to avoid complications imposed by a unique id also
 see itemId and ref. Note: to access the container of an item see ownerCt.]]></description><name>id</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The type attribute for input fields -- e.g. radio, text, password, file (defaults to 'text'). The types 'file' and
 'password' must be used to render those field types currently -- there are no separate Ext components for those. Note
 that if you use inputType:'file', emptyText is not supported and should be avoided.]]></description><name>inputType</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class to use when marking a field invalid (defaults to 'x-form-invalid')]]></description><name>invalidClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The error text to use when marking a field invalid and no message is provided (defaults to 'The value in this field is
 invalid')]]></description><name>invalidText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use the
 FormLayout layout manager (e.g. Ext.form.FormPanel or specifying layout:'form'). An additional CSS class to apply to the
 div wrapping the form item element of this field. If supplied, itemCls at the field level will override the default
 itemCls supplied at the container level. The value specified for itemCls will be added to the default class
 ('x-form-item'). Since it is applied to the item wrapper (see Ext.layout.FormLayout.fieldTpl), it allows you to write
 standard CSS rules that can apply to the field, the label (if specified), or any other element within the markup for the
 field. Note: see the note for fieldLabel. Example use: // Apply a style to the field's label:
 <style>
     .required
 .x-form-item-label {font-weight:bold;color:red;}
 </style>
 
 new Ext.FormPanel({
     height: 100,
     renderTo:
 Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         itemCls: 'required' //this
 label will be styled
     },{
         xtype: 'textfield',
         fieldLabel: 'Favorite Color'
     }]
 });]]></description><name>itemCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An itemId can be used as an alternative way to get a reference to a component when no object reference is available.
 Instead of using an id with Ext.getCmp, use itemId with Ext.Container.getComponent which will retrieve itemId's or id's.
 Since itemId's are an index to the container's internal MixedCollection, the itemId is scoped locally to the container
 -- avoiding potential conflicts with Ext.ComponentMgr which requires a unique id. var c = new Ext.Panel({ //
     height:
 300,
     renderTo: document.body,
     layout: 'auto',
     items: [
         {
             itemId: 'p1',
            
 title: 'Panel 1',
             height: 150
         },
         {
             itemId: 'p2',
             title: 'Panel 2',
  
 height: 150
         }
     ]
 })
 p1 = c.getComponent('p1'); // not the same as Ext.getCmp()
 p2 =
 p1.ownerCt.getComponent('p2'); // reference via a sibling Also see id and ref. Note: to access the container of an item
 see ownerCt.]]></description><name>itemId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The separator to display after the text of each fieldLabel. This property may be configured at various levels. The order
 of precedence is: field / component level container level layout level (defaults to colon ':') To display no separator
 for this field's label specify empty string ''. Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 layoutConfig: {
         labelSeparator: '~'   // layout config has lowest priority (defaults to ':')
     },
    
 labelSeparator: '>>',     // config at container level
     items: [{
         xtype: 'textfield',
         fieldLabel:
 'Field 1',
         labelSeparator: '...' // field/component level config supersedes others
     },{
         xtype:
 'textfield',
         fieldLabel: 'Field 2' // labelSeparator will be '='
     }]
 });]]></description><name>labelSeparator</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS style specification string to apply directly to this field's label. Defaults to the container's labelStyle value
 if set (e.g., Ext.layout.FormLayout.labelStyle , or ''). Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         labelStyle: 'font-weight:bold;'
     }]
 });]]></description><name>labelStyle</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout or one of the two BoxLayout subclasses. An object containing margins to apply to this BoxComponent in the
 format: {
     top: (top margin),
     right: (right margin),
     bottom: (bottom margin),
     left: (left margin)
 } May
 also be a string containing space-separated, numeric margin values. The order of the sides associated with each value
 matches the way CSS processes margin values: If there is only one value, it applies to all sides. If there are two
 values, the top and bottom borders are set to the first value and the right and left are set to the second. If there are
 three values, the top is set to the first value, the left and right are set to the second, and the bottom is set to the
 third. If there are four values, they apply to the top, right, bottom, and left, respectively. Defaults to: {top:0,
 right:0, bottom:0, left:0}]]></description><name>margins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Experimental The effect used when displaying a validation message under the field (defaults to 'normal').]]></description><name>msgFx</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The location where the message text set through markInvalid should display. Must be one of the following values: qtip
 Display a quick tip containing the message when the user hovers over the field. This is the default. Ext.QuickTips.init
 must have been called for this setting to work. title Display the message in a default browser title attribute popup.
 under Add a block div beneath the field containing the error message. side Add an error icon to the right of the field,
 displaying the message in a popup on hover. [element id] Add the error message directly to the innerHTML of the
 specified element.]]></description><name>msgTarget</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element when the mouse moves over the Element, and
 removed when the mouse moves out. (defaults to ''). This can be useful for adding customized 'active' or 'hover' styles
 to the component or any of its children using standard CSS rules.]]></description><name>overCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level x coordinate for this component if contained within a positioning container.]]></description><name>pageX</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level y coordinate for this component if contained within a positioning container.]]></description><name>pageY</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to disable marking the field invalid. Defaults to false.]]></description><name>preventMark</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered ptype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a Plugin is being specified not as a fully
 instantiated Component, but as a Component config object. The ptype will be looked up at render time up to determine
 what type of Plugin to create. If you create your own Plugins, you may register them using
 Ext.ComponentMgr.registerPlugin in order to be able to take advantage of lazy instantiation and rendering.]]></description><name>ptype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to mark the field as readOnly in HTML (defaults to false). Note: this only sets the element's readOnly DOM
 attribute. Setting readOnly=true, for example, will not disable triggering a ComboBox or DateField; it gives you the
 option of forcing the user to choose via the trigger without typing in the text box. To hide the trigger use
 hideTrigger.]]></description><name>readOnly</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A path specification, relative to the Component's ownerCt specifying into which ancestor Container to place a named
 reference to this Component. The ancestor axis can be traversed by using '/' characters in the path. For example, to put
 a reference to a Toolbar Button into the Panel which owns the Toolbar: var myGrid = new Ext.grid.EditorGridPanel({
    
 title: 'My EditorGridPanel',
     store: myStore,
     colModel: myColModel,
     tbar: [{
         text: 'Save',
        
 handler: saveChanges,
         disabled: true,
         ref: '../saveButton'
     }],
     listeners: {
         afteredit:
 function() {
 //          The button reference is in the GridPanel
             myGrid.saveButton.enable();
         }
    
 }
 }); In the code above, if the ref had been 'saveButton' the reference would have been placed into the Toolbar. Each
 '/' in the ref moves up one level from the Component's ownerCt. Also see the added and removed events.]]></description><name>ref</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout layout manager (e.g. specifying layout:'border'). See Ext.layout.BorderLayout also.]]></description><name>region</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should trigger this component to save its state (defaults to none). stateEvents may
 be any type of event supported by this component, including browser or custom events (e.g., ['click',
 'customerchange']). See stateful for an explanation of saving and restoring Component state.]]></description><name>stateEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id for this component to use for state management purposes (defaults to the component id if one was set,
 otherwise null if the component is using a generated id). See stateful for an explanation of saving and restoring
 Component state.]]></description><name>stateId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A flag which causes the Component to attempt to restore the state of internal properties from a saved state on startup.
 The component must have either a stateId or id assigned for state to be managed. Auto-generated ids are not guaranteed
 to be stable across page loads and cannot be relied upon to save and restore the same state for a component. For state
 saving to work, the state manager's provider must have been set to an implementation of Ext.state.Provider which
 overrides the set and get methods to save and recall name/value pairs. A built-in implementation,
 Ext.state.CookieProvider is available. To set the state provider for the current page: Ext.state.Manager.setProvider(new
 Ext.state.CookieProvider({
     expires: new Date(new Date().getTime()+(1000*60*60*24*7)), //7 days from now
 })); A
 stateful Component attempts to save state when one of the events listed in the stateEvents configuration fires. To save
 state, a stateful Component first serializes its state by calling getState. By default, this function does nothing. The
 developer must provide an implementation which returns an object hash which represents the Component's restorable state.
 The value yielded by getState is passed to Ext.state.Manager.set which uses the configured Ext.state.Provider to save
 the object keyed by the Component's stateId, or, if that is not specified, its id. During construction, a stateful
 Component attempts to restore its state by calling Ext.state.Manager.get passing the stateId, or, if that is not
 specified, the id. The resulting object is passed to applyState. The default implementation of applyState simply copies
 properties into the object, but a developer may override this to support more behaviour. You can perform extra
 processing on state save and restore by attaching handlers to the beforestaterestore, staterestore, beforestatesave and
 statesave events.]]></description><name>stateful</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
     title: 'Some Title',
     renderTo: Ext.getBody(),
     width: 400, height:
 300,
     layout: 'form',
     items: [{
         xtype: 'textarea',
         style: {
             width: '95%',
            
 marginBottom: '10px'
         }
     },
         new Ext.Button({
             text: 'Send',
             minWidth: '100',
   
          style: {
                 marginBottom: '10px'
             }
         })
     ]
 });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[False to clear the name attribute on the field so that it is not submitted during a form post. Defaults to true.]]></description><name>submitValue</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The tabIndex for this field. Note this only applies to fields that are rendered, not those which are built via applyTo
 (defaults to undefined).]]></description><name>tabIndex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is a child item of a TabPanel. A string to be used as innerHTML
 (html tags are accepted) to show in a tooltip when mousing over the associated tab selector element.
 Ext.QuickTips.init() must be called in order for the tips to render.]]></description><name>tabTip</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Whether the field should validate when it loses focus (defaults to true).]]></description><name>validateOnBlur</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The length of time in milliseconds after user input begins until validation is initiated (defaults to 250)]]></description><name>validationDelay</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The event that should initiate field validation. Set to false to disable automatic validation (defaults to 'keyup').]]></description><name>validationEvent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A value to initialize this field with (defaults to undefined).]]></description><name>value</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local x (left) coordinate for this component if contained within a positioning container.]]></description><name>x</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered xtype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a child item of a Container is being specified not
 as a fully instantiated Component, but as a Component config object. The xtype will be looked up at render time up to
 determine what type of child Component to create. The predefined xtypes are listed here. If you subclass Components to
 create your own Components, you may register them using Ext.ComponentMgr.registerType in order to be able to take
 advantage of lazy instantiation and rendering.]]></description><name>xtype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local y (top) coordinate for this component if contained within a positioning container.]]></description><name>y</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 Standard container used for grouping items within a 
 <a href="output/Ext.form.FormPanel.html"
 ext:cls="Ext.form.FormPanel">form</a>. 
 <pre><code><b>var</b> form = <b>new</b> Ext.FormPanel({
     title: <em>'Simple
 Form <b>with</b> FieldSets'</em>,
     labelWidth: 75, <i>// <b>label</b> settings here cascade unless overridden</i>
    
 url: <em>'save-form.php'</em>,
     frame:true,
     bodyStyle:<em>'padding:5px 5px 0'</em>,
     width: 700,
     renderTo:
 document.body,
     layout:<em>'column'</em>, <i>// arrange items <b>in</b> columns</i>
     defaults: {      <i>//
 defaults applied to items</i>
         layout: <em>'form'</em>,
         border: false,
         bodyStyle:
 <em>'padding:4px'</em>
     },
     items: [{
         <i>// Fieldset <b>in</b> Column 1</i>
        
 xtype:<em>'fieldset'</em>,
         columnWidth: 0.5,
         title: <em>'Fieldset 1'</em>,
         collapsible: true,
   
 autoHeight:true,
         defaults: {
             anchor: <em>'-20'</em> <i>// leave room <b>for</b> error icon</i>
      
 },
         defaultType: <em>'textfield'</em>,
         items :[{
                 fieldLabel: <em>'Field 1'</em>
          
 }, {
                 fieldLabel: <em>'Field 2'</em>
             }, {
                 fieldLabel: <em>'Field 3'</em>
     
 }
         ]
     },{
         <i>// Fieldset <b>in</b> Column 2 - Panel inside</i>
         xtype:<em>'fieldset'</em>,
     
 title: <em>'Show Panel'</em>, <i>// title, header, or checkboxToggle creates fieldset header</i>
        
 autoHeight:true,
         columnWidth: 0.5,
         checkboxToggle: true,
         collapsed: true, <i>// fieldset
 initially collapsed</i>
         layout:<em>'anchor'</em>,
         items :[{
             xtype: <em>'panel'</em>,
        
 anchor: <em>'100%'</em>,
             title: <em>'Panel inside a fieldset'</em>,
             frame: true,
            
 height: 100
         }]
     }]
 });</code></pre>]]></description><name>form.fieldSet</name><tag-class>org.brushingbits.jnap.ui.extjs3.form.FieldSet</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[A string component id or the numeric index of the component that should be initially activated within the container's
 layout on render. For example, activeItem: 'item-1' or activeItem: 0 (index 0 = the first item in the container's
 collection). activeItem only applies to layout styles that can display items one at a time (like
 Ext.layout.AccordionLayout, Ext.layout.CardLayout and Ext.layout.FitLayout). Related to
 Ext.layout.ContainerLayout.activeItem.]]></description><name>activeItem</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Whether the component can move the Dom node when rendering (defaults to true).]]></description><name>allowDomMove</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use an
 AnchorLayout (or subclass thereof). based layout manager, for example: Ext.form.FormPanel specifying layout: 'anchor' //
 or 'form', or 'absolute' See Ext.layout.AnchorLayout.anchor also.]]></description><name>anchor</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to animate the transition when the panel is collapsed, false to skip the animation (defaults to false).]]></description><name>animCollapse</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The id of the node, a DOM node or an existing Element corresponding to a DIV that is already present in the document
 that specifies some panel-specific structural markup. When applyTo is used, constituent parts of the panel can be
 specified by CSS class name within the main element, and the panel will automatically create those components from that
 markup. Any required components not specified in the markup will be autogenerated if necessary. The following class
 names are supported (baseCls will be replaced by baseCls): baseCls + '-header' baseCls + '-header-text' baseCls +
 '-bwrap' baseCls + '-tbar' baseCls + '-body' baseCls + '-bbar' baseCls + '-footer' Using this config, a call to render()
 is not required. If applyTo is specified, any value passed for renderTo will be ignored and the target element's parent
 node will automatically be used as the panel's container.]]></description><name>applyTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If true the container will automatically destroy any contained component that is removed from it, else destruction must
 be handled manually (defaults to true).]]></description><name>autoDestroy</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A tag name or DomHelper spec used to create the Element which will encapsulate this Component. You do not normally need
 to specify this. For the base classes Ext.Component, Ext.BoxComponent, and Ext.Container, this defaults to 'div'. The
 more complex Ext classes use a more complex DOM structure created by their own onRender methods. This is intended to
 allow the developer to create application-specific utility Components encapsulated by different DOM elements. Example
 usage: <pre><code>{
     xtype: 'box',
     autoEl: {
         tag: 'img',
         src: 'http://www.example.com/example.jpg'
     }
 },
 {
     xtype: 'box',
     autoEl: {
         tag: 'blockquote',
         html: 'autoEl is cool!'
     }
 }, {
     xtype: 'container',
     autoEl: 'ul',
     cls: 'ux-unordered-list',
     items: {
         xtype: 'box',
         autoEl: 'li',
   
      html: 'First list item'
     }
 }</pre></code>]]></description><name>autoEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to use height:'auto', false to use fixed height (defaults to false). Note: Setting autoHeight: true means that the
 browser will manage the panel's height based on its contents, and that Ext will not manage it at all. If the panel is
 within a layout that manages dimensions (fit, border, etc.) then setting autoHeight: true can cause issues with
 scrolling and will not generally work as expected since the panel will take on the height of its contents rather than
 the height required by the Ext layout.]]></description><name>autoHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A valid url spec according to the Updater Ext.Updater.update method. If autoLoad is not null, the panel will attempt to
 load its contents immediately upon render. The URL will become the default URL for this panel's body element, so it may
 be refreshed at any time.]]></description><name>autoLoad</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to use overflow:'auto' on the components layout element and show scroll bars automatically when necessary, false to
 clip any overflowing content (defaults to false).]]></description><name>autoScroll</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True if the component should check for hidden classes (e.g. 'x-hidden' or 'x-hide-display') and remove them on render
 (defaults to false).]]></description><name>autoShow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to use width:'auto', false to use fixed width (or allow it to be managed by its parent Container's layout manager.
 Defaults to false. Note: Although many components inherit this config option, not all will function as expected with a
 width of 'auto'. Setting autoWidth:true means that the browser will manage width based on the element's contents, and
 that Ext will not manage it at all. If the browser is managing the width, be aware that resizes performed by the browser
 in response to changes within the structure of the Component cannot be detected. Therefore changes to the width might
 result in elements needing to be synchronized with the new width. For example, where the target element is: <div
 id='grid-container' style='margin-left:25%;width:50%'></div> A Panel rendered into that target element must listen for
 browser window resize in order to relay its child items when the browser changes its width: var myPanel = new
 Ext.Panel({
     renderTo: 'grid-container',
     monitorResize: true, // relay on browser resize
     title: 'Panel',
    
 height: 400,
     autoWidth: true,
     layout: 'hbox',
     layoutConfig: {
         align: 'stretch'
     },
     defaults: {
         flex: 1
     },
     items: [{
         title: 'Box 1',
     }, {
         title: 'Box 2'
     }, {
         title:
 'Box 3'
     }],
 });]]></description><name>autoWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The base CSS class applied to the fieldset (defaults to 'x-fieldset').]]></description><name>baseCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to display an interior border on the body element of the panel, false to hide it (defaults to true). This only
 applies when border == true. If border == true and bodyBorder == false, the border will display as a 1px wide inset
 border, giving the entire body element an inset appearance.]]></description><name>bodyBorder</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A DomHelper element specification object may be specified for any Panel Element. By default, the Default element in the
 table below will be used for the html markup to create a child element with the commensurate Default class name (baseCls
 will be replaced by baseCls): 
 Panel      Default  Default             Custom      Additional       Additional
 Element  
 element  class               element     class            style
 ========   ==========================   =========  
 ==============   ===========
 header     div      baseCls+'-header'   headerCfg   headerCssClass   headerStyle
 bwrap     
 div      baseCls+'-bwrap'     bwrapCfg    bwrapCssClass    bwrapStyle
 + tbar     div      baseCls+'-tbar'       tbarCfg 
 tbarCssClass     tbarStyle
 + body     div      baseCls+'-body'       bodyCfg     bodyCssClass     bodyStyle
 + bbar    
 div      baseCls+'-bbar'       bbarCfg     bbarCssClass     bbarStyle
 + footer   div      baseCls+'-footer'   footerCfg 
 footerCssClass   footerStyle
  Configuring a Custom element may be used, for example, to force the body Element to use a
 different form of markup than is created by default. An example of this might be to create a child Panel containing a
 custom content, such as a header, or forcing centering of all Panel content by having the body be a <center> element:
 new Ext.Panel({
     title: 'Message Title',
     renderTo: Ext.getBody(),
     width: 200, height: 130,
     bodyCfg: {
    
 tag: 'center',
         cls: 'x-panel-body',  // Default class not applied if Custom element specified
         html:
 'Message'
     },
     footerCfg: {
         tag: 'h2',
         cls: 'x-panel-footer',        // same as the Default class
 
 html: 'footer html'
     },
     footerCssClass: 'custom-footer', // additional css class, see addClass
     footerStyle:  
 'background-color:red' // see bodyStyle
 }); The example above also explicitly creates a footer with custom markup and
 styling applied.]]></description><name>bodyCfg</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Additional css class selector to be applied to the body element in the format expected by Ext.Element.addClass (defaults
 to null). See bodyCfg.]]></description><name>bodyCssClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Custom CSS styles to be applied to the body element in the format expected by Ext.Element.applyStyles (defaults to
 null). See bodyCfg.]]></description><name>bodyStyle</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to display the borders of the panel's body element, false to hide them (defaults to true). By default, the border
 is a 2px wide inset border, but this can be further altered by setting bodyBorder to false.]]></description><name>border</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to ['add', 'remove'].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[When set to true (50 milliseconds) or a number of milliseconds, the layout assigned for this container will buffer the
 frequency it calculates and does a re-layout of components. This is useful for heavy containers or containers with a
 large quantity of sub-components for which frequent layout calls would be expensive. Defaults to 50.]]></description><name>bufferResize</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The alignment of any buttons added to this panel. Valid values are 'right', 'left' and 'center' (defaults to 'right').]]></description><name>buttonAlign</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A DomHelper element specification object specifying the element structure of this Panel's bwrap Element. See bodyCfg
 also.]]></description><name>bwrapCfg</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The name to assign to the fieldset's checkbox if checkboxToggle = true (defaults to '[checkbox id]-checkbox').]]></description><name>checkboxName</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to render a checkbox into the fieldset frame just in front of the legend to expand/collapse the fieldset when the
 checkbox is toggled. (defaults to false). A DomHelper element spec may also be specified to create the checkbox. If true
 is specified, the default DomHelper config object used to create the element is: {tag: 'input', type: 'checkbox', name:
 this.checkboxName || this.id+'-checkbox'}]]></description><name>checkboxToggle</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class used to to apply to the special clearing div rendered directly after each form field wrapper to provide
 field clearing (defaults to 'x-form-clear-left'). Note: this config is only used when this Component is rendered by a
 Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or specifying
 layout:'form') and either a fieldLabel is specified or isFormField=true is specified. See Ext.layout.FormLayout.fieldTpl
 also.]]></description><name>clearCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Panels themselves do not directly support being closed, but some Panel subclasses do (like Ext.Window) or a Panel Class
 within an Ext.TabPanel. Specify true to enable closing in such situations. Defaults to false.]]></description><name>closable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element (defaults to ''). This can be useful for
 adding customized styles to the component or any of its children using standard CSS rules.]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to make sure the collapse/expand toggle button always renders first (to the left of) any other tools in the panel's
 title bar, false to render it last (defaults to true).]]></description><name>collapseFirst</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to render the panel collapsed, false to render it expanded (defaults to false).]]></description><name>collapsed</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS class to add to the panel's element after it has been collapsed (defaults to 'x-panel-collapsed').]]></description><name>collapsedCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to make the fieldset collapsible and have the expand/collapse toggle button automatically rendered into the legend
 element, false to keep the fieldset statically sized with no collapse button (defaults to false). Another option is to
 configure checkboxToggle.]]></description><name>collapsible</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's container. This can be useful for adding customized
 styles to the container or any of its children using standard CSS rules. See Ext.layout.ContainerLayout.extraCls also.
 Note: ctCls defaults to '' except for the following class which assigns a value by default: Box Layout :
 'x-box-layout-ct' To configure the above Class with an extra CSS class append to the default. For example, for BoxLayout
 (Hbox and Vbox): ctCls: 'x-box-layout-ct custom-class']]></description><name>ctCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default xtype of child Components to create in this Container when a child item is specified as a raw configuration
 object, rather than as an instantiated Component. Defaults to 'panel', except Ext.menu.Menu which defaults to
 'menuitem', and Ext.Toolbar and Ext.ButtonGroup which default to 'button'.]]></description><name>defaultType</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[This option is a means of applying default settings to all added items whether added through the items config or via the
 add or insert methods. If an added item is a config object, and not an instantiated Component, then the default
 properties are unconditionally applied. If the added item is an instantiated Component, then the default properties are
 applied conditionally so as not to override existing properties in the item. If the defaults option is specified as a
 function, then the function will be called using this Container as the scope (this reference) and passing the added item
 as the first parameter. Any resulting object from that call is then applied to the item as default properties. For
 example, to automatically apply padding to the body of each of a set of contained Ext.Panel items, you could pass:
 defaults: {bodyStyle:'padding:15px'}. Usage: defaults: {               // defaults are applied to items, not the
 container
     autoScroll:true
 },
 items: [
     {
         xtype: 'panel',   // defaults do not have precedence over
       
 id: 'panel1',     // options in config objects, so the defaults
         autoScroll: false // will not be applied here,
 panel1 will be autoScroll:false
     },
     new Ext.Panel({       // defaults do have precedence over options
         id:
 'panel2',     // options in components, so the defaults
         autoScroll: false // will be applied here, panel2 will
 be autoScroll:true.
     })
 ]]]></description><name>defaults</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this panel disabled (default is false). An important note when using the disabled config on panels is that IE
 will often fail to initialize the disabled mask element correectly if the panel's layout has not yet completed by the
 time the Panel is disabled during the render process. If you experience this issue, you may need to instead use the
 afterlayout event to initialize the disabled state: new Ext.Panel({
     ...
     listeners: {
         'afterlayout': {
   
 fn: function(p){
                 p.disable();
             },
             single: true // important, as many layouts can
 occur
         }
     }
 });]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class added to the component when it is disabled (defaults to 'x-item-disabled').]]></description><name>disabledClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to enable dragging of this Panel (defaults to false). For custom drag/drop implementations, an Ext.Panel.DD config
 could also be passed in this config instead of true. Ext.Panel.DD is an internal, undocumented class which moves a proxy
 Element around in place of the Panel's element, but provides no other behaviour during dragging or on drop. It is a
 subclass of Ext.dd.DragSource, so behaviour may be added by implementing the interface methods of Ext.dd.DragDrop e.g.:
 new Ext.Panel({
     title: 'Drag me',
     x: 100,
     y: 100,
     renderTo: Ext.getBody(),
     floating: true,
    
 frame: true,
     width: 400,
     height: 200,
     draggable: {
 //      Config option of Ext.Panel.DD class.
 //      It's
 a floating Panel, so do not show a placeholder proxy in the original position.
         insertProxy: false,
 
 //     
 Called for each mousemove event while dragging the DD object.
         onDrag : function(e){
 //          Record the x,y
 position of the drag proxy so that we can
 //          position the Panel at end of drag.
             var pel =
 this.proxy.getEl();
             this.x = pel.getLeft(true);
             this.y = pel.getTop(true);
 
 //          Keep the
 Shadow aligned if there is one.
             var s = this.panel.getEl().shadow;
             if (s) {
                
 s.realign(this.x, this.y, pel.getWidth(), pel.getHeight());
             }
         },
 
 //      Called on the mouseup
 event.
         endDrag : function(e){
             this.panel.setPosition(this.x, this.y);
         }
     }
 }).show();]]></description><name>draggable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A comma-delimited list of panel elements to initialize when the panel is rendered. Normally, this list will be generated
 automatically based on the items added to the panel at config time, but sometimes it might be useful to make sure a
 structural element is rendered even if not specified at config time (for example, you may want to add a button or
 toolbar dynamically after the panel has been rendered). Adding those elements to this list will allocate the required
 placeholders in the panel when it is rendered. Valid values are header tbar (top bar) body bbar (bottom bar) footer
 Defaults to 'body'.]]></description><name>elements</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A Toolbar object, a Toolbar config, or an array of Buttons/Button configs, describing a Toolbar to be rendered into this
 Panel's footer element. After render, the fbar property will be an Toolbar instance. If buttons are specified, they will
 supersede the fbar configuration property. The Panel's buttonAlign configuration affects the layout of these items, for
 example: var w = new Ext.Window({
     height: 250,
     width: 500,
     bbar: new Ext.Toolbar({
         items: [{
        
 text: 'bbar Left'
         },'->',{
             text: 'bbar Right'
         }]
     }),
     buttonAlign: 'left', //
 anything but 'center' or 'right' and you can use '-', and '->'
                                   // to control the
 alignment of fbar items
     fbar: [{
         text: 'fbar Left'
     },'->',{
         text: 'fbar Right'
     }]
 }).show();
 Note: Although a Toolbar may contain Field components, these will not be updated by a load of an ancestor FormPanel. A
 Panel's toolbars are not part of the standard Container->Component hierarchy, and so are not scanned to collect form
 items. However, the values will be submitted because form submission parameters are collected from the DOM tree.]]></description><name>fbar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The label text to display next to this Component (defaults to ''). Note: this config is only used when this Component is
 rendered by a Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or
 specifying layout:'form'). Also see hideLabel and Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
    
 height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name'
    
 }]
 });]]></description><name>fieldLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use a
 BoxLayout. Each child Component with a flex property will be flexed either vertically (by a VBoxLayout) or horizontally
 (by an HBoxLayout) according to the item's relative flex value compared to the sum of all Components with flex value
 specified. Any child items that have either a flex = 0 or flex = undefined will not be 'flexed' (the initial size will
 not be changed).]]></description><name>flex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[This property is used to configure the underlying Ext.Layer. Acceptable values for this configuration property are:
 false : Default. Display the panel inline where it is rendered. true : Float the panel (absolute position it with
 automatic shimming and shadow). Setting floating to true will create an Ext.Layer for this panel and display the panel
 at negative offsets so that it is hidden. Since the panel will be absolute positioned, the position must be set
 explicitly after render (e.g., myPanel.setPosition(100,100);). Note: when floating a panel you should always assign a
 fixed width, otherwise it will be auto width and will expand to fill to the right edge of the viewport. object : The
 specified object will be used as the configuration object for the Ext.Layer that will be created.]]></description><name>floating</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to create the footer element explicitly, false to skip creating it. The footer will be created automatically if
 buttons or a fbar have been configured. See bodyCfg for an example.]]></description><name>footer</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A DomHelper element specification object specifying the element structure of this Panel's footer Element. See bodyCfg
 also.]]></description><name>footerCfg</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If true the container will force a layout initially even if hidden or collapsed. This option is useful for forcing forms
 to render in collapsed or hidden containers. (defaults to false).]]></description><name>forceLayout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[false by default to render with plain 1px square borders. true to render with 9 elements, complete with custom rounded
 corners (also see Ext.Element.boxWrap). The template generated for each condition is depicted below: // frame =
 false
 <div id="developer-specified-id-goes-here" class="x-panel">
 
     <div class="x-panel-header"><span
 class="x-panel-header-text">Title: (frame:false)</span></div>
 
     <div class="x-panel-bwrap">
         <div
 class="x-panel-body"><p>html value goes here</p></div>
     </div>
 </div>
 
 // frame = true (create 9 elements)
 <div
 id="developer-specified-id-goes-here" class="x-panel">
     <div class="x-panel-tl"><div class="x-panel-tr"><div
 class="x-panel-tc">
         <div class="x-panel-header"><span class="x-panel-header-text">Title:
 (frame:true)</span></div>
     </div></div></div>
 
     <div class="x-panel-bwrap">
         <div class="x-panel-ml"><div
 class="x-panel-mr"><div class="x-panel-mc">
             <div class="x-panel-body"><p>html value goes here</p></div>
     
 </div></div></div>
 
         <div class="x-panel-bl"><div class="x-panel-br"><div class="x-panel-bc"/>
        
 </div></div></div>
 </div>]]></description><name>frame</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to create the Panel's header element explicitly, false to skip creating it. If a title is set the header will be
 created automatically, otherwise it will not. If a title is set but header is explicitly set to false, the header will
 not be rendered.]]></description><name>header</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to display the panel title in the header, false to hide it (defaults to true).]]></description><name>headerAsText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A DomHelper element specification object specifying the element structure of this Panel's header Element. See bodyCfg
 also.]]></description><name>headerCfg</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component hidden (default is false). If true, the hide method will be called internally.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide the borders of each contained component, false to defer to the component's existing border settings
 (defaults to false).]]></description><name>hideBorders</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to hide the expand/collapse toggle button when collapsible == true, false to display it (defaults to false).]]></description><name>hideCollapseTool</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to completely hide the label element (label and separator). Defaults to false. By default, even if you do not
 specify a fieldLabel the space will still be reserved so that the field will line up with other fields that do have
 labels. Setting this to true will cause the field to not reserve that space. Note: see the note for clearCls. Example
 use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield'
        
 hideLabel: true
     }]
 });]]></description><name>hideLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[How this component should be hidden. Supported values are 'visibility' (css visibility), 'offsets' (negative offset
 position) and 'display' (css display). Note: the default of 'display' is generally preferred since items are
 automatically laid out when they are first shown (no sizing is done while hidden).]]></description><name>hideMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide and show the component's container when hide/show is called on the component, false to hide and show the
 component itself (defaults to false). For example, this can be used as a shortcut for a hide button on a window by
 setting hide:true on the button when adding it to its parent container.]]></description><name>hideParent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class selector that specifies a background image to be used as the header icon (defaults to ''). An example of
 specifying a custom icon class would be something like: // specify the property in the config for the class:
      ...
   
 iconCls: 'my-icon'
 
 // css class that specifies background image to be used as the icon image:
 .my-icon {
 background-image: url(../images/my-icon.gif) 0 6px no-repeat !important; }]]></description><name>iconCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id of this component (defaults to an auto-assigned id). You should assign an id if you need to be able to
 access the component later and you do not have an object reference available (e.g., using Ext.getCmp). Note that this id
 will also be used as the element id for the containing HTML element that is rendered to the page for this component.
 This allows you to write id-based CSS rules to style the specific instance of this component uniquely, and also to
 select sub-elements using this component's id as the parent. Note: to avoid complications imposed by a unique id also
 see itemId and ref. Note: to access the container of an item see ownerCt.]]></description><name>id</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A css class to apply to the x-form-item of fields (see Ext.layout.FormLayout.fieldTpl for details). This property
 cascades to child containers.]]></description><name>itemCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An itemId can be used as an alternative way to get a reference to a component when no object reference is available.
 Instead of using an id with Ext.getCmp, use itemId with Ext.Container.getComponent which will retrieve itemId's or id's.
 Since itemId's are an index to the container's internal MixedCollection, the itemId is scoped locally to the container
 -- avoiding potential conflicts with Ext.ComponentMgr which requires a unique id. var c = new Ext.Panel({ //
     height:
 300,
     renderTo: document.body,
     layout: 'auto',
     items: [
         {
             itemId: 'p1',
            
 title: 'Panel 1',
             height: 150
         },
         {
             itemId: 'p2',
             title: 'Panel 2',
  
 height: 150
         }
     ]
 })
 p1 = c.getComponent('p1'); // not the same as Ext.getCmp()
 p2 =
 p1.ownerCt.getComponent('p2'); // reference via a sibling Also see id and ref. Note: to access the container of an item
 see ownerCt.]]></description><name>itemId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A Ext.KeyMap config object (in the format expected by Ext.KeyMap.addBinding used to assign custom key handling to this
 panel (defaults to null).]]></description><name>keys</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The separator to display after the text of each fieldLabel. This property may be configured at various levels. The order
 of precedence is: field / component level container level layout level (defaults to colon ':') To display no separator
 for this field's label specify empty string ''. Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 layoutConfig: {
         labelSeparator: '~'   // layout config has lowest priority (defaults to ':')
     },
    
 labelSeparator: '>>',     // config at container level
     items: [{
         xtype: 'textfield',
         fieldLabel:
 'Field 1',
         labelSeparator: '...' // field/component level config supersedes others
     },{
         xtype:
 'textfield',
         fieldLabel: 'Field 2' // labelSeparator will be '='
     }]
 });]]></description><name>labelSeparator</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS style specification string to apply directly to this field's label. Defaults to the container's labelStyle value
 if set (e.g., Ext.layout.FormLayout.labelStyle , or ''). Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         labelStyle: 'font-weight:bold;'
     }]
 });]]></description><name>labelStyle</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of labels. This property cascades to child containers.]]></description><name>labelWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.Container.layout to use inside the fieldset (defaults to 'form').]]></description><name>layout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout or one of the two BoxLayout subclasses. An object containing margins to apply to this BoxComponent in the
 format: {
     top: (top margin),
     right: (right margin),
     bottom: (bottom margin),
     left: (left margin)
 } May
 also be a string containing space-separated, numeric margin values. The order of the sides associated with each value
 matches the way CSS processes margin values: If there is only one value, it applies to all sides. If there are two
 values, the top and bottom borders are set to the first value and the right and left are set to the second. If there are
 three values, the top is set to the first value, the left and right are set to the second, and the bottom is set to the
 third. If there are four values, they apply to the top, right, bottom, and left, respectively. Defaults to: {top:0,
 right:0, bottom:0, left:0}]]></description><name>margins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to mask the panel when it is disabled, false to not mask it (defaults to true). Either way, the panel will always
 tell its contained elements to disable themselves when it is disabled, but masking the panel can provide an additional
 visual cue that the panel is disabled.]]></description><name>maskDisabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Minimum width in pixels of all buttons in this panel (defaults to 75)]]></description><name>minButtonWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically monitor window resize events to handle anything that is sensitive to the current size of the
 viewport. This value is typically managed by the chosen layout and should not need to be set manually.]]></description><name>monitorResize</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element when the mouse moves over the Element, and
 removed when the mouse moves out. (defaults to ''). This can be useful for adding customized 'active' or 'hover' styles
 to the component or any of its children using standard CSS rules.]]></description><name>overCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A shortcut for setting a padding style on the body element. The value can either be a number to be applied to all sides,
 or a normal css string describing padding. Defaults to undefined.]]></description><name>padding</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level x coordinate for this component if contained within a positioning container.]]></description><name>pageX</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level y coordinate for this component if contained within a positioning container.]]></description><name>pageY</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to false. When set to true, an extra css class 'x-panel-normal' will be added to the panel's element,
 effectively applying css styles suggested by the W3C (see http://www.w3.org/TR/CSS21/sample.html) to the Panel's body
 element (not the header, footer, etc.).]]></description><name>preventBodyReset</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered ptype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a Plugin is being specified not as a fully
 instantiated Component, but as a Component config object. The ptype will be looked up at render time up to determine
 what type of Plugin to create. If you create your own Plugins, you may register them using
 Ext.ComponentMgr.registerPlugin in order to be able to take advantage of lazy instantiation and rendering.]]></description><name>ptype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A path specification, relative to the Component's ownerCt specifying into which ancestor Container to place a named
 reference to this Component. The ancestor axis can be traversed by using '/' characters in the path. For example, to put
 a reference to a Toolbar Button into the Panel which owns the Toolbar: var myGrid = new Ext.grid.EditorGridPanel({
    
 title: 'My EditorGridPanel',
     store: myStore,
     colModel: myColModel,
     tbar: [{
         text: 'Save',
        
 handler: saveChanges,
         disabled: true,
         ref: '../saveButton'
     }],
     listeners: {
         afteredit:
 function() {
 //          The button reference is in the GridPanel
             myGrid.saveButton.enable();
         }
    
 }
 }); In the code above, if the ref had been 'saveButton' the reference would have been placed into the Toolbar. Each
 '/' in the ref moves up one level from the Component's ownerCt. Also see the added and removed events.]]></description><name>ref</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout layout manager (e.g. specifying layout:'border'). See Ext.layout.BorderLayout also.]]></description><name>region</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The event to listen to for resizing in layouts. Defaults to 'bodyresize'.]]></description><name>resizeEvent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true (or a valid Ext.Shadow Ext.Shadow.mode value) to display a shadow behind the panel, false to display no shadow
 (defaults to 'sides'). Note that this option only applies when floating = true.]]></description><name>shadow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The number of pixels to offset the shadow if displayed (defaults to 4). Note that this option only applies when floating
 = true.]]></description><name>shadowOffset</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[false to disable the iframe shim in browsers which need one (defaults to true). Note that this option only applies when
 floating = true.]]></description><name>shim</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should trigger this component to save its state (defaults to none). stateEvents may
 be any type of event supported by this component, including browser or custom events (e.g., ['click',
 'customerchange']). See stateful for an explanation of saving and restoring Component state.]]></description><name>stateEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id for this component to use for state management purposes (defaults to the component id if one was set,
 otherwise null if the component is using a generated id). See stateful for an explanation of saving and restoring
 Component state.]]></description><name>stateId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A flag which causes the Component to attempt to restore the state of internal properties from a saved state on startup.
 The component must have either a stateId or id assigned for state to be managed. Auto-generated ids are not guaranteed
 to be stable across page loads and cannot be relied upon to save and restore the same state for a component. For state
 saving to work, the state manager's provider must have been set to an implementation of Ext.state.Provider which
 overrides the set and get methods to save and recall name/value pairs. A built-in implementation,
 Ext.state.CookieProvider is available. To set the state provider for the current page: Ext.state.Manager.setProvider(new
 Ext.state.CookieProvider({
     expires: new Date(new Date().getTime()+(1000*60*60*24*7)), //7 days from now
 })); A
 stateful Component attempts to save state when one of the events listed in the stateEvents configuration fires. To save
 state, a stateful Component first serializes its state by calling getState. By default, this function does nothing. The
 developer must provide an implementation which returns an object hash which represents the Component's restorable state.
 The value yielded by getState is passed to Ext.state.Manager.set which uses the configured Ext.state.Provider to save
 the object keyed by the Component's stateId, or, if that is not specified, its id. During construction, a stateful
 Component attempts to restore its state by calling Ext.state.Manager.get passing the stateId, or, if that is not
 specified, the id. The resulting object is passed to applyState. The default implementation of applyState simply copies
 properties into the object, but a developer may override this to support more behaviour. You can perform extra
 processing on state save and restore by attaching handlers to the beforestaterestore, staterestore, beforestatesave and
 statesave events.]]></description><name>stateful</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
     title: 'Some Title',
     renderTo: Ext.getBody(),
     width: 400, height:
 300,
     layout: 'form',
     items: [{
         xtype: 'textarea',
         style: {
             width: '95%',
            
 marginBottom: '10px'
         }
     },
         new Ext.Button({
             text: 'Send',
             minWidth: '100',
   
          style: {
                 marginBottom: '10px'
             }
         })
     ]
 });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is a child item of a TabPanel. A string to be used as innerHTML
 (html tags are accepted) to show in a tooltip when mousing over the associated tab selector element.
 Ext.QuickTips.init() must be called in order for the tips to render.]]></description><name>tabTip</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The title text to be used as innerHTML (html tags are accepted) to display in the panel header (defaults to ''). When a
 title is specified the header element will automatically be created and displayed unless header is explicitly set to
 false. If you do not want to specify a title at config time, but you may want one later, you must either specify a
 non-empty title (a blank space ' ' will do) or header:true so that the container element will get created.]]></description><name>title</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to allow expanding and collapsing the panel (when collapsible = true) by clicking anywhere in the header bar,
 false) to allow it only by clicking to tool button (defaults to false)). If this panel is a child item of a border
 layout also see the BorderLayout.Region floatable config option.]]></description><name>titleCollapse</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A Template used to create tools in the header Element. Defaults to: new Ext.Template('<div class="x-tool
 x-tool-{id}">&#160;</div>') This may may be overridden to provide a custom DOM structure for tools based upon a more
 complex XTemplate. The template's data is a single tool configuration object (Not the entire Array) as specified in
 tools. In the following example an <a> tag is used to provide a visual indication when hovering over the tool: var win =
 new Ext.Window({
     tools: [{
         id: 'download',
         href: '/MyPdfDoc.pdf'
     }],
     toolTemplate: new
 Ext.XTemplate(
         '<tpl if="id==\'download\'">',
             '<a class="x-tool x-tool-pdf" href="{href}"></a>',
    
 '</tpl>',
         '<tpl if="id!=\'download\'">',
             '<div class="x-tool x-tool-{id}">&#160;</div>',
        
 '</tpl>'
     ),
     width:500,
     height:300,
     closeAction:'hide'
 }); Note that the CSS class 'x-tool-pdf' should
 have an associated style rule which provides an appropriate background image, something like: a.x-tool-pdf
 {background-image: url(../shared/extjs/images/pdf.gif)!important;}]]></description><name>toolTemplate</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of tool button configs to be added to the header tool area. When rendered, each tool is stored as an Element
 referenced by a public property called tools.<tool-type> Each tool config may contain the following properties: id :
 String Required. The type of tool to create. By default, this assigns a CSS class of the form x-tool-<tool-type> to the
 resulting tool Element. Ext provides CSS rules, and an icon sprite containing images for the tool types listed below.
 The developer may implement custom tools by supplying alternate CSS rules and background images: toggle (Created by
 default when collapsible is true) close minimize maximize restore gear pin unpin right left up down refresh minus plus
 help search save print handler : Function Required. The function to call when clicked. Arguments passed are: event :
 Ext.EventObject The click event. toolEl : Ext.Element The tool Element. panel : Ext.Panel The host Panel tc : Object The
 tool configuration object stopEvent : Boolean Defaults to true. Specify as false to allow click event to propagate.
 scope : Object The scope in which to call the handler. qtip : String/Object A tip string, or a config argument to
 Ext.QuickTip.register hidden : Boolean True to initially render hidden. on : Object A listener config object specifiying
 event listeners in the format of an argument to addListener Note that, apart from the toggle tool which is provided when
 a panel is collapsible, these tools only provide the visual button. Any required functionality must be provided by
 adding handlers that implement the necessary behavior. Example usage: tools:[{
     id:'refresh',
     qtip: 'Refresh form
 Data',
     // hidden:true,
     handler: function(event, toolEl, panel){
         // refresh logic
     }
 },
 {
    
 id:'help',
     qtip: 'Get Help',
     handler: function(event, toolEl, panel){
         // whatever
     }
 }] For the
 custom id of 'help' define two relevant css classes with a link to a 15x15 image: .x-tool-help {background-image:
 url(images/help.png);}
 .x-tool-help-over {background-image: url(images/help_over.png);}
 // if using an image
 sprite:
 .x-tool-help {background-image: url(images/help.png) no-repeat 0 0;}
 .x-tool-help-over
 {background-position:-15px 0;}]]></description><name>tools</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Overrides the baseCls setting to baseCls = 'x-plain' which renders the panel unstyled except for required attributes for
 Ext layouts to function (e.g. overflow:hidden).]]></description><name>unstyled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local x (left) coordinate for this component if contained within a positioning container.]]></description><name>x</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered xtype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a child item of a Container is being specified not
 as a fully instantiated Component, but as a Component config object. The xtype will be looked up at render time up to
 determine what type of child Component to create. The predefined xtypes are listed here. If you subclass Components to
 create your own Components, you may register them using Ext.ComponentMgr.registerType in order to be able to take
 advantage of lazy instantiation and rendering.]]></description><name>xtype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local y (top) coordinate for this component if contained within a positioning container.]]></description><name>y</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 Provides a lightweight HTML Editor component. Some toolbar features are not supported by Safari and will be
 automatically hidden when needed. These are noted in the config options where appropriate. 
 <br />
 <br />The editor's
 toolbar buttons have tooltips defined in the 
 <a href="output/Ext.form.HtmlEditor.html#Ext.form.HtmlEditor-buttonTips"
 ext:member="buttonTips" ext:cls="Ext.form.HtmlEditor">buttonTips</a> property, but they are not enabled by default
 unless the global 
 <a href="output/Ext.QuickTips.html" ext:cls="Ext.QuickTips">Ext.QuickTips</a> singleton is 
 <a
 href="output/Ext.QuickTips.html#Ext.QuickTips-init" ext:member="init" ext:cls="Ext.QuickTips">initialized</a>. 
 <br
 />
 <br />
 <b>Note: The focus/blur and validation marking functionality inherited from Ext.form.Field is NOT supported by
 this editor.</b> 
 <br />
 <br />An Editor is a sensitive component that can't be used in all spots standard fields can be
 used. Putting an Editor within any element that has display set to 'none' can cause problems in Safari and Firefox due
 to their default iframe reloading bugs. 
 <br />
 <br />Example usage: 
 <pre><code><i>// Simple example rendered
 <b>with</b> <b>default</b> options:</i>
 Ext.QuickTips.init();  <i>// enable tooltips</i>
 <b>new</b>
 Ext.form.HtmlEditor({
     renderTo: Ext.getBody(),
     width: 800,
     height: 300
 });
 
 <i>// Passed via xtype into a
 container and <b>with</b> custom options:</i>
 Ext.QuickTips.init();  <i>// enable tooltips</i>
 <b>new</b> Ext.Panel({
   
 title: <em>'HTML Editor'</em>,
     renderTo: Ext.getBody(),
     width: 600,
     height: 300,
     frame: true,
    
 layout: <em>'fit'</em>,
     items: {
         xtype: <em>'htmleditor'</em>,
         enableColors: false,
        
 enableAlignments: false
     }
 });</code></pre>]]></description><name>form.htmlEditor</name><tag-class>org.brushingbits.jnap.ui.extjs3.form.HtmlEditor</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[The field's HTML name attribute (defaults to ''). Note: this property must be set if this field is to be automatically
 included with form submit().]]></description><name>name</name><required>true</required><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Whether the component can move the Dom node when rendering (defaults to true).]]></description><name>allowDomMove</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use an
 AnchorLayout (or subclass thereof). based layout manager, for example: Ext.form.FormPanel specifying layout: 'anchor' //
 or 'form', or 'absolute' See Ext.layout.AnchorLayout.anchor also.]]></description><name>anchor</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element corresponding to a DIV that is already present in
 the document that specifies some structural markup for this component. Description : When applyTo is used, constituent
 parts of the component can also be specified by id or CSS class name within the main element, and the component being
 created may attempt to create its subcomponents from that markup if applicable. Notes : When using this config, a call
 to render() is not required. If applyTo is specified, any value passed for renderTo will be ignored and the target
 element's parent node will automatically be used as the component's container.]]></description><name>applyTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A DomHelper element spec, or true for a default element spec. Used to create the Element which will encapsulate this
 Component. See autoEl for details. Defaults to: {tag: 'input', type: 'text', size: '20', autocomplete: 'off'}]]></description><name>autoCreate</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A tag name or DomHelper spec used to create the Element which will encapsulate this Component. You do not normally need
 to specify this. For the base classes Ext.Component, Ext.BoxComponent, and Ext.Container, this defaults to 'div'. The
 more complex Ext classes use a more complex DOM structure created by their own onRender methods. This is intended to
 allow the developer to create application-specific utility Components encapsulated by different DOM elements. Example
 usage: <pre><code>{
     xtype: 'box',
     autoEl: {
         tag: 'img',
         src: 'http://www.example.com/example.jpg'
     }
 },
 {
     xtype: 'box',
     autoEl: {
         tag: 'blockquote',
         html: 'autoEl is cool!'
     }
 }, {
     xtype: 'container',
     autoEl: 'ul',
     cls: 'ux-unordered-list',
     items: {
         xtype: 'box',
         autoEl: 'li',
   
      html: 'First list item'
     }
 }</pre></code>]]></description><name>autoEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to use height:'auto', false to use fixed height (or allow it to be managed by its parent Container's layout
 manager. Defaults to false. Note: Although many components inherit this config option, not all will function as expected
 with a height of 'auto'. Setting autoHeight:true means that the browser will manage height based on the element's
 contents, and that Ext will not manage it at all. If the browser is managing the height, be aware that resizes performed
 by the browser in response to changes within the structure of the Component cannot be detected. Therefore changes to the
 height might result in elements needing to be synchronized with the new height. Example: var w = new Ext.Window({
    
 title: 'Window',
     width: 600,
     autoHeight: true,
     items: {
         title: 'Collapse Me',
         height: 400,
  
 collapsible: true,
         border: false,
         listeners: {
             beforecollapse: function() {
                w.el.shadow.hide();
             },
             beforeexpand: function() {
                w.el.shadow.hide();
             },
             collapse: function() {
                w.syncShadow();
             },
             expand: function() {
                w.syncShadow();
             }
         }
     }
 }).show();]]></description><name>autoHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to use overflow:'auto' on the components layout element and show scroll bars automatically when necessary, false to
 clip any overflowing content (defaults to false).]]></description><name>autoScroll</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True if the component should check for hidden classes (e.g. 'x-hidden' or 'x-hide-display') and remove them on render
 (defaults to false).]]></description><name>autoShow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to use width:'auto', false to use fixed width (or allow it to be managed by its parent Container's layout manager.
 Defaults to false. Note: Although many components inherit this config option, not all will function as expected with a
 width of 'auto'. Setting autoWidth:true means that the browser will manage width based on the element's contents, and
 that Ext will not manage it at all. If the browser is managing the width, be aware that resizes performed by the browser
 in response to changes within the structure of the Component cannot be detected. Therefore changes to the width might
 result in elements needing to be synchronized with the new width. For example, where the target element is: <div
 id='grid-container' style='margin-left:25%;width:50%'></div> A Panel rendered into that target element must listen for
 browser window resize in order to relay its child items when the browser changes its width: var myPanel = new
 Ext.Panel({
     renderTo: 'grid-container',
     monitorResize: true, // relay on browser resize
     title: 'Panel',
    
 height: 400,
     autoWidth: true,
     layout: 'hbox',
     layoutConfig: {
         align: 'stretch'
     },
     defaults: {
         flex: 1
     },
     items: [{
         title: 'Box 1',
     }, {
         title: 'Box 2'
     }, {
         title:
 'Box 3'
     }],
 });]]></description><name>autoWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to [].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class used to to apply to the special clearing div rendered directly after each form field wrapper to provide
 field clearing (defaults to 'x-form-clear-left'). Note: this config is only used when this Component is rendered by a
 Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or specifying
 layout:'form') and either a fieldLabel is specified or isFormField=true is specified. See Ext.layout.FormLayout.fieldTpl
 also.]]></description><name>clearCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom CSS class to apply to the field's underlying element (defaults to '').]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default text for the create link prompt]]></description><name>createLinkText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's container. This can be useful for adding customized
 styles to the container or any of its children using standard CSS rules. See Ext.layout.ContainerLayout.extraCls also.
 Note: ctCls defaults to '' except for the following class which assigns a value by default: Box Layout :
 'x-box-layout-ct' To configure the above Class with an extra CSS class append to the default. For example, for BoxLayout
 (Hbox and Vbox): ctCls: 'x-box-layout-ct custom-class']]></description><name>ctCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default value for the create link prompt (defaults to http:/ /)]]></description><name>defaultLinkValue</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A default value to be put into the editor to resolve focus issues (defaults to (Non-breaking space) in Opera and IE6,
 (Zero-width space) in all other browsers).]]></description><name>defaultValue</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to disable the field (defaults to false). Be aware that conformant with the HTML specification, disabled Fields
 will not be submitted.]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class added to the component when it is disabled (defaults to 'x-item-disabled').]]></description><name>disabledClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Enable the left, center, right alignment buttons (defaults to true)]]></description><name>enableAlignments</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Enable the fore/highlight color buttons (defaults to true)]]></description><name>enableColors</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Enable font selection. Not available in Safari. (defaults to true)]]></description><name>enableFont</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Enable the increase/decrease font size buttons (defaults to true)]]></description><name>enableFontSize</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Enable the bold, italic and underline buttons (defaults to true)]]></description><name>enableFormat</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Enable the create link button. Not available in Safari. (defaults to true)]]></description><name>enableLinks</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Enable the bullet and numbered list buttons. Not available in Safari. (defaults to true)]]></description><name>enableLists</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Enable the switch to source edit button. Not available in Safari. (defaults to true)]]></description><name>enableSourceEdit</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default CSS class for the field (defaults to 'x-form-field')]]></description><name>fieldClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The label text to display next to this Component (defaults to ''). Note: this config is only used when this Component is
 rendered by a Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or
 specifying layout:'form'). Also see hideLabel and Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
    
 height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name'
    
 }]
 });]]></description><name>fieldLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use a
 BoxLayout. Each child Component with a flex property will be flexed either vertically (by a VBoxLayout) or horizontally
 (by an HBoxLayout) according to the item's relative flex value compared to the sum of all Components with flex value
 specified. Any child items that have either a flex = 0 or flex = undefined will not be 'flexed' (the initial size will
 not be changed).]]></description><name>flex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class to use when the field receives focus (defaults to 'x-form-focus')]]></description><name>focusClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of available font families]]></description><name>fontFamilies</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component hidden (default is false). If true, the hide method will be called internally.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to completely hide the label element (label and separator). Defaults to false. By default, even if you do not
 specify a fieldLabel the space will still be reserved so that the field will line up with other fields that do have
 labels. Setting this to true will cause the field to not reserve that space. Note: see the note for clearCls. Example
 use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield'
        
 hideLabel: true
     }]
 });]]></description><name>hideLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[How this component should be hidden. Supported values are 'visibility' (css visibility), 'offsets' (negative offset
 position) and 'display' (css display). Note: the default of 'display' is generally preferred since items are
 automatically laid out when they are first shown (no sizing is done while hidden).]]></description><name>hideMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide and show the component's container when hide/show is called on the component, false to hide and show the
 component itself (defaults to false). For example, this can be used as a shortcut for a hide button on a window by
 setting hide:true on the button when adding it to its parent container.]]></description><name>hideParent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id of this component (defaults to an auto-assigned id). You should assign an id if you need to be able to
 access the component later and you do not have an object reference available (e.g., using Ext.getCmp). Note that this id
 will also be used as the element id for the containing HTML element that is rendered to the page for this component.
 This allows you to write id-based CSS rules to style the specific instance of this component uniquely, and also to
 select sub-elements using this component's id as the parent. Note: to avoid complications imposed by a unique id also
 see itemId and ref. Note: to access the container of an item see ownerCt.]]></description><name>id</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The type attribute for input fields -- e.g. radio, text, password, file (defaults to 'text'). The types 'file' and
 'password' must be used to render those field types currently -- there are no separate Ext components for those. Note
 that if you use inputType:'file', emptyText is not supported and should be avoided.]]></description><name>inputType</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class to use when marking a field invalid (defaults to 'x-form-invalid')]]></description><name>invalidClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The error text to use when marking a field invalid and no message is provided (defaults to 'The value in this field is
 invalid')]]></description><name>invalidText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use the
 FormLayout layout manager (e.g. Ext.form.FormPanel or specifying layout:'form'). An additional CSS class to apply to the
 div wrapping the form item element of this field. If supplied, itemCls at the field level will override the default
 itemCls supplied at the container level. The value specified for itemCls will be added to the default class
 ('x-form-item'). Since it is applied to the item wrapper (see Ext.layout.FormLayout.fieldTpl), it allows you to write
 standard CSS rules that can apply to the field, the label (if specified), or any other element within the markup for the
 field. Note: see the note for fieldLabel. Example use: // Apply a style to the field's label:
 <style>
     .required
 .x-form-item-label {font-weight:bold;color:red;}
 </style>
 
 new Ext.FormPanel({
     height: 100,
     renderTo:
 Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         itemCls: 'required' //this
 label will be styled
     },{
         xtype: 'textfield',
         fieldLabel: 'Favorite Color'
     }]
 });]]></description><name>itemCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An itemId can be used as an alternative way to get a reference to a component when no object reference is available.
 Instead of using an id with Ext.getCmp, use itemId with Ext.Container.getComponent which will retrieve itemId's or id's.
 Since itemId's are an index to the container's internal MixedCollection, the itemId is scoped locally to the container
 -- avoiding potential conflicts with Ext.ComponentMgr which requires a unique id. var c = new Ext.Panel({ //
     height:
 300,
     renderTo: document.body,
     layout: 'auto',
     items: [
         {
             itemId: 'p1',
            
 title: 'Panel 1',
             height: 150
         },
         {
             itemId: 'p2',
             title: 'Panel 2',
  
 height: 150
         }
     ]
 })
 p1 = c.getComponent('p1'); // not the same as Ext.getCmp()
 p2 =
 p1.ownerCt.getComponent('p2'); // reference via a sibling Also see id and ref. Note: to access the container of an item
 see ownerCt.]]></description><name>itemId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The separator to display after the text of each fieldLabel. This property may be configured at various levels. The order
 of precedence is: field / component level container level layout level (defaults to colon ':') To display no separator
 for this field's label specify empty string ''. Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 layoutConfig: {
         labelSeparator: '~'   // layout config has lowest priority (defaults to ':')
     },
    
 labelSeparator: '>>',     // config at container level
     items: [{
         xtype: 'textfield',
         fieldLabel:
 'Field 1',
         labelSeparator: '...' // field/component level config supersedes others
     },{
         xtype:
 'textfield',
         fieldLabel: 'Field 2' // labelSeparator will be '='
     }]
 });]]></description><name>labelSeparator</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS style specification string to apply directly to this field's label. Defaults to the container's labelStyle value
 if set (e.g., Ext.layout.FormLayout.labelStyle , or ''). Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         labelStyle: 'font-weight:bold;'
     }]
 });]]></description><name>labelStyle</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout or one of the two BoxLayout subclasses. An object containing margins to apply to this BoxComponent in the
 format: {
     top: (top margin),
     right: (right margin),
     bottom: (bottom margin),
     left: (left margin)
 } May
 also be a string containing space-separated, numeric margin values. The order of the sides associated with each value
 matches the way CSS processes margin values: If there is only one value, it applies to all sides. If there are two
 values, the top and bottom borders are set to the first value and the right and left are set to the second. If there are
 three values, the top is set to the first value, the left and right are set to the second, and the bottom is set to the
 third. If there are four values, they apply to the top, right, bottom, and left, respectively. Defaults to: {top:0,
 right:0, bottom:0, left:0}]]></description><name>margins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Experimental The effect used when displaying a validation message under the field (defaults to 'normal').]]></description><name>msgFx</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The location where the message text set through markInvalid should display. Must be one of the following values: qtip
 Display a quick tip containing the message when the user hovers over the field. This is the default. Ext.QuickTips.init
 must have been called for this setting to work. title Display the message in a default browser title attribute popup.
 under Add a block div beneath the field containing the error message. side Add an error icon to the right of the field,
 displaying the message in a popup on hover. [element id] Add the error message directly to the innerHTML of the
 specified element.]]></description><name>msgTarget</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element when the mouse moves over the Element, and
 removed when the mouse moves out. (defaults to ''). This can be useful for adding customized 'active' or 'hover' styles
 to the component or any of its children using standard CSS rules.]]></description><name>overCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level x coordinate for this component if contained within a positioning container.]]></description><name>pageX</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level y coordinate for this component if contained within a positioning container.]]></description><name>pageY</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to disable marking the field invalid. Defaults to false.]]></description><name>preventMark</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered ptype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a Plugin is being specified not as a fully
 instantiated Component, but as a Component config object. The ptype will be looked up at render time up to determine
 what type of Plugin to create. If you create your own Plugins, you may register them using
 Ext.ComponentMgr.registerPlugin in order to be able to take advantage of lazy instantiation and rendering.]]></description><name>ptype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to mark the field as readOnly in HTML (defaults to false). Note: this only sets the element's readOnly DOM
 attribute. Setting readOnly=true, for example, will not disable triggering a ComboBox or DateField; it gives you the
 option of forcing the user to choose via the trigger without typing in the text box. To hide the trigger use
 hideTrigger.]]></description><name>readOnly</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A path specification, relative to the Component's ownerCt specifying into which ancestor Container to place a named
 reference to this Component. The ancestor axis can be traversed by using '/' characters in the path. For example, to put
 a reference to a Toolbar Button into the Panel which owns the Toolbar: var myGrid = new Ext.grid.EditorGridPanel({
    
 title: 'My EditorGridPanel',
     store: myStore,
     colModel: myColModel,
     tbar: [{
         text: 'Save',
        
 handler: saveChanges,
         disabled: true,
         ref: '../saveButton'
     }],
     listeners: {
         afteredit:
 function() {
 //          The button reference is in the GridPanel
             myGrid.saveButton.enable();
         }
    
 }
 }); In the code above, if the ref had been 'saveButton' the reference would have been placed into the Toolbar. Each
 '/' in the ref moves up one level from the Component's ownerCt. Also see the added and removed events.]]></description><name>ref</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout layout manager (e.g. specifying layout:'border'). See Ext.layout.BorderLayout also.]]></description><name>region</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should trigger this component to save its state (defaults to none). stateEvents may
 be any type of event supported by this component, including browser or custom events (e.g., ['click',
 'customerchange']). See stateful for an explanation of saving and restoring Component state.]]></description><name>stateEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id for this component to use for state management purposes (defaults to the component id if one was set,
 otherwise null if the component is using a generated id). See stateful for an explanation of saving and restoring
 Component state.]]></description><name>stateId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A flag which causes the Component to attempt to restore the state of internal properties from a saved state on startup.
 The component must have either a stateId or id assigned for state to be managed. Auto-generated ids are not guaranteed
 to be stable across page loads and cannot be relied upon to save and restore the same state for a component. For state
 saving to work, the state manager's provider must have been set to an implementation of Ext.state.Provider which
 overrides the set and get methods to save and recall name/value pairs. A built-in implementation,
 Ext.state.CookieProvider is available. To set the state provider for the current page: Ext.state.Manager.setProvider(new
 Ext.state.CookieProvider({
     expires: new Date(new Date().getTime()+(1000*60*60*24*7)), //7 days from now
 })); A
 stateful Component attempts to save state when one of the events listed in the stateEvents configuration fires. To save
 state, a stateful Component first serializes its state by calling getState. By default, this function does nothing. The
 developer must provide an implementation which returns an object hash which represents the Component's restorable state.
 The value yielded by getState is passed to Ext.state.Manager.set which uses the configured Ext.state.Provider to save
 the object keyed by the Component's stateId, or, if that is not specified, its id. During construction, a stateful
 Component attempts to restore its state by calling Ext.state.Manager.get passing the stateId, or, if that is not
 specified, the id. The resulting object is passed to applyState. The default implementation of applyState simply copies
 properties into the object, but a developer may override this to support more behaviour. You can perform extra
 processing on state save and restore by attaching handlers to the beforestaterestore, staterestore, beforestatesave and
 statesave events.]]></description><name>stateful</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
     title: 'Some Title',
     renderTo: Ext.getBody(),
     width: 400, height:
 300,
     layout: 'form',
     items: [{
         xtype: 'textarea',
         style: {
             width: '95%',
            
 marginBottom: '10px'
         }
     },
         new Ext.Button({
             text: 'Send',
             minWidth: '100',
   
          style: {
                 marginBottom: '10px'
             }
         })
     ]
 });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[False to clear the name attribute on the field so that it is not submitted during a form post. Defaults to true.]]></description><name>submitValue</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The tabIndex for this field. Note this only applies to fields that are rendered, not those which are built via applyTo
 (defaults to undefined).]]></description><name>tabIndex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is a child item of a TabPanel. A string to be used as innerHTML
 (html tags are accepted) to show in a tooltip when mousing over the associated tab selector element.
 Ext.QuickTips.init() must be called in order for the tips to render.]]></description><name>tabTip</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Whether the field should validate when it loses focus (defaults to true).]]></description><name>validateOnBlur</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The length of time in milliseconds after user input begins until validation is initiated (defaults to 250)]]></description><name>validationDelay</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The event that should initiate field validation. Set to false to disable automatic validation (defaults to 'keyup').]]></description><name>validationEvent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A value to initialize this field with (defaults to undefined).]]></description><name>value</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local x (left) coordinate for this component if contained within a positioning container.]]></description><name>x</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered xtype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a child item of a Container is being specified not
 as a fully instantiated Component, but as a Component config object. The xtype will be looked up at render time up to
 determine what type of child Component to create. The predefined xtypes are listed here. If you subclass Components to
 create your own Components, you may register them using Ext.ComponentMgr.registerType in order to be able to take
 advantage of lazy instantiation and rendering.]]></description><name>xtype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local y (top) coordinate for this component if contained within a positioning container.]]></description><name>y</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 Basic Label field.]]></description><name>form.label</name><tag-class>org.brushingbits.jnap.ui.extjs3.form.Label</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[Whether the component can move the Dom node when rendering (defaults to true).]]></description><name>allowDomMove</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use an
 AnchorLayout (or subclass thereof). based layout manager, for example: Ext.form.FormPanel specifying layout: 'anchor' //
 or 'form', or 'absolute' See Ext.layout.AnchorLayout.anchor also.]]></description><name>anchor</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element corresponding to a DIV that is already present in
 the document that specifies some structural markup for this component. Description : When applyTo is used, constituent
 parts of the component can also be specified by id or CSS class name within the main element, and the component being
 created may attempt to create its subcomponents from that markup if applicable. Notes : When using this config, a call
 to render() is not required. If applyTo is specified, any value passed for renderTo will be ignored and the target
 element's parent node will automatically be used as the component's container.]]></description><name>applyTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A tag name or DomHelper spec used to create the Element which will encapsulate this Component. You do not normally need
 to specify this. For the base classes Ext.Component, Ext.BoxComponent, and Ext.Container, this defaults to 'div'. The
 more complex Ext classes use a more complex DOM structure created by their own onRender methods. This is intended to
 allow the developer to create application-specific utility Components encapsulated by different DOM elements. Example
 usage: <pre><code>{
     xtype: 'box',
     autoEl: {
         tag: 'img',
         src: 'http://www.example.com/example.jpg'
     }
 },
 {
     xtype: 'box',
     autoEl: {
         tag: 'blockquote',
         html: 'autoEl is cool!'
     }
 }, {
     xtype: 'container',
     autoEl: 'ul',
     cls: 'ux-unordered-list',
     items: {
         xtype: 'box',
         autoEl: 'li',
   
      html: 'First list item'
     }
 }</pre></code>]]></description><name>autoEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to use height:'auto', false to use fixed height (or allow it to be managed by its parent Container's layout
 manager. Defaults to false. Note: Although many components inherit this config option, not all will function as expected
 with a height of 'auto'. Setting autoHeight:true means that the browser will manage height based on the element's
 contents, and that Ext will not manage it at all. If the browser is managing the height, be aware that resizes performed
 by the browser in response to changes within the structure of the Component cannot be detected. Therefore changes to the
 height might result in elements needing to be synchronized with the new height. Example: var w = new Ext.Window({
    
 title: 'Window',
     width: 600,
     autoHeight: true,
     items: {
         title: 'Collapse Me',
         height: 400,
  
 collapsible: true,
         border: false,
         listeners: {
             beforecollapse: function() {
                w.el.shadow.hide();
             },
             beforeexpand: function() {
                w.el.shadow.hide();
             },
             collapse: function() {
                w.syncShadow();
             },
             expand: function() {
                w.syncShadow();
             }
         }
     }
 }).show();]]></description><name>autoHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to use overflow:'auto' on the components layout element and show scroll bars automatically when necessary, false to
 clip any overflowing content (defaults to false).]]></description><name>autoScroll</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True if the component should check for hidden classes (e.g. 'x-hidden' or 'x-hide-display') and remove them on render
 (defaults to false).]]></description><name>autoShow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to use width:'auto', false to use fixed width (or allow it to be managed by its parent Container's layout manager.
 Defaults to false. Note: Although many components inherit this config option, not all will function as expected with a
 width of 'auto'. Setting autoWidth:true means that the browser will manage width based on the element's contents, and
 that Ext will not manage it at all. If the browser is managing the width, be aware that resizes performed by the browser
 in response to changes within the structure of the Component cannot be detected. Therefore changes to the width might
 result in elements needing to be synchronized with the new width. For example, where the target element is: <div
 id='grid-container' style='margin-left:25%;width:50%'></div> A Panel rendered into that target element must listen for
 browser window resize in order to relay its child items when the browser changes its width: var myPanel = new
 Ext.Panel({
     renderTo: 'grid-container',
     monitorResize: true, // relay on browser resize
     title: 'Panel',
    
 height: 400,
     autoWidth: true,
     layout: 'hbox',
     layoutConfig: {
         align: 'stretch'
     },
     defaults: {
         flex: 1
     },
     items: [{
         title: 'Box 1',
     }, {
         title: 'Box 2'
     }, {
         title:
 'Box 3'
     }],
 });]]></description><name>autoWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to [].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class used to to apply to the special clearing div rendered directly after each form field wrapper to provide
 field clearing (defaults to 'x-form-clear-left'). Note: this config is only used when this Component is rendered by a
 Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or specifying
 layout:'form') and either a fieldLabel is specified or isFormField=true is specified. See Ext.layout.FormLayout.fieldTpl
 also.]]></description><name>clearCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element (defaults to ''). This can be useful for
 adding customized styles to the component or any of its children using standard CSS rules.]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's container. This can be useful for adding customized
 styles to the container or any of its children using standard CSS rules. See Ext.layout.ContainerLayout.extraCls also.
 Note: ctCls defaults to '' except for the following class which assigns a value by default: Box Layout :
 'x-box-layout-ct' To configure the above Class with an extra CSS class append to the default. For example, for BoxLayout
 (Hbox and Vbox): ctCls: 'x-box-layout-ct custom-class']]></description><name>ctCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component disabled (default is false).]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class added to the component when it is disabled (defaults to 'x-item-disabled').]]></description><name>disabledClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The label text to display next to this Component (defaults to ''). Note: this config is only used when this Component is
 rendered by a Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or
 specifying layout:'form'). Also see hideLabel and Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
    
 height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name'
    
 }]
 });]]></description><name>fieldLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use a
 BoxLayout. Each child Component with a flex property will be flexed either vertically (by a VBoxLayout) or horizontally
 (by an HBoxLayout) according to the item's relative flex value compared to the sum of all Components with flex value
 specified. Any child items that have either a flex = 0 or flex = undefined will not be 'flexed' (the initial size will
 not be changed).]]></description><name>flex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The id of the input element to which this label will be bound via the standard HTML 'for' attribute. If not specified,
 the attribute will not be added to the label.]]></description><name>forId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component hidden (default is false). If true, the hide method will be called internally.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to completely hide the label element (label and separator). Defaults to false. By default, even if you do not
 specify a fieldLabel the space will still be reserved so that the field will line up with other fields that do have
 labels. Setting this to true will cause the field to not reserve that space. Note: see the note for clearCls. Example
 use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield'
        
 hideLabel: true
     }]
 });]]></description><name>hideLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[How this component should be hidden. Supported values are 'visibility' (css visibility), 'offsets' (negative offset
 position) and 'display' (css display). Note: the default of 'display' is generally preferred since items are
 automatically laid out when they are first shown (no sizing is done while hidden).]]></description><name>hideMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide and show the component's container when hide/show is called on the component, false to hide and show the
 component itself (defaults to false). For example, this can be used as a shortcut for a hide button on a window by
 setting hide:true on the button when adding it to its parent container.]]></description><name>hideParent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment that will be used as the label's innerHTML (defaults to ''). Note that if text is specified it will
 take precedence and this value will be ignored.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id of this component (defaults to an auto-assigned id). You should assign an id if you need to be able to
 access the component later and you do not have an object reference available (e.g., using Ext.getCmp). Note that this id
 will also be used as the element id for the containing HTML element that is rendered to the page for this component.
 This allows you to write id-based CSS rules to style the specific instance of this component uniquely, and also to
 select sub-elements using this component's id as the parent. Note: to avoid complications imposed by a unique id also
 see itemId and ref. Note: to access the container of an item see ownerCt.]]></description><name>id</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use the
 FormLayout layout manager (e.g. Ext.form.FormPanel or specifying layout:'form'). An additional CSS class to apply to the
 div wrapping the form item element of this field. If supplied, itemCls at the field level will override the default
 itemCls supplied at the container level. The value specified for itemCls will be added to the default class
 ('x-form-item'). Since it is applied to the item wrapper (see Ext.layout.FormLayout.fieldTpl), it allows you to write
 standard CSS rules that can apply to the field, the label (if specified), or any other element within the markup for the
 field. Note: see the note for fieldLabel. Example use: // Apply a style to the field's label:
 <style>
     .required
 .x-form-item-label {font-weight:bold;color:red;}
 </style>
 
 new Ext.FormPanel({
     height: 100,
     renderTo:
 Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         itemCls: 'required' //this
 label will be styled
     },{
         xtype: 'textfield',
         fieldLabel: 'Favorite Color'
     }]
 });]]></description><name>itemCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An itemId can be used as an alternative way to get a reference to a component when no object reference is available.
 Instead of using an id with Ext.getCmp, use itemId with Ext.Container.getComponent which will retrieve itemId's or id's.
 Since itemId's are an index to the container's internal MixedCollection, the itemId is scoped locally to the container
 -- avoiding potential conflicts with Ext.ComponentMgr which requires a unique id. var c = new Ext.Panel({ //
     height:
 300,
     renderTo: document.body,
     layout: 'auto',
     items: [
         {
             itemId: 'p1',
            
 title: 'Panel 1',
             height: 150
         },
         {
             itemId: 'p2',
             title: 'Panel 2',
  
 height: 150
         }
     ]
 })
 p1 = c.getComponent('p1'); // not the same as Ext.getCmp()
 p2 =
 p1.ownerCt.getComponent('p2'); // reference via a sibling Also see id and ref. Note: to access the container of an item
 see ownerCt.]]></description><name>itemId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The separator to display after the text of each fieldLabel. This property may be configured at various levels. The order
 of precedence is: field / component level container level layout level (defaults to colon ':') To display no separator
 for this field's label specify empty string ''. Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 layoutConfig: {
         labelSeparator: '~'   // layout config has lowest priority (defaults to ':')
     },
    
 labelSeparator: '>>',     // config at container level
     items: [{
         xtype: 'textfield',
         fieldLabel:
 'Field 1',
         labelSeparator: '...' // field/component level config supersedes others
     },{
         xtype:
 'textfield',
         fieldLabel: 'Field 2' // labelSeparator will be '='
     }]
 });]]></description><name>labelSeparator</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS style specification string to apply directly to this field's label. Defaults to the container's labelStyle value
 if set (e.g., Ext.layout.FormLayout.labelStyle , or ''). Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         labelStyle: 'font-weight:bold;'
     }]
 });]]></description><name>labelStyle</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout or one of the two BoxLayout subclasses. An object containing margins to apply to this BoxComponent in the
 format: {
     top: (top margin),
     right: (right margin),
     bottom: (bottom margin),
     left: (left margin)
 } May
 also be a string containing space-separated, numeric margin values. The order of the sides associated with each value
 matches the way CSS processes margin values: If there is only one value, it applies to all sides. If there are two
 values, the top and bottom borders are set to the first value and the right and left are set to the second. If there are
 three values, the top is set to the first value, the left and right are set to the second, and the bottom is set to the
 third. If there are four values, they apply to the top, right, bottom, and left, respectively. Defaults to: {top:0,
 right:0, bottom:0, left:0}]]></description><name>margins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element when the mouse moves over the Element, and
 removed when the mouse moves out. (defaults to ''). This can be useful for adding customized 'active' or 'hover' styles
 to the component or any of its children using standard CSS rules.]]></description><name>overCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level x coordinate for this component if contained within a positioning container.]]></description><name>pageX</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level y coordinate for this component if contained within a positioning container.]]></description><name>pageY</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered ptype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a Plugin is being specified not as a fully
 instantiated Component, but as a Component config object. The ptype will be looked up at render time up to determine
 what type of Plugin to create. If you create your own Plugins, you may register them using
 Ext.ComponentMgr.registerPlugin in order to be able to take advantage of lazy instantiation and rendering.]]></description><name>ptype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A path specification, relative to the Component's ownerCt specifying into which ancestor Container to place a named
 reference to this Component. The ancestor axis can be traversed by using '/' characters in the path. For example, to put
 a reference to a Toolbar Button into the Panel which owns the Toolbar: var myGrid = new Ext.grid.EditorGridPanel({
    
 title: 'My EditorGridPanel',
     store: myStore,
     colModel: myColModel,
     tbar: [{
         text: 'Save',
        
 handler: saveChanges,
         disabled: true,
         ref: '../saveButton'
     }],
     listeners: {
         afteredit:
 function() {
 //          The button reference is in the GridPanel
             myGrid.saveButton.enable();
         }
    
 }
 }); In the code above, if the ref had been 'saveButton' the reference would have been placed into the Toolbar. Each
 '/' in the ref moves up one level from the Component's ownerCt. Also see the added and removed events.]]></description><name>ref</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout layout manager (e.g. specifying layout:'border'). See Ext.layout.BorderLayout also.]]></description><name>region</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should trigger this component to save its state (defaults to none). stateEvents may
 be any type of event supported by this component, including browser or custom events (e.g., ['click',
 'customerchange']). See stateful for an explanation of saving and restoring Component state.]]></description><name>stateEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id for this component to use for state management purposes (defaults to the component id if one was set,
 otherwise null if the component is using a generated id). See stateful for an explanation of saving and restoring
 Component state.]]></description><name>stateId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A flag which causes the Component to attempt to restore the state of internal properties from a saved state on startup.
 The component must have either a stateId or id assigned for state to be managed. Auto-generated ids are not guaranteed
 to be stable across page loads and cannot be relied upon to save and restore the same state for a component. For state
 saving to work, the state manager's provider must have been set to an implementation of Ext.state.Provider which
 overrides the set and get methods to save and recall name/value pairs. A built-in implementation,
 Ext.state.CookieProvider is available. To set the state provider for the current page: Ext.state.Manager.setProvider(new
 Ext.state.CookieProvider({
     expires: new Date(new Date().getTime()+(1000*60*60*24*7)), //7 days from now
 })); A
 stateful Component attempts to save state when one of the events listed in the stateEvents configuration fires. To save
 state, a stateful Component first serializes its state by calling getState. By default, this function does nothing. The
 developer must provide an implementation which returns an object hash which represents the Component's restorable state.
 The value yielded by getState is passed to Ext.state.Manager.set which uses the configured Ext.state.Provider to save
 the object keyed by the Component's stateId, or, if that is not specified, its id. During construction, a stateful
 Component attempts to restore its state by calling Ext.state.Manager.get passing the stateId, or, if that is not
 specified, the id. The resulting object is passed to applyState. The default implementation of applyState simply copies
 properties into the object, but a developer may override this to support more behaviour. You can perform extra
 processing on state save and restore by attaching handlers to the beforestaterestore, staterestore, beforestatesave and
 statesave events.]]></description><name>stateful</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
     title: 'Some Title',
     renderTo: Ext.getBody(),
     width: 400, height:
 300,
     layout: 'form',
     items: [{
         xtype: 'textarea',
         style: {
             width: '95%',
            
 marginBottom: '10px'
         }
     },
         new Ext.Button({
             text: 'Send',
             minWidth: '100',
   
          style: {
                 marginBottom: '10px'
             }
         })
     ]
 });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is a child item of a TabPanel. A string to be used as innerHTML
 (html tags are accepted) to show in a tooltip when mousing over the associated tab selector element.
 Ext.QuickTips.init() must be called in order for the tips to render.]]></description><name>tabTip</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The plain text to display within the label (defaults to ''). If you need to include HTML tags within the label's
 innerHTML, use the html config instead.]]></description><name>text</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local x (left) coordinate for this component if contained within a positioning container.]]></description><name>x</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered xtype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a child item of a Container is being specified not
 as a fully instantiated Component, but as a Component config object. The xtype will be looked up at render time up to
 determine what type of child Component to create. The predefined xtypes are listed here. If you subclass Components to
 create your own Components, you may register them using Ext.ComponentMgr.registerType in order to be able to take
 advantage of lazy instantiation and rendering.]]></description><name>xtype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local y (top) coordinate for this component if contained within a positioning container.]]></description><name>y</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 Numeric text field that provides automatic keystroke filtering and numeric validation.]]></description><name>form.numberfield</name><tag-class>org.brushingbits.jnap.ui.extjs3.form.NumberField</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[The field's HTML name attribute (defaults to ''). Note: this property must be set if this field is to be automatically
 included with form submit().]]></description><name>name</name><required>true</required><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify false to validate that the value's length is > 0 (defaults to true)]]></description><name>allowBlank</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[False to disallow decimal values (defaults to true)]]></description><name>allowDecimals</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Whether the component can move the Dom node when rendering (defaults to true).]]></description><name>allowDomMove</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[False to prevent entering a negative sign (defaults to true)]]></description><name>allowNegative</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use an
 AnchorLayout (or subclass thereof). based layout manager, for example: Ext.form.FormPanel specifying layout: 'anchor' //
 or 'form', or 'absolute' See Ext.layout.AnchorLayout.anchor also.]]></description><name>anchor</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element corresponding to a DIV that is already present in
 the document that specifies some structural markup for this component. Description : When applyTo is used, constituent
 parts of the component can also be specified by id or CSS class name within the main element, and the component being
 created may attempt to create its subcomponents from that markup if applicable. Notes : When using this config, a call
 to render() is not required. If applyTo is specified, any value passed for renderTo will be ignored and the target
 element's parent node will automatically be used as the component's container.]]></description><name>applyTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A DomHelper element spec, or true for a default element spec. Used to create the Element which will encapsulate this
 Component. See autoEl for details. Defaults to: {tag: 'input', type: 'text', size: '20', autocomplete: 'off'}]]></description><name>autoCreate</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A tag name or DomHelper spec used to create the Element which will encapsulate this Component. You do not normally need
 to specify this. For the base classes Ext.Component, Ext.BoxComponent, and Ext.Container, this defaults to 'div'. The
 more complex Ext classes use a more complex DOM structure created by their own onRender methods. This is intended to
 allow the developer to create application-specific utility Components encapsulated by different DOM elements. Example
 usage: <pre><code>{
     xtype: 'box',
     autoEl: {
         tag: 'img',
         src: 'http://www.example.com/example.jpg'
     }
 },
 {
     xtype: 'box',
     autoEl: {
         tag: 'blockquote',
         html: 'autoEl is cool!'
     }
 }, {
     xtype: 'container',
     autoEl: 'ul',
     cls: 'ux-unordered-list',
     items: {
         xtype: 'box',
         autoEl: 'li',
   
      html: 'First list item'
     }
 }</pre></code>]]></description><name>autoEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to use height:'auto', false to use fixed height (or allow it to be managed by its parent Container's layout
 manager. Defaults to false. Note: Although many components inherit this config option, not all will function as expected
 with a height of 'auto'. Setting autoHeight:true means that the browser will manage height based on the element's
 contents, and that Ext will not manage it at all. If the browser is managing the height, be aware that resizes performed
 by the browser in response to changes within the structure of the Component cannot be detected. Therefore changes to the
 height might result in elements needing to be synchronized with the new height. Example: var w = new Ext.Window({
    
 title: 'Window',
     width: 600,
     autoHeight: true,
     items: {
         title: 'Collapse Me',
         height: 400,
  
 collapsible: true,
         border: false,
         listeners: {
             beforecollapse: function() {
                w.el.shadow.hide();
             },
             beforeexpand: function() {
                w.el.shadow.hide();
             },
             collapse: function() {
                w.syncShadow();
             },
             expand: function() {
                w.syncShadow();
             }
         }
     }
 }).show();]]></description><name>autoHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to use overflow:'auto' on the components layout element and show scroll bars automatically when necessary, false to
 clip any overflowing content (defaults to false).]]></description><name>autoScroll</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True if the component should check for hidden classes (e.g. 'x-hidden' or 'x-hide-display') and remove them on render
 (defaults to false).]]></description><name>autoShow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically strip not allowed characters from the field. Defaults to false]]></description><name>autoStripChars</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to use width:'auto', false to use fixed width (or allow it to be managed by its parent Container's layout manager.
 Defaults to false. Note: Although many components inherit this config option, not all will function as expected with a
 width of 'auto'. Setting autoWidth:true means that the browser will manage width based on the element's contents, and
 that Ext will not manage it at all. If the browser is managing the width, be aware that resizes performed by the browser
 in response to changes within the structure of the Component cannot be detected. Therefore changes to the width might
 result in elements needing to be synchronized with the new width. For example, where the target element is: <div
 id='grid-container' style='margin-left:25%;width:50%'></div> A Panel rendered into that target element must listen for
 browser window resize in order to relay its child items when the browser changes its width: var myPanel = new
 Ext.Panel({
     renderTo: 'grid-container',
     monitorResize: true, // relay on browser resize
     title: 'Panel',
    
 height: 400,
     autoWidth: true,
     layout: 'hbox',
     layoutConfig: {
         align: 'stretch'
     },
     defaults: {
         flex: 1
     },
     items: [{
         title: 'Box 1',
     }, {
         title: 'Box 2'
     }, {
         title:
 'Box 3'
     }],
 });]]></description><name>autoWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The base set of characters to evaluate as valid numbers (defaults to '0123456789').]]></description><name>baseChars</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The error text to display if the allowBlank validation fails (defaults to 'This field is required')]]></description><name>blankText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to [].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class used to to apply to the special clearing div rendered directly after each form field wrapper to provide
 field clearing (defaults to 'x-form-clear-left'). Note: this config is only used when this Component is rendered by a
 Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or specifying
 layout:'form') and either a fieldLabel is specified or isFormField=true is specified. See Ext.layout.FormLayout.fieldTpl
 also.]]></description><name>clearCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom CSS class to apply to the field's underlying element (defaults to '').]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's container. This can be useful for adding customized
 styles to the container or any of its children using standard CSS rules. See Ext.layout.ContainerLayout.extraCls also.
 Note: ctCls defaults to '' except for the following class which assigns a value by default: Box Layout :
 'x-box-layout-ct' To configure the above Class with an extra CSS class append to the default. For example, for BoxLayout
 (Hbox and Vbox): ctCls: 'x-box-layout-ct custom-class']]></description><name>ctCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum precision to display after the decimal separator (defaults to 2)]]></description><name>decimalPrecision</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Character(s) to allow as the decimal separator (defaults to '.')]]></description><name>decimalSeparator</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify true to disable input keystroke filtering (defaults to false)]]></description><name>disableKeyFilter</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to disable the field (defaults to false). Be aware that conformant with the HTML specification, disabled Fields
 will not be submitted.]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class added to the component when it is disabled (defaults to 'x-item-disabled').]]></description><name>disabledClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class to apply to an empty field to style the emptyText (defaults to 'x-form-empty-field'). This class is
 automatically added and removed as needed depending on the current field value.]]></description><name>emptyClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default text to place into an empty field (defaults to null). Note: that this value will be submitted to the server
 if this field is enabled and configured with a name.]]></description><name>emptyText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to enable the proxying of key events for the HTML input field (defaults to false)]]></description><name>enableKeyEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default CSS class for the field (defaults to "x-form-field x-form-num-field")]]></description><name>fieldClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The label text to display next to this Component (defaults to ''). Note: this config is only used when this Component is
 rendered by a Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or
 specifying layout:'form'). Also see hideLabel and Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
    
 height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name'
    
 }]
 });]]></description><name>fieldLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use a
 BoxLayout. Each child Component with a flex property will be flexed either vertically (by a VBoxLayout) or horizontally
 (by an HBoxLayout) according to the item's relative flex value compared to the sum of all Components with flex value
 specified. Any child items that have either a flex = 0 or flex = undefined will not be 'flexed' (the initial size will
 not be changed).]]></description><name>flex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class to use when the field receives focus (defaults to 'x-form-focus')]]></description><name>focusClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true if this field should automatically grow and shrink to its content (defaults to false)]]></description><name>grow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum width to allow when grow = true (defaults to 800)]]></description><name>growMax</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum width to allow when grow = true (defaults to 30)]]></description><name>growMin</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component hidden (default is false). If true, the hide method will be called internally.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to completely hide the label element (label and separator). Defaults to false. By default, even if you do not
 specify a fieldLabel the space will still be reserved so that the field will line up with other fields that do have
 labels. Setting this to true will cause the field to not reserve that space. Note: see the note for clearCls. Example
 use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield'
        
 hideLabel: true
     }]
 });]]></description><name>hideLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[How this component should be hidden. Supported values are 'visibility' (css visibility), 'offsets' (negative offset
 position) and 'display' (css display). Note: the default of 'display' is generally preferred since items are
 automatically laid out when they are first shown (no sizing is done while hidden).]]></description><name>hideMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide and show the component's container when hide/show is called on the component, false to hide and show the
 component itself (defaults to false). For example, this can be used as a shortcut for a hide button on a window by
 setting hide:true on the button when adding it to its parent container.]]></description><name>hideParent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id of this component (defaults to an auto-assigned id). You should assign an id if you need to be able to
 access the component later and you do not have an object reference available (e.g., using Ext.getCmp). Note that this id
 will also be used as the element id for the containing HTML element that is rendered to the page for this component.
 This allows you to write id-based CSS rules to style the specific instance of this component uniquely, and also to
 select sub-elements using this component's id as the parent. Note: to avoid complications imposed by a unique id also
 see itemId and ref. Note: to access the container of an item see ownerCt.]]></description><name>id</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The type attribute for input fields -- e.g. radio, text, password, file (defaults to 'text'). The types 'file' and
 'password' must be used to render those field types currently -- there are no separate Ext components for those. Note
 that if you use inputType:'file', emptyText is not supported and should be avoided.]]></description><name>inputType</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class to use when marking a field invalid (defaults to 'x-form-invalid')]]></description><name>invalidClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The error text to use when marking a field invalid and no message is provided (defaults to 'The value in this field is
 invalid')]]></description><name>invalidText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use the
 FormLayout layout manager (e.g. Ext.form.FormPanel or specifying layout:'form'). An additional CSS class to apply to the
 div wrapping the form item element of this field. If supplied, itemCls at the field level will override the default
 itemCls supplied at the container level. The value specified for itemCls will be added to the default class
 ('x-form-item'). Since it is applied to the item wrapper (see Ext.layout.FormLayout.fieldTpl), it allows you to write
 standard CSS rules that can apply to the field, the label (if specified), or any other element within the markup for the
 field. Note: see the note for fieldLabel. Example use: // Apply a style to the field's label:
 <style>
     .required
 .x-form-item-label {font-weight:bold;color:red;}
 </style>
 
 new Ext.FormPanel({
     height: 100,
     renderTo:
 Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         itemCls: 'required' //this
 label will be styled
     },{
         xtype: 'textfield',
         fieldLabel: 'Favorite Color'
     }]
 });]]></description><name>itemCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An itemId can be used as an alternative way to get a reference to a component when no object reference is available.
 Instead of using an id with Ext.getCmp, use itemId with Ext.Container.getComponent which will retrieve itemId's or id's.
 Since itemId's are an index to the container's internal MixedCollection, the itemId is scoped locally to the container
 -- avoiding potential conflicts with Ext.ComponentMgr which requires a unique id. var c = new Ext.Panel({ //
     height:
 300,
     renderTo: document.body,
     layout: 'auto',
     items: [
         {
             itemId: 'p1',
            
 title: 'Panel 1',
             height: 150
         },
         {
             itemId: 'p2',
             title: 'Panel 2',
  
 height: 150
         }
     ]
 })
 p1 = c.getComponent('p1'); // not the same as Ext.getCmp()
 p2 =
 p1.ownerCt.getComponent('p2'); // reference via a sibling Also see id and ref. Note: to access the container of an item
 see ownerCt.]]></description><name>itemId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The separator to display after the text of each fieldLabel. This property may be configured at various levels. The order
 of precedence is: field / component level container level layout level (defaults to colon ':') To display no separator
 for this field's label specify empty string ''. Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 layoutConfig: {
         labelSeparator: '~'   // layout config has lowest priority (defaults to ':')
     },
    
 labelSeparator: '>>',     // config at container level
     items: [{
         xtype: 'textfield',
         fieldLabel:
 'Field 1',
         labelSeparator: '...' // field/component level config supersedes others
     },{
         xtype:
 'textfield',
         fieldLabel: 'Field 2' // labelSeparator will be '='
     }]
 });]]></description><name>labelSeparator</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS style specification string to apply directly to this field's label. Defaults to the container's labelStyle value
 if set (e.g., Ext.layout.FormLayout.labelStyle , or ''). Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         labelStyle: 'font-weight:bold;'
     }]
 });]]></description><name>labelStyle</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout or one of the two BoxLayout subclasses. An object containing margins to apply to this BoxComponent in the
 format: {
     top: (top margin),
     right: (right margin),
     bottom: (bottom margin),
     left: (left margin)
 } May
 also be a string containing space-separated, numeric margin values. The order of the sides associated with each value
 matches the way CSS processes margin values: If there is only one value, it applies to all sides. If there are two
 values, the top and bottom borders are set to the first value and the right and left are set to the second. If there are
 three values, the top is set to the first value, the left and right are set to the second, and the bottom is set to the
 third. If there are four values, they apply to the top, right, bottom, and left, respectively. Defaults to: {top:0,
 right:0, bottom:0, left:0}]]></description><name>margins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An input mask regular expression that will be used to filter keystrokes that do not match (defaults to null). The maskRe
 will not operate on any paste events.]]></description><name>maskRe</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Maximum input field length allowed by validation (defaults to Number.MAX_VALUE). This behavior is intended to provide
 instant feedback to the user by improving usability to allow pasting and editing or overtyping and back tracking. To
 restrict the maximum number of characters that can be entered into the field use autoCreate to add any attributes you
 want to a field, for example: var myField = new Ext.form.NumberField({
     id: 'mobile',
     anchor:'90%',
    
 fieldLabel: 'Mobile',
     maxLength: 16, // for validation
     autoCreate: {tag: 'input', type: 'text', size: '20',
 autocomplete: 'off', maxlength: '10'}
 });]]></description><name>maxLength</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Error text to display if the maximum length validation fails (defaults to 'The maximum length for this field is
 {maxLength}')]]></description><name>maxLengthText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Error text to display if the maximum value validation fails (defaults to "The maximum value for this field is
 {maxValue}")]]></description><name>maxText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum allowed value (defaults to Number.MAX_VALUE)]]></description><name>maxValue</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Minimum input field length required (defaults to 0)]]></description><name>minLength</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Error text to display if the minimum length validation fails (defaults to 'The minimum length for this field is
 {minLength}')]]></description><name>minLengthText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Error text to display if the minimum value validation fails (defaults to "The minimum value for this field is
 {minValue}")]]></description><name>minText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum allowed value (defaults to Number.NEGATIVE_INFINITY)]]></description><name>minValue</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Experimental The effect used when displaying a validation message under the field (defaults to 'normal').]]></description><name>msgFx</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The location where the message text set through markInvalid should display. Must be one of the following values: qtip
 Display a quick tip containing the message when the user hovers over the field. This is the default. Ext.QuickTips.init
 must have been called for this setting to work. title Display the message in a default browser title attribute popup.
 under Add a block div beneath the field containing the error message. side Add an error icon to the right of the field,
 displaying the message in a popup on hover. [element id] Add the error message directly to the innerHTML of the
 specified element.]]></description><name>msgTarget</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Error text to display if the value is not a valid number. For example, this can happen if a valid character like '.' or
 '-' is left in the field with no number (defaults to "{value} is not a valid number")]]></description><name>nanText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element when the mouse moves over the Element, and
 removed when the mouse moves out. (defaults to ''). This can be useful for adding customized 'active' or 'hover' styles
 to the component or any of its children using standard CSS rules.]]></description><name>overCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level x coordinate for this component if contained within a positioning container.]]></description><name>pageX</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level y coordinate for this component if contained within a positioning container.]]></description><name>pageY</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to disable marking the field invalid. Defaults to false.]]></description><name>preventMark</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered ptype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a Plugin is being specified not as a fully
 instantiated Component, but as a Component config object. The ptype will be looked up at render time up to determine
 what type of Plugin to create. If you create your own Plugins, you may register them using
 Ext.ComponentMgr.registerPlugin in order to be able to take advantage of lazy instantiation and rendering.]]></description><name>ptype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to mark the field as readOnly in HTML (defaults to false). Note: this only sets the element's readOnly DOM
 attribute. Setting readOnly=true, for example, will not disable triggering a ComboBox or DateField; it gives you the
 option of forcing the user to choose via the trigger without typing in the text box. To hide the trigger use
 hideTrigger.]]></description><name>readOnly</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A path specification, relative to the Component's ownerCt specifying into which ancestor Container to place a named
 reference to this Component. The ancestor axis can be traversed by using '/' characters in the path. For example, to put
 a reference to a Toolbar Button into the Panel which owns the Toolbar: var myGrid = new Ext.grid.EditorGridPanel({
    
 title: 'My EditorGridPanel',
     store: myStore,
     colModel: myColModel,
     tbar: [{
         text: 'Save',
        
 handler: saveChanges,
         disabled: true,
         ref: '../saveButton'
     }],
     listeners: {
         afteredit:
 function() {
 //          The button reference is in the GridPanel
             myGrid.saveButton.enable();
         }
    
 }
 }); In the code above, if the ref had been 'saveButton' the reference would have been placed into the Toolbar. Each
 '/' in the ref moves up one level from the Component's ownerCt. Also see the added and removed events.]]></description><name>ref</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A JavaScript RegExp object to be tested against the field value during validation (defaults to null). If the test fails,
 the field will be marked invalid using regexText.]]></description><name>regex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The error text to display if regex is used and the test fails during validation (defaults to '')]]></description><name>regexText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout layout manager (e.g. specifying layout:'border'). See Ext.layout.BorderLayout also.]]></description><name>region</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to automatically select any existing field text when the field receives input focus (defaults to false)]]></description><name>selectOnFocus</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should trigger this component to save its state (defaults to none). stateEvents may
 be any type of event supported by this component, including browser or custom events (e.g., ['click',
 'customerchange']). See stateful for an explanation of saving and restoring Component state.]]></description><name>stateEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id for this component to use for state management purposes (defaults to the component id if one was set,
 otherwise null if the component is using a generated id). See stateful for an explanation of saving and restoring
 Component state.]]></description><name>stateId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A flag which causes the Component to attempt to restore the state of internal properties from a saved state on startup.
 The component must have either a stateId or id assigned for state to be managed. Auto-generated ids are not guaranteed
 to be stable across page loads and cannot be relied upon to save and restore the same state for a component. For state
 saving to work, the state manager's provider must have been set to an implementation of Ext.state.Provider which
 overrides the set and get methods to save and recall name/value pairs. A built-in implementation,
 Ext.state.CookieProvider is available. To set the state provider for the current page: Ext.state.Manager.setProvider(new
 Ext.state.CookieProvider({
     expires: new Date(new Date().getTime()+(1000*60*60*24*7)), //7 days from now
 })); A
 stateful Component attempts to save state when one of the events listed in the stateEvents configuration fires. To save
 state, a stateful Component first serializes its state by calling getState. By default, this function does nothing. The
 developer must provide an implementation which returns an object hash which represents the Component's restorable state.
 The value yielded by getState is passed to Ext.state.Manager.set which uses the configured Ext.state.Provider to save
 the object keyed by the Component's stateId, or, if that is not specified, its id. During construction, a stateful
 Component attempts to restore its state by calling Ext.state.Manager.get passing the stateId, or, if that is not
 specified, the id. The resulting object is passed to applyState. The default implementation of applyState simply copies
 properties into the object, but a developer may override this to support more behaviour. You can perform extra
 processing on state save and restore by attaching handlers to the beforestaterestore, staterestore, beforestatesave and
 statesave events.]]></description><name>stateful</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A JavaScript RegExp object used to strip unwanted content from the value before validation (defaults to null).]]></description><name>stripCharsRe</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
     title: 'Some Title',
     renderTo: Ext.getBody(),
     width: 400, height:
 300,
     layout: 'form',
     items: [{
         xtype: 'textarea',
         style: {
             width: '95%',
            
 marginBottom: '10px'
         }
     },
         new Ext.Button({
             text: 'Send',
             minWidth: '100',
   
          style: {
                 marginBottom: '10px'
             }
         })
     ]
 });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[False to clear the name attribute on the field so that it is not submitted during a form post. Defaults to true.]]></description><name>submitValue</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The tabIndex for this field. Note this only applies to fields that are rendered, not those which are built via applyTo
 (defaults to undefined).]]></description><name>tabIndex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is a child item of a TabPanel. A string to be used as innerHTML
 (html tags are accepted) to show in a tooltip when mousing over the associated tab selector element.
 Ext.QuickTips.init() must be called in order for the tips to render.]]></description><name>tabTip</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Whether the field should validate when it loses focus (defaults to true).]]></description><name>validateOnBlur</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The length of time in milliseconds after user input begins until validation is initiated (defaults to 250)]]></description><name>validationDelay</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The event that should initiate field validation. Set to false to disable automatic validation (defaults to 'keyup').]]></description><name>validationEvent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom validation function to be called during field validation (validateValue) (defaults to null). If specified, this
 function will be called first, allowing the developer to override the default validation process. This function will be
 passed the following Parameters: value: Mixed The current field value This function is to Return: true: Boolean true if
 the value is valid msg: String An error message if the value is invalid]]></description><name>validator</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A value to initialize this field with (defaults to undefined).]]></description><name>value</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A validation type name as defined in Ext.form.VTypes (defaults to null)]]></description><name>vtype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom error message to display in place of the default message provided for the vtype currently set for this field
 (defaults to ''). Note: only applies if vtype is set, else ignored.]]></description><name>vtypeText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local x (left) coordinate for this component if contained within a positioning container.]]></description><name>x</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered xtype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a child item of a Container is being specified not
 as a fully instantiated Component, but as a Component config object. The xtype will be looked up at render time up to
 determine what type of child Component to create. The predefined xtypes are listed here. If you subclass Components to
 create your own Components, you may register them using Ext.ComponentMgr.registerType in order to be able to take
 advantage of lazy instantiation and rendering.]]></description><name>xtype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local y (top) coordinate for this component if contained within a positioning container.]]></description><name>y</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 <p>Standard form container.</p> 
 <p><b><u>Layout</u></b></p> 
 <p>By default, FormPanel is configured with
 <tt>layout:'form'</tt> to use an <a href="output/Ext.layout.FormLayout.html"
 ext:cls="Ext.layout.FormLayout">Ext.layout.FormLayout</a> layout manager, which styles and renders fields and labels
 correctly. When nesting additional Containers within a FormPanel, you should ensure that any descendant Containers which
 host input Fields use the <a href="output/Ext.layout.FormLayout.html"
 ext:cls="Ext.layout.FormLayout">Ext.layout.FormLayout</a> layout manager.</p> 
 <p><b><u>BasicForm</u></b></p>
 
 <p>Although <b>not listed</b> as configuration options of FormPanel, the FormPanel class accepts all of the config
 options required to configure its internal <a href="output/Ext.form.BasicForm.html"
 ext:cls="Ext.form.BasicForm">Ext.form.BasicForm</a> for: </p>
 <div class="mdetail-params">
  <ul> 
   <li><a
 href="output/Ext.form.BasicForm.html#Ext.form.BasicForm-fileUpload" ext:member="fileUpload"
 ext:cls="Ext.form.BasicForm">file uploads</a></li> 
   <li>functionality for <a
 href="output/Ext.form.BasicForm.html#Ext.form.BasicForm-doAction" ext:member="doAction"
 ext:cls="Ext.form.BasicForm">loading, validating and submitting</a> the form</li> 
  </ul>
 </div> 
 <p><b>Note</b>: If
 subclassing FormPanel, any configuration options for the BasicForm must be applied to the <tt><b>initialConfig</b></tt>
 property of the FormPanel. Applying <a href="output/Ext.form.BasicForm.html" ext:cls="Ext.form.BasicForm">BasicForm</a>
 configuration settings to <b><tt>this</tt></b> will <b>not</b> affect the BasicForm's configuration.</p> 
 <p><b><u>Form
 Validation</u></b></p> 
 <p>For information on form validation see the following:</p> 
 <div class="mdetail-params">
  <ul>
 
   <li><a href="output/Ext.form.TextField.html" ext:cls="Ext.form.TextField">Ext.form.TextField</a></li> 
   <li><a
 href="output/Ext.form.VTypes.html" ext:cls="Ext.form.VTypes">Ext.form.VTypes</a></li> 
   <li><a
 href="output/Ext.form.BasicForm.html#Ext.form.BasicForm-doAction" ext:member="doAction"
 ext:cls="Ext.form.BasicForm">BasicForm.doAction <b>clientValidation</b> notes</a></li> 
   <li><tt><a
 href="output/Ext.form.FormPanel.html#Ext.form.FormPanel-monitorValid" ext:member="monitorValid"
 ext:cls="Ext.form.FormPanel">monitorValid</a></tt></li> 
  </ul>
 </div> 
 <p><b><u>Form Submission</u></b></p> 
 <p>By
 default, Ext Forms are submitted through Ajax, using <a href="output/Ext.form.Action.html"
 ext:cls="Ext.form.Action">Ext.form.Action</a>. To enable normal browser submission of the <a
 href="output/Ext.form.BasicForm.html" ext:cls="Ext.form.BasicForm">BasicForm</a> contained in this FormPanel, see the
 <tt><b><a href="output/Ext.form.BasicForm.html#Ext.form.BasicForm-standardSubmit" ext:member="standardSubmit"
 ext:cls="Ext.form.BasicForm">standardSubmit</a></b></tt> option.</p>]]></description><name>form.panel</name><tag-class>org.brushingbits.jnap.ui.extjs3.form.FormPanel</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[A string component id or the numeric index of the component that should be initially activated within the container's
 layout on render. For example, activeItem: 'item-1' or activeItem: 0 (index 0 = the first item in the container's
 collection). activeItem only applies to layout styles that can display items one at a time (like
 Ext.layout.AccordionLayout, Ext.layout.CardLayout and Ext.layout.FitLayout). Related to
 Ext.layout.ContainerLayout.activeItem.]]></description><name>activeItem</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Whether the component can move the Dom node when rendering (defaults to true).]]></description><name>allowDomMove</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use an
 AnchorLayout (or subclass thereof). based layout manager, for example: Ext.form.FormPanel specifying layout: 'anchor' //
 or 'form', or 'absolute' See Ext.layout.AnchorLayout.anchor also.]]></description><name>anchor</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to animate the transition when the panel is collapsed, false to skip the animation (defaults to true if the Ext.Fx
 class is available, otherwise false).]]></description><name>animCollapse</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If specified load and submit actions will be handled with Ext.form.Action.DirectLoad and Ext.form.Action.DirectSubmit.
 Methods which have been imported by Ext.Direct can be specified here to load and submit forms. Such as the following:
 api: {
     load: App.ss.MyProfile.load,
     submit: App.ss.MyProfile.submit
 } Load actions can use paramOrder or
 paramsAsHash to customize how the load method is invoked. Submit actions will always use a standard form submit. The
 formHandler configuration must be set on the associated server-side method which has been imported by Ext.Direct]]></description><name>api</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The id of the node, a DOM node or an existing Element corresponding to a DIV that is already present in the document
 that specifies some panel-specific structural markup. When applyTo is used, constituent parts of the panel can be
 specified by CSS class name within the main element, and the panel will automatically create those components from that
 markup. Any required components not specified in the markup will be autogenerated if necessary. The following class
 names are supported (baseCls will be replaced by baseCls): baseCls + '-header' baseCls + '-header-text' baseCls +
 '-bwrap' baseCls + '-tbar' baseCls + '-body' baseCls + '-bbar' baseCls + '-footer' Using this config, a call to render()
 is not required. If applyTo is specified, any value passed for renderTo will be ignored and the target element's parent
 node will automatically be used as the panel's container.]]></description><name>applyTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If true the container will automatically destroy any contained component that is removed from it, else destruction must
 be handled manually (defaults to true).]]></description><name>autoDestroy</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A tag name or DomHelper spec used to create the Element which will encapsulate this Component. You do not normally need
 to specify this. For the base classes Ext.Component, Ext.BoxComponent, and Ext.Container, this defaults to 'div'. The
 more complex Ext classes use a more complex DOM structure created by their own onRender methods. This is intended to
 allow the developer to create application-specific utility Components encapsulated by different DOM elements. Example
 usage: <pre><code>{
     xtype: 'box',
     autoEl: {
         tag: 'img',
         src: 'http://www.example.com/example.jpg'
     }
 },
 {
     xtype: 'box',
     autoEl: {
         tag: 'blockquote',
         html: 'autoEl is cool!'
     }
 }, {
     xtype: 'container',
     autoEl: 'ul',
     cls: 'ux-unordered-list',
     items: {
         xtype: 'box',
         autoEl: 'li',
   
      html: 'First list item'
     }
 }</pre></code>]]></description><name>autoEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to use height:'auto', false to use fixed height (defaults to false). Note: Setting autoHeight: true means that the
 browser will manage the panel's height based on its contents, and that Ext will not manage it at all. If the panel is
 within a layout that manages dimensions (fit, border, etc.) then setting autoHeight: true can cause issues with
 scrolling and will not generally work as expected since the panel will take on the height of its contents rather than
 the height required by the Ext layout.]]></description><name>autoHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A valid url spec according to the Updater Ext.Updater.update method. If autoLoad is not null, the panel will attempt to
 load its contents immediately upon render. The URL will become the default URL for this panel's body element, so it may
 be refreshed at any time.]]></description><name>autoLoad</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to use overflow:'auto' on the components layout element and show scroll bars automatically when necessary, false to
 clip any overflowing content (defaults to false).]]></description><name>autoScroll</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True if the component should check for hidden classes (e.g. 'x-hidden' or 'x-hide-display') and remove them on render
 (defaults to false).]]></description><name>autoShow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to use width:'auto', false to use fixed width (or allow it to be managed by its parent Container's layout manager.
 Defaults to false. Note: Although many components inherit this config option, not all will function as expected with a
 width of 'auto'. Setting autoWidth:true means that the browser will manage width based on the element's contents, and
 that Ext will not manage it at all. If the browser is managing the width, be aware that resizes performed by the browser
 in response to changes within the structure of the Component cannot be detected. Therefore changes to the width might
 result in elements needing to be synchronized with the new width. For example, where the target element is: <div
 id='grid-container' style='margin-left:25%;width:50%'></div> A Panel rendered into that target element must listen for
 browser window resize in order to relay its child items when the browser changes its width: var myPanel = new
 Ext.Panel({
     renderTo: 'grid-container',
     monitorResize: true, // relay on browser resize
     title: 'Panel',
    
 height: 400,
     autoWidth: true,
     layout: 'hbox',
     layoutConfig: {
         align: 'stretch'
     },
     defaults: {
         flex: 1
     },
     items: [{
         title: 'Box 1',
     }, {
         title: 'Box 2'
     }, {
         title:
 'Box 3'
     }],
 });]]></description><name>autoWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The base CSS class to apply to this panel's element (defaults to 'x-panel'). Another option available by default is to
 specify 'x-plain' which strips all styling except for required attributes for Ext layouts to function (e.g.
 overflow:hidden). See unstyled also.]]></description><name>baseCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Parameters to pass with all requests. e.g. baseParams: {id: '123', foo: 'bar'}. Parameters are encoded as standard HTTP
 parameters using Ext.urlEncode.]]></description><name>baseParams</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to display an interior border on the body element of the panel, false to hide it (defaults to true). This only
 applies when border == true. If border == true and bodyBorder == false, the border will display as a 1px wide inset
 border, giving the entire body element an inset appearance.]]></description><name>bodyBorder</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A DomHelper element specification object may be specified for any Panel Element. By default, the Default element in the
 table below will be used for the html markup to create a child element with the commensurate Default class name (baseCls
 will be replaced by baseCls): 
 Panel      Default  Default             Custom      Additional       Additional
 Element  
 element  class               element     class            style
 ========   ==========================   =========  
 ==============   ===========
 header     div      baseCls+'-header'   headerCfg   headerCssClass   headerStyle
 bwrap     
 div      baseCls+'-bwrap'     bwrapCfg    bwrapCssClass    bwrapStyle
 + tbar     div      baseCls+'-tbar'       tbarCfg 
 tbarCssClass     tbarStyle
 + body     div      baseCls+'-body'       bodyCfg     bodyCssClass     bodyStyle
 + bbar    
 div      baseCls+'-bbar'       bbarCfg     bbarCssClass     bbarStyle
 + footer   div      baseCls+'-footer'   footerCfg 
 footerCssClass   footerStyle
  Configuring a Custom element may be used, for example, to force the body Element to use a
 different form of markup than is created by default. An example of this might be to create a child Panel containing a
 custom content, such as a header, or forcing centering of all Panel content by having the body be a <center> element:
 new Ext.Panel({
     title: 'Message Title',
     renderTo: Ext.getBody(),
     width: 200, height: 130,
     bodyCfg: {
    
 tag: 'center',
         cls: 'x-panel-body',  // Default class not applied if Custom element specified
         html:
 'Message'
     },
     footerCfg: {
         tag: 'h2',
         cls: 'x-panel-footer',        // same as the Default class
 
 html: 'footer html'
     },
     footerCssClass: 'custom-footer', // additional css class, see addClass
     footerStyle:  
 'background-color:red' // see bodyStyle
 }); The example above also explicitly creates a footer with custom markup and
 styling applied.]]></description><name>bodyCfg</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Additional css class selector to be applied to the body element in the format expected by Ext.Element.addClass (defaults
 to null). See bodyCfg.]]></description><name>bodyCssClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Custom CSS styles to be applied to the body element in the format expected by Ext.Element.applyStyles (defaults to
 null). See bodyCfg.]]></description><name>bodyStyle</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to display the borders of the panel's body element, false to hide them (defaults to true). By default, the border
 is a 2px wide inset border, but this can be further altered by setting bodyBorder to false.]]></description><name>border</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to ['add', 'remove'].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[When set to true (50 milliseconds) or a number of milliseconds, the layout assigned for this container will buffer the
 frequency it calculates and does a re-layout of components. This is useful for heavy containers or containers with a
 large quantity of sub-components for which frequent layout calls would be expensive. Defaults to 50.]]></description><name>bufferResize</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The alignment of any buttons added to this panel. Valid values are 'right', 'left' and 'center' (defaults to 'right').]]></description><name>buttonAlign</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A DomHelper element specification object specifying the element structure of this Panel's bwrap Element. See bodyCfg
 also.]]></description><name>bwrapCfg</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class used to to apply to the special clearing div rendered directly after each form field wrapper to provide
 field clearing (defaults to 'x-form-clear-left'). Note: this config is only used when this Component is rendered by a
 Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or specifying
 layout:'form') and either a fieldLabel is specified or isFormField=true is specified. See Ext.layout.FormLayout.fieldTpl
 also.]]></description><name>clearCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Panels themselves do not directly support being closed, but some Panel subclasses do (like Ext.Window) or a Panel Class
 within an Ext.TabPanel. Specify true to enable closing in such situations. Defaults to false.]]></description><name>closable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element (defaults to ''). This can be useful for
 adding customized styles to the component or any of its children using standard CSS rules.]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to make sure the collapse/expand toggle button always renders first (to the left of) any other tools in the panel's
 title bar, false to render it last (defaults to true).]]></description><name>collapseFirst</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to render the panel collapsed, false to render it expanded (defaults to false).]]></description><name>collapsed</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS class to add to the panel's element after it has been collapsed (defaults to 'x-panel-collapsed').]]></description><name>collapsedCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to make the panel collapsible and have the expand/collapse toggle button automatically rendered into the header
 tool button area, false to keep the panel statically sized with no button (defaults to false).]]></description><name>collapsible</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's container. This can be useful for adding customized
 styles to the container or any of its children using standard CSS rules. See Ext.layout.ContainerLayout.extraCls also.
 Note: ctCls defaults to '' except for the following class which assigns a value by default: Box Layout :
 'x-box-layout-ct' To configure the above Class with an extra CSS class append to the default. For example, for BoxLayout
 (Hbox and Vbox): ctCls: 'x-box-layout-ct custom-class']]></description><name>ctCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default xtype of child Components to create in this Container when a child item is specified as a raw configuration
 object, rather than as an instantiated Component. Defaults to 'panel', except Ext.menu.Menu which defaults to
 'menuitem', and Ext.Toolbar and Ext.ButtonGroup which default to 'button'.]]></description><name>defaultType</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[This option is a means of applying default settings to all added items whether added through the items config or via the
 add or insert methods. If an added item is a config object, and not an instantiated Component, then the default
 properties are unconditionally applied. If the added item is an instantiated Component, then the default properties are
 applied conditionally so as not to override existing properties in the item. If the defaults option is specified as a
 function, then the function will be called using this Container as the scope (this reference) and passing the added item
 as the first parameter. Any resulting object from that call is then applied to the item as default properties. For
 example, to automatically apply padding to the body of each of a set of contained Ext.Panel items, you could pass:
 defaults: {bodyStyle:'padding:15px'}. Usage: defaults: {               // defaults are applied to items, not the
 container
     autoScroll:true
 },
 items: [
     {
         xtype: 'panel',   // defaults do not have precedence over
       
 id: 'panel1',     // options in config objects, so the defaults
         autoScroll: false // will not be applied here,
 panel1 will be autoScroll:false
     },
     new Ext.Panel({       // defaults do have precedence over options
         id:
 'panel2',     // options in components, so the defaults
         autoScroll: false // will be applied here, panel2 will
 be autoScroll:true.
     })
 ]]]></description><name>defaults</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this panel disabled (default is false). An important note when using the disabled config on panels is that IE
 will often fail to initialize the disabled mask element correectly if the panel's layout has not yet completed by the
 time the Panel is disabled during the render process. If you experience this issue, you may need to instead use the
 afterlayout event to initialize the disabled state: new Ext.Panel({
     ...
     listeners: {
         'afterlayout': {
   
 fn: function(p){
                 p.disable();
             },
             single: true // important, as many layouts can
 occur
         }
     }
 });]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class added to the component when it is disabled (defaults to 'x-item-disabled').]]></description><name>disabledClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to enable dragging of this Panel (defaults to false). For custom drag/drop implementations, an Ext.Panel.DD config
 could also be passed in this config instead of true. Ext.Panel.DD is an internal, undocumented class which moves a proxy
 Element around in place of the Panel's element, but provides no other behaviour during dragging or on drop. It is a
 subclass of Ext.dd.DragSource, so behaviour may be added by implementing the interface methods of Ext.dd.DragDrop e.g.:
 new Ext.Panel({
     title: 'Drag me',
     x: 100,
     y: 100,
     renderTo: Ext.getBody(),
     floating: true,
    
 frame: true,
     width: 400,
     height: 200,
     draggable: {
 //      Config option of Ext.Panel.DD class.
 //      It's
 a floating Panel, so do not show a placeholder proxy in the original position.
         insertProxy: false,
 
 //     
 Called for each mousemove event while dragging the DD object.
         onDrag : function(e){
 //          Record the x,y
 position of the drag proxy so that we can
 //          position the Panel at end of drag.
             var pel =
 this.proxy.getEl();
             this.x = pel.getLeft(true);
             this.y = pel.getTop(true);
 
 //          Keep the
 Shadow aligned if there is one.
             var s = this.panel.getEl().shadow;
             if (s) {
                
 s.realign(this.x, this.y, pel.getWidth(), pel.getHeight());
             }
         },
 
 //      Called on the mouseup
 event.
         endDrag : function(e){
             this.panel.setPosition(this.x, this.y);
         }
     }
 }).show();]]></description><name>draggable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A comma-delimited list of panel elements to initialize when the panel is rendered. Normally, this list will be generated
 automatically based on the items added to the panel at config time, but sometimes it might be useful to make sure a
 structural element is rendered even if not specified at config time (for example, you may want to add a button or
 toolbar dynamically after the panel has been rendered). Adding those elements to this list will allocate the required
 placeholders in the panel when it is rendered. Valid values are header tbar (top bar) body bbar (bottom bar) footer
 Defaults to 'body'.]]></description><name>elements</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An Ext.data.DataReader (e.g. Ext.data.XmlReader) to be used to read field error messages returned from 'submit' actions.
 This is optional as there is built-in support for processing JSON. The Records which provide messages for the invalid
 Fields must use the Field name (or id) as the Record ID, and must contain a field called 'msg' which contains the error
 message. The errorReader does not have to be a full-blown implementation of a DataReader. It simply needs to implement a
 read(xhr) function which returns an Array of Records in an object with the following structure: {
     records:
 recordArray
 }]]></description><name>errorReader</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A Toolbar object, a Toolbar config, or an array of Buttons/Button configs, describing a Toolbar to be rendered into this
 Panel's footer element. After render, the fbar property will be an Toolbar instance. If buttons are specified, they will
 supersede the fbar configuration property. The Panel's buttonAlign configuration affects the layout of these items, for
 example: var w = new Ext.Window({
     height: 250,
     width: 500,
     bbar: new Ext.Toolbar({
         items: [{
        
 text: 'bbar Left'
         },'->',{
             text: 'bbar Right'
         }]
     }),
     buttonAlign: 'left', //
 anything but 'center' or 'right' and you can use '-', and '->'
                                   // to control the
 alignment of fbar items
     fbar: [{
         text: 'fbar Left'
     },'->',{
         text: 'fbar Right'
     }]
 }).show();
 Note: Although a Toolbar may contain Field components, these will not be updated by a load of an ancestor FormPanel. A
 Panel's toolbars are not part of the standard Container->Component hierarchy, and so are not scanned to collect form
 items. However, the values will be submitted because form submission parameters are collected from the DOM tree.]]></description><name>fbar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The label text to display next to this Component (defaults to ''). Note: this config is only used when this Component is
 rendered by a Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or
 specifying layout:'form'). Also see hideLabel and Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
    
 height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name'
    
 }]
 });]]></description><name>fieldLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Set to true if this form is a file upload. File uploads are not performed using normal 'Ajax' techniques, that is they
 are not performed using XMLHttpRequests. Instead the form is submitted in the standard manner with the DOM <form>
 element temporarily modified to have its target set to refer to a dynamically generated, hidden <iframe> which is
 inserted into the document but removed after the return data has been gathered. The server response is parsed by the
 browser to create the document for the IFRAME. If the server is using JSON to send the return object, then the
 Content-Type header must be set to "text/html" in order to tell the browser to insert the text unchanged into the
 document body. Characters which are significant to an HTML parser must be sent as HTML entities, so encode "<" as
 "&lt;", "&" as "&amp;" etc. The response text is retrieved from the document, and a fake XMLHttpRequest object is
 created containing a responseText property in order to conform to the requirements of event handlers and callbacks. Be
 aware that file upload packets are sent with the content type multipart/form and some server technologies (notably JEE)
 may require some custom processing in order to retrieve parameter names and parameter values from the packet content.]]></description><name>fileUpload</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use a
 BoxLayout. Each child Component with a flex property will be flexed either vertically (by a VBoxLayout) or horizontally
 (by an HBoxLayout) according to the item's relative flex value compared to the sum of all Components with flex value
 specified. Any child items that have either a flex = 0 or flex = undefined will not be 'flexed' (the initial size will
 not be changed).]]></description><name>flex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[This property is used to configure the underlying Ext.Layer. Acceptable values for this configuration property are:
 false : Default. Display the panel inline where it is rendered. true : Float the panel (absolute position it with
 automatic shimming and shadow). Setting floating to true will create an Ext.Layer for this panel and display the panel
 at negative offsets so that it is hidden. Since the panel will be absolute positioned, the position must be set
 explicitly after render (e.g., myPanel.setPosition(100,100);). Note: when floating a panel you should always assign a
 fixed width, otherwise it will be auto width and will expand to fill to the right edge of the viewport. object : The
 specified object will be used as the configuration object for the Ext.Layer that will be created.]]></description><name>floating</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to create the footer element explicitly, false to skip creating it. The footer will be created automatically if
 buttons or a fbar have been configured. See bodyCfg for an example.]]></description><name>footer</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A DomHelper element specification object specifying the element structure of this Panel's footer Element. See bodyCfg
 also.]]></description><name>footerCfg</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If true the container will force a layout initially even if hidden or collapsed. This option is useful for forcing forms
 to render in collapsed or hidden containers. (defaults to false).]]></description><name>forceLayout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The id of the FORM tag (defaults to an auto-generated id).]]></description><name>formId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[false by default to render with plain 1px square borders. true to render with 9 elements, complete with custom rounded
 corners (also see Ext.Element.boxWrap). The template generated for each condition is depicted below: // frame =
 false
 <div id="developer-specified-id-goes-here" class="x-panel">
 
     <div class="x-panel-header"><span
 class="x-panel-header-text">Title: (frame:false)</span></div>
 
     <div class="x-panel-bwrap">
         <div
 class="x-panel-body"><p>html value goes here</p></div>
     </div>
 </div>
 
 // frame = true (create 9 elements)
 <div
 id="developer-specified-id-goes-here" class="x-panel">
     <div class="x-panel-tl"><div class="x-panel-tr"><div
 class="x-panel-tc">
         <div class="x-panel-header"><span class="x-panel-header-text">Title:
 (frame:true)</span></div>
     </div></div></div>
 
     <div class="x-panel-bwrap">
         <div class="x-panel-ml"><div
 class="x-panel-mr"><div class="x-panel-mc">
             <div class="x-panel-body"><p>html value goes here</p></div>
     
 </div></div></div>
 
         <div class="x-panel-bl"><div class="x-panel-br"><div class="x-panel-bc"/>
        
 </div></div></div>
 </div>]]></description><name>frame</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to create the Panel's header element explicitly, false to skip creating it. If a title is set the header will be
 created automatically, otherwise it will not. If a title is set but header is explicitly set to false, the header will
 not be rendered.]]></description><name>header</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to display the panel title in the header, false to hide it (defaults to true).]]></description><name>headerAsText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A DomHelper element specification object specifying the element structure of this Panel's header Element. See bodyCfg
 also.]]></description><name>headerCfg</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component hidden (default is false). If true, the hide method will be called internally.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide the borders of each contained component, false to defer to the component's existing border settings
 (defaults to false).]]></description><name>hideBorders</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to hide the expand/collapse toggle button when collapsible == true, false to display it (defaults to false).]]></description><name>hideCollapseTool</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to completely hide the label element (label and separator). Defaults to false. By default, even if you do not
 specify a fieldLabel the space will still be reserved so that the field will line up with other fields that do have
 labels. Setting this to true will cause the field to not reserve that space. Note: see the note for clearCls. Example
 use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield'
        
 hideLabel: true
     }]
 });]]></description><name>hideLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to hide field labels by default (sets display:none). Defaults to false. Also see Ext.Component.hideLabel.]]></description><name>hideLabels</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[How this component should be hidden. Supported values are 'visibility' (css visibility), 'offsets' (negative offset
 position) and 'display' (css display). Note: the default of 'display' is generally preferred since items are
 automatically laid out when they are first shown (no sizing is done while hidden).]]></description><name>hideMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide and show the component's container when hide/show is called on the component, false to hide and show the
 component itself (defaults to false). For example, this can be used as a shortcut for a hide button on a window by
 setting hide:true on the button when adding it to its parent container.]]></description><name>hideParent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class selector that specifies a background image to be used as the header icon (defaults to ''). An example of
 specifying a custom icon class would be something like: // specify the property in the config for the class:
      ...
   
 iconCls: 'my-icon'
 
 // css class that specifies background image to be used as the icon image:
 .my-icon {
 background-image: url(../images/my-icon.gif) 0 6px no-repeat !important; }]]></description><name>iconCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id of this component (defaults to an auto-assigned id). You should assign an id if you need to be able to
 access the component later and you do not have an object reference available (e.g., using Ext.getCmp). Note that this id
 will also be used as the element id for the containing HTML element that is rendered to the page for this component.
 This allows you to write id-based CSS rules to style the specific instance of this component uniquely, and also to
 select sub-elements using this component's id as the parent. Note: to avoid complications imposed by a unique id also
 see itemId and ref. Note: to access the container of an item see ownerCt.]]></description><name>id</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A css class to apply to the x-form-item of fields. This property cascades to child containers.]]></description><name>itemCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An itemId can be used as an alternative way to get a reference to a component when no object reference is available.
 Instead of using an id with Ext.getCmp, use itemId with Ext.Container.getComponent which will retrieve itemId's or id's.
 Since itemId's are an index to the container's internal MixedCollection, the itemId is scoped locally to the container
 -- avoiding potential conflicts with Ext.ComponentMgr which requires a unique id. var c = new Ext.Panel({ //
     height:
 300,
     renderTo: document.body,
     layout: 'auto',
     items: [
         {
             itemId: 'p1',
            
 title: 'Panel 1',
             height: 150
         },
         {
             itemId: 'p2',
             title: 'Panel 2',
  
 height: 150
         }
     ]
 })
 p1 = c.getComponent('p1'); // not the same as Ext.getCmp()
 p2 =
 p1.ownerCt.getComponent('p2'); // reference via a sibling Also see id and ref. Note: to access the container of an item
 see ownerCt.]]></description><name>itemId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A Ext.KeyMap config object (in the format expected by Ext.KeyMap.addBinding used to assign custom key handling to this
 panel (defaults to null).]]></description><name>keys</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The label alignment value used for the text-align specification for the container. Valid values are "left", "top" or
 "right" (defaults to "left"). This property cascades to child containers and can be overridden on any child container
 (e.g., a fieldset can specify a different labelAlign for its fields).]]></description><name>labelAlign</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default padding in pixels for field labels (defaults to 5). labelPad only applies if labelWidth is also specified,
 otherwise it will be ignored.]]></description><name>labelPad</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[See Ext.Component.labelSeparator]]></description><name>labelSeparator</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS style specification string to apply directly to this field's label. Defaults to the container's labelStyle value
 if set (e.g., Ext.layout.FormLayout.labelStyle , or ''). Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         labelStyle: 'font-weight:bold;'
     }]
 });]]></description><name>labelStyle</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of labels in pixels. This property cascades to child containers and can be overridden on any child container
 (e.g., a fieldset can specify a different labelWidth for its fields) (defaults to 100).]]></description><name>labelWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to 'form'. Normally this configuration property should not be altered. For additional details see
 Ext.layout.FormLayout and Ext.Container.layout.]]></description><name>layout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout or one of the two BoxLayout subclasses. An object containing margins to apply to this BoxComponent in the
 format: {
     top: (top margin),
     right: (right margin),
     bottom: (bottom margin),
     left: (left margin)
 } May
 also be a string containing space-separated, numeric margin values. The order of the sides associated with each value
 matches the way CSS processes margin values: If there is only one value, it applies to all sides. If there are two
 values, the top and bottom borders are set to the first value and the right and left are set to the second. If there are
 three values, the top is set to the first value, the left and right are set to the second, and the bottom is set to the
 third. If there are four values, they apply to the top, right, bottom, and left, respectively. Defaults to: {top:0,
 right:0, bottom:0, left:0}]]></description><name>margins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to mask the panel when it is disabled, false to not mask it (defaults to true). Either way, the panel will always
 tell its contained elements to disable themselves when it is disabled, but masking the panel can provide an additional
 visual cue that the panel is disabled.]]></description><name>maskDisabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The request method to use (GET or POST) for form actions if one isn't supplied in the action options.]]></description><name>method</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Minimum width of all buttons in pixels (defaults to 75).]]></description><name>minButtonWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The milliseconds to poll valid state, ignored if monitorValid is not true (defaults to 200)]]></description><name>monitorPoll</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically monitor window resize events to handle anything that is sensitive to the current size of the
 viewport. This value is typically managed by the chosen layout and should not need to be set manually.]]></description><name>monitorResize</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If true, the form monitors its valid state client-side and regularly fires the clientvalidation event passing that
 state. When monitoring valid state, the FormPanel enables/disables any of its configured buttons which have been
 configured with formBind: true depending on whether the form is valid or not. Defaults to false]]></description><name>monitorValid</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element when the mouse moves over the Element, and
 removed when the mouse moves out. (defaults to ''). This can be useful for adding customized 'active' or 'hover' styles
 to the component or any of its children using standard CSS rules.]]></description><name>overCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A shortcut for setting a padding style on the body element. The value can either be a number to be applied to all sides,
 or a normal css string describing padding. Defaults to undefined.]]></description><name>padding</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level x coordinate for this component if contained within a positioning container.]]></description><name>pageX</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level y coordinate for this component if contained within a positioning container.]]></description><name>pageY</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A list of params to be executed server side. Defaults to undefined. Only used for the api load configuration. Specify
 the params in the order in which they must be executed on the server-side as either (1) an Array of String values, or
 (2) a String of params delimited by either whitespace, comma, or pipe. For example, any of the following would be
 acceptable: paramOrder: ['param1','param2','param3']
 paramOrder: 'param1 param2 param3'
 paramOrder:
 'param1,param2,param3'
 paramOrder: 'param1|param2|param']]></description><name>paramOrder</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Only used for the api load configuration. Send parameters as a collection of named arguments (defaults to false).
 Providing a paramOrder nullifies this configuration.]]></description><name>paramsAsHash</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to false. When set to true, an extra css class 'x-panel-normal' will be added to the panel's element,
 effectively applying css styles suggested by the W3C (see http://www.w3.org/TR/CSS21/sample.html) to the Panel's body
 element (not the header, footer, etc.).]]></description><name>preventBodyReset</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered ptype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a Plugin is being specified not as a fully
 instantiated Component, but as a Component config object. The ptype will be looked up at render time up to determine
 what type of Plugin to create. If you create your own Plugins, you may register them using
 Ext.ComponentMgr.registerPlugin in order to be able to take advantage of lazy instantiation and rendering.]]></description><name>ptype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An Ext.data.DataReader (e.g. Ext.data.XmlReader) to be used to read data when executing 'load' actions. This is optional
 as there is built-in support for processing JSON. For additional information on using an XMLReader see the example
 provided in examples/form/xml-form.html.]]></description><name>reader</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A path specification, relative to the Component's ownerCt specifying into which ancestor Container to place a named
 reference to this Component. The ancestor axis can be traversed by using '/' characters in the path. For example, to put
 a reference to a Toolbar Button into the Panel which owns the Toolbar: var myGrid = new Ext.grid.EditorGridPanel({
    
 title: 'My EditorGridPanel',
     store: myStore,
     colModel: myColModel,
     tbar: [{
         text: 'Save',
        
 handler: saveChanges,
         disabled: true,
         ref: '../saveButton'
     }],
     listeners: {
         afteredit:
 function() {
 //          The button reference is in the GridPanel
             myGrid.saveButton.enable();
         }
    
 }
 }); In the code above, if the ref had been 'saveButton' the reference would have been placed into the Toolbar. Each
 '/' in the ref moves up one level from the Component's ownerCt. Also see the added and removed events.]]></description><name>ref</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout layout manager (e.g. specifying layout:'border'). See Ext.layout.BorderLayout also.]]></description><name>region</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The event to listen to for resizing in layouts. Defaults to 'bodyresize'.]]></description><name>resizeEvent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true (or a valid Ext.Shadow Ext.Shadow.mode value) to display a shadow behind the panel, false to display no shadow
 (defaults to 'sides'). Note that this option only applies when floating = true.]]></description><name>shadow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The number of pixels to offset the shadow if displayed (defaults to 4). Note that this option only applies when floating
 = true.]]></description><name>shadowOffset</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[false to disable the iframe shim in browsers which need one (defaults to true). Note that this option only applies when
 floating = true.]]></description><name>shim</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If set to true, standard HTML form submits are used instead of XHR (Ajax) style form submissions. Defaults to false.
 Note: When using standardSubmit, the options to submit are ignored because Ext's Ajax infrastracture is bypassed. To
 pass extra parameters (e.g. baseParams and params), utilize hidden fields to submit extra data, for example:
 <pre>new Ext.FormPanel({
     standardSubmit: true,
     baseParams: {
         foo: 'bar'
     },
     url: 'myProcess.php',
    
 items: [{
         xtype: 'textfield',
         name: 'userName'
     }],
     buttons: [{
         text: 'Save',
        
 handler: function(){
             var fp = this.ownerCt.ownerCt,
                 form = fp.getForm();
             if (form.isValid()) {
                 // check if there are baseParams and if
                 // hiddent items have been added already
                 if (fp.baseParams && !fp.paramsAdded) {
                     // add hidden items for all baseParams
                     for (i in fp.baseParams) {
                         fp.add({
                            
 xtype: 'hidden',
                             name: i,
                             value: fp.baseParams[i]
               
 });
                     }
                     fp.doLayout();
                     // set a custom flag to prevent
 re-adding
                     fp.paramsAdded = true;
                 }
                 form.submit();
             }
     
    }
     }]
 });</pre>]]></description><name>standardSubmit</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should trigger this component to save its state (defaults to none). stateEvents may
 be any type of event supported by this component, including browser or custom events (e.g., ['click',
 'customerchange']). See stateful for an explanation of saving and restoring Component state.]]></description><name>stateEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id for this component to use for state management purposes (defaults to the component id if one was set,
 otherwise null if the component is using a generated id). See stateful for an explanation of saving and restoring
 Component state.]]></description><name>stateId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A flag which causes the Component to attempt to restore the state of internal properties from a saved state on startup.
 The component must have either a stateId or id assigned for state to be managed. Auto-generated ids are not guaranteed
 to be stable across page loads and cannot be relied upon to save and restore the same state for a component. For state
 saving to work, the state manager's provider must have been set to an implementation of Ext.state.Provider which
 overrides the set and get methods to save and recall name/value pairs. A built-in implementation,
 Ext.state.CookieProvider is available. To set the state provider for the current page: Ext.state.Manager.setProvider(new
 Ext.state.CookieProvider({
     expires: new Date(new Date().getTime()+(1000*60*60*24*7)), //7 days from now
 })); A
 stateful Component attempts to save state when one of the events listed in the stateEvents configuration fires. To save
 state, a stateful Component first serializes its state by calling getState. By default, this function does nothing. The
 developer must provide an implementation which returns an object hash which represents the Component's restorable state.
 The value yielded by getState is passed to Ext.state.Manager.set which uses the configured Ext.state.Provider to save
 the object keyed by the Component's stateId, or, if that is not specified, its id. During construction, a stateful
 Component attempts to restore its state by calling Ext.state.Manager.get passing the stateId, or, if that is not
 specified, the id. The resulting object is passed to applyState. The default implementation of applyState simply copies
 properties into the object, but a developer may override this to support more behaviour. You can perform extra
 processing on state save and restore by attaching handlers to the beforestaterestore, staterestore, beforestatesave and
 statesave events.]]></description><name>stateful</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
     title: 'Some Title',
     renderTo: Ext.getBody(),
     width: 400, height:
 300,
     layout: 'form',
     items: [{
         xtype: 'textarea',
         style: {
             width: '95%',
            
 marginBottom: '10px'
         }
     },
         new Ext.Button({
             text: 'Send',
             minWidth: '100',
   
          style: {
                 marginBottom: '10px'
             }
         })
     ]
 });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is a child item of a TabPanel. A string to be used as innerHTML
 (html tags are accepted) to show in a tooltip when mousing over the associated tab selector element.
 Ext.QuickTips.init() must be called in order for the tips to render.]]></description><name>tabTip</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Timeout for form actions in seconds (default is 30 seconds).]]></description><name>timeout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The title text to be used as innerHTML (html tags are accepted) to display in the panel header (defaults to ''). When a
 title is specified the header element will automatically be created and displayed unless header is explicitly set to
 false. If you do not want to specify a title at config time, but you may want one later, you must either specify a
 non-empty title (a blank space ' ' will do) or header:true so that the container element will get created.]]></description><name>title</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to allow expanding and collapsing the panel (when collapsible = true) by clicking anywhere in the header bar,
 false) to allow it only by clicking to tool button (defaults to false)). If this panel is a child item of a border
 layout also see the BorderLayout.Region floatable config option.]]></description><name>titleCollapse</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A Template used to create tools in the header Element. Defaults to: new Ext.Template('<div class="x-tool
 x-tool-{id}">&#160;</div>') This may may be overridden to provide a custom DOM structure for tools based upon a more
 complex XTemplate. The template's data is a single tool configuration object (Not the entire Array) as specified in
 tools. In the following example an <a> tag is used to provide a visual indication when hovering over the tool: var win =
 new Ext.Window({
     tools: [{
         id: 'download',
         href: '/MyPdfDoc.pdf'
     }],
     toolTemplate: new
 Ext.XTemplate(
         '<tpl if="id==\'download\'">',
             '<a class="x-tool x-tool-pdf" href="{href}"></a>',
    
 '</tpl>',
         '<tpl if="id!=\'download\'">',
             '<div class="x-tool x-tool-{id}">&#160;</div>',
        
 '</tpl>'
     ),
     width:500,
     height:300,
     closeAction:'hide'
 }); Note that the CSS class 'x-tool-pdf' should
 have an associated style rule which provides an appropriate background image, something like: a.x-tool-pdf
 {background-image: url(../shared/extjs/images/pdf.gif)!important;}]]></description><name>toolTemplate</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of tool button configs to be added to the header tool area. When rendered, each tool is stored as an Element
 referenced by a public property called tools.<tool-type> Each tool config may contain the following properties: id :
 String Required. The type of tool to create. By default, this assigns a CSS class of the form x-tool-<tool-type> to the
 resulting tool Element. Ext provides CSS rules, and an icon sprite containing images for the tool types listed below.
 The developer may implement custom tools by supplying alternate CSS rules and background images: toggle (Created by
 default when collapsible is true) close minimize maximize restore gear pin unpin right left up down refresh minus plus
 help search save print handler : Function Required. The function to call when clicked. Arguments passed are: event :
 Ext.EventObject The click event. toolEl : Ext.Element The tool Element. panel : Ext.Panel The host Panel tc : Object The
 tool configuration object stopEvent : Boolean Defaults to true. Specify as false to allow click event to propagate.
 scope : Object The scope in which to call the handler. qtip : String/Object A tip string, or a config argument to
 Ext.QuickTip.register hidden : Boolean True to initially render hidden. on : Object A listener config object specifiying
 event listeners in the format of an argument to addListener Note that, apart from the toggle tool which is provided when
 a panel is collapsible, these tools only provide the visual button. Any required functionality must be provided by
 adding handlers that implement the necessary behavior. Example usage: tools:[{
     id:'refresh',
     qtip: 'Refresh form
 Data',
     // hidden:true,
     handler: function(event, toolEl, panel){
         // refresh logic
     }
 },
 {
    
 id:'help',
     qtip: 'Get Help',
     handler: function(event, toolEl, panel){
         // whatever
     }
 }] For the
 custom id of 'help' define two relevant css classes with a link to a 15x15 image: .x-tool-help {background-image:
 url(images/help.png);}
 .x-tool-help-over {background-image: url(images/help_over.png);}
 // if using an image
 sprite:
 .x-tool-help {background-image: url(images/help.png) no-repeat 0 0;}
 .x-tool-help-over
 {background-position:-15px 0;}]]></description><name>tools</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If set to true, reset() resets to the last loaded or setValues() data instead of when the form was first created.
 Defaults to false.]]></description><name>trackResetOnLoad</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Overrides the baseCls setting to baseCls = 'x-plain' which renders the panel unstyled except for required attributes for
 Ext layouts to function (e.g. overflow:hidden).]]></description><name>unstyled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The URL to use for form actions if one isn't supplied in the doAction options.]]></description><name>url</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default title to show for the waiting message box (defaults to 'Please Wait...')]]></description><name>waitTitle</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local x (left) coordinate for this component if contained within a positioning container.]]></description><name>x</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered xtype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a child item of a Container is being specified not
 as a fully instantiated Component, but as a Component config object. The xtype will be looked up at render time up to
 determine what type of child Component to create. The predefined xtypes are listed here. If you subclass Components to
 create your own Components, you may register them using Ext.ComponentMgr.registerType in order to be able to take
 advantage of lazy instantiation and rendering.]]></description><name>xtype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local y (top) coordinate for this component if contained within a positioning container.]]></description><name>y</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 A grouping container for 
 <a href="output/Ext.form.Radio.html" ext:cls="Ext.form.Radio">Ext.form.Radio</a> controls.]]></description><name>form.radioGroup</name><tag-class>org.brushingbits.jnap.ui.extjs3.form.RadioGroup</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[The field's HTML name attribute (defaults to ''). Note: this property must be set if this field is to be automatically
 included with form submit().]]></description><name>name</name><required>true</required><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to allow every item in the group to be blank (defaults to true). If allowBlank = false and no items are selected at
 validation time, {@link]]></description><name>allowBlank</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Whether the component can move the Dom node when rendering (defaults to true).]]></description><name>allowDomMove</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use an
 AnchorLayout (or subclass thereof). based layout manager, for example: Ext.form.FormPanel specifying layout: 'anchor' //
 or 'form', or 'absolute' See Ext.layout.AnchorLayout.anchor also.]]></description><name>anchor</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element corresponding to a DIV that is already present in
 the document that specifies some structural markup for this component. Description : When applyTo is used, constituent
 parts of the component can also be specified by id or CSS class name within the main element, and the component being
 created may attempt to create its subcomponents from that markup if applicable. Notes : When using this config, a call
 to render() is not required. If applyTo is specified, any value passed for renderTo will be ignored and the target
 element's parent node will automatically be used as the component's container.]]></description><name>applyTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A DomHelper element spec, or true for a default element spec. Used to create the Element which will encapsulate this
 Component. See autoEl for details. Defaults to: {tag: 'input', type: 'text', size: '20', autocomplete: 'off'}]]></description><name>autoCreate</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A tag name or DomHelper spec used to create the Element which will encapsulate this Component. You do not normally need
 to specify this. For the base classes Ext.Component, Ext.BoxComponent, and Ext.Container, this defaults to 'div'. The
 more complex Ext classes use a more complex DOM structure created by their own onRender methods. This is intended to
 allow the developer to create application-specific utility Components encapsulated by different DOM elements. Example
 usage: <pre><code>{
     xtype: 'box',
     autoEl: {
         tag: 'img',
         src: 'http://www.example.com/example.jpg'
     }
 },
 {
     xtype: 'box',
     autoEl: {
         tag: 'blockquote',
         html: 'autoEl is cool!'
     }
 }, {
     xtype: 'container',
     autoEl: 'ul',
     cls: 'ux-unordered-list',
     items: {
         xtype: 'box',
         autoEl: 'li',
   
      html: 'First list item'
     }
 }</pre></code>]]></description><name>autoEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to use height:'auto', false to use fixed height (or allow it to be managed by its parent Container's layout
 manager. Defaults to false. Note: Although many components inherit this config option, not all will function as expected
 with a height of 'auto'. Setting autoHeight:true means that the browser will manage height based on the element's
 contents, and that Ext will not manage it at all. If the browser is managing the height, be aware that resizes performed
 by the browser in response to changes within the structure of the Component cannot be detected. Therefore changes to the
 height might result in elements needing to be synchronized with the new height. Example: var w = new Ext.Window({
    
 title: 'Window',
     width: 600,
     autoHeight: true,
     items: {
         title: 'Collapse Me',
         height: 400,
  
 collapsible: true,
         border: false,
         listeners: {
             beforecollapse: function() {
                w.el.shadow.hide();
             },
             beforeexpand: function() {
                w.el.shadow.hide();
             },
             collapse: function() {
                w.syncShadow();
             },
             expand: function() {
                w.syncShadow();
             }
         }
     }
 }).show();]]></description><name>autoHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to use overflow:'auto' on the components layout element and show scroll bars automatically when necessary, false to
 clip any overflowing content (defaults to false).]]></description><name>autoScroll</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True if the component should check for hidden classes (e.g. 'x-hidden' or 'x-hide-display') and remove them on render
 (defaults to false).]]></description><name>autoShow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to use width:'auto', false to use fixed width (or allow it to be managed by its parent Container's layout manager.
 Defaults to false. Note: Although many components inherit this config option, not all will function as expected with a
 width of 'auto'. Setting autoWidth:true means that the browser will manage width based on the element's contents, and
 that Ext will not manage it at all. If the browser is managing the width, be aware that resizes performed by the browser
 in response to changes within the structure of the Component cannot be detected. Therefore changes to the width might
 result in elements needing to be synchronized with the new width. For example, where the target element is: <div
 id='grid-container' style='margin-left:25%;width:50%'></div> A Panel rendered into that target element must listen for
 browser window resize in order to relay its child items when the browser changes its width: var myPanel = new
 Ext.Panel({
     renderTo: 'grid-container',
     monitorResize: true, // relay on browser resize
     title: 'Panel',
    
 height: 400,
     autoWidth: true,
     layout: 'hbox',
     layoutConfig: {
         align: 'stretch'
     },
     defaults: {
         flex: 1
     },
     items: [{
         title: 'Box 1',
     }, {
         title: 'Box 2'
     }, {
         title:
 'Box 3'
     }],
 });]]></description><name>autoWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Error text to display if the allowBlank validation fails (defaults to 'You must select one item in this group')]]></description><name>blankText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to [].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class used to to apply to the special clearing div rendered directly after each form field wrapper to provide
 field clearing (defaults to 'x-form-clear-left'). Note: this config is only used when this Component is rendered by a
 Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or specifying
 layout:'form') and either a fieldLabel is specified or isFormField=true is specified. See Ext.layout.FormLayout.fieldTpl
 also.]]></description><name>clearCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom CSS class to apply to the field's underlying element (defaults to '').]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the number of columns to use when displaying grouped checkbox/radio controls using automatic layout. This
 config can take several types of values: 'auto' : The controls will be rendered one per column on one row and the width
 of each column will be evenly distributed based on the width of the overall field container. This is the default. Number
 : If you specific a number (e.g., 3) that number of columns will be created and the contained controls will be
 automatically distributed based on the value of vertical. Array : Object You can also specify an array of column widths,
 mixing integer (fixed width) and float (percentage width) values as needed (e.g., [100, .25, .75]). Any integer values
 will be rendered first, then any float values will be calculated as a percentage of the remaining space. Float values do
 not have to add up to 1 (100%) although if you want the controls to take up the entire field container you should do so.]]></description><name>columns</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's container. This can be useful for adding customized
 styles to the container or any of its children using standard CSS rules. See Ext.layout.ContainerLayout.extraCls also.
 Note: ctCls defaults to '' except for the following class which assigns a value by default: Box Layout :
 'x-box-layout-ct' To configure the above Class with an extra CSS class append to the default. For example, for BoxLayout
 (Hbox and Vbox): ctCls: 'x-box-layout-ct custom-class']]></description><name>ctCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to disable the field (defaults to false). Be aware that conformant with the HTML specification, disabled Fields
 will not be submitted.]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class added to the component when it is disabled (defaults to 'x-item-disabled').]]></description><name>disabledClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default CSS class for the field (defaults to 'x-form-field')]]></description><name>fieldClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The label text to display next to this Component (defaults to ''). Note: this config is only used when this Component is
 rendered by a Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or
 specifying layout:'form'). Also see hideLabel and Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
    
 height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name'
    
 }]
 });]]></description><name>fieldLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use a
 BoxLayout. Each child Component with a flex property will be flexed either vertically (by a VBoxLayout) or horizontally
 (by an HBoxLayout) according to the item's relative flex value compared to the sum of all Components with flex value
 specified. Any child items that have either a flex = 0 or flex = undefined will not be 'flexed' (the initial size will
 not be changed).]]></description><name>flex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class to use when the field receives focus (defaults to 'x-form-focus')]]></description><name>focusClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component hidden (default is false). If true, the hide method will be called internally.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to completely hide the label element (label and separator). Defaults to false. By default, even if you do not
 specify a fieldLabel the space will still be reserved so that the field will line up with other fields that do have
 labels. Setting this to true will cause the field to not reserve that space. Note: see the note for clearCls. Example
 use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield'
        
 hideLabel: true
     }]
 });]]></description><name>hideLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[How this component should be hidden. Supported values are 'visibility' (css visibility), 'offsets' (negative offset
 position) and 'display' (css display). Note: the default of 'display' is generally preferred since items are
 automatically laid out when they are first shown (no sizing is done while hidden).]]></description><name>hideMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide and show the component's container when hide/show is called on the component, false to hide and show the
 component itself (defaults to false). For example, this can be used as a shortcut for a hide button on a window by
 setting hide:true on the button when adding it to its parent container.]]></description><name>hideParent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id of this component (defaults to an auto-assigned id). You should assign an id if you need to be able to
 access the component later and you do not have an object reference available (e.g., using Ext.getCmp). Note that this id
 will also be used as the element id for the containing HTML element that is rendered to the page for this component.
 This allows you to write id-based CSS rules to style the specific instance of this component uniquely, and also to
 select sub-elements using this component's id as the parent. Note: to avoid complications imposed by a unique id also
 see itemId and ref. Note: to access the container of an item see ownerCt.]]></description><name>id</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The type attribute for input fields -- e.g. radio, text, password, file (defaults to 'text'). The types 'file' and
 'password' must be used to render those field types currently -- there are no separate Ext components for those. Note
 that if you use inputType:'file', emptyText is not supported and should be avoided.]]></description><name>inputType</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class to use when marking a field invalid (defaults to 'x-form-invalid')]]></description><name>invalidClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The error text to use when marking a field invalid and no message is provided (defaults to 'The value in this field is
 invalid')]]></description><name>invalidText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use the
 FormLayout layout manager (e.g. Ext.form.FormPanel or specifying layout:'form'). An additional CSS class to apply to the
 div wrapping the form item element of this field. If supplied, itemCls at the field level will override the default
 itemCls supplied at the container level. The value specified for itemCls will be added to the default class
 ('x-form-item'). Since it is applied to the item wrapper (see Ext.layout.FormLayout.fieldTpl), it allows you to write
 standard CSS rules that can apply to the field, the label (if specified), or any other element within the markup for the
 field. Note: see the note for fieldLabel. Example use: // Apply a style to the field's label:
 <style>
     .required
 .x-form-item-label {font-weight:bold;color:red;}
 </style>
 
 new Ext.FormPanel({
     height: 100,
     renderTo:
 Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         itemCls: 'required' //this
 label will be styled
     },{
         xtype: 'textfield',
         fieldLabel: 'Favorite Color'
     }]
 });]]></description><name>itemCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An itemId can be used as an alternative way to get a reference to a component when no object reference is available.
 Instead of using an id with Ext.getCmp, use itemId with Ext.Container.getComponent which will retrieve itemId's or id's.
 Since itemId's are an index to the container's internal MixedCollection, the itemId is scoped locally to the container
 -- avoiding potential conflicts with Ext.ComponentMgr which requires a unique id. var c = new Ext.Panel({ //
     height:
 300,
     renderTo: document.body,
     layout: 'auto',
     items: [
         {
             itemId: 'p1',
            
 title: 'Panel 1',
             height: 150
         },
         {
             itemId: 'p2',
             title: 'Panel 2',
  
 height: 150
         }
     ]
 })
 p1 = c.getComponent('p1'); // not the same as Ext.getCmp()
 p2 =
 p1.ownerCt.getComponent('p2'); // reference via a sibling Also see id and ref. Note: to access the container of an item
 see ownerCt.]]></description><name>itemId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An Array of Radios or Radio config objects to arrange in the group.]]></description><name>items</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The separator to display after the text of each fieldLabel. This property may be configured at various levels. The order
 of precedence is: field / component level container level layout level (defaults to colon ':') To display no separator
 for this field's label specify empty string ''. Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 layoutConfig: {
         labelSeparator: '~'   // layout config has lowest priority (defaults to ':')
     },
    
 labelSeparator: '>>',     // config at container level
     items: [{
         xtype: 'textfield',
         fieldLabel:
 'Field 1',
         labelSeparator: '...' // field/component level config supersedes others
     },{
         xtype:
 'textfield',
         fieldLabel: 'Field 2' // labelSeparator will be '='
     }]
 });]]></description><name>labelSeparator</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS style specification string to apply directly to this field's label. Defaults to the container's labelStyle value
 if set (e.g., Ext.layout.FormLayout.labelStyle , or ''). Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         labelStyle: 'font-weight:bold;'
     }]
 });]]></description><name>labelStyle</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout or one of the two BoxLayout subclasses. An object containing margins to apply to this BoxComponent in the
 format: {
     top: (top margin),
     right: (right margin),
     bottom: (bottom margin),
     left: (left margin)
 } May
 also be a string containing space-separated, numeric margin values. The order of the sides associated with each value
 matches the way CSS processes margin values: If there is only one value, it applies to all sides. If there are two
 values, the top and bottom borders are set to the first value and the right and left are set to the second. If there are
 three values, the top is set to the first value, the left and right are set to the second, and the bottom is set to the
 third. If there are four values, they apply to the top, right, bottom, and left, respectively. Defaults to: {top:0,
 right:0, bottom:0, left:0}]]></description><name>margins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Experimental The effect used when displaying a validation message under the field (defaults to 'normal').]]></description><name>msgFx</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The location where the message text set through markInvalid should display. Must be one of the following values: qtip
 Display a quick tip containing the message when the user hovers over the field. This is the default. Ext.QuickTips.init
 must have been called for this setting to work. title Display the message in a default browser title attribute popup.
 under Add a block div beneath the field containing the error message. side Add an error icon to the right of the field,
 displaying the message in a popup on hover. [element id] Add the error message directly to the innerHTML of the
 specified element.]]></description><name>msgTarget</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element when the mouse moves over the Element, and
 removed when the mouse moves out. (defaults to ''). This can be useful for adding customized 'active' or 'hover' styles
 to the component or any of its children using standard CSS rules.]]></description><name>overCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level x coordinate for this component if contained within a positioning container.]]></description><name>pageX</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level y coordinate for this component if contained within a positioning container.]]></description><name>pageY</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to disable marking the field invalid. Defaults to false.]]></description><name>preventMark</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered ptype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a Plugin is being specified not as a fully
 instantiated Component, but as a Component config object. The ptype will be looked up at render time up to determine
 what type of Plugin to create. If you create your own Plugins, you may register them using
 Ext.ComponentMgr.registerPlugin in order to be able to take advantage of lazy instantiation and rendering.]]></description><name>ptype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to mark the field as readOnly in HTML (defaults to false). Note: this only sets the element's readOnly DOM
 attribute. Setting readOnly=true, for example, will not disable triggering a ComboBox or DateField; it gives you the
 option of forcing the user to choose via the trigger without typing in the text box. To hide the trigger use
 hideTrigger.]]></description><name>readOnly</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A path specification, relative to the Component's ownerCt specifying into which ancestor Container to place a named
 reference to this Component. The ancestor axis can be traversed by using '/' characters in the path. For example, to put
 a reference to a Toolbar Button into the Panel which owns the Toolbar: var myGrid = new Ext.grid.EditorGridPanel({
    
 title: 'My EditorGridPanel',
     store: myStore,
     colModel: myColModel,
     tbar: [{
         text: 'Save',
        
 handler: saveChanges,
         disabled: true,
         ref: '../saveButton'
     }],
     listeners: {
         afteredit:
 function() {
 //          The button reference is in the GridPanel
             myGrid.saveButton.enable();
         }
    
 }
 }); In the code above, if the ref had been 'saveButton' the reference would have been placed into the Toolbar. Each
 '/' in the ref moves up one level from the Component's ownerCt. Also see the added and removed events.]]></description><name>ref</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout layout manager (e.g. specifying layout:'border'). See Ext.layout.BorderLayout also.]]></description><name>region</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should trigger this component to save its state (defaults to none). stateEvents may
 be any type of event supported by this component, including browser or custom events (e.g., ['click',
 'customerchange']). See stateful for an explanation of saving and restoring Component state.]]></description><name>stateEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id for this component to use for state management purposes (defaults to the component id if one was set,
 otherwise null if the component is using a generated id). See stateful for an explanation of saving and restoring
 Component state.]]></description><name>stateId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A flag which causes the Component to attempt to restore the state of internal properties from a saved state on startup.
 The component must have either a stateId or id assigned for state to be managed. Auto-generated ids are not guaranteed
 to be stable across page loads and cannot be relied upon to save and restore the same state for a component. For state
 saving to work, the state manager's provider must have been set to an implementation of Ext.state.Provider which
 overrides the set and get methods to save and recall name/value pairs. A built-in implementation,
 Ext.state.CookieProvider is available. To set the state provider for the current page: Ext.state.Manager.setProvider(new
 Ext.state.CookieProvider({
     expires: new Date(new Date().getTime()+(1000*60*60*24*7)), //7 days from now
 })); A
 stateful Component attempts to save state when one of the events listed in the stateEvents configuration fires. To save
 state, a stateful Component first serializes its state by calling getState. By default, this function does nothing. The
 developer must provide an implementation which returns an object hash which represents the Component's restorable state.
 The value yielded by getState is passed to Ext.state.Manager.set which uses the configured Ext.state.Provider to save
 the object keyed by the Component's stateId, or, if that is not specified, its id. During construction, a stateful
 Component attempts to restore its state by calling Ext.state.Manager.get passing the stateId, or, if that is not
 specified, the id. The resulting object is passed to applyState. The default implementation of applyState simply copies
 properties into the object, but a developer may override this to support more behaviour. You can perform extra
 processing on state save and restore by attaching handlers to the beforestaterestore, staterestore, beforestatesave and
 statesave events.]]></description><name>stateful</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
     title: 'Some Title',
     renderTo: Ext.getBody(),
     width: 400, height:
 300,
     layout: 'form',
     items: [{
         xtype: 'textarea',
         style: {
             width: '95%',
            
 marginBottom: '10px'
         }
     },
         new Ext.Button({
             text: 'Send',
             minWidth: '100',
   
          style: {
                 marginBottom: '10px'
             }
         })
     ]
 });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[False to clear the name attribute on the field so that it is not submitted during a form post. Defaults to true.]]></description><name>submitValue</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The tabIndex for this field. Note this only applies to fields that are rendered, not those which are built via applyTo
 (defaults to undefined).]]></description><name>tabIndex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is a child item of a TabPanel. A string to be used as innerHTML
 (html tags are accepted) to show in a tooltip when mousing over the associated tab selector element.
 Ext.QuickTips.init() must be called in order for the tips to render.]]></description><name>tabTip</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Whether the field should validate when it loses focus (defaults to true).]]></description><name>validateOnBlur</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The length of time in milliseconds after user input begins until validation is initiated (defaults to 250)]]></description><name>validationDelay</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The event that should initiate field validation. Set to false to disable automatic validation (defaults to 'keyup').]]></description><name>validationEvent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A value to initialize this field with (defaults to undefined).]]></description><name>value</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to distribute contained controls across columns, completely filling each column top to bottom before starting on
 the next column. The number of controls in each column will be automatically calculated to keep columns as even as
 possible. The default value is false, so that controls will be added to columns one at a time, completely filling each
 row left to right before starting on the next row.]]></description><name>vertical</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local x (left) coordinate for this component if contained within a positioning container.]]></description><name>x</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered xtype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a child item of a Container is being specified not
 as a fully instantiated Component, but as a Component config object. The xtype will be looked up at render time up to
 determine what type of child Component to create. The predefined xtypes are listed here. If you subclass Components to
 create your own Components, you may register them using Ext.ComponentMgr.registerType in order to be able to take
 advantage of lazy instantiation and rendering.]]></description><name>xtype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local y (top) coordinate for this component if contained within a positioning container.]]></description><name>y</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 Wraps a 
 <a href="output/Ext.slider.MultiSlider.html" ext:cls="Ext.slider.MultiSlider">Slider</a> so it can be used as a
 form field.]]></description><name>form.sliderfield</name><tag-class>org.brushingbits.jnap.ui.extjs3.form.SliderField</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[The field's HTML name attribute (defaults to ''). Note: this property must be set if this field is to be automatically
 included with form submit().]]></description><name>name</name><required>true</required><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Whether the component can move the Dom node when rendering (defaults to true).]]></description><name>allowDomMove</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use an
 AnchorLayout (or subclass thereof). based layout manager, for example: Ext.form.FormPanel specifying layout: 'anchor' //
 or 'form', or 'absolute' See Ext.layout.AnchorLayout.anchor also.]]></description><name>anchor</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element corresponding to a DIV that is already present in
 the document that specifies some structural markup for this component. Description : When applyTo is used, constituent
 parts of the component can also be specified by id or CSS class name within the main element, and the component being
 created may attempt to create its subcomponents from that markup if applicable. Notes : When using this config, a call
 to render() is not required. If applyTo is specified, any value passed for renderTo will be ignored and the target
 element's parent node will automatically be used as the component's container.]]></description><name>applyTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A DomHelper element spec, or true for a default element spec. Used to create the Element which will encapsulate this
 Component. See autoEl for details. Defaults to: {tag: 'input', type: 'text', size: '20', autocomplete: 'off'}]]></description><name>autoCreate</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A tag name or DomHelper spec used to create the Element which will encapsulate this Component. You do not normally need
 to specify this. For the base classes Ext.Component, Ext.BoxComponent, and Ext.Container, this defaults to 'div'. The
 more complex Ext classes use a more complex DOM structure created by their own onRender methods. This is intended to
 allow the developer to create application-specific utility Components encapsulated by different DOM elements. Example
 usage: <pre><code>{
     xtype: 'box',
     autoEl: {
         tag: 'img',
         src: 'http://www.example.com/example.jpg'
     }
 },
 {
     xtype: 'box',
     autoEl: {
         tag: 'blockquote',
         html: 'autoEl is cool!'
     }
 }, {
     xtype: 'container',
     autoEl: 'ul',
     cls: 'ux-unordered-list',
     items: {
         xtype: 'box',
         autoEl: 'li',
   
      html: 'First list item'
     }
 }</pre></code>]]></description><name>autoEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to use height:'auto', false to use fixed height (or allow it to be managed by its parent Container's layout
 manager. Defaults to false. Note: Although many components inherit this config option, not all will function as expected
 with a height of 'auto'. Setting autoHeight:true means that the browser will manage height based on the element's
 contents, and that Ext will not manage it at all. If the browser is managing the height, be aware that resizes performed
 by the browser in response to changes within the structure of the Component cannot be detected. Therefore changes to the
 height might result in elements needing to be synchronized with the new height. Example: var w = new Ext.Window({
    
 title: 'Window',
     width: 600,
     autoHeight: true,
     items: {
         title: 'Collapse Me',
         height: 400,
  
 collapsible: true,
         border: false,
         listeners: {
             beforecollapse: function() {
                w.el.shadow.hide();
             },
             beforeexpand: function() {
                w.el.shadow.hide();
             },
             collapse: function() {
                w.syncShadow();
             },
             expand: function() {
                w.syncShadow();
             }
         }
     }
 }).show();]]></description><name>autoHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to use overflow:'auto' on the components layout element and show scroll bars automatically when necessary, false to
 clip any overflowing content (defaults to false).]]></description><name>autoScroll</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True if the component should check for hidden classes (e.g. 'x-hidden' or 'x-hide-display') and remove them on render
 (defaults to false).]]></description><name>autoShow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to use width:'auto', false to use fixed width (or allow it to be managed by its parent Container's layout manager.
 Defaults to false. Note: Although many components inherit this config option, not all will function as expected with a
 width of 'auto'. Setting autoWidth:true means that the browser will manage width based on the element's contents, and
 that Ext will not manage it at all. If the browser is managing the width, be aware that resizes performed by the browser
 in response to changes within the structure of the Component cannot be detected. Therefore changes to the width might
 result in elements needing to be synchronized with the new width. For example, where the target element is: <div
 id='grid-container' style='margin-left:25%;width:50%'></div> A Panel rendered into that target element must listen for
 browser window resize in order to relay its child items when the browser changes its width: var myPanel = new
 Ext.Panel({
     renderTo: 'grid-container',
     monitorResize: true, // relay on browser resize
     title: 'Panel',
    
 height: 400,
     autoWidth: true,
     layout: 'hbox',
     layoutConfig: {
         align: 'stretch'
     },
     defaults: {
         flex: 1
     },
     items: [{
         title: 'Box 1',
     }, {
         title: 'Box 2'
     }, {
         title:
 'Box 3'
     }],
 });]]></description><name>autoWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to [].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class used to to apply to the special clearing div rendered directly after each form field wrapper to provide
 field clearing (defaults to 'x-form-clear-left'). Note: this config is only used when this Component is rendered by a
 Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or specifying
 layout:'form') and either a fieldLabel is specified or isFormField=true is specified. See Ext.layout.FormLayout.fieldTpl
 also.]]></description><name>clearCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom CSS class to apply to the field's underlying element (defaults to '').]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's container. This can be useful for adding customized
 styles to the container or any of its children using standard CSS rules. See Ext.layout.ContainerLayout.extraCls also.
 Note: ctCls defaults to '' except for the following class which assigns a value by default: Box Layout :
 'x-box-layout-ct' To configure the above Class with an extra CSS class append to the default. For example, for BoxLayout
 (Hbox and Vbox): ctCls: 'x-box-layout-ct custom-class']]></description><name>ctCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to disable the field (defaults to false). Be aware that conformant with the HTML specification, disabled Fields
 will not be submitted.]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class added to the component when it is disabled (defaults to 'x-item-disabled').]]></description><name>disabledClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default CSS class for the field (defaults to 'x-form-field')]]></description><name>fieldClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The label text to display next to this Component (defaults to ''). Note: this config is only used when this Component is
 rendered by a Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or
 specifying layout:'form'). Also see hideLabel and Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
    
 height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name'
    
 }]
 });]]></description><name>fieldLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use a
 BoxLayout. Each child Component with a flex property will be flexed either vertically (by a VBoxLayout) or horizontally
 (by an HBoxLayout) according to the item's relative flex value compared to the sum of all Components with flex value
 specified. Any child items that have either a flex = 0 or flex = undefined will not be 'flexed' (the initial size will
 not be changed).]]></description><name>flex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class to use when the field receives focus (defaults to 'x-form-focus')]]></description><name>focusClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component hidden (default is false). If true, the hide method will be called internally.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to completely hide the label element (label and separator). Defaults to false. By default, even if you do not
 specify a fieldLabel the space will still be reserved so that the field will line up with other fields that do have
 labels. Setting this to true will cause the field to not reserve that space. Note: see the note for clearCls. Example
 use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield'
        
 hideLabel: true
     }]
 });]]></description><name>hideLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[How this component should be hidden. Supported values are 'visibility' (css visibility), 'offsets' (negative offset
 position) and 'display' (css display). Note: the default of 'display' is generally preferred since items are
 automatically laid out when they are first shown (no sizing is done while hidden).]]></description><name>hideMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide and show the component's container when hide/show is called on the component, false to hide and show the
 component itself (defaults to false). For example, this can be used as a shortcut for a hide button on a window by
 setting hide:true on the button when adding it to its parent container.]]></description><name>hideParent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id of this component (defaults to an auto-assigned id). You should assign an id if you need to be able to
 access the component later and you do not have an object reference available (e.g., using Ext.getCmp). Note that this id
 will also be used as the element id for the containing HTML element that is rendered to the page for this component.
 This allows you to write id-based CSS rules to style the specific instance of this component uniquely, and also to
 select sub-elements using this component's id as the parent. Note: to avoid complications imposed by a unique id also
 see itemId and ref. Note: to access the container of an item see ownerCt.]]></description><name>id</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The type attribute for input fields -- e.g. radio, text, password, file (defaults to 'text'). The types 'file' and
 'password' must be used to render those field types currently -- there are no separate Ext components for those. Note
 that if you use inputType:'file', emptyText is not supported and should be avoided.]]></description><name>inputType</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class to use when marking a field invalid (defaults to 'x-form-invalid')]]></description><name>invalidClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The error text to use when marking a field invalid and no message is provided (defaults to 'The value in this field is
 invalid')]]></description><name>invalidText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use the
 FormLayout layout manager (e.g. Ext.form.FormPanel or specifying layout:'form'). An additional CSS class to apply to the
 div wrapping the form item element of this field. If supplied, itemCls at the field level will override the default
 itemCls supplied at the container level. The value specified for itemCls will be added to the default class
 ('x-form-item'). Since it is applied to the item wrapper (see Ext.layout.FormLayout.fieldTpl), it allows you to write
 standard CSS rules that can apply to the field, the label (if specified), or any other element within the markup for the
 field. Note: see the note for fieldLabel. Example use: // Apply a style to the field's label:
 <style>
     .required
 .x-form-item-label {font-weight:bold;color:red;}
 </style>
 
 new Ext.FormPanel({
     height: 100,
     renderTo:
 Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         itemCls: 'required' //this
 label will be styled
     },{
         xtype: 'textfield',
         fieldLabel: 'Favorite Color'
     }]
 });]]></description><name>itemCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An itemId can be used as an alternative way to get a reference to a component when no object reference is available.
 Instead of using an id with Ext.getCmp, use itemId with Ext.Container.getComponent which will retrieve itemId's or id's.
 Since itemId's are an index to the container's internal MixedCollection, the itemId is scoped locally to the container
 -- avoiding potential conflicts with Ext.ComponentMgr which requires a unique id. var c = new Ext.Panel({ //
     height:
 300,
     renderTo: document.body,
     layout: 'auto',
     items: [
         {
             itemId: 'p1',
            
 title: 'Panel 1',
             height: 150
         },
         {
             itemId: 'p2',
             title: 'Panel 2',
  
 height: 150
         }
     ]
 })
 p1 = c.getComponent('p1'); // not the same as Ext.getCmp()
 p2 =
 p1.ownerCt.getComponent('p2'); // reference via a sibling Also see id and ref. Note: to access the container of an item
 see ownerCt.]]></description><name>itemId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The separator to display after the text of each fieldLabel. This property may be configured at various levels. The order
 of precedence is: field / component level container level layout level (defaults to colon ':') To display no separator
 for this field's label specify empty string ''. Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 layoutConfig: {
         labelSeparator: '~'   // layout config has lowest priority (defaults to ':')
     },
    
 labelSeparator: '>>',     // config at container level
     items: [{
         xtype: 'textfield',
         fieldLabel:
 'Field 1',
         labelSeparator: '...' // field/component level config supersedes others
     },{
         xtype:
 'textfield',
         fieldLabel: 'Field 2' // labelSeparator will be '='
     }]
 });]]></description><name>labelSeparator</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS style specification string to apply directly to this field's label. Defaults to the container's labelStyle value
 if set (e.g., Ext.layout.FormLayout.labelStyle , or ''). Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         labelStyle: 'font-weight:bold;'
     }]
 });]]></description><name>labelStyle</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout or one of the two BoxLayout subclasses. An object containing margins to apply to this BoxComponent in the
 format: {
     top: (top margin),
     right: (right margin),
     bottom: (bottom margin),
     left: (left margin)
 } May
 also be a string containing space-separated, numeric margin values. The order of the sides associated with each value
 matches the way CSS processes margin values: If there is only one value, it applies to all sides. If there are two
 values, the top and bottom borders are set to the first value and the right and left are set to the second. If there are
 three values, the top is set to the first value, the left and right are set to the second, and the bottom is set to the
 third. If there are four values, they apply to the top, right, bottom, and left, respectively. Defaults to: {top:0,
 right:0, bottom:0, left:0}]]></description><name>margins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Experimental The effect used when displaying a validation message under the field (defaults to 'normal').]]></description><name>msgFx</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The location where the message text set through markInvalid should display. Must be one of the following values: qtip
 Display a quick tip containing the message when the user hovers over the field. This is the default. Ext.QuickTips.init
 must have been called for this setting to work. title Display the message in a default browser title attribute popup.
 under Add a block div beneath the field containing the error message. side Add an error icon to the right of the field,
 displaying the message in a popup on hover. [element id] Add the error message directly to the innerHTML of the
 specified element.]]></description><name>msgTarget</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element when the mouse moves over the Element, and
 removed when the mouse moves out. (defaults to ''). This can be useful for adding customized 'active' or 'hover' styles
 to the component or any of its children using standard CSS rules.]]></description><name>overCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level x coordinate for this component if contained within a positioning container.]]></description><name>pageX</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level y coordinate for this component if contained within a positioning container.]]></description><name>pageY</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to disable marking the field invalid. Defaults to false.]]></description><name>preventMark</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered ptype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a Plugin is being specified not as a fully
 instantiated Component, but as a Component config object. The ptype will be looked up at render time up to determine
 what type of Plugin to create. If you create your own Plugins, you may register them using
 Ext.ComponentMgr.registerPlugin in order to be able to take advantage of lazy instantiation and rendering.]]></description><name>ptype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to mark the field as readOnly in HTML (defaults to false). Note: this only sets the element's readOnly DOM
 attribute. Setting readOnly=true, for example, will not disable triggering a ComboBox or DateField; it gives you the
 option of forcing the user to choose via the trigger without typing in the text box. To hide the trigger use
 hideTrigger.]]></description><name>readOnly</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A path specification, relative to the Component's ownerCt specifying into which ancestor Container to place a named
 reference to this Component. The ancestor axis can be traversed by using '/' characters in the path. For example, to put
 a reference to a Toolbar Button into the Panel which owns the Toolbar: var myGrid = new Ext.grid.EditorGridPanel({
    
 title: 'My EditorGridPanel',
     store: myStore,
     colModel: myColModel,
     tbar: [{
         text: 'Save',
        
 handler: saveChanges,
         disabled: true,
         ref: '../saveButton'
     }],
     listeners: {
         afteredit:
 function() {
 //          The button reference is in the GridPanel
             myGrid.saveButton.enable();
         }
    
 }
 }); In the code above, if the ref had been 'saveButton' the reference would have been placed into the Toolbar. Each
 '/' in the ref moves up one level from the Component's ownerCt. Also see the added and removed events.]]></description><name>ref</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout layout manager (e.g. specifying layout:'border'). See Ext.layout.BorderLayout also.]]></description><name>region</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should trigger this component to save its state (defaults to none). stateEvents may
 be any type of event supported by this component, including browser or custom events (e.g., ['click',
 'customerchange']). See stateful for an explanation of saving and restoring Component state.]]></description><name>stateEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id for this component to use for state management purposes (defaults to the component id if one was set,
 otherwise null if the component is using a generated id). See stateful for an explanation of saving and restoring
 Component state.]]></description><name>stateId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A flag which causes the Component to attempt to restore the state of internal properties from a saved state on startup.
 The component must have either a stateId or id assigned for state to be managed. Auto-generated ids are not guaranteed
 to be stable across page loads and cannot be relied upon to save and restore the same state for a component. For state
 saving to work, the state manager's provider must have been set to an implementation of Ext.state.Provider which
 overrides the set and get methods to save and recall name/value pairs. A built-in implementation,
 Ext.state.CookieProvider is available. To set the state provider for the current page: Ext.state.Manager.setProvider(new
 Ext.state.CookieProvider({
     expires: new Date(new Date().getTime()+(1000*60*60*24*7)), //7 days from now
 })); A
 stateful Component attempts to save state when one of the events listed in the stateEvents configuration fires. To save
 state, a stateful Component first serializes its state by calling getState. By default, this function does nothing. The
 developer must provide an implementation which returns an object hash which represents the Component's restorable state.
 The value yielded by getState is passed to Ext.state.Manager.set which uses the configured Ext.state.Provider to save
 the object keyed by the Component's stateId, or, if that is not specified, its id. During construction, a stateful
 Component attempts to restore its state by calling Ext.state.Manager.get passing the stateId, or, if that is not
 specified, the id. The resulting object is passed to applyState. The default implementation of applyState simply copies
 properties into the object, but a developer may override this to support more behaviour. You can perform extra
 processing on state save and restore by attaching handlers to the beforestaterestore, staterestore, beforestatesave and
 statesave events.]]></description><name>stateful</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
     title: 'Some Title',
     renderTo: Ext.getBody(),
     width: 400, height:
 300,
     layout: 'form',
     items: [{
         xtype: 'textarea',
         style: {
             width: '95%',
            
 marginBottom: '10px'
         }
     },
         new Ext.Button({
             text: 'Send',
             minWidth: '100',
   
          style: {
                 marginBottom: '10px'
             }
         })
     ]
 });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[False to clear the name attribute on the field so that it is not submitted during a form post. Defaults to true.]]></description><name>submitValue</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The tabIndex for this field. Note this only applies to fields that are rendered, not those which are built via applyTo
 (defaults to undefined).]]></description><name>tabIndex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is a child item of a TabPanel. A string to be used as innerHTML
 (html tags are accepted) to show in a tooltip when mousing over the associated tab selector element.
 Ext.QuickTips.init() must be called in order for the tips to render.]]></description><name>tabTip</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A function used to display custom text for the slider tip. Defaults to null, which will use the default on the plugin.]]></description><name>tipText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to use an Ext.slider.Tip to display tips for the value. Defaults to true.]]></description><name>useTips</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Whether the field should validate when it loses focus (defaults to true).]]></description><name>validateOnBlur</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The length of time in milliseconds after user input begins until validation is initiated (defaults to 250)]]></description><name>validationDelay</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The event that should initiate field validation. Set to false to disable automatic validation (defaults to 'keyup').]]></description><name>validationEvent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A value to initialize this field with (defaults to undefined).]]></description><name>value</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local x (left) coordinate for this component if contained within a positioning container.]]></description><name>x</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered xtype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a child item of a Container is being specified not
 as a fully instantiated Component, but as a Component config object. The xtype will be looked up at render time up to
 determine what type of child Component to create. The predefined xtypes are listed here. If you subclass Components to
 create your own Components, you may register them using Ext.ComponentMgr.registerType in order to be able to take
 advantage of lazy instantiation and rendering.]]></description><name>xtype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local y (top) coordinate for this component if contained within a positioning container.]]></description><name>y</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 Multiline text field. Can be used as a direct replacement for traditional textarea fields, plus adds support for
 auto-sizing.]]></description><name>form.textarea</name><tag-class>org.brushingbits.jnap.ui.extjs3.form.TextArea</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[The field's HTML name attribute (defaults to ''). Note: this property must be set if this field is to be automatically
 included with form submit().]]></description><name>name</name><required>true</required><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify false to validate that the value's length is > 0 (defaults to true)]]></description><name>allowBlank</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Whether the component can move the Dom node when rendering (defaults to true).]]></description><name>allowDomMove</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use an
 AnchorLayout (or subclass thereof). based layout manager, for example: Ext.form.FormPanel specifying layout: 'anchor' //
 or 'form', or 'absolute' See Ext.layout.AnchorLayout.anchor also.]]></description><name>anchor</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element corresponding to a DIV that is already present in
 the document that specifies some structural markup for this component. Description : When applyTo is used, constituent
 parts of the component can also be specified by id or CSS class name within the main element, and the component being
 created may attempt to create its subcomponents from that markup if applicable. Notes : When using this config, a call
 to render() is not required. If applyTo is specified, any value passed for renderTo will be ignored and the target
 element's parent node will automatically be used as the component's container.]]></description><name>applyTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A DomHelper element spec, or true for a default element spec. Used to create the Element which will encapsulate this
 Component. See autoEl for details. Defaults to: {tag: "textarea", style: "width:100px;height:60px;", autocomplete:
 "off"}]]></description><name>autoCreate</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A tag name or DomHelper spec used to create the Element which will encapsulate this Component. You do not normally need
 to specify this. For the base classes Ext.Component, Ext.BoxComponent, and Ext.Container, this defaults to 'div'. The
 more complex Ext classes use a more complex DOM structure created by their own onRender methods. This is intended to
 allow the developer to create application-specific utility Components encapsulated by different DOM elements. Example
 usage: <pre><code>{
     xtype: 'box',
     autoEl: {
         tag: 'img',
         src: 'http://www.example.com/example.jpg'
     }
 },
 {
     xtype: 'box',
     autoEl: {
         tag: 'blockquote',
         html: 'autoEl is cool!'
     }
 }, {
     xtype: 'container',
     autoEl: 'ul',
     cls: 'ux-unordered-list',
     items: {
         xtype: 'box',
         autoEl: 'li',
   
      html: 'First list item'
     }
 }</pre></code>]]></description><name>autoEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to use height:'auto', false to use fixed height (or allow it to be managed by its parent Container's layout
 manager. Defaults to false. Note: Although many components inherit this config option, not all will function as expected
 with a height of 'auto'. Setting autoHeight:true means that the browser will manage height based on the element's
 contents, and that Ext will not manage it at all. If the browser is managing the height, be aware that resizes performed
 by the browser in response to changes within the structure of the Component cannot be detected. Therefore changes to the
 height might result in elements needing to be synchronized with the new height. Example: var w = new Ext.Window({
    
 title: 'Window',
     width: 600,
     autoHeight: true,
     items: {
         title: 'Collapse Me',
         height: 400,
  
 collapsible: true,
         border: false,
         listeners: {
             beforecollapse: function() {
                w.el.shadow.hide();
             },
             beforeexpand: function() {
                w.el.shadow.hide();
             },
             collapse: function() {
                w.syncShadow();
             },
             expand: function() {
                w.syncShadow();
             }
         }
     }
 }).show();]]></description><name>autoHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to use overflow:'auto' on the components layout element and show scroll bars automatically when necessary, false to
 clip any overflowing content (defaults to false).]]></description><name>autoScroll</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True if the component should check for hidden classes (e.g. 'x-hidden' or 'x-hide-display') and remove them on render
 (defaults to false).]]></description><name>autoShow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to use width:'auto', false to use fixed width (or allow it to be managed by its parent Container's layout manager.
 Defaults to false. Note: Although many components inherit this config option, not all will function as expected with a
 width of 'auto'. Setting autoWidth:true means that the browser will manage width based on the element's contents, and
 that Ext will not manage it at all. If the browser is managing the width, be aware that resizes performed by the browser
 in response to changes within the structure of the Component cannot be detected. Therefore changes to the width might
 result in elements needing to be synchronized with the new width. For example, where the target element is: <div
 id='grid-container' style='margin-left:25%;width:50%'></div> A Panel rendered into that target element must listen for
 browser window resize in order to relay its child items when the browser changes its width: var myPanel = new
 Ext.Panel({
     renderTo: 'grid-container',
     monitorResize: true, // relay on browser resize
     title: 'Panel',
    
 height: 400,
     autoWidth: true,
     layout: 'hbox',
     layoutConfig: {
         align: 'stretch'
     },
     defaults: {
         flex: 1
     },
     items: [{
         title: 'Box 1',
     }, {
         title: 'Box 2'
     }, {
         title:
 'Box 3'
     }],
 });]]></description><name>autoWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The error text to display if the allowBlank validation fails (defaults to 'This field is required')]]></description><name>blankText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to [].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class used to to apply to the special clearing div rendered directly after each form field wrapper to provide
 field clearing (defaults to 'x-form-clear-left'). Note: this config is only used when this Component is rendered by a
 Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or specifying
 layout:'form') and either a fieldLabel is specified or isFormField=true is specified. See Ext.layout.FormLayout.fieldTpl
 also.]]></description><name>clearCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom CSS class to apply to the field's underlying element (defaults to '').]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's container. This can be useful for adding customized
 styles to the container or any of its children using standard CSS rules. See Ext.layout.ContainerLayout.extraCls also.
 Note: ctCls defaults to '' except for the following class which assigns a value by default: Box Layout :
 'x-box-layout-ct' To configure the above Class with an extra CSS class append to the default. For example, for BoxLayout
 (Hbox and Vbox): ctCls: 'x-box-layout-ct custom-class']]></description><name>ctCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify true to disable input keystroke filtering (defaults to false)]]></description><name>disableKeyFilter</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to disable the field (defaults to false). Be aware that conformant with the HTML specification, disabled Fields
 will not be submitted.]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class added to the component when it is disabled (defaults to 'x-item-disabled').]]></description><name>disabledClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class to apply to an empty field to style the emptyText (defaults to 'x-form-empty-field'). This class is
 automatically added and removed as needed depending on the current field value.]]></description><name>emptyClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default text to place into an empty field (defaults to null). Note: that this value will be submitted to the server
 if this field is enabled and configured with a name.]]></description><name>emptyText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to enable the proxying of key events for the HTML input field (defaults to false)]]></description><name>enableKeyEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default CSS class for the field (defaults to 'x-form-field')]]></description><name>fieldClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The label text to display next to this Component (defaults to ''). Note: this config is only used when this Component is
 rendered by a Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or
 specifying layout:'form'). Also see hideLabel and Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
    
 height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name'
    
 }]
 });]]></description><name>fieldLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use a
 BoxLayout. Each child Component with a flex property will be flexed either vertically (by a VBoxLayout) or horizontally
 (by an HBoxLayout) according to the item's relative flex value compared to the sum of all Components with flex value
 specified. Any child items that have either a flex = 0 or flex = undefined will not be 'flexed' (the initial size will
 not be changed).]]></description><name>flex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class to use when the field receives focus (defaults to 'x-form-focus')]]></description><name>focusClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true if this field should automatically grow and shrink to its content (defaults to false)]]></description><name>grow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum height to allow when grow=true (defaults to 1000)]]></description><name>growMax</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum height to allow when grow=true (defaults to 60)]]></description><name>growMin</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component hidden (default is false). If true, the hide method will be called internally.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to completely hide the label element (label and separator). Defaults to false. By default, even if you do not
 specify a fieldLabel the space will still be reserved so that the field will line up with other fields that do have
 labels. Setting this to true will cause the field to not reserve that space. Note: see the note for clearCls. Example
 use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield'
        
 hideLabel: true
     }]
 });]]></description><name>hideLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[How this component should be hidden. Supported values are 'visibility' (css visibility), 'offsets' (negative offset
 position) and 'display' (css display). Note: the default of 'display' is generally preferred since items are
 automatically laid out when they are first shown (no sizing is done while hidden).]]></description><name>hideMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide and show the component's container when hide/show is called on the component, false to hide and show the
 component itself (defaults to false). For example, this can be used as a shortcut for a hide button on a window by
 setting hide:true on the button when adding it to its parent container.]]></description><name>hideParent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id of this component (defaults to an auto-assigned id). You should assign an id if you need to be able to
 access the component later and you do not have an object reference available (e.g., using Ext.getCmp). Note that this id
 will also be used as the element id for the containing HTML element that is rendered to the page for this component.
 This allows you to write id-based CSS rules to style the specific instance of this component uniquely, and also to
 select sub-elements using this component's id as the parent. Note: to avoid complications imposed by a unique id also
 see itemId and ref. Note: to access the container of an item see ownerCt.]]></description><name>id</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The type attribute for input fields -- e.g. radio, text, password, file (defaults to 'text'). The types 'file' and
 'password' must be used to render those field types currently -- there are no separate Ext components for those. Note
 that if you use inputType:'file', emptyText is not supported and should be avoided.]]></description><name>inputType</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class to use when marking a field invalid (defaults to 'x-form-invalid')]]></description><name>invalidClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The error text to use when marking a field invalid and no message is provided (defaults to 'The value in this field is
 invalid')]]></description><name>invalidText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use the
 FormLayout layout manager (e.g. Ext.form.FormPanel or specifying layout:'form'). An additional CSS class to apply to the
 div wrapping the form item element of this field. If supplied, itemCls at the field level will override the default
 itemCls supplied at the container level. The value specified for itemCls will be added to the default class
 ('x-form-item'). Since it is applied to the item wrapper (see Ext.layout.FormLayout.fieldTpl), it allows you to write
 standard CSS rules that can apply to the field, the label (if specified), or any other element within the markup for the
 field. Note: see the note for fieldLabel. Example use: // Apply a style to the field's label:
 <style>
     .required
 .x-form-item-label {font-weight:bold;color:red;}
 </style>
 
 new Ext.FormPanel({
     height: 100,
     renderTo:
 Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         itemCls: 'required' //this
 label will be styled
     },{
         xtype: 'textfield',
         fieldLabel: 'Favorite Color'
     }]
 });]]></description><name>itemCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An itemId can be used as an alternative way to get a reference to a component when no object reference is available.
 Instead of using an id with Ext.getCmp, use itemId with Ext.Container.getComponent which will retrieve itemId's or id's.
 Since itemId's are an index to the container's internal MixedCollection, the itemId is scoped locally to the container
 -- avoiding potential conflicts with Ext.ComponentMgr which requires a unique id. var c = new Ext.Panel({ //
     height:
 300,
     renderTo: document.body,
     layout: 'auto',
     items: [
         {
             itemId: 'p1',
            
 title: 'Panel 1',
             height: 150
         },
         {
             itemId: 'p2',
             title: 'Panel 2',
  
 height: 150
         }
     ]
 })
 p1 = c.getComponent('p1'); // not the same as Ext.getCmp()
 p2 =
 p1.ownerCt.getComponent('p2'); // reference via a sibling Also see id and ref. Note: to access the container of an item
 see ownerCt.]]></description><name>itemId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The separator to display after the text of each fieldLabel. This property may be configured at various levels. The order
 of precedence is: field / component level container level layout level (defaults to colon ':') To display no separator
 for this field's label specify empty string ''. Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 layoutConfig: {
         labelSeparator: '~'   // layout config has lowest priority (defaults to ':')
     },
    
 labelSeparator: '>>',     // config at container level
     items: [{
         xtype: 'textfield',
         fieldLabel:
 'Field 1',
         labelSeparator: '...' // field/component level config supersedes others
     },{
         xtype:
 'textfield',
         fieldLabel: 'Field 2' // labelSeparator will be '='
     }]
 });]]></description><name>labelSeparator</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS style specification string to apply directly to this field's label. Defaults to the container's labelStyle value
 if set (e.g., Ext.layout.FormLayout.labelStyle , or ''). Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         labelStyle: 'font-weight:bold;'
     }]
 });]]></description><name>labelStyle</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout or one of the two BoxLayout subclasses. An object containing margins to apply to this BoxComponent in the
 format: {
     top: (top margin),
     right: (right margin),
     bottom: (bottom margin),
     left: (left margin)
 } May
 also be a string containing space-separated, numeric margin values. The order of the sides associated with each value
 matches the way CSS processes margin values: If there is only one value, it applies to all sides. If there are two
 values, the top and bottom borders are set to the first value and the right and left are set to the second. If there are
 three values, the top is set to the first value, the left and right are set to the second, and the bottom is set to the
 third. If there are four values, they apply to the top, right, bottom, and left, respectively. Defaults to: {top:0,
 right:0, bottom:0, left:0}]]></description><name>margins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An input mask regular expression that will be used to filter keystrokes that do not match (defaults to null). The maskRe
 will not operate on any paste events.]]></description><name>maskRe</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Maximum input field length allowed by validation (defaults to Number.MAX_VALUE). This behavior is intended to provide
 instant feedback to the user by improving usability to allow pasting and editing or overtyping and back tracking. To
 restrict the maximum number of characters that can be entered into the field use autoCreate to add any attributes you
 want to a field, for example: var myField = new Ext.form.NumberField({
     id: 'mobile',
     anchor:'90%',
    
 fieldLabel: 'Mobile',
     maxLength: 16, // for validation
     autoCreate: {tag: 'input', type: 'text', size: '20',
 autocomplete: 'off', maxlength: '10'}
 });]]></description><name>maxLength</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Error text to display if the maximum length validation fails (defaults to 'The maximum length for this field is
 {maxLength}')]]></description><name>maxLengthText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Minimum input field length required (defaults to 0)]]></description><name>minLength</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Error text to display if the minimum length validation fails (defaults to 'The minimum length for this field is
 {minLength}')]]></description><name>minLengthText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Experimental The effect used when displaying a validation message under the field (defaults to 'normal').]]></description><name>msgFx</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The location where the message text set through markInvalid should display. Must be one of the following values: qtip
 Display a quick tip containing the message when the user hovers over the field. This is the default. Ext.QuickTips.init
 must have been called for this setting to work. title Display the message in a default browser title attribute popup.
 under Add a block div beneath the field containing the error message. side Add an error icon to the right of the field,
 displaying the message in a popup on hover. [element id] Add the error message directly to the innerHTML of the
 specified element.]]></description><name>msgTarget</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element when the mouse moves over the Element, and
 removed when the mouse moves out. (defaults to ''). This can be useful for adding customized 'active' or 'hover' styles
 to the component or any of its children using standard CSS rules.]]></description><name>overCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level x coordinate for this component if contained within a positioning container.]]></description><name>pageX</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level y coordinate for this component if contained within a positioning container.]]></description><name>pageY</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to disable marking the field invalid. Defaults to false.]]></description><name>preventMark</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to prevent scrollbars from appearing regardless of how much text is in the field. This option is only relevant when
 grow is true. Equivalent to setting overflow: hidden, defaults to false.]]></description><name>preventScrollbars</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered ptype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a Plugin is being specified not as a fully
 instantiated Component, but as a Component config object. The ptype will be looked up at render time up to determine
 what type of Plugin to create. If you create your own Plugins, you may register them using
 Ext.ComponentMgr.registerPlugin in order to be able to take advantage of lazy instantiation and rendering.]]></description><name>ptype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to mark the field as readOnly in HTML (defaults to false). Note: this only sets the element's readOnly DOM
 attribute. Setting readOnly=true, for example, will not disable triggering a ComboBox or DateField; it gives you the
 option of forcing the user to choose via the trigger without typing in the text box. To hide the trigger use
 hideTrigger.]]></description><name>readOnly</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A path specification, relative to the Component's ownerCt specifying into which ancestor Container to place a named
 reference to this Component. The ancestor axis can be traversed by using '/' characters in the path. For example, to put
 a reference to a Toolbar Button into the Panel which owns the Toolbar: var myGrid = new Ext.grid.EditorGridPanel({
    
 title: 'My EditorGridPanel',
     store: myStore,
     colModel: myColModel,
     tbar: [{
         text: 'Save',
        
 handler: saveChanges,
         disabled: true,
         ref: '../saveButton'
     }],
     listeners: {
         afteredit:
 function() {
 //          The button reference is in the GridPanel
             myGrid.saveButton.enable();
         }
    
 }
 }); In the code above, if the ref had been 'saveButton' the reference would have been placed into the Toolbar. Each
 '/' in the ref moves up one level from the Component's ownerCt. Also see the added and removed events.]]></description><name>ref</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A JavaScript RegExp object to be tested against the field value during validation (defaults to null). If the test fails,
 the field will be marked invalid using regexText.]]></description><name>regex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The error text to display if regex is used and the test fails during validation (defaults to '')]]></description><name>regexText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout layout manager (e.g. specifying layout:'border'). See Ext.layout.BorderLayout also.]]></description><name>region</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to automatically select any existing field text when the field receives input focus (defaults to false)]]></description><name>selectOnFocus</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should trigger this component to save its state (defaults to none). stateEvents may
 be any type of event supported by this component, including browser or custom events (e.g., ['click',
 'customerchange']). See stateful for an explanation of saving and restoring Component state.]]></description><name>stateEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id for this component to use for state management purposes (defaults to the component id if one was set,
 otherwise null if the component is using a generated id). See stateful for an explanation of saving and restoring
 Component state.]]></description><name>stateId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A flag which causes the Component to attempt to restore the state of internal properties from a saved state on startup.
 The component must have either a stateId or id assigned for state to be managed. Auto-generated ids are not guaranteed
 to be stable across page loads and cannot be relied upon to save and restore the same state for a component. For state
 saving to work, the state manager's provider must have been set to an implementation of Ext.state.Provider which
 overrides the set and get methods to save and recall name/value pairs. A built-in implementation,
 Ext.state.CookieProvider is available. To set the state provider for the current page: Ext.state.Manager.setProvider(new
 Ext.state.CookieProvider({
     expires: new Date(new Date().getTime()+(1000*60*60*24*7)), //7 days from now
 })); A
 stateful Component attempts to save state when one of the events listed in the stateEvents configuration fires. To save
 state, a stateful Component first serializes its state by calling getState. By default, this function does nothing. The
 developer must provide an implementation which returns an object hash which represents the Component's restorable state.
 The value yielded by getState is passed to Ext.state.Manager.set which uses the configured Ext.state.Provider to save
 the object keyed by the Component's stateId, or, if that is not specified, its id. During construction, a stateful
 Component attempts to restore its state by calling Ext.state.Manager.get passing the stateId, or, if that is not
 specified, the id. The resulting object is passed to applyState. The default implementation of applyState simply copies
 properties into the object, but a developer may override this to support more behaviour. You can perform extra
 processing on state save and restore by attaching handlers to the beforestaterestore, staterestore, beforestatesave and
 statesave events.]]></description><name>stateful</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A JavaScript RegExp object used to strip unwanted content from the value before validation (defaults to null).]]></description><name>stripCharsRe</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
     title: 'Some Title',
     renderTo: Ext.getBody(),
     width: 400, height:
 300,
     layout: 'form',
     items: [{
         xtype: 'textarea',
         style: {
             width: '95%',
            
 marginBottom: '10px'
         }
     },
         new Ext.Button({
             text: 'Send',
             minWidth: '100',
   
          style: {
                 marginBottom: '10px'
             }
         })
     ]
 });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[False to clear the name attribute on the field so that it is not submitted during a form post. Defaults to true.]]></description><name>submitValue</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The tabIndex for this field. Note this only applies to fields that are rendered, not those which are built via applyTo
 (defaults to undefined).]]></description><name>tabIndex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is a child item of a TabPanel. A string to be used as innerHTML
 (html tags are accepted) to show in a tooltip when mousing over the associated tab selector element.
 Ext.QuickTips.init() must be called in order for the tips to render.]]></description><name>tabTip</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Whether the field should validate when it loses focus (defaults to true).]]></description><name>validateOnBlur</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The length of time in milliseconds after user input begins until validation is initiated (defaults to 250)]]></description><name>validationDelay</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The event that should initiate field validation. Set to false to disable automatic validation (defaults to 'keyup').]]></description><name>validationEvent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom validation function to be called during field validation (validateValue) (defaults to null). If specified, this
 function will be called first, allowing the developer to override the default validation process. This function will be
 passed the following Parameters: value: Mixed The current field value This function is to Return: true: Boolean true if
 the value is valid msg: String An error message if the value is invalid]]></description><name>validator</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A value to initialize this field with (defaults to undefined).]]></description><name>value</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A validation type name as defined in Ext.form.VTypes (defaults to null)]]></description><name>vtype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom error message to display in place of the default message provided for the vtype currently set for this field
 (defaults to ''). Note: only applies if vtype is set, else ignored.]]></description><name>vtypeText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local x (left) coordinate for this component if contained within a positioning container.]]></description><name>x</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered xtype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a child item of a Container is being specified not
 as a fully instantiated Component, but as a Component config object. The xtype will be looked up at render time up to
 determine what type of child Component to create. The predefined xtypes are listed here. If you subclass Components to
 create your own Components, you may register them using Ext.ComponentMgr.registerType in order to be able to take
 advantage of lazy instantiation and rendering.]]></description><name>xtype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local y (top) coordinate for this component if contained within a positioning container.]]></description><name>y</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 <p>Basic text field. Can be used as a direct replacement for traditional text inputs, or as the base class for more
 sophisticated input controls (like <a href="output/Ext.form.TextArea.html"
 ext:cls="Ext.form.TextArea">Ext.form.TextArea</a> and <a href="output/Ext.form.ComboBox.html"
 ext:cls="Ext.form.ComboBox">Ext.form.ComboBox</a>).</p> 
 <p><b><u>Validation</u></b></p> 
 <p>The validation procedure is
 described in the documentation for <a href="output/Ext.form.TextField.html#Ext.form.TextField-validateValue"
 ext:member="validateValue" ext:cls="Ext.form.TextField">validateValue</a>.</p> 
 <p><b><u>Alter Validation
 Behavior</u></b></p> 
 <p>Validation behavior for each field can be configured:</p> 
 <div class="mdetail-params">
  <ul> 
 
 <li><code><a href="output/Ext.form.TextField.html#Ext.form.TextField-invalidText" ext:member="invalidText"
 ext:cls="Ext.form.TextField">invalidText</a></code> : the default validation message to show if any validation step
 above does not provide a message when invalid</li> 
   <li><code><a
 href="output/Ext.form.TextField.html#Ext.form.TextField-maskRe" ext:member="maskRe"
 ext:cls="Ext.form.TextField">maskRe</a></code> : filter out keystrokes before any validation occurs</li> 
   <li><code><a
 href="output/Ext.form.TextField.html#Ext.form.TextField-stripCharsRe" ext:member="stripCharsRe"
 ext:cls="Ext.form.TextField">stripCharsRe</a></code> : filter characters after being typed in, but before being
 validated</li> 
   <li><code><a href="output/Ext.form.Field.html#Ext.form.Field-invalidClass" ext:member="invalidClass"
 ext:cls="Ext.form.Field">invalidClass</a></code> : alternate style when invalid</li> 
   <li><code><a
 href="output/Ext.form.Field.html#Ext.form.Field-validateOnBlur" ext:member="validateOnBlur"
 ext:cls="Ext.form.Field">validateOnBlur</a></code>, <code><a
 href="output/Ext.form.Field.html#Ext.form.Field-validationDelay" ext:member="validationDelay"
 ext:cls="Ext.form.Field">validationDelay</a></code>, and <code><a
 href="output/Ext.form.Field.html#Ext.form.Field-validationEvent" ext:member="validationEvent"
 ext:cls="Ext.form.Field">validationEvent</a></code> : modify how/when validation is triggered</li> 
  </ul>
 </div>]]></description><name>form.textfield</name><tag-class>org.brushingbits.jnap.ui.extjs3.form.TextField</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[The field's HTML name attribute (defaults to ''). Note: this property must be set if this field is to be automatically
 included with form submit().]]></description><name>name</name><required>true</required><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify false to validate that the value's length is > 0 (defaults to true)]]></description><name>allowBlank</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Whether the component can move the Dom node when rendering (defaults to true).]]></description><name>allowDomMove</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use an
 AnchorLayout (or subclass thereof). based layout manager, for example: Ext.form.FormPanel specifying layout: 'anchor' //
 or 'form', or 'absolute' See Ext.layout.AnchorLayout.anchor also.]]></description><name>anchor</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element corresponding to a DIV that is already present in
 the document that specifies some structural markup for this component. Description : When applyTo is used, constituent
 parts of the component can also be specified by id or CSS class name within the main element, and the component being
 created may attempt to create its subcomponents from that markup if applicable. Notes : When using this config, a call
 to render() is not required. If applyTo is specified, any value passed for renderTo will be ignored and the target
 element's parent node will automatically be used as the component's container.]]></description><name>applyTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A DomHelper element spec, or true for a default element spec. Used to create the Element which will encapsulate this
 Component. See autoEl for details. Defaults to: {tag: 'input', type: 'text', size: '20', autocomplete: 'off'}]]></description><name>autoCreate</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A tag name or DomHelper spec used to create the Element which will encapsulate this Component. You do not normally need
 to specify this. For the base classes Ext.Component, Ext.BoxComponent, and Ext.Container, this defaults to 'div'. The
 more complex Ext classes use a more complex DOM structure created by their own onRender methods. This is intended to
 allow the developer to create application-specific utility Components encapsulated by different DOM elements. Example
 usage: <pre><code>{
     xtype: 'box',
     autoEl: {
         tag: 'img',
         src: 'http://www.example.com/example.jpg'
     }
 },
 {
     xtype: 'box',
     autoEl: {
         tag: 'blockquote',
         html: 'autoEl is cool!'
     }
 }, {
     xtype: 'container',
     autoEl: 'ul',
     cls: 'ux-unordered-list',
     items: {
         xtype: 'box',
         autoEl: 'li',
   
      html: 'First list item'
     }
 }</pre></code>]]></description><name>autoEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to use height:'auto', false to use fixed height (or allow it to be managed by its parent Container's layout
 manager. Defaults to false. Note: Although many components inherit this config option, not all will function as expected
 with a height of 'auto'. Setting autoHeight:true means that the browser will manage height based on the element's
 contents, and that Ext will not manage it at all. If the browser is managing the height, be aware that resizes performed
 by the browser in response to changes within the structure of the Component cannot be detected. Therefore changes to the
 height might result in elements needing to be synchronized with the new height. Example: var w = new Ext.Window({
    
 title: 'Window',
     width: 600,
     autoHeight: true,
     items: {
         title: 'Collapse Me',
         height: 400,
  
 collapsible: true,
         border: false,
         listeners: {
             beforecollapse: function() {
                w.el.shadow.hide();
             },
             beforeexpand: function() {
                w.el.shadow.hide();
             },
             collapse: function() {
                w.syncShadow();
             },
             expand: function() {
                w.syncShadow();
             }
         }
     }
 }).show();]]></description><name>autoHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to use overflow:'auto' on the components layout element and show scroll bars automatically when necessary, false to
 clip any overflowing content (defaults to false).]]></description><name>autoScroll</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True if the component should check for hidden classes (e.g. 'x-hidden' or 'x-hide-display') and remove them on render
 (defaults to false).]]></description><name>autoShow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to use width:'auto', false to use fixed width (or allow it to be managed by its parent Container's layout manager.
 Defaults to false. Note: Although many components inherit this config option, not all will function as expected with a
 width of 'auto'. Setting autoWidth:true means that the browser will manage width based on the element's contents, and
 that Ext will not manage it at all. If the browser is managing the width, be aware that resizes performed by the browser
 in response to changes within the structure of the Component cannot be detected. Therefore changes to the width might
 result in elements needing to be synchronized with the new width. For example, where the target element is: <div
 id='grid-container' style='margin-left:25%;width:50%'></div> A Panel rendered into that target element must listen for
 browser window resize in order to relay its child items when the browser changes its width: var myPanel = new
 Ext.Panel({
     renderTo: 'grid-container',
     monitorResize: true, // relay on browser resize
     title: 'Panel',
    
 height: 400,
     autoWidth: true,
     layout: 'hbox',
     layoutConfig: {
         align: 'stretch'
     },
     defaults: {
         flex: 1
     },
     items: [{
         title: 'Box 1',
     }, {
         title: 'Box 2'
     }, {
         title:
 'Box 3'
     }],
 });]]></description><name>autoWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The error text to display if the allowBlank validation fails (defaults to 'This field is required')]]></description><name>blankText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to [].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class used to to apply to the special clearing div rendered directly after each form field wrapper to provide
 field clearing (defaults to 'x-form-clear-left'). Note: this config is only used when this Component is rendered by a
 Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or specifying
 layout:'form') and either a fieldLabel is specified or isFormField=true is specified. See Ext.layout.FormLayout.fieldTpl
 also.]]></description><name>clearCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom CSS class to apply to the field's underlying element (defaults to '').]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's container. This can be useful for adding customized
 styles to the container or any of its children using standard CSS rules. See Ext.layout.ContainerLayout.extraCls also.
 Note: ctCls defaults to '' except for the following class which assigns a value by default: Box Layout :
 'x-box-layout-ct' To configure the above Class with an extra CSS class append to the default. For example, for BoxLayout
 (Hbox and Vbox): ctCls: 'x-box-layout-ct custom-class']]></description><name>ctCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify true to disable input keystroke filtering (defaults to false)]]></description><name>disableKeyFilter</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to disable the field (defaults to false). Be aware that conformant with the HTML specification, disabled Fields
 will not be submitted.]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class added to the component when it is disabled (defaults to 'x-item-disabled').]]></description><name>disabledClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class to apply to an empty field to style the emptyText (defaults to 'x-form-empty-field'). This class is
 automatically added and removed as needed depending on the current field value.]]></description><name>emptyClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default text to place into an empty field (defaults to null). Note: that this value will be submitted to the server
 if this field is enabled and configured with a name.]]></description><name>emptyText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to enable the proxying of key events for the HTML input field (defaults to false)]]></description><name>enableKeyEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default CSS class for the field (defaults to 'x-form-field')]]></description><name>fieldClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The label text to display next to this Component (defaults to ''). Note: this config is only used when this Component is
 rendered by a Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or
 specifying layout:'form'). Also see hideLabel and Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
    
 height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name'
    
 }]
 });]]></description><name>fieldLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use a
 BoxLayout. Each child Component with a flex property will be flexed either vertically (by a VBoxLayout) or horizontally
 (by an HBoxLayout) according to the item's relative flex value compared to the sum of all Components with flex value
 specified. Any child items that have either a flex = 0 or flex = undefined will not be 'flexed' (the initial size will
 not be changed).]]></description><name>flex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class to use when the field receives focus (defaults to 'x-form-focus')]]></description><name>focusClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true if this field should automatically grow and shrink to its content (defaults to false)]]></description><name>grow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum width to allow when grow = true (defaults to 800)]]></description><name>growMax</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum width to allow when grow = true (defaults to 30)]]></description><name>growMin</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component hidden (default is false). If true, the hide method will be called internally.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to completely hide the label element (label and separator). Defaults to false. By default, even if you do not
 specify a fieldLabel the space will still be reserved so that the field will line up with other fields that do have
 labels. Setting this to true will cause the field to not reserve that space. Note: see the note for clearCls. Example
 use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield'
        
 hideLabel: true
     }]
 });]]></description><name>hideLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[How this component should be hidden. Supported values are 'visibility' (css visibility), 'offsets' (negative offset
 position) and 'display' (css display). Note: the default of 'display' is generally preferred since items are
 automatically laid out when they are first shown (no sizing is done while hidden).]]></description><name>hideMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide and show the component's container when hide/show is called on the component, false to hide and show the
 component itself (defaults to false). For example, this can be used as a shortcut for a hide button on a window by
 setting hide:true on the button when adding it to its parent container.]]></description><name>hideParent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id of this component (defaults to an auto-assigned id). You should assign an id if you need to be able to
 access the component later and you do not have an object reference available (e.g., using Ext.getCmp). Note that this id
 will also be used as the element id for the containing HTML element that is rendered to the page for this component.
 This allows you to write id-based CSS rules to style the specific instance of this component uniquely, and also to
 select sub-elements using this component's id as the parent. Note: to avoid complications imposed by a unique id also
 see itemId and ref. Note: to access the container of an item see ownerCt.]]></description><name>id</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The type attribute for input fields -- e.g. radio, text, password, file (defaults to 'text'). The types 'file' and
 'password' must be used to render those field types currently -- there are no separate Ext components for those. Note
 that if you use inputType:'file', emptyText is not supported and should be avoided.]]></description><name>inputType</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class to use when marking a field invalid (defaults to 'x-form-invalid')]]></description><name>invalidClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The error text to use when marking a field invalid and no message is provided (defaults to 'The value in this field is
 invalid')]]></description><name>invalidText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use the
 FormLayout layout manager (e.g. Ext.form.FormPanel or specifying layout:'form'). An additional CSS class to apply to the
 div wrapping the form item element of this field. If supplied, itemCls at the field level will override the default
 itemCls supplied at the container level. The value specified for itemCls will be added to the default class
 ('x-form-item'). Since it is applied to the item wrapper (see Ext.layout.FormLayout.fieldTpl), it allows you to write
 standard CSS rules that can apply to the field, the label (if specified), or any other element within the markup for the
 field. Note: see the note for fieldLabel. Example use: // Apply a style to the field's label:
 <style>
     .required
 .x-form-item-label {font-weight:bold;color:red;}
 </style>
 
 new Ext.FormPanel({
     height: 100,
     renderTo:
 Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         itemCls: 'required' //this
 label will be styled
     },{
         xtype: 'textfield',
         fieldLabel: 'Favorite Color'
     }]
 });]]></description><name>itemCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An itemId can be used as an alternative way to get a reference to a component when no object reference is available.
 Instead of using an id with Ext.getCmp, use itemId with Ext.Container.getComponent which will retrieve itemId's or id's.
 Since itemId's are an index to the container's internal MixedCollection, the itemId is scoped locally to the container
 -- avoiding potential conflicts with Ext.ComponentMgr which requires a unique id. var c = new Ext.Panel({ //
     height:
 300,
     renderTo: document.body,
     layout: 'auto',
     items: [
         {
             itemId: 'p1',
            
 title: 'Panel 1',
             height: 150
         },
         {
             itemId: 'p2',
             title: 'Panel 2',
  
 height: 150
         }
     ]
 })
 p1 = c.getComponent('p1'); // not the same as Ext.getCmp()
 p2 =
 p1.ownerCt.getComponent('p2'); // reference via a sibling Also see id and ref. Note: to access the container of an item
 see ownerCt.]]></description><name>itemId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The separator to display after the text of each fieldLabel. This property may be configured at various levels. The order
 of precedence is: field / component level container level layout level (defaults to colon ':') To display no separator
 for this field's label specify empty string ''. Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 layoutConfig: {
         labelSeparator: '~'   // layout config has lowest priority (defaults to ':')
     },
    
 labelSeparator: '>>',     // config at container level
     items: [{
         xtype: 'textfield',
         fieldLabel:
 'Field 1',
         labelSeparator: '...' // field/component level config supersedes others
     },{
         xtype:
 'textfield',
         fieldLabel: 'Field 2' // labelSeparator will be '='
     }]
 });]]></description><name>labelSeparator</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS style specification string to apply directly to this field's label. Defaults to the container's labelStyle value
 if set (e.g., Ext.layout.FormLayout.labelStyle , or ''). Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         labelStyle: 'font-weight:bold;'
     }]
 });]]></description><name>labelStyle</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout or one of the two BoxLayout subclasses. An object containing margins to apply to this BoxComponent in the
 format: {
     top: (top margin),
     right: (right margin),
     bottom: (bottom margin),
     left: (left margin)
 } May
 also be a string containing space-separated, numeric margin values. The order of the sides associated with each value
 matches the way CSS processes margin values: If there is only one value, it applies to all sides. If there are two
 values, the top and bottom borders are set to the first value and the right and left are set to the second. If there are
 three values, the top is set to the first value, the left and right are set to the second, and the bottom is set to the
 third. If there are four values, they apply to the top, right, bottom, and left, respectively. Defaults to: {top:0,
 right:0, bottom:0, left:0}]]></description><name>margins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An input mask regular expression that will be used to filter keystrokes that do not match (defaults to null). The maskRe
 will not operate on any paste events.]]></description><name>maskRe</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Maximum input field length allowed by validation (defaults to Number.MAX_VALUE). This behavior is intended to provide
 instant feedback to the user by improving usability to allow pasting and editing or overtyping and back tracking. To
 restrict the maximum number of characters that can be entered into the field use autoCreate to add any attributes you
 want to a field, for example: var myField = new Ext.form.NumberField({
     id: 'mobile',
     anchor:'90%',
    
 fieldLabel: 'Mobile',
     maxLength: 16, // for validation
     autoCreate: {tag: 'input', type: 'text', size: '20',
 autocomplete: 'off', maxlength: '10'}
 });]]></description><name>maxLength</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Error text to display if the maximum length validation fails (defaults to 'The maximum length for this field is
 {maxLength}')]]></description><name>maxLengthText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Minimum input field length required (defaults to 0)]]></description><name>minLength</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Error text to display if the minimum length validation fails (defaults to 'The minimum length for this field is
 {minLength}')]]></description><name>minLengthText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Experimental The effect used when displaying a validation message under the field (defaults to 'normal').]]></description><name>msgFx</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The location where the message text set through markInvalid should display. Must be one of the following values: qtip
 Display a quick tip containing the message when the user hovers over the field. This is the default. Ext.QuickTips.init
 must have been called for this setting to work. title Display the message in a default browser title attribute popup.
 under Add a block div beneath the field containing the error message. side Add an error icon to the right of the field,
 displaying the message in a popup on hover. [element id] Add the error message directly to the innerHTML of the
 specified element.]]></description><name>msgTarget</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element when the mouse moves over the Element, and
 removed when the mouse moves out. (defaults to ''). This can be useful for adding customized 'active' or 'hover' styles
 to the component or any of its children using standard CSS rules.]]></description><name>overCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level x coordinate for this component if contained within a positioning container.]]></description><name>pageX</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level y coordinate for this component if contained within a positioning container.]]></description><name>pageY</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to disable marking the field invalid. Defaults to false.]]></description><name>preventMark</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered ptype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a Plugin is being specified not as a fully
 instantiated Component, but as a Component config object. The ptype will be looked up at render time up to determine
 what type of Plugin to create. If you create your own Plugins, you may register them using
 Ext.ComponentMgr.registerPlugin in order to be able to take advantage of lazy instantiation and rendering.]]></description><name>ptype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to mark the field as readOnly in HTML (defaults to false). Note: this only sets the element's readOnly DOM
 attribute. Setting readOnly=true, for example, will not disable triggering a ComboBox or DateField; it gives you the
 option of forcing the user to choose via the trigger without typing in the text box. To hide the trigger use
 hideTrigger.]]></description><name>readOnly</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A path specification, relative to the Component's ownerCt specifying into which ancestor Container to place a named
 reference to this Component. The ancestor axis can be traversed by using '/' characters in the path. For example, to put
 a reference to a Toolbar Button into the Panel which owns the Toolbar: var myGrid = new Ext.grid.EditorGridPanel({
    
 title: 'My EditorGridPanel',
     store: myStore,
     colModel: myColModel,
     tbar: [{
         text: 'Save',
        
 handler: saveChanges,
         disabled: true,
         ref: '../saveButton'
     }],
     listeners: {
         afteredit:
 function() {
 //          The button reference is in the GridPanel
             myGrid.saveButton.enable();
         }
    
 }
 }); In the code above, if the ref had been 'saveButton' the reference would have been placed into the Toolbar. Each
 '/' in the ref moves up one level from the Component's ownerCt. Also see the added and removed events.]]></description><name>ref</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A JavaScript RegExp object to be tested against the field value during validation (defaults to null). If the test fails,
 the field will be marked invalid using regexText.]]></description><name>regex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The error text to display if regex is used and the test fails during validation (defaults to '')]]></description><name>regexText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout layout manager (e.g. specifying layout:'border'). See Ext.layout.BorderLayout also.]]></description><name>region</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to automatically select any existing field text when the field receives input focus (defaults to false)]]></description><name>selectOnFocus</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should trigger this component to save its state (defaults to none). stateEvents may
 be any type of event supported by this component, including browser or custom events (e.g., ['click',
 'customerchange']). See stateful for an explanation of saving and restoring Component state.]]></description><name>stateEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id for this component to use for state management purposes (defaults to the component id if one was set,
 otherwise null if the component is using a generated id). See stateful for an explanation of saving and restoring
 Component state.]]></description><name>stateId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A flag which causes the Component to attempt to restore the state of internal properties from a saved state on startup.
 The component must have either a stateId or id assigned for state to be managed. Auto-generated ids are not guaranteed
 to be stable across page loads and cannot be relied upon to save and restore the same state for a component. For state
 saving to work, the state manager's provider must have been set to an implementation of Ext.state.Provider which
 overrides the set and get methods to save and recall name/value pairs. A built-in implementation,
 Ext.state.CookieProvider is available. To set the state provider for the current page: Ext.state.Manager.setProvider(new
 Ext.state.CookieProvider({
     expires: new Date(new Date().getTime()+(1000*60*60*24*7)), //7 days from now
 })); A
 stateful Component attempts to save state when one of the events listed in the stateEvents configuration fires. To save
 state, a stateful Component first serializes its state by calling getState. By default, this function does nothing. The
 developer must provide an implementation which returns an object hash which represents the Component's restorable state.
 The value yielded by getState is passed to Ext.state.Manager.set which uses the configured Ext.state.Provider to save
 the object keyed by the Component's stateId, or, if that is not specified, its id. During construction, a stateful
 Component attempts to restore its state by calling Ext.state.Manager.get passing the stateId, or, if that is not
 specified, the id. The resulting object is passed to applyState. The default implementation of applyState simply copies
 properties into the object, but a developer may override this to support more behaviour. You can perform extra
 processing on state save and restore by attaching handlers to the beforestaterestore, staterestore, beforestatesave and
 statesave events.]]></description><name>stateful</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A JavaScript RegExp object used to strip unwanted content from the value before validation (defaults to null).]]></description><name>stripCharsRe</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
     title: 'Some Title',
     renderTo: Ext.getBody(),
     width: 400, height:
 300,
     layout: 'form',
     items: [{
         xtype: 'textarea',
         style: {
             width: '95%',
            
 marginBottom: '10px'
         }
     },
         new Ext.Button({
             text: 'Send',
             minWidth: '100',
   
          style: {
                 marginBottom: '10px'
             }
         })
     ]
 });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[False to clear the name attribute on the field so that it is not submitted during a form post. Defaults to true.]]></description><name>submitValue</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The tabIndex for this field. Note this only applies to fields that are rendered, not those which are built via applyTo
 (defaults to undefined).]]></description><name>tabIndex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is a child item of a TabPanel. A string to be used as innerHTML
 (html tags are accepted) to show in a tooltip when mousing over the associated tab selector element.
 Ext.QuickTips.init() must be called in order for the tips to render.]]></description><name>tabTip</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Whether the field should validate when it loses focus (defaults to true).]]></description><name>validateOnBlur</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The length of time in milliseconds after user input begins until validation is initiated (defaults to 250)]]></description><name>validationDelay</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The event that should initiate field validation. Set to false to disable automatic validation (defaults to 'keyup').]]></description><name>validationEvent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom validation function to be called during field validation (validateValue) (defaults to null). If specified, this
 function will be called first, allowing the developer to override the default validation process. This function will be
 passed the following Parameters: value: Mixed The current field value This function is to Return: true: Boolean true if
 the value is valid msg: String An error message if the value is invalid]]></description><name>validator</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A value to initialize this field with (defaults to undefined).]]></description><name>value</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A validation type name as defined in Ext.form.VTypes (defaults to null)]]></description><name>vtype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom error message to display in place of the default message provided for the vtype currently set for this field
 (defaults to ''). Note: only applies if vtype is set, else ignored.]]></description><name>vtypeText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local x (left) coordinate for this component if contained within a positioning container.]]></description><name>x</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered xtype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a child item of a Container is being specified not
 as a fully instantiated Component, but as a Component config object. The xtype will be looked up at render time up to
 determine what type of child Component to create. The predefined xtypes are listed here. If you subclass Components to
 create your own Components, you may register them using Ext.ComponentMgr.registerType in order to be able to take
 advantage of lazy instantiation and rendering.]]></description><name>xtype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local y (top) coordinate for this component if contained within a positioning container.]]></description><name>y</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 Provides a time input field with a time dropdown and automatic time validation. Example usage: 
 <pre><code><b>new</b>
 Ext.form.TimeField({
     minValue: <em>'9:00 AM'</em>,
     maxValue: <em>'6:00 PM'</em>,
     increment:
 30
 });</code></pre>]]></description><name>form.timefield</name><tag-class>org.brushingbits.jnap.ui.extjs3.form.TimeField</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[The field's HTML name attribute (defaults to ''). Note: this property must be set if this field is to be automatically
 included with form submit().]]></description><name>name</name><required>true</required><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The text query to send to the server to return all records for the list with no filtering (defaults to '')]]></description><name>allQuery</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify false to validate that the value's length is > 0 (defaults to true)]]></description><name>allowBlank</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Whether the component can move the Dom node when rendering (defaults to true).]]></description><name>allowDomMove</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Multiple date formats separated by "|" to try when parsing a user input value and it doesn't match the defined format
 (defaults to 'g:ia|g:iA|g:i a|g:i A|h:i|g:i|H:i|ga|ha|gA|h a|g a|g A|gi|hi|gia|hia|g|H|gi a|hi a|giA|hiA|gi A|hi A').]]></description><name>altFormats</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use an
 AnchorLayout (or subclass thereof). based layout manager, for example: Ext.form.FormPanel specifying layout: 'anchor' //
 or 'form', or 'absolute' See Ext.layout.AnchorLayout.anchor also.]]></description><name>anchor</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element corresponding to a DIV that is already present in
 the document that specifies some structural markup for this component. Description : When applyTo is used, constituent
 parts of the component can also be specified by id or CSS class name within the main element, and the component being
 created may attempt to create its subcomponents from that markup if applicable. Notes : When using this config, a call
 to render() is not required. If applyTo is specified, any value passed for renderTo will be ignored and the target
 element's parent node will automatically be used as the component's container.]]></description><name>applyTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A DomHelper element spec, or true for a default element spec. Used to create the Element which will encapsulate this
 Component. See autoEl for details. Defaults to: {tag: "input", type: "text", size: "24", autocomplete: "off"}]]></description><name>autoCreate</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A tag name or DomHelper spec used to create the Element which will encapsulate this Component. You do not normally need
 to specify this. For the base classes Ext.Component, Ext.BoxComponent, and Ext.Container, this defaults to 'div'. The
 more complex Ext classes use a more complex DOM structure created by their own onRender methods. This is intended to
 allow the developer to create application-specific utility Components encapsulated by different DOM elements. Example
 usage: <pre><code>{
     xtype: 'box',
     autoEl: {
         tag: 'img',
         src: 'http://www.example.com/example.jpg'
     }
 },
 {
     xtype: 'box',
     autoEl: {
         tag: 'blockquote',
         html: 'autoEl is cool!'
     }
 }, {
     xtype: 'container',
     autoEl: 'ul',
     cls: 'ux-unordered-list',
     items: {
         xtype: 'box',
         autoEl: 'li',
   
      html: 'First list item'
     }
 }</pre></code>]]></description><name>autoEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to use height:'auto', false to use fixed height (or allow it to be managed by its parent Container's layout
 manager. Defaults to false. Note: Although many components inherit this config option, not all will function as expected
 with a height of 'auto'. Setting autoHeight:true means that the browser will manage height based on the element's
 contents, and that Ext will not manage it at all. If the browser is managing the height, be aware that resizes performed
 by the browser in response to changes within the structure of the Component cannot be detected. Therefore changes to the
 height might result in elements needing to be synchronized with the new height. Example: var w = new Ext.Window({
    
 title: 'Window',
     width: 600,
     autoHeight: true,
     items: {
         title: 'Collapse Me',
         height: 400,
  
 collapsible: true,
         border: false,
         listeners: {
             beforecollapse: function() {
                w.el.shadow.hide();
             },
             beforeexpand: function() {
                w.el.shadow.hide();
             },
             collapse: function() {
                w.syncShadow();
             },
             expand: function() {
                w.syncShadow();
             }
         }
     }
 }).show();]]></description><name>autoHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to use overflow:'auto' on the components layout element and show scroll bars automatically when necessary, false to
 clip any overflowing content (defaults to false).]]></description><name>autoScroll</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to select the first result gathered by the data store (defaults to true). A false value would require a manual
 selection from the dropdown list to set the components value unless the value of (typeAheadDelay) were true.]]></description><name>autoSelect</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True if the component should check for hidden classes (e.g. 'x-hidden' or 'x-hide-display') and remove them on render
 (defaults to false).]]></description><name>autoShow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to use width:'auto', false to use fixed width (or allow it to be managed by its parent Container's layout manager.
 Defaults to false. Note: Although many components inherit this config option, not all will function as expected with a
 width of 'auto'. Setting autoWidth:true means that the browser will manage width based on the element's contents, and
 that Ext will not manage it at all. If the browser is managing the width, be aware that resizes performed by the browser
 in response to changes within the structure of the Component cannot be detected. Therefore changes to the width might
 result in elements needing to be synchronized with the new width. For example, where the target element is: <div
 id='grid-container' style='margin-left:25%;width:50%'></div> A Panel rendered into that target element must listen for
 browser window resize in order to relay its child items when the browser changes its width: var myPanel = new
 Ext.Panel({
     renderTo: 'grid-container',
     monitorResize: true, // relay on browser resize
     title: 'Panel',
    
 height: 400,
     autoWidth: true,
     layout: 'hbox',
     layoutConfig: {
         align: 'stretch'
     },
     defaults: {
         flex: 1
     },
     items: [{
         title: 'Box 1',
     }, {
         title: 'Box 2'
     }, {
         title:
 'Box 3'
     }],
 });]]></description><name>autoWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The error text to display if the allowBlank validation fails (defaults to 'This field is required')]]></description><name>blankText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to [].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class used to to apply to the special clearing div rendered directly after each form field wrapper to provide
 field clearing (defaults to 'x-form-clear-left'). Note: this config is only used when this Component is rendered by a
 Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or specifying
 layout:'form') and either a fieldLabel is specified or isFormField=true is specified. See Ext.layout.FormLayout.fieldTpl
 also.]]></description><name>clearCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to clear any filters on the store (when in local mode) when reset is called (defaults to true)]]></description><name>clearFilterOnReset</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom CSS class to apply to the field's underlying element (defaults to '').]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's container. This can be useful for adding customized
 styles to the container or any of its children using standard CSS rules. See Ext.layout.ContainerLayout.extraCls also.
 Note: ctCls defaults to '' except for the following class which assigns a value by default: Box Layout :
 'x-box-layout-ct' To configure the above Class with an extra CSS class append to the default. For example, for BoxLayout
 (Hbox and Vbox): ctCls: 'x-box-layout-ct custom-class']]></description><name>ctCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify true to disable input keystroke filtering (defaults to false)]]></description><name>disableKeyFilter</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to disable the field (defaults to false). Be aware that conformant with the HTML specification, disabled Fields
 will not be submitted.]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class added to the component when it is disabled (defaults to 'x-item-disabled').]]></description><name>disabledClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The underlying data field name to bind to this ComboBox (defaults to undefined if mode = 'remote' or 'field1' if
 transforming a select or if the field name is autogenerated based on the store configuration). See also valueField.
 Note: if using a ComboBox in an Editor Grid a renderer will be needed to show the displayField when the editor is not
 active.]]></description><name>displayField</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[false to prevent the user from typing text directly into the field, the field will only respond to a click on the
 trigger to set the value. (defaults to true).]]></description><name>editable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class to apply to an empty field to style the emptyText (defaults to 'x-form-empty-field'). This class is
 automatically added and removed as needed depending on the current field value.]]></description><name>emptyClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default text to place into an empty field (defaults to null). Note: that this value will be submitted to the server
 if this field is enabled and configured with a name.]]></description><name>emptyText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to enable the proxying of key events for the HTML input field (defaults to false)]]></description><name>enableKeyEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default CSS class for the field (defaults to 'x-form-field')]]></description><name>fieldClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The label text to display next to this Component (defaults to ''). Note: this config is only used when this Component is
 rendered by a Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or
 specifying layout:'form'). Also see hideLabel and Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
    
 height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name'
    
 }]
 });]]></description><name>fieldLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use a
 BoxLayout. Each child Component with a flex property will be flexed either vertically (by a VBoxLayout) or horizontally
 (by an HBoxLayout) according to the item's relative flex value compared to the sum of all Components with flex value
 specified. Any child items that have either a flex = 0 or flex = undefined will not be 'flexed' (the initial size will
 not be changed).]]></description><name>flex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class to use when the field receives focus (defaults to 'x-form-focus')]]></description><name>focusClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to restrict the selected value to one of the values in the list, false to allow the user to set arbitrary text into
 the field (defaults to false)]]></description><name>forceSelection</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default time format string which can be overriden for localization support. The format must be valid according to
 Date.parseDate (defaults to 'g:i A', e.g., '3:15 PM'). For 24-hour time format try 'H:i' instead.]]></description><name>format</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true if this field should automatically grow and shrink to its content (defaults to false)]]></description><name>grow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum width to allow when grow = true (defaults to 800)]]></description><name>growMax</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum width to allow when grow = true (defaults to 30)]]></description><name>growMin</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height in pixels of the dropdown list resize handle if resizable = true (defaults to 8)]]></description><name>handleHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component hidden (default is false). If true, the hide method will be called internally.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If hiddenName is specified, hiddenId can also be provided to give the hidden field a unique id. The hiddenId and combo
 id should be different, since no two DOM nodes should share the same id.]]></description><name>hiddenId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If specified, a hidden form field with this name is dynamically generated to store the field's data value (defaults to
 the underlying DOM element's name). Required for the combo's value to automatically post during a form submission. See
 also valueField.]]></description><name>hiddenName</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Sets the initial value of the hidden field if hiddenName is specified to contain the selected valueField, from the
 Store. Defaults to the configured value.]]></description><name>hiddenValue</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to completely hide the label element (label and separator). Defaults to false. By default, even if you do not
 specify a fieldLabel the space will still be reserved so that the field will line up with other fields that do have
 labels. Setting this to true will cause the field to not reserve that space. Note: see the note for clearCls. Example
 use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield'
        
 hideLabel: true
     }]
 });]]></description><name>hideLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[How this component should be hidden. Supported values are 'visibility' (css visibility), 'offsets' (negative offset
 position) and 'display' (css display). Note: the default of 'display' is generally preferred since items are
 automatically laid out when they are first shown (no sizing is done while hidden).]]></description><name>hideMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide and show the component's container when hide/show is called on the component, false to hide and show the
 component itself (defaults to false). For example, this can be used as a shortcut for a hide button on a window by
 setting hide:true on the button when adding it to its parent container.]]></description><name>hideParent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to hide the trigger element and display only the base text field (defaults to false)]]></description><name>hideTrigger</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id of this component (defaults to an auto-assigned id). You should assign an id if you need to be able to
 access the component later and you do not have an object reference available (e.g., using Ext.getCmp). Note that this id
 will also be used as the element id for the containing HTML element that is rendered to the page for this component.
 This allows you to write id-based CSS rules to style the specific instance of this component uniquely, and also to
 select sub-elements using this component's id as the parent. Note: to avoid complications imposed by a unique id also
 see itemId and ref. Note: to access the container of an item see ownerCt.]]></description><name>id</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The number of minutes between each time value in the list (defaults to 15).]]></description><name>increment</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The type attribute for input fields -- e.g. radio, text, password, file (defaults to 'text'). The types 'file' and
 'password' must be used to render those field types currently -- there are no separate Ext components for those. Note
 that if you use inputType:'file', emptyText is not supported and should be avoided.]]></description><name>inputType</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class to use when marking a field invalid (defaults to 'x-form-invalid')]]></description><name>invalidClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The error text to display when the time in the field is invalid (defaults to '{value} is not a valid time').]]></description><name>invalidText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use the
 FormLayout layout manager (e.g. Ext.form.FormPanel or specifying layout:'form'). An additional CSS class to apply to the
 div wrapping the form item element of this field. If supplied, itemCls at the field level will override the default
 itemCls supplied at the container level. The value specified for itemCls will be added to the default class
 ('x-form-item'). Since it is applied to the item wrapper (see Ext.layout.FormLayout.fieldTpl), it allows you to write
 standard CSS rules that can apply to the field, the label (if specified), or any other element within the markup for the
 field. Note: see the note for fieldLabel. Example use: // Apply a style to the field's label:
 <style>
     .required
 .x-form-item-label {font-weight:bold;color:red;}
 </style>
 
 new Ext.FormPanel({
     height: 100,
     renderTo:
 Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         itemCls: 'required' //this
 label will be styled
     },{
         xtype: 'textfield',
         fieldLabel: 'Favorite Color'
     }]
 });]]></description><name>itemCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An itemId can be used as an alternative way to get a reference to a component when no object reference is available.
 Instead of using an id with Ext.getCmp, use itemId with Ext.Container.getComponent which will retrieve itemId's or id's.
 Since itemId's are an index to the container's internal MixedCollection, the itemId is scoped locally to the container
 -- avoiding potential conflicts with Ext.ComponentMgr which requires a unique id. var c = new Ext.Panel({ //
     height:
 300,
     renderTo: document.body,
     layout: 'auto',
     items: [
         {
             itemId: 'p1',
            
 title: 'Panel 1',
             height: 150
         },
         {
             itemId: 'p2',
             title: 'Panel 2',
  
 height: 150
         }
     ]
 })
 p1 = c.getComponent('p1'); // not the same as Ext.getCmp()
 p2 =
 p1.ownerCt.getComponent('p2'); // reference via a sibling Also see id and ref. Note: to access the container of an item
 see ownerCt.]]></description><name>itemId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A simple CSS selector (e.g. div.some-class or span:first-child) that will be used to determine what nodes the
 Ext.DataView which handles the dropdown display will be working with. Note: this setting is required if a custom
 XTemplate has been specified in tpl which assigns a class other than 'x-combo-list-item' to dropdown list items]]></description><name>itemSelector</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The separator to display after the text of each fieldLabel. This property may be configured at various levels. The order
 of precedence is: field / component level container level layout level (defaults to colon ':') To display no separator
 for this field's label specify empty string ''. Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 layoutConfig: {
         labelSeparator: '~'   // layout config has lowest priority (defaults to ':')
     },
    
 labelSeparator: '>>',     // config at container level
     items: [{
         xtype: 'textfield',
         fieldLabel:
 'Field 1',
         labelSeparator: '...' // field/component level config supersedes others
     },{
         xtype:
 'textfield',
         fieldLabel: 'Field 2' // labelSeparator will be '='
     }]
 });]]></description><name>labelSeparator</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS style specification string to apply directly to this field's label. Defaults to the container's labelStyle value
 if set (e.g., Ext.layout.FormLayout.labelStyle , or ''). Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         labelStyle: 'font-weight:bold;'
     }]
 });]]></description><name>labelStyle</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to not initialize the list for this combo until the field is focused (defaults to true)]]></description><name>lazyInit</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to prevent the ComboBox from rendering until requested (should always be used when rendering into an Ext.Editor
 (e.g. Grids), defaults to false).]]></description><name>lazyRender</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A valid anchor position value. See Ext.Element.alignTo for details on supported anchor positions and offsets. To specify
 x/y offsets as well, this value may be specified as an Array of Ext.Element.alignTo method arguments. [ 'tl-bl?', [6,0]
 ](defaults to 'tl-bl?')]]></description><name>listAlign</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class to add to the predefined 'x-combo-list' class applied the dropdown list element (defaults to '').]]></description><name>listClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The empty text to display in the data view if no items are found. (defaults to '')]]></description><name>listEmptyText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width (used as a parameter to Ext.Element.setWidth) of the dropdown list (defaults to the width of the ComboBox
 field). See also minListWidth]]></description><name>listWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The text to display in the dropdown list while data is loading. Only applies when mode = 'remote' (defaults to
 'Loading...')]]></description><name>loadingText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout or one of the two BoxLayout subclasses. An object containing margins to apply to this BoxComponent in the
 format: {
     top: (top margin),
     right: (right margin),
     bottom: (bottom margin),
     left: (left margin)
 } May
 also be a string containing space-separated, numeric margin values. The order of the sides associated with each value
 matches the way CSS processes margin values: If there is only one value, it applies to all sides. If there are two
 values, the top and bottom borders are set to the first value and the right and left are set to the second. If there are
 three values, the top is set to the first value, the left and right are set to the second, and the bottom is set to the
 third. If there are four values, they apply to the top, right, bottom, and left, respectively. Defaults to: {top:0,
 right:0, bottom:0, left:0}]]></description><name>margins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An input mask regular expression that will be used to filter keystrokes that do not match (defaults to null). The maskRe
 will not operate on any paste events.]]></description><name>maskRe</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum height in pixels of the dropdown list before scrollbars are shown (defaults to 300)]]></description><name>maxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Maximum input field length allowed by validation (defaults to Number.MAX_VALUE). This behavior is intended to provide
 instant feedback to the user by improving usability to allow pasting and editing or overtyping and back tracking. To
 restrict the maximum number of characters that can be entered into the field use autoCreate to add any attributes you
 want to a field, for example: var myField = new Ext.form.NumberField({
     id: 'mobile',
     anchor:'90%',
    
 fieldLabel: 'Mobile',
     maxLength: 16, // for validation
     autoCreate: {tag: 'input', type: 'text', size: '20',
 autocomplete: 'off', maxlength: '10'}
 });]]></description><name>maxLength</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Error text to display if the maximum length validation fails (defaults to 'The maximum length for this field is
 {maxLength}')]]></description><name>maxLengthText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The error text to display when the time is after maxValue (defaults to 'The time in this field must be equal to or
 before {0}').]]></description><name>maxText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum allowed time. Can be either a Javascript date object with a valid time value or a string time in a valid
 format -- see format and altFormats (defaults to undefined).]]></description><name>maxValue</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum number of characters the user must type before autocomplete and typeAhead activate (defaults to 4 if mode =
 'remote' or 0 if mode = 'local', does not apply if editable = false).]]></description><name>minChars</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum height in pixels of the dropdown list when the list is constrained by its distance to the viewport edges
 (defaults to 90)]]></description><name>minHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Minimum input field length required (defaults to 0)]]></description><name>minLength</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Error text to display if the minimum length validation fails (defaults to 'The minimum length for this field is
 {minLength}')]]></description><name>minLengthText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum width of the dropdown list in pixels (defaults to 70, will be ignored if listWidth has a higher value)]]></description><name>minListWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The error text to display when the date in the cell is before minValue (defaults to 'The time in this field must be
 equal to or after {0}').]]></description><name>minText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum allowed time. Can be either a Javascript date object with a valid time value or a string time in a valid
 format -- see format and altFormats (defaults to undefined).]]></description><name>minValue</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Acceptable values are: 'remote' : Default Automatically loads the store the first time the trigger is clicked. If you do
 not want the store to be automatically loaded the first time the trigger is clicked, set to 'local' and manually load
 the store. To force a requery of the store every time the trigger is clicked see lastQuery. 'local' : ComboBox loads
 local data var combo = new Ext.form.ComboBox({
     renderTo: document.body,
     mode: 'local',
     store: new
 Ext.data.ArrayStore({
         id: 0,
         fields: [
             'myId',  // numeric value is the key
            
 'displayText'
         ],
         data: [[1, 'item1'], [2, 'item2']]  // data is local
     }),
     valueField: 'myId',
   
  displayField: 'displayText',
     triggerAction: 'all'
 });]]></description><name>mode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Experimental The effect used when displaying a validation message under the field (defaults to 'normal').]]></description><name>msgFx</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The location where the message text set through markInvalid should display. Must be one of the following values: qtip
 Display a quick tip containing the message when the user hovers over the field. This is the default. Ext.QuickTips.init
 must have been called for this setting to work. title Display the message in a default browser title attribute popup.
 under Add a block div beneath the field containing the error message. side Add an error icon to the right of the field,
 displaying the message in a popup on hover. [element id] Add the error message directly to the innerHTML of the
 specified element.]]></description><name>msgTarget</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element when the mouse moves over the Element, and
 removed when the mouse moves out. (defaults to ''). This can be useful for adding customized 'active' or 'hover' styles
 to the component or any of its children using standard CSS rules.]]></description><name>overCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If greater than 0, a Ext.PagingToolbar is displayed in the footer of the dropdown list and the filter queries will
 execute with page start and limit parameters. Only applies when mode = 'remote' (defaults to 0).]]></description><name>pageSize</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level x coordinate for this component if contained within a positioning container.]]></description><name>pageX</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level y coordinate for this component if contained within a positioning container.]]></description><name>pageY</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to disable marking the field invalid. Defaults to false.]]></description><name>preventMark</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered ptype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a Plugin is being specified not as a fully
 instantiated Component, but as a Component config object. The ptype will be looked up at render time up to determine
 what type of Plugin to create. If you create your own Plugins, you may register them using
 Ext.ComponentMgr.registerPlugin in order to be able to take advantage of lazy instantiation and rendering.]]></description><name>ptype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The length of time in milliseconds to delay between the start of typing and sending the query to filter the dropdown
 list (defaults to 500 if mode = 'remote' or 10 if mode = 'local')]]></description><name>queryDelay</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Name of the query (baseParam name for the store) as it will be passed on the querystring (defaults to 'query')]]></description><name>queryParam</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to prevent the user from changing the field, and hides the trigger. Superceeds the editable and hideTrigger options
 if the value is true. (defaults to false)]]></description><name>readOnly</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A path specification, relative to the Component's ownerCt specifying into which ancestor Container to place a named
 reference to this Component. The ancestor axis can be traversed by using '/' characters in the path. For example, to put
 a reference to a Toolbar Button into the Panel which owns the Toolbar: var myGrid = new Ext.grid.EditorGridPanel({
    
 title: 'My EditorGridPanel',
     store: myStore,
     colModel: myColModel,
     tbar: [{
         text: 'Save',
        
 handler: saveChanges,
         disabled: true,
         ref: '../saveButton'
     }],
     listeners: {
         afteredit:
 function() {
 //          The button reference is in the GridPanel
             myGrid.saveButton.enable();
         }
    
 }
 }); In the code above, if the ref had been 'saveButton' the reference would have been placed into the Toolbar. Each
 '/' in the ref moves up one level from the Component's ownerCt. Also see the added and removed events.]]></description><name>ref</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A JavaScript RegExp object to be tested against the field value during validation (defaults to null). If the test fails,
 the field will be marked invalid using regexText.]]></description><name>regex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The error text to display if regex is used and the test fails during validation (defaults to '')]]></description><name>regexText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout layout manager (e.g. specifying layout:'border'). See Ext.layout.BorderLayout also.]]></description><name>region</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to add a resize handle to the bottom of the dropdown list (creates an Ext.Resizable with 'se' pinned handles).
 Defaults to false.]]></description><name>resizable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to select any existing text in the field immediately on focus. Only applies when editable = true (defaults to
 false).]]></description><name>selectOnFocus</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class to apply to the selected item in the dropdown list (defaults to 'x-combo-selected')]]></description><name>selectedClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true or "sides" for the default effect, "frame" for 4-way shadow, and "drop" for bottom-right]]></description><name>shadow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should trigger this component to save its state (defaults to none). stateEvents may
 be any type of event supported by this component, including browser or custom events (e.g., ['click',
 'customerchange']). See stateful for an explanation of saving and restoring Component state.]]></description><name>stateEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id for this component to use for state management purposes (defaults to the component id if one was set,
 otherwise null if the component is using a generated id). See stateful for an explanation of saving and restoring
 Component state.]]></description><name>stateId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A flag which causes the Component to attempt to restore the state of internal properties from a saved state on startup.
 The component must have either a stateId or id assigned for state to be managed. Auto-generated ids are not guaranteed
 to be stable across page loads and cannot be relied upon to save and restore the same state for a component. For state
 saving to work, the state manager's provider must have been set to an implementation of Ext.state.Provider which
 overrides the set and get methods to save and recall name/value pairs. A built-in implementation,
 Ext.state.CookieProvider is available. To set the state provider for the current page: Ext.state.Manager.setProvider(new
 Ext.state.CookieProvider({
     expires: new Date(new Date().getTime()+(1000*60*60*24*7)), //7 days from now
 })); A
 stateful Component attempts to save state when one of the events listed in the stateEvents configuration fires. To save
 state, a stateful Component first serializes its state by calling getState. By default, this function does nothing. The
 developer must provide an implementation which returns an object hash which represents the Component's restorable state.
 The value yielded by getState is passed to Ext.state.Manager.set which uses the configured Ext.state.Provider to save
 the object keyed by the Component's stateId, or, if that is not specified, its id. During construction, a stateful
 Component attempts to restore its state by calling Ext.state.Manager.get passing the stateId, or, if that is not
 specified, the id. The resulting object is passed to applyState. The default implementation of applyState simply copies
 properties into the object, but a developer may override this to support more behaviour. You can perform extra
 processing on state save and restore by attaching handlers to the beforestaterestore, staterestore, beforestatesave and
 statesave events.]]></description><name>stateful</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The data source to which this combo is bound (defaults to undefined). Acceptable values for this property are: any Store
 subclass an Array : Arrays will be converted to a Ext.data.ArrayStore internally, automatically generating field names
 to work with all data components. 1-dimensional array : (e.g., ['Foo','Bar']) A 1-dimensional array will automatically
 be expanded (each array item will be used for both the combo valueField and displayField) 2-dimensional array : (e.g.,
 [['f','Foo'],['b','Bar']]) For a multi-dimensional array, the value in index 0 of each item will be assumed to be the
 combo valueField, while the value at index 1 is assumed to be the combo displayField. See also mode.]]></description><name>store</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A JavaScript RegExp object used to strip unwanted content from the value before validation (defaults to null).]]></description><name>stripCharsRe</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
     title: 'Some Title',
     renderTo: Ext.getBody(),
     width: 400, height:
 300,
     layout: 'form',
     items: [{
         xtype: 'textarea',
         style: {
             width: '95%',
            
 marginBottom: '10px'
         }
     },
         new Ext.Button({
             text: 'Send',
             minWidth: '100',
   
          style: {
                 marginBottom: '10px'
             }
         })
     ]
 });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[False to clear the name attribute on the field so that it is not submitted during a form post. If a hiddenName is
 specified, setting this to true will cause both the hidden field and the element to be submitted. Defaults to undefined.]]></description><name>submitValue</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The tabIndex for this field. Note this only applies to fields that are rendered, not those which are built via applyTo
 (defaults to undefined).]]></description><name>tabIndex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is a child item of a TabPanel. A string to be used as innerHTML
 (html tags are accepted) to show in a tooltip when mousing over the associated tab selector element.
 Ext.QuickTips.init() must be called in order for the tips to render.]]></description><name>tabTip</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If supplied, a header element is created containing this text and added into the top of the dropdown list (defaults to
 undefined, with no header element)]]></description><name>title</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The id, DOM node or element of an existing HTML SELECT to convert to a ComboBox. Note that if you specify this and the
 combo is going to be in an Ext.form.BasicForm or Ext.form.FormPanel, you must also set lazyRender = true.]]></description><name>transform</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The action to execute when the trigger is clicked. 'query' : Default run the query using the raw value. 'all' : run the
 query specified by the allQuery config option See also queryParam.]]></description><name>triggerAction</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An additional CSS class used to style the trigger button. The trigger will always get the class 'x-form-trigger' and
 triggerClass will be appended if specified (defaults to 'x-form-arrow-trigger' which displays a downward arrow icon).]]></description><name>triggerClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A DomHelper config object specifying the structure of the trigger element for this Field. (Optional). Specify this when
 you need a customized element to act as the trigger button for a TriggerField. Note that when using this option, it is
 the developer's responsibility to ensure correct sizing, positioning and appearance of the trigger. Defaults to: {tag:
 "img", src: Ext.BLANK_IMAGE_URL, cls: "x-form-trigger " + this.triggerClass}]]></description><name>triggerConfig</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to populate and autoselect the remainder of the text being typed after a configurable delay (typeAheadDelay) if it
 matches a known value (defaults to false)]]></description><name>typeAhead</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The length of time in milliseconds to wait until the typeahead text is displayed if typeAhead = true (defaults to 250)]]></description><name>typeAheadDelay</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Whether the field should validate when it loses focus (defaults to true).]]></description><name>validateOnBlur</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The length of time in milliseconds after user input begins until validation is initiated (defaults to 250)]]></description><name>validationDelay</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The event that should initiate field validation. Set to false to disable automatic validation (defaults to 'keyup').]]></description><name>validationEvent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom validation function to be called during field validation (validateValue) (defaults to null). If specified, this
 function will be called first, allowing the developer to override the default validation process. This function will be
 passed the following Parameters: value: Mixed The current field value This function is to Return: true: Boolean true if
 the value is valid msg: String An error message if the value is invalid]]></description><name>validator</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A value to initialize this field with (defaults to undefined).]]></description><name>value</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The underlying data value name to bind to this ComboBox (defaults to undefined if mode = 'remote' or 'field2' if
 transforming a select or if the field name is autogenerated based on the store configuration). Note: use of a valueField
 requires the user to make a selection in order for a value to be mapped. See also hiddenName, hiddenValue, and
 displayField.]]></description><name>valueField</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[When using a name/value combo, if the value passed to setValue is not found in the store, valueNotFoundText will be
 displayed as the field text if defined (defaults to undefined). If this default text is used, it means there is no value
 set and no validation will occur on this field.]]></description><name>valueNotFoundText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A validation type name as defined in Ext.form.VTypes (defaults to null)]]></description><name>vtype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom error message to display in place of the default message provided for the vtype currently set for this field
 (defaults to ''). Note: only applies if vtype is set, else ignored.]]></description><name>vtypeText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The class added to the to the wrap of the trigger element. Defaults to x-trigger-wrap-focus.]]></description><name>wrapFocusClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local x (left) coordinate for this component if contained within a positioning container.]]></description><name>x</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered xtype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a child item of a Container is being specified not
 as a fully instantiated Component, but as a Component config object. The xtype will be looked up at render time up to
 determine what type of child Component to create. The predefined xtypes are listed here. If you subclass Components to
 create your own Components, you may register them using Ext.ComponentMgr.registerType in order to be able to take
 advantage of lazy instantiation and rendering.]]></description><name>xtype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local y (top) coordinate for this component if contained within a positioning container.]]></description><name>y</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 Provides a convenient wrapper for TextFields that adds a clickable trigger button (looks like a combobox by default).
 The trigger has no default action, so you must assign a function to implement the trigger click handler by overriding
 
 <a href="output/Ext.form.TriggerField.html#Ext.form.TriggerField-onTriggerClick" ext:member="onTriggerClick"
 ext:cls="Ext.form.TriggerField">onTriggerClick</a>. You can create a TriggerField directly, as it renders exactly like a
 combobox for which you can provide a custom implementation. For example: 
 <pre><code><b>var</b> trigger = <b>new</b>
 Ext.form.TriggerField();
 trigger.onTriggerClick = myTriggerFn;
 trigger.applyToMarkup(<em>'my-field'</em>);</code></pre>
 However, in general you will most likely want to use TriggerField as the base class for a reusable component. 
 <a
 href="output/Ext.form.DateField.html" ext:cls="Ext.form.DateField">Ext.form.DateField</a> and 
 <a
 href="output/Ext.form.ComboBox.html" ext:cls="Ext.form.ComboBox">Ext.form.ComboBox</a> are perfect examples of this.]]></description><name>form.triggerfield</name><tag-class>org.brushingbits.jnap.ui.extjs3.form.TriggerField</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[The field's HTML name attribute (defaults to ''). Note: this property must be set if this field is to be automatically
 included with form submit().]]></description><name>name</name><required>true</required><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify false to validate that the value's length is > 0 (defaults to true)]]></description><name>allowBlank</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Whether the component can move the Dom node when rendering (defaults to true).]]></description><name>allowDomMove</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use an
 AnchorLayout (or subclass thereof). based layout manager, for example: Ext.form.FormPanel specifying layout: 'anchor' //
 or 'form', or 'absolute' See Ext.layout.AnchorLayout.anchor also.]]></description><name>anchor</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element corresponding to a DIV that is already present in
 the document that specifies some structural markup for this component. Description : When applyTo is used, constituent
 parts of the component can also be specified by id or CSS class name within the main element, and the component being
 created may attempt to create its subcomponents from that markup if applicable. Notes : When using this config, a call
 to render() is not required. If applyTo is specified, any value passed for renderTo will be ignored and the target
 element's parent node will automatically be used as the component's container.]]></description><name>applyTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A DomHelper element spec, or true for a default element spec. Used to create the Element which will encapsulate this
 Component. See autoEl for details. Defaults to: {tag: "input", type: "text", size: "16", autocomplete: "off"}]]></description><name>autoCreate</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A tag name or DomHelper spec used to create the Element which will encapsulate this Component. You do not normally need
 to specify this. For the base classes Ext.Component, Ext.BoxComponent, and Ext.Container, this defaults to 'div'. The
 more complex Ext classes use a more complex DOM structure created by their own onRender methods. This is intended to
 allow the developer to create application-specific utility Components encapsulated by different DOM elements. Example
 usage: <pre><code>{
     xtype: 'box',
     autoEl: {
         tag: 'img',
         src: 'http://www.example.com/example.jpg'
     }
 },
 {
     xtype: 'box',
     autoEl: {
         tag: 'blockquote',
         html: 'autoEl is cool!'
     }
 }, {
     xtype: 'container',
     autoEl: 'ul',
     cls: 'ux-unordered-list',
     items: {
         xtype: 'box',
         autoEl: 'li',
   
      html: 'First list item'
     }
 }</pre></code>]]></description><name>autoEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to use height:'auto', false to use fixed height (or allow it to be managed by its parent Container's layout
 manager. Defaults to false. Note: Although many components inherit this config option, not all will function as expected
 with a height of 'auto'. Setting autoHeight:true means that the browser will manage height based on the element's
 contents, and that Ext will not manage it at all. If the browser is managing the height, be aware that resizes performed
 by the browser in response to changes within the structure of the Component cannot be detected. Therefore changes to the
 height might result in elements needing to be synchronized with the new height. Example: var w = new Ext.Window({
    
 title: 'Window',
     width: 600,
     autoHeight: true,
     items: {
         title: 'Collapse Me',
         height: 400,
  
 collapsible: true,
         border: false,
         listeners: {
             beforecollapse: function() {
                w.el.shadow.hide();
             },
             beforeexpand: function() {
                w.el.shadow.hide();
             },
             collapse: function() {
                w.syncShadow();
             },
             expand: function() {
                w.syncShadow();
             }
         }
     }
 }).show();]]></description><name>autoHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to use overflow:'auto' on the components layout element and show scroll bars automatically when necessary, false to
 clip any overflowing content (defaults to false).]]></description><name>autoScroll</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True if the component should check for hidden classes (e.g. 'x-hidden' or 'x-hide-display') and remove them on render
 (defaults to false).]]></description><name>autoShow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to use width:'auto', false to use fixed width (or allow it to be managed by its parent Container's layout manager.
 Defaults to false. Note: Although many components inherit this config option, not all will function as expected with a
 width of 'auto'. Setting autoWidth:true means that the browser will manage width based on the element's contents, and
 that Ext will not manage it at all. If the browser is managing the width, be aware that resizes performed by the browser
 in response to changes within the structure of the Component cannot be detected. Therefore changes to the width might
 result in elements needing to be synchronized with the new width. For example, where the target element is: <div
 id='grid-container' style='margin-left:25%;width:50%'></div> A Panel rendered into that target element must listen for
 browser window resize in order to relay its child items when the browser changes its width: var myPanel = new
 Ext.Panel({
     renderTo: 'grid-container',
     monitorResize: true, // relay on browser resize
     title: 'Panel',
    
 height: 400,
     autoWidth: true,
     layout: 'hbox',
     layoutConfig: {
         align: 'stretch'
     },
     defaults: {
         flex: 1
     },
     items: [{
         title: 'Box 1',
     }, {
         title: 'Box 2'
     }, {
         title:
 'Box 3'
     }],
 });]]></description><name>autoWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The error text to display if the allowBlank validation fails (defaults to 'This field is required')]]></description><name>blankText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to [].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class used to to apply to the special clearing div rendered directly after each form field wrapper to provide
 field clearing (defaults to 'x-form-clear-left'). Note: this config is only used when this Component is rendered by a
 Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or specifying
 layout:'form') and either a fieldLabel is specified or isFormField=true is specified. See Ext.layout.FormLayout.fieldTpl
 also.]]></description><name>clearCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom CSS class to apply to the field's underlying element (defaults to '').]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's container. This can be useful for adding customized
 styles to the container or any of its children using standard CSS rules. See Ext.layout.ContainerLayout.extraCls also.
 Note: ctCls defaults to '' except for the following class which assigns a value by default: Box Layout :
 'x-box-layout-ct' To configure the above Class with an extra CSS class append to the default. For example, for BoxLayout
 (Hbox and Vbox): ctCls: 'x-box-layout-ct custom-class']]></description><name>ctCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify true to disable input keystroke filtering (defaults to false)]]></description><name>disableKeyFilter</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to disable the field (defaults to false). Be aware that conformant with the HTML specification, disabled Fields
 will not be submitted.]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class added to the component when it is disabled (defaults to 'x-item-disabled').]]></description><name>disabledClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[false to prevent the user from typing text directly into the field, the field will only respond to a click on the
 trigger to set the value. (defaults to true).]]></description><name>editable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class to apply to an empty field to style the emptyText (defaults to 'x-form-empty-field'). This class is
 automatically added and removed as needed depending on the current field value.]]></description><name>emptyClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default text to place into an empty field (defaults to null). Note: that this value will be submitted to the server
 if this field is enabled and configured with a name.]]></description><name>emptyText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to enable the proxying of key events for the HTML input field (defaults to false)]]></description><name>enableKeyEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default CSS class for the field (defaults to 'x-form-field')]]></description><name>fieldClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The label text to display next to this Component (defaults to ''). Note: this config is only used when this Component is
 rendered by a Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or
 specifying layout:'form'). Also see hideLabel and Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
    
 height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name'
    
 }]
 });]]></description><name>fieldLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use a
 BoxLayout. Each child Component with a flex property will be flexed either vertically (by a VBoxLayout) or horizontally
 (by an HBoxLayout) according to the item's relative flex value compared to the sum of all Components with flex value
 specified. Any child items that have either a flex = 0 or flex = undefined will not be 'flexed' (the initial size will
 not be changed).]]></description><name>flex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class to use when the field receives focus (defaults to 'x-form-focus')]]></description><name>focusClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true if this field should automatically grow and shrink to its content (defaults to false)]]></description><name>grow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum width to allow when grow = true (defaults to 800)]]></description><name>growMax</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum width to allow when grow = true (defaults to 30)]]></description><name>growMin</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component hidden (default is false). If true, the hide method will be called internally.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to completely hide the label element (label and separator). Defaults to false. By default, even if you do not
 specify a fieldLabel the space will still be reserved so that the field will line up with other fields that do have
 labels. Setting this to true will cause the field to not reserve that space. Note: see the note for clearCls. Example
 use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield'
        
 hideLabel: true
     }]
 });]]></description><name>hideLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[How this component should be hidden. Supported values are 'visibility' (css visibility), 'offsets' (negative offset
 position) and 'display' (css display). Note: the default of 'display' is generally preferred since items are
 automatically laid out when they are first shown (no sizing is done while hidden).]]></description><name>hideMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide and show the component's container when hide/show is called on the component, false to hide and show the
 component itself (defaults to false). For example, this can be used as a shortcut for a hide button on a window by
 setting hide:true on the button when adding it to its parent container.]]></description><name>hideParent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to hide the trigger element and display only the base text field (defaults to false)]]></description><name>hideTrigger</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id of this component (defaults to an auto-assigned id). You should assign an id if you need to be able to
 access the component later and you do not have an object reference available (e.g., using Ext.getCmp). Note that this id
 will also be used as the element id for the containing HTML element that is rendered to the page for this component.
 This allows you to write id-based CSS rules to style the specific instance of this component uniquely, and also to
 select sub-elements using this component's id as the parent. Note: to avoid complications imposed by a unique id also
 see itemId and ref. Note: to access the container of an item see ownerCt.]]></description><name>id</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The type attribute for input fields -- e.g. radio, text, password, file (defaults to 'text'). The types 'file' and
 'password' must be used to render those field types currently -- there are no separate Ext components for those. Note
 that if you use inputType:'file', emptyText is not supported and should be avoided.]]></description><name>inputType</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class to use when marking a field invalid (defaults to 'x-form-invalid')]]></description><name>invalidClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The error text to use when marking a field invalid and no message is provided (defaults to 'The value in this field is
 invalid')]]></description><name>invalidText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use the
 FormLayout layout manager (e.g. Ext.form.FormPanel or specifying layout:'form'). An additional CSS class to apply to the
 div wrapping the form item element of this field. If supplied, itemCls at the field level will override the default
 itemCls supplied at the container level. The value specified for itemCls will be added to the default class
 ('x-form-item'). Since it is applied to the item wrapper (see Ext.layout.FormLayout.fieldTpl), it allows you to write
 standard CSS rules that can apply to the field, the label (if specified), or any other element within the markup for the
 field. Note: see the note for fieldLabel. Example use: // Apply a style to the field's label:
 <style>
     .required
 .x-form-item-label {font-weight:bold;color:red;}
 </style>
 
 new Ext.FormPanel({
     height: 100,
     renderTo:
 Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         itemCls: 'required' //this
 label will be styled
     },{
         xtype: 'textfield',
         fieldLabel: 'Favorite Color'
     }]
 });]]></description><name>itemCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An itemId can be used as an alternative way to get a reference to a component when no object reference is available.
 Instead of using an id with Ext.getCmp, use itemId with Ext.Container.getComponent which will retrieve itemId's or id's.
 Since itemId's are an index to the container's internal MixedCollection, the itemId is scoped locally to the container
 -- avoiding potential conflicts with Ext.ComponentMgr which requires a unique id. var c = new Ext.Panel({ //
     height:
 300,
     renderTo: document.body,
     layout: 'auto',
     items: [
         {
             itemId: 'p1',
            
 title: 'Panel 1',
             height: 150
         },
         {
             itemId: 'p2',
             title: 'Panel 2',
  
 height: 150
         }
     ]
 })
 p1 = c.getComponent('p1'); // not the same as Ext.getCmp()
 p2 =
 p1.ownerCt.getComponent('p2'); // reference via a sibling Also see id and ref. Note: to access the container of an item
 see ownerCt.]]></description><name>itemId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The separator to display after the text of each fieldLabel. This property may be configured at various levels. The order
 of precedence is: field / component level container level layout level (defaults to colon ':') To display no separator
 for this field's label specify empty string ''. Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 layoutConfig: {
         labelSeparator: '~'   // layout config has lowest priority (defaults to ':')
     },
    
 labelSeparator: '>>',     // config at container level
     items: [{
         xtype: 'textfield',
         fieldLabel:
 'Field 1',
         labelSeparator: '...' // field/component level config supersedes others
     },{
         xtype:
 'textfield',
         fieldLabel: 'Field 2' // labelSeparator will be '='
     }]
 });]]></description><name>labelSeparator</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS style specification string to apply directly to this field's label. Defaults to the container's labelStyle value
 if set (e.g., Ext.layout.FormLayout.labelStyle , or ''). Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         labelStyle: 'font-weight:bold;'
     }]
 });]]></description><name>labelStyle</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout or one of the two BoxLayout subclasses. An object containing margins to apply to this BoxComponent in the
 format: {
     top: (top margin),
     right: (right margin),
     bottom: (bottom margin),
     left: (left margin)
 } May
 also be a string containing space-separated, numeric margin values. The order of the sides associated with each value
 matches the way CSS processes margin values: If there is only one value, it applies to all sides. If there are two
 values, the top and bottom borders are set to the first value and the right and left are set to the second. If there are
 three values, the top is set to the first value, the left and right are set to the second, and the bottom is set to the
 third. If there are four values, they apply to the top, right, bottom, and left, respectively. Defaults to: {top:0,
 right:0, bottom:0, left:0}]]></description><name>margins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An input mask regular expression that will be used to filter keystrokes that do not match (defaults to null). The maskRe
 will not operate on any paste events.]]></description><name>maskRe</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Maximum input field length allowed by validation (defaults to Number.MAX_VALUE). This behavior is intended to provide
 instant feedback to the user by improving usability to allow pasting and editing or overtyping and back tracking. To
 restrict the maximum number of characters that can be entered into the field use autoCreate to add any attributes you
 want to a field, for example: var myField = new Ext.form.NumberField({
     id: 'mobile',
     anchor:'90%',
    
 fieldLabel: 'Mobile',
     maxLength: 16, // for validation
     autoCreate: {tag: 'input', type: 'text', size: '20',
 autocomplete: 'off', maxlength: '10'}
 });]]></description><name>maxLength</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Error text to display if the maximum length validation fails (defaults to 'The maximum length for this field is
 {maxLength}')]]></description><name>maxLengthText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Minimum input field length required (defaults to 0)]]></description><name>minLength</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Error text to display if the minimum length validation fails (defaults to 'The minimum length for this field is
 {minLength}')]]></description><name>minLengthText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Experimental The effect used when displaying a validation message under the field (defaults to 'normal').]]></description><name>msgFx</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The location where the message text set through markInvalid should display. Must be one of the following values: qtip
 Display a quick tip containing the message when the user hovers over the field. This is the default. Ext.QuickTips.init
 must have been called for this setting to work. title Display the message in a default browser title attribute popup.
 under Add a block div beneath the field containing the error message. side Add an error icon to the right of the field,
 displaying the message in a popup on hover. [element id] Add the error message directly to the innerHTML of the
 specified element.]]></description><name>msgTarget</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element when the mouse moves over the Element, and
 removed when the mouse moves out. (defaults to ''). This can be useful for adding customized 'active' or 'hover' styles
 to the component or any of its children using standard CSS rules.]]></description><name>overCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level x coordinate for this component if contained within a positioning container.]]></description><name>pageX</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level y coordinate for this component if contained within a positioning container.]]></description><name>pageY</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to disable marking the field invalid. Defaults to false.]]></description><name>preventMark</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered ptype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a Plugin is being specified not as a fully
 instantiated Component, but as a Component config object. The ptype will be looked up at render time up to determine
 what type of Plugin to create. If you create your own Plugins, you may register them using
 Ext.ComponentMgr.registerPlugin in order to be able to take advantage of lazy instantiation and rendering.]]></description><name>ptype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to prevent the user from changing the field, and hides the trigger. Superceeds the editable and hideTrigger options
 if the value is true. (defaults to false)]]></description><name>readOnly</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A path specification, relative to the Component's ownerCt specifying into which ancestor Container to place a named
 reference to this Component. The ancestor axis can be traversed by using '/' characters in the path. For example, to put
 a reference to a Toolbar Button into the Panel which owns the Toolbar: var myGrid = new Ext.grid.EditorGridPanel({
    
 title: 'My EditorGridPanel',
     store: myStore,
     colModel: myColModel,
     tbar: [{
         text: 'Save',
        
 handler: saveChanges,
         disabled: true,
         ref: '../saveButton'
     }],
     listeners: {
         afteredit:
 function() {
 //          The button reference is in the GridPanel
             myGrid.saveButton.enable();
         }
    
 }
 }); In the code above, if the ref had been 'saveButton' the reference would have been placed into the Toolbar. Each
 '/' in the ref moves up one level from the Component's ownerCt. Also see the added and removed events.]]></description><name>ref</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A JavaScript RegExp object to be tested against the field value during validation (defaults to null). If the test fails,
 the field will be marked invalid using regexText.]]></description><name>regex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The error text to display if regex is used and the test fails during validation (defaults to '')]]></description><name>regexText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout layout manager (e.g. specifying layout:'border'). See Ext.layout.BorderLayout also.]]></description><name>region</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to automatically select any existing field text when the field receives input focus (defaults to false)]]></description><name>selectOnFocus</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should trigger this component to save its state (defaults to none). stateEvents may
 be any type of event supported by this component, including browser or custom events (e.g., ['click',
 'customerchange']). See stateful for an explanation of saving and restoring Component state.]]></description><name>stateEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id for this component to use for state management purposes (defaults to the component id if one was set,
 otherwise null if the component is using a generated id). See stateful for an explanation of saving and restoring
 Component state.]]></description><name>stateId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A flag which causes the Component to attempt to restore the state of internal properties from a saved state on startup.
 The component must have either a stateId or id assigned for state to be managed. Auto-generated ids are not guaranteed
 to be stable across page loads and cannot be relied upon to save and restore the same state for a component. For state
 saving to work, the state manager's provider must have been set to an implementation of Ext.state.Provider which
 overrides the set and get methods to save and recall name/value pairs. A built-in implementation,
 Ext.state.CookieProvider is available. To set the state provider for the current page: Ext.state.Manager.setProvider(new
 Ext.state.CookieProvider({
     expires: new Date(new Date().getTime()+(1000*60*60*24*7)), //7 days from now
 })); A
 stateful Component attempts to save state when one of the events listed in the stateEvents configuration fires. To save
 state, a stateful Component first serializes its state by calling getState. By default, this function does nothing. The
 developer must provide an implementation which returns an object hash which represents the Component's restorable state.
 The value yielded by getState is passed to Ext.state.Manager.set which uses the configured Ext.state.Provider to save
 the object keyed by the Component's stateId, or, if that is not specified, its id. During construction, a stateful
 Component attempts to restore its state by calling Ext.state.Manager.get passing the stateId, or, if that is not
 specified, the id. The resulting object is passed to applyState. The default implementation of applyState simply copies
 properties into the object, but a developer may override this to support more behaviour. You can perform extra
 processing on state save and restore by attaching handlers to the beforestaterestore, staterestore, beforestatesave and
 statesave events.]]></description><name>stateful</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A JavaScript RegExp object used to strip unwanted content from the value before validation (defaults to null).]]></description><name>stripCharsRe</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
     title: 'Some Title',
     renderTo: Ext.getBody(),
     width: 400, height:
 300,
     layout: 'form',
     items: [{
         xtype: 'textarea',
         style: {
             width: '95%',
            
 marginBottom: '10px'
         }
     },
         new Ext.Button({
             text: 'Send',
             minWidth: '100',
   
          style: {
                 marginBottom: '10px'
             }
         })
     ]
 });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[False to clear the name attribute on the field so that it is not submitted during a form post. Defaults to true.]]></description><name>submitValue</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The tabIndex for this field. Note this only applies to fields that are rendered, not those which are built via applyTo
 (defaults to undefined).]]></description><name>tabIndex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is a child item of a TabPanel. A string to be used as innerHTML
 (html tags are accepted) to show in a tooltip when mousing over the associated tab selector element.
 Ext.QuickTips.init() must be called in order for the tips to render.]]></description><name>tabTip</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An additional CSS class used to style the trigger button. The trigger will always get the class 'x-form-trigger' by
 default and triggerClass will be appended if specified.]]></description><name>triggerClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A DomHelper config object specifying the structure of the trigger element for this Field. (Optional). Specify this when
 you need a customized element to act as the trigger button for a TriggerField. Note that when using this option, it is
 the developer's responsibility to ensure correct sizing, positioning and appearance of the trigger. Defaults to: {tag:
 "img", src: Ext.BLANK_IMAGE_URL, cls: "x-form-trigger " + this.triggerClass}]]></description><name>triggerConfig</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Whether the field should validate when it loses focus (defaults to true).]]></description><name>validateOnBlur</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The length of time in milliseconds after user input begins until validation is initiated (defaults to 250)]]></description><name>validationDelay</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The event that should initiate field validation. Set to false to disable automatic validation (defaults to 'keyup').]]></description><name>validationEvent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom validation function to be called during field validation (validateValue) (defaults to null). If specified, this
 function will be called first, allowing the developer to override the default validation process. This function will be
 passed the following Parameters: value: Mixed The current field value This function is to Return: true: Boolean true if
 the value is valid msg: String An error message if the value is invalid]]></description><name>validator</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A value to initialize this field with (defaults to undefined).]]></description><name>value</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A validation type name as defined in Ext.form.VTypes (defaults to null)]]></description><name>vtype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom error message to display in place of the default message provided for the vtype currently set for this field
 (defaults to ''). Note: only applies if vtype is set, else ignored.]]></description><name>vtypeText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The class added to the to the wrap of the trigger element. Defaults to x-trigger-wrap-focus.]]></description><name>wrapFocusClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local x (left) coordinate for this component if contained within a positioning container.]]></description><name>x</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered xtype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a child item of a Container is being specified not
 as a fully instantiated Component, but as a Component config object. The xtype will be looked up at render time up to
 determine what type of child Component to create. The predefined xtypes are listed here. If you subclass Components to
 create your own Components, you may register them using Ext.ComponentMgr.registerType in order to be able to take
 advantage of lazy instantiation and rendering.]]></description><name>xtype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local y (top) coordinate for this component if contained within a positioning container.]]></description><name>y</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 TwinTriggerField is not a public class to be used directly. It is meant as an abstract base class to be extended by an
 implementing class. For an example of implementing this class, see the custom SearchField implementation here: 
 <a
 href="http://extjs.com/deploy/ext/examples/form/custom.html">http://extjs.com/deploy/ext/examples/form/custom.html</a>]]></description><name>form.twinTriggerField</name><tag-class>org.brushingbits.jnap.ui.extjs3.form.TwinTriggerField</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[The field's HTML name attribute (defaults to ''). Note: this property must be set if this field is to be automatically
 included with form submit().]]></description><name>name</name><required>true</required><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify false to validate that the value's length is > 0 (defaults to true)]]></description><name>allowBlank</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Whether the component can move the Dom node when rendering (defaults to true).]]></description><name>allowDomMove</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use an
 AnchorLayout (or subclass thereof). based layout manager, for example: Ext.form.FormPanel specifying layout: 'anchor' //
 or 'form', or 'absolute' See Ext.layout.AnchorLayout.anchor also.]]></description><name>anchor</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element corresponding to a DIV that is already present in
 the document that specifies some structural markup for this component. Description : When applyTo is used, constituent
 parts of the component can also be specified by id or CSS class name within the main element, and the component being
 created may attempt to create its subcomponents from that markup if applicable. Notes : When using this config, a call
 to render() is not required. If applyTo is specified, any value passed for renderTo will be ignored and the target
 element's parent node will automatically be used as the component's container.]]></description><name>applyTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A DomHelper element spec, or true for a default element spec. Used to create the Element which will encapsulate this
 Component. See autoEl for details. Defaults to: {tag: "input", type: "text", size: "16", autocomplete: "off"}]]></description><name>autoCreate</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A tag name or DomHelper spec used to create the Element which will encapsulate this Component. You do not normally need
 to specify this. For the base classes Ext.Component, Ext.BoxComponent, and Ext.Container, this defaults to 'div'. The
 more complex Ext classes use a more complex DOM structure created by their own onRender methods. This is intended to
 allow the developer to create application-specific utility Components encapsulated by different DOM elements. Example
 usage: <pre><code>{
     xtype: 'box',
     autoEl: {
         tag: 'img',
         src: 'http://www.example.com/example.jpg'
     }
 },
 {
     xtype: 'box',
     autoEl: {
         tag: 'blockquote',
         html: 'autoEl is cool!'
     }
 }, {
     xtype: 'container',
     autoEl: 'ul',
     cls: 'ux-unordered-list',
     items: {
         xtype: 'box',
         autoEl: 'li',
   
      html: 'First list item'
     }
 }</pre></code>]]></description><name>autoEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to use height:'auto', false to use fixed height (or allow it to be managed by its parent Container's layout
 manager. Defaults to false. Note: Although many components inherit this config option, not all will function as expected
 with a height of 'auto'. Setting autoHeight:true means that the browser will manage height based on the element's
 contents, and that Ext will not manage it at all. If the browser is managing the height, be aware that resizes performed
 by the browser in response to changes within the structure of the Component cannot be detected. Therefore changes to the
 height might result in elements needing to be synchronized with the new height. Example: var w = new Ext.Window({
    
 title: 'Window',
     width: 600,
     autoHeight: true,
     items: {
         title: 'Collapse Me',
         height: 400,
  
 collapsible: true,
         border: false,
         listeners: {
             beforecollapse: function() {
                w.el.shadow.hide();
             },
             beforeexpand: function() {
                w.el.shadow.hide();
             },
             collapse: function() {
                w.syncShadow();
             },
             expand: function() {
                w.syncShadow();
             }
         }
     }
 }).show();]]></description><name>autoHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to use overflow:'auto' on the components layout element and show scroll bars automatically when necessary, false to
 clip any overflowing content (defaults to false).]]></description><name>autoScroll</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True if the component should check for hidden classes (e.g. 'x-hidden' or 'x-hide-display') and remove them on render
 (defaults to false).]]></description><name>autoShow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to use width:'auto', false to use fixed width (or allow it to be managed by its parent Container's layout manager.
 Defaults to false. Note: Although many components inherit this config option, not all will function as expected with a
 width of 'auto'. Setting autoWidth:true means that the browser will manage width based on the element's contents, and
 that Ext will not manage it at all. If the browser is managing the width, be aware that resizes performed by the browser
 in response to changes within the structure of the Component cannot be detected. Therefore changes to the width might
 result in elements needing to be synchronized with the new width. For example, where the target element is: <div
 id='grid-container' style='margin-left:25%;width:50%'></div> A Panel rendered into that target element must listen for
 browser window resize in order to relay its child items when the browser changes its width: var myPanel = new
 Ext.Panel({
     renderTo: 'grid-container',
     monitorResize: true, // relay on browser resize
     title: 'Panel',
    
 height: 400,
     autoWidth: true,
     layout: 'hbox',
     layoutConfig: {
         align: 'stretch'
     },
     defaults: {
         flex: 1
     },
     items: [{
         title: 'Box 1',
     }, {
         title: 'Box 2'
     }, {
         title:
 'Box 3'
     }],
 });]]></description><name>autoWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The error text to display if the allowBlank validation fails (defaults to 'This field is required')]]></description><name>blankText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to [].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class used to to apply to the special clearing div rendered directly after each form field wrapper to provide
 field clearing (defaults to 'x-form-clear-left'). Note: this config is only used when this Component is rendered by a
 Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or specifying
 layout:'form') and either a fieldLabel is specified or isFormField=true is specified. See Ext.layout.FormLayout.fieldTpl
 also.]]></description><name>clearCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom CSS class to apply to the field's underlying element (defaults to '').]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's container. This can be useful for adding customized
 styles to the container or any of its children using standard CSS rules. See Ext.layout.ContainerLayout.extraCls also.
 Note: ctCls defaults to '' except for the following class which assigns a value by default: Box Layout :
 'x-box-layout-ct' To configure the above Class with an extra CSS class append to the default. For example, for BoxLayout
 (Hbox and Vbox): ctCls: 'x-box-layout-ct custom-class']]></description><name>ctCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify true to disable input keystroke filtering (defaults to false)]]></description><name>disableKeyFilter</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to disable the field (defaults to false). Be aware that conformant with the HTML specification, disabled Fields
 will not be submitted.]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class added to the component when it is disabled (defaults to 'x-item-disabled').]]></description><name>disabledClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[false to prevent the user from typing text directly into the field, the field will only respond to a click on the
 trigger to set the value. (defaults to true).]]></description><name>editable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class to apply to an empty field to style the emptyText (defaults to 'x-form-empty-field'). This class is
 automatically added and removed as needed depending on the current field value.]]></description><name>emptyClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default text to place into an empty field (defaults to null). Note: that this value will be submitted to the server
 if this field is enabled and configured with a name.]]></description><name>emptyText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to enable the proxying of key events for the HTML input field (defaults to false)]]></description><name>enableKeyEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default CSS class for the field (defaults to 'x-form-field')]]></description><name>fieldClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The label text to display next to this Component (defaults to ''). Note: this config is only used when this Component is
 rendered by a Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or
 specifying layout:'form'). Also see hideLabel and Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
    
 height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name'
    
 }]
 });]]></description><name>fieldLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use a
 BoxLayout. Each child Component with a flex property will be flexed either vertically (by a VBoxLayout) or horizontally
 (by an HBoxLayout) according to the item's relative flex value compared to the sum of all Components with flex value
 specified. Any child items that have either a flex = 0 or flex = undefined will not be 'flexed' (the initial size will
 not be changed).]]></description><name>flex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class to use when the field receives focus (defaults to 'x-form-focus')]]></description><name>focusClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true if this field should automatically grow and shrink to its content (defaults to false)]]></description><name>grow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum width to allow when grow = true (defaults to 800)]]></description><name>growMax</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum width to allow when grow = true (defaults to 30)]]></description><name>growMin</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component hidden (default is false). If true, the hide method will be called internally.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to completely hide the label element (label and separator). Defaults to false. By default, even if you do not
 specify a fieldLabel the space will still be reserved so that the field will line up with other fields that do have
 labels. Setting this to true will cause the field to not reserve that space. Note: see the note for clearCls. Example
 use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield'
        
 hideLabel: true
     }]
 });]]></description><name>hideLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[How this component should be hidden. Supported values are 'visibility' (css visibility), 'offsets' (negative offset
 position) and 'display' (css display). Note: the default of 'display' is generally preferred since items are
 automatically laid out when they are first shown (no sizing is done while hidden).]]></description><name>hideMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide and show the component's container when hide/show is called on the component, false to hide and show the
 component itself (defaults to false). For example, this can be used as a shortcut for a hide button on a window by
 setting hide:true on the button when adding it to its parent container.]]></description><name>hideParent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to hide the trigger element and display only the base text field (defaults to false)]]></description><name>hideTrigger</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id of this component (defaults to an auto-assigned id). You should assign an id if you need to be able to
 access the component later and you do not have an object reference available (e.g., using Ext.getCmp). Note that this id
 will also be used as the element id for the containing HTML element that is rendered to the page for this component.
 This allows you to write id-based CSS rules to style the specific instance of this component uniquely, and also to
 select sub-elements using this component's id as the parent. Note: to avoid complications imposed by a unique id also
 see itemId and ref. Note: to access the container of an item see ownerCt.]]></description><name>id</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The type attribute for input fields -- e.g. radio, text, password, file (defaults to 'text'). The types 'file' and
 'password' must be used to render those field types currently -- there are no separate Ext components for those. Note
 that if you use inputType:'file', emptyText is not supported and should be avoided.]]></description><name>inputType</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class to use when marking a field invalid (defaults to 'x-form-invalid')]]></description><name>invalidClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The error text to use when marking a field invalid and no message is provided (defaults to 'The value in this field is
 invalid')]]></description><name>invalidText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use the
 FormLayout layout manager (e.g. Ext.form.FormPanel or specifying layout:'form'). An additional CSS class to apply to the
 div wrapping the form item element of this field. If supplied, itemCls at the field level will override the default
 itemCls supplied at the container level. The value specified for itemCls will be added to the default class
 ('x-form-item'). Since it is applied to the item wrapper (see Ext.layout.FormLayout.fieldTpl), it allows you to write
 standard CSS rules that can apply to the field, the label (if specified), or any other element within the markup for the
 field. Note: see the note for fieldLabel. Example use: // Apply a style to the field's label:
 <style>
     .required
 .x-form-item-label {font-weight:bold;color:red;}
 </style>
 
 new Ext.FormPanel({
     height: 100,
     renderTo:
 Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         itemCls: 'required' //this
 label will be styled
     },{
         xtype: 'textfield',
         fieldLabel: 'Favorite Color'
     }]
 });]]></description><name>itemCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An itemId can be used as an alternative way to get a reference to a component when no object reference is available.
 Instead of using an id with Ext.getCmp, use itemId with Ext.Container.getComponent which will retrieve itemId's or id's.
 Since itemId's are an index to the container's internal MixedCollection, the itemId is scoped locally to the container
 -- avoiding potential conflicts with Ext.ComponentMgr which requires a unique id. var c = new Ext.Panel({ //
     height:
 300,
     renderTo: document.body,
     layout: 'auto',
     items: [
         {
             itemId: 'p1',
            
 title: 'Panel 1',
             height: 150
         },
         {
             itemId: 'p2',
             title: 'Panel 2',
  
 height: 150
         }
     ]
 })
 p1 = c.getComponent('p1'); // not the same as Ext.getCmp()
 p2 =
 p1.ownerCt.getComponent('p2'); // reference via a sibling Also see id and ref. Note: to access the container of an item
 see ownerCt.]]></description><name>itemId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The separator to display after the text of each fieldLabel. This property may be configured at various levels. The order
 of precedence is: field / component level container level layout level (defaults to colon ':') To display no separator
 for this field's label specify empty string ''. Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 layoutConfig: {
         labelSeparator: '~'   // layout config has lowest priority (defaults to ':')
     },
    
 labelSeparator: '>>',     // config at container level
     items: [{
         xtype: 'textfield',
         fieldLabel:
 'Field 1',
         labelSeparator: '...' // field/component level config supersedes others
     },{
         xtype:
 'textfield',
         fieldLabel: 'Field 2' // labelSeparator will be '='
     }]
 });]]></description><name>labelSeparator</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS style specification string to apply directly to this field's label. Defaults to the container's labelStyle value
 if set (e.g., Ext.layout.FormLayout.labelStyle , or ''). Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         labelStyle: 'font-weight:bold;'
     }]
 });]]></description><name>labelStyle</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout or one of the two BoxLayout subclasses. An object containing margins to apply to this BoxComponent in the
 format: {
     top: (top margin),
     right: (right margin),
     bottom: (bottom margin),
     left: (left margin)
 } May
 also be a string containing space-separated, numeric margin values. The order of the sides associated with each value
 matches the way CSS processes margin values: If there is only one value, it applies to all sides. If there are two
 values, the top and bottom borders are set to the first value and the right and left are set to the second. If there are
 three values, the top is set to the first value, the left and right are set to the second, and the bottom is set to the
 third. If there are four values, they apply to the top, right, bottom, and left, respectively. Defaults to: {top:0,
 right:0, bottom:0, left:0}]]></description><name>margins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An input mask regular expression that will be used to filter keystrokes that do not match (defaults to null). The maskRe
 will not operate on any paste events.]]></description><name>maskRe</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Maximum input field length allowed by validation (defaults to Number.MAX_VALUE). This behavior is intended to provide
 instant feedback to the user by improving usability to allow pasting and editing or overtyping and back tracking. To
 restrict the maximum number of characters that can be entered into the field use autoCreate to add any attributes you
 want to a field, for example: var myField = new Ext.form.NumberField({
     id: 'mobile',
     anchor:'90%',
    
 fieldLabel: 'Mobile',
     maxLength: 16, // for validation
     autoCreate: {tag: 'input', type: 'text', size: '20',
 autocomplete: 'off', maxlength: '10'}
 });]]></description><name>maxLength</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Error text to display if the maximum length validation fails (defaults to 'The maximum length for this field is
 {maxLength}')]]></description><name>maxLengthText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Minimum input field length required (defaults to 0)]]></description><name>minLength</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Error text to display if the minimum length validation fails (defaults to 'The minimum length for this field is
 {minLength}')]]></description><name>minLengthText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Experimental The effect used when displaying a validation message under the field (defaults to 'normal').]]></description><name>msgFx</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The location where the message text set through markInvalid should display. Must be one of the following values: qtip
 Display a quick tip containing the message when the user hovers over the field. This is the default. Ext.QuickTips.init
 must have been called for this setting to work. title Display the message in a default browser title attribute popup.
 under Add a block div beneath the field containing the error message. side Add an error icon to the right of the field,
 displaying the message in a popup on hover. [element id] Add the error message directly to the innerHTML of the
 specified element.]]></description><name>msgTarget</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element when the mouse moves over the Element, and
 removed when the mouse moves out. (defaults to ''). This can be useful for adding customized 'active' or 'hover' styles
 to the component or any of its children using standard CSS rules.]]></description><name>overCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level x coordinate for this component if contained within a positioning container.]]></description><name>pageX</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level y coordinate for this component if contained within a positioning container.]]></description><name>pageY</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to disable marking the field invalid. Defaults to false.]]></description><name>preventMark</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered ptype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a Plugin is being specified not as a fully
 instantiated Component, but as a Component config object. The ptype will be looked up at render time up to determine
 what type of Plugin to create. If you create your own Plugins, you may register them using
 Ext.ComponentMgr.registerPlugin in order to be able to take advantage of lazy instantiation and rendering.]]></description><name>ptype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to prevent the user from changing the field, and hides the trigger. Superceeds the editable and hideTrigger options
 if the value is true. (defaults to false)]]></description><name>readOnly</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A path specification, relative to the Component's ownerCt specifying into which ancestor Container to place a named
 reference to this Component. The ancestor axis can be traversed by using '/' characters in the path. For example, to put
 a reference to a Toolbar Button into the Panel which owns the Toolbar: var myGrid = new Ext.grid.EditorGridPanel({
    
 title: 'My EditorGridPanel',
     store: myStore,
     colModel: myColModel,
     tbar: [{
         text: 'Save',
        
 handler: saveChanges,
         disabled: true,
         ref: '../saveButton'
     }],
     listeners: {
         afteredit:
 function() {
 //          The button reference is in the GridPanel
             myGrid.saveButton.enable();
         }
    
 }
 }); In the code above, if the ref had been 'saveButton' the reference would have been placed into the Toolbar. Each
 '/' in the ref moves up one level from the Component's ownerCt. Also see the added and removed events.]]></description><name>ref</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A JavaScript RegExp object to be tested against the field value during validation (defaults to null). If the test fails,
 the field will be marked invalid using regexText.]]></description><name>regex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The error text to display if regex is used and the test fails during validation (defaults to '')]]></description><name>regexText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout layout manager (e.g. specifying layout:'border'). See Ext.layout.BorderLayout also.]]></description><name>region</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to automatically select any existing field text when the field receives input focus (defaults to false)]]></description><name>selectOnFocus</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should trigger this component to save its state (defaults to none). stateEvents may
 be any type of event supported by this component, including browser or custom events (e.g., ['click',
 'customerchange']). See stateful for an explanation of saving and restoring Component state.]]></description><name>stateEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id for this component to use for state management purposes (defaults to the component id if one was set,
 otherwise null if the component is using a generated id). See stateful for an explanation of saving and restoring
 Component state.]]></description><name>stateId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A flag which causes the Component to attempt to restore the state of internal properties from a saved state on startup.
 The component must have either a stateId or id assigned for state to be managed. Auto-generated ids are not guaranteed
 to be stable across page loads and cannot be relied upon to save and restore the same state for a component. For state
 saving to work, the state manager's provider must have been set to an implementation of Ext.state.Provider which
 overrides the set and get methods to save and recall name/value pairs. A built-in implementation,
 Ext.state.CookieProvider is available. To set the state provider for the current page: Ext.state.Manager.setProvider(new
 Ext.state.CookieProvider({
     expires: new Date(new Date().getTime()+(1000*60*60*24*7)), //7 days from now
 })); A
 stateful Component attempts to save state when one of the events listed in the stateEvents configuration fires. To save
 state, a stateful Component first serializes its state by calling getState. By default, this function does nothing. The
 developer must provide an implementation which returns an object hash which represents the Component's restorable state.
 The value yielded by getState is passed to Ext.state.Manager.set which uses the configured Ext.state.Provider to save
 the object keyed by the Component's stateId, or, if that is not specified, its id. During construction, a stateful
 Component attempts to restore its state by calling Ext.state.Manager.get passing the stateId, or, if that is not
 specified, the id. The resulting object is passed to applyState. The default implementation of applyState simply copies
 properties into the object, but a developer may override this to support more behaviour. You can perform extra
 processing on state save and restore by attaching handlers to the beforestaterestore, staterestore, beforestatesave and
 statesave events.]]></description><name>stateful</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A JavaScript RegExp object used to strip unwanted content from the value before validation (defaults to null).]]></description><name>stripCharsRe</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
     title: 'Some Title',
     renderTo: Ext.getBody(),
     width: 400, height:
 300,
     layout: 'form',
     items: [{
         xtype: 'textarea',
         style: {
             width: '95%',
            
 marginBottom: '10px'
         }
     },
         new Ext.Button({
             text: 'Send',
             minWidth: '100',
   
          style: {
                 marginBottom: '10px'
             }
         })
     ]
 });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[False to clear the name attribute on the field so that it is not submitted during a form post. Defaults to true.]]></description><name>submitValue</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The tabIndex for this field. Note this only applies to fields that are rendered, not those which are built via applyTo
 (defaults to undefined).]]></description><name>tabIndex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is a child item of a TabPanel. A string to be used as innerHTML
 (html tags are accepted) to show in a tooltip when mousing over the associated tab selector element.
 Ext.QuickTips.init() must be called in order for the tips to render.]]></description><name>tabTip</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An additional CSS class used to style the trigger button. The trigger will always get the class 'x-form-trigger' by
 default and triggerClass will be appended if specified.]]></description><name>trigger1Class</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An additional CSS class used to style the trigger button. The trigger will always get the class 'x-form-trigger' by
 default and triggerClass will be appended if specified.]]></description><name>trigger2Class</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An additional CSS class used to style the trigger button. The trigger will always get the class 'x-form-trigger' by
 default and triggerClass will be appended if specified.]]></description><name>triggerClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A DomHelper config object specifying the structure of the trigger elements for this Field. (Optional). Specify this when
 you need a customized element to contain the two trigger elements for this Field. Each trigger element must be marked by
 the CSS class x-form-trigger (also see trigger1Class and trigger2Class). Note that when using this option, it is the
 developer's responsibility to ensure correct sizing, positioning and appearance of the triggers.]]></description><name>triggerConfig</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Whether the field should validate when it loses focus (defaults to true).]]></description><name>validateOnBlur</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The length of time in milliseconds after user input begins until validation is initiated (defaults to 250)]]></description><name>validationDelay</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The event that should initiate field validation. Set to false to disable automatic validation (defaults to 'keyup').]]></description><name>validationEvent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom validation function to be called during field validation (validateValue) (defaults to null). If specified, this
 function will be called first, allowing the developer to override the default validation process. This function will be
 passed the following Parameters: value: Mixed The current field value This function is to Return: true: Boolean true if
 the value is valid msg: String An error message if the value is invalid]]></description><name>validator</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A value to initialize this field with (defaults to undefined).]]></description><name>value</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A validation type name as defined in Ext.form.VTypes (defaults to null)]]></description><name>vtype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom error message to display in place of the default message provided for the vtype currently set for this field
 (defaults to ''). Note: only applies if vtype is set, else ignored.]]></description><name>vtypeText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The class added to the to the wrap of the trigger element. Defaults to x-trigger-wrap-focus.]]></description><name>wrapFocusClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local x (left) coordinate for this component if contained within a positioning container.]]></description><name>x</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered xtype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a child item of a Container is being specified not
 as a fully instantiated Component, but as a Component config object. The xtype will be looked up at render time up to
 determine what type of child Component to create. The predefined xtypes are listed here. If you subclass Components to
 create your own Components, you may register them using Ext.ComponentMgr.registerType in order to be able to take
 advantage of lazy instantiation and rendering.]]></description><name>xtype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local y (top) coordinate for this component if contained within a positioning container.]]></description><name>y</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 <p>A Grid column type which renders an icon, or a series of icons in a grid cell, and offers a scoped click handler for
 each icon. Example usage:</p> 
 <pre><code><b>new</b> Ext.grid.GridPanel({
     store: myStore,
     columns: [
         {
  
 xtype: <em>'actioncolumn'</em>,
             width: 50,
             items: [
                 {
                     icon  
 : <em>'sell.gif'</em>,                <i>// Use a URL <b>in</b> the icon config</i>
                     tooltip:
 <em>'Sell stock'</em>,
                     handler: <b>function</b>(grid, rowIndex, colIndex) {
                        
 <b>var</b> rec = store.getAt(rowIndex);
                         alert(<em>&quot;Sell &quot;</em> +
 rec.get(<em>'company'</em>));
                     }
                 },
                 {
                     getClass:
 <b>function</b>(v, meta, rec) {  <i>// Or <b>return</b> a class from a <b>function</b></i>
                        
 <b>if</b> (rec.get(<em>'change'</em>) &lt; 0) {
                             this.items[1].tooltip = <em>'Do not
 buy!'</em>;
                             <b>return</b> <em>'alert-col'</em>;
                         } <b>else</b> {
     
 this.items[1].tooltip = <em>'Buy stock'</em>;
                             <b>return</b> <em>'buy-col'</em>;
             
 }
                     },
                     handler: <b>function</b>(grid, rowIndex, colIndex) {
                       
 <b>var</b> rec = store.getAt(rowIndex);
                         alert(<em>&quot;Buy &quot;</em> +
 rec.get(<em>'company'</em>));
                     }
                 }
             ]
         }
         <i>//any other
 columns here</i>
     ]
 });
 </code></pre> 
 <p>The action column can be at any index in the columns array, and a grid can
 have any number of action columns. </p>]]></description><name>grid.actionColumn</name><tag-class>org.brushingbits.jnap.ui.extjs3.grid.ActionColumn</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[Optional. Set the CSS text-align property of the column. Defaults to undefined.]]></description><name>align</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The alt text to use for the image element. Defaults to ''.]]></description><name>altText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. An inline style definition string which is applied to all table cells in the column (excluding headers).
 Defaults to undefined.]]></description><name>css</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Required. The name of the field in the grid's Ext.data.Store's Ext.data.Record definition from which to draw the
 column's value.]]></description><name>dataIndex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Defaults to true, enabling the configured editor. Set to false to initially disable editing on this column.
 The initial configuration may be dynamically altered using Ext.grid.ColumnModel.setEditable().]]></description><name>editable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. The Ext.form.Field to use when editing values in this column if editing is supported by the grid. See editable
 also.]]></description><name>editor</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. If the grid is being rendered by an Ext.grid.GroupingView, this option may be used to specify the text to
 display when there is an empty group value. Defaults to the Ext.grid.GroupingView.emptyGroupText.]]></description><name>emptyGroupText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. true if the column width cannot be changed. Defaults to false.]]></description><name>fixed</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A function which returns the CSS class to apply to the icon image. The function is passed the following parameters: v :
 Object The value of the column's configured field (if any). metadata : Object An object in which you may set the
 following attributes: css : String A CSS class name to add to the cell's TD element. attr : String An HTML attribute
 definition string to apply to the data container element within the table cell (e.g. 'style="color:red;"'). r :
 Ext.data.Record The Record providing the data. rowIndex : Number The row index.. colIndex : Number The column index.
 store : Ext.data.Store The Store which is providing the data Model.]]></description><name>getCssClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. If the grid is being rendered by an Ext.grid.GroupingView, this option may be used to specify the text with
 which to prefix the group field value in the group header line. See also groupRenderer and
 Ext.grid.GroupingView.showGroupName.]]></description><name>groupName</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. If the grid is being rendered by an Ext.grid.GroupingView, this option may be used to specify the function
 used to format the grouping field value for display in the group header. If a groupRenderer is not specified, the
 configured renderer will be called; if a renderer is also not specified the new value of the group field will be used.
 The called function (either the groupRenderer or renderer) will be passed the following parameters: v : Object The new
 value of the group field. unused : undefined Unused parameter. r : Ext.data.Record The Record providing the data for the
 row which caused group change. rowIndex : Number The row index of the Record which caused group change. colIndex :
 Number The column index of the group field. ds : Ext.data.Store The Store which is providing the data Model. The
 function should return a string value.]]></description><name>groupRenderer</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. If the grid is being rendered by an Ext.grid.GroupingView, this option may be used to disable the header menu
 item to group by the column selected. Defaults to true, which enables the header menu group option. Set to false to
 disable (but still show) the group option in the header menu for the column. See also groupName.]]></description><name>groupable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A function called when the icon is clicked. The handler is passed the following parameters: grid : GridPanel The owning
 GridPanel. rowIndex : Number The row index clicked on. colIndex : Number The column index clicked on. item : Object The
 clicked item (or this Column if multiple items were not configured). e : Event The click event.]]></description><name>handler</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. The header text to be used as innerHTML (html tags are accepted) to display in the Grid view. Note: to have a
 clickable header with no text displayed use '&#160'.]]></description><name>header</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. true to initially hide this column. Defaults to false. A hidden column may be shown via the header row menu.
 If a column is never to be shown, simply do not include this column in the Column Model at all.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify as false to prevent the user from hiding this column (defaults to true). To disallow column hiding
 globally for all columns in the grid, use Ext.grid.GridPanel.enableColumnHide instead.]]></description><name>hideable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The URL of an image to display as the clickable element in the column. Optional - defaults to Ext.BLANK_IMAGE_URL.]]></description><name>icon</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS class to apply to the icon image. To determine the class dynamically, configure the Column with a getClass
 function.]]></description><name>iconCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. A name which identifies this column (defaults to the column's initial ordinal position.) The id is used to
 create a CSS class name which is applied to all table cells (including headers) in that column (in this context the id
 does not need to be unique). The class name takes the form of x-grid3-td-id Header cells will also receive this class
 name, but will also have the class x-grid3-hd So, to target header cells, use CSS selectors such as: .x-grid3-hd-row
 .x-grid3-td-id The Ext.grid.GridPanel.autoExpandColumn grid config option references the column via this unique
 identifier.]]></description><name>id</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An Array which may contain multiple icon definitions, each element of which may contain: icon : String The url of an
 image to display as the clickable element in the column. iconCls : String A CSS class to apply to the icon image. To
 determine the class dynamically, configure the item with a getClass function. getClass : Function A function which
 returns the CSS class to apply to the icon image. The function is passed the following parameters: v : Object The value
 of the column's configured field (if any). metadata : Object An object in which you may set the following attributes:
 css : String A CSS class name to add to the cell's TD element. attr : String An HTML attribute definition string to
 apply to the data container element within the table cell (e.g. 'style="color:red;"'). r : Ext.data.Record The Record
 providing the data. rowIndex : Number The row index.. colIndex : Number The column index. store : Ext.data.Store The
 Store which is providing the data Model. handler : Function A function called when the icon is clicked. scope : Scope
 The scope (this reference) in which the handler and getClass functions are executed. Fallback defaults are this Column's
 configured scope, then this Column. tooltip : String A tooltip message to be displayed on hover. Ext.QuickTips must have
 been initialized.]]></description><name>items</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. true to disable the column menu. Defaults to false.]]></description><name>menuDisabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[For an alternative to specifying a renderer see xtype Optional. A renderer is an 'interceptor' method which can be used
 transform data (value, appearance, etc.) before it is rendered). This may be specified in either of three ways: A
 renderer function used to return HTML markup for a cell given the cell's data value. A string which references a
 property name of the Ext.util.Format class which provides a renderer function. An object specifying both the renderer
 function, and its execution scope (this reference) e.g.:
 <pre><code>{
     fn: this.gridRenderer,
     scope: this
 }</code></pre>
 If not
 specified, the default renderer uses the raw data value. For information about the renderer function (passed parameters,
 etc.), see Ext.grid.ColumnModel.setRenderer. An example of specifying renderer function inline:
 <pre><code>
 var companyColumn = {
    header: 'Company Name',
    dataIndex: 'company',
    renderer: function(value, metaData, record, rowIndex, colIndex, store) {
       // provide the logic depending on business rules
       // name of your own choosing to manipulate the cell depending upon
       // the data in the underlying Record object.
       if (value == 'whatever') {
           // metaData.css : String : A CSS class name to add to the TD element of the cell.
           // metaData.attr : String : An html attribute definition string to apply to
           // the data container element within the table
           // cell (e.g. 'style="color:red;"').
           metaData.css = 'name-of-css-class-you-will-define';
       }
       return value;
    }
 }</code></pre>
 See also scope.]]></description><name>renderer</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. false to disable column resizing. Defaults to true.]]></description><name>resizable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The scope (this reference) in which the handler and getClass fuctions are executed. Defaults to this Column.]]></description><name>scope</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. true if sorting is to be allowed on this column. Defaults to the value of the
 Ext.grid.ColumnModel.defaultSortable property. Whether local/remote sorting is used is specified in
 Ext.data.Store.remoteSort.]]></description><name>sortable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to true. Prevent grid row selection upon mousedown.]]></description><name>stopSelection</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A tooltip message to be displayed on hover. Ext.QuickTips must have been initialized.]]></description><name>tooltip</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. The initial width in pixels of the column. The width of each column can also be affected if any of the
 following are configured: Ext.grid.GridPanel.autoExpandColumn Ext.grid.GridView.forceFit By specifying forceFit:true,
 non-fixed width columns will be re-proportioned (based on the relative initial widths) to fill the width of the grid so
 that no horizontal scrollbar is shown. Ext.grid.GridView.autoFill Ext.grid.GridPanel.minColumnWidth Note: when the width
 of each column is determined, a space on the right side is reserved for the vertical scrollbar. The
 Ext.grid.GridView.scrollOffset can be modified to reduce or eliminate the reserved offset.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 <p>A Column definition class which renders boolean data fields. See the <a
 href="output/Ext.grid.Column.html#Ext.grid.Column-xtype" ext:member="xtype" ext:cls="Ext.grid.Column">xtype</a> config
 option of <a href="output/Ext.grid.Column.html" ext:cls="Ext.grid.Column">Ext.grid.Column</a> for more details.</p>]]></description><name>grid.booleanColumn</name><tag-class>org.brushingbits.jnap.ui.extjs3.grid.BooleanColumn</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[Optional. Set the CSS text-align property of the column. Defaults to undefined.]]></description><name>align</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. An inline style definition string which is applied to all table cells in the column (excluding headers).
 Defaults to undefined.]]></description><name>css</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Required. The name of the field in the grid's Ext.data.Store's Ext.data.Record definition from which to draw the
 column's value.]]></description><name>dataIndex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Defaults to true, enabling the configured editor. Set to false to initially disable editing on this column.
 The initial configuration may be dynamically altered using Ext.grid.ColumnModel.setEditable().]]></description><name>editable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. The Ext.form.Field to use when editing values in this column if editing is supported by the grid. See editable
 also.]]></description><name>editor</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. If the grid is being rendered by an Ext.grid.GroupingView, this option may be used to specify the text to
 display when there is an empty group value. Defaults to the Ext.grid.GroupingView.emptyGroupText.]]></description><name>emptyGroupText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The string returned by the renderer when the column value is falsy (but not undefined) (defaults to 'false').]]></description><name>falseText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. true if the column width cannot be changed. Defaults to false.]]></description><name>fixed</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. If the grid is being rendered by an Ext.grid.GroupingView, this option may be used to specify the text with
 which to prefix the group field value in the group header line. See also groupRenderer and
 Ext.grid.GroupingView.showGroupName.]]></description><name>groupName</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. If the grid is being rendered by an Ext.grid.GroupingView, this option may be used to specify the function
 used to format the grouping field value for display in the group header. If a groupRenderer is not specified, the
 configured renderer will be called; if a renderer is also not specified the new value of the group field will be used.
 The called function (either the groupRenderer or renderer) will be passed the following parameters: v : Object The new
 value of the group field. unused : undefined Unused parameter. r : Ext.data.Record The Record providing the data for the
 row which caused group change. rowIndex : Number The row index of the Record which caused group change. colIndex :
 Number The column index of the group field. ds : Ext.data.Store The Store which is providing the data Model. The
 function should return a string value.]]></description><name>groupRenderer</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. If the grid is being rendered by an Ext.grid.GroupingView, this option may be used to disable the header menu
 item to group by the column selected. Defaults to true, which enables the header menu group option. Set to false to
 disable (but still show) the group option in the header menu for the column. See also groupName.]]></description><name>groupable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. The header text to be used as innerHTML (html tags are accepted) to display in the Grid view. Note: to have a
 clickable header with no text displayed use '&#160'.]]></description><name>header</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. true to initially hide this column. Defaults to false. A hidden column may be shown via the header row menu.
 If a column is never to be shown, simply do not include this column in the Column Model at all.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify as false to prevent the user from hiding this column (defaults to true). To disallow column hiding
 globally for all columns in the grid, use Ext.grid.GridPanel.enableColumnHide instead.]]></description><name>hideable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. A name which identifies this column (defaults to the column's initial ordinal position.) The id is used to
 create a CSS class name which is applied to all table cells (including headers) in that column (in this context the id
 does not need to be unique). The class name takes the form of x-grid3-td-id Header cells will also receive this class
 name, but will also have the class x-grid3-hd So, to target header cells, use CSS selectors such as: .x-grid3-hd-row
 .x-grid3-td-id The Ext.grid.GridPanel.autoExpandColumn grid config option references the column via this unique
 identifier.]]></description><name>id</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. true to disable the column menu. Defaults to false.]]></description><name>menuDisabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[For an alternative to specifying a renderer see xtype Optional. A renderer is an 'interceptor' method which can be used
 transform data (value, appearance, etc.) before it is rendered). This may be specified in either of three ways: A
 renderer function used to return HTML markup for a cell given the cell's data value. A string which references a
 property name of the Ext.util.Format class which provides a renderer function. An object specifying both the renderer
 function, and its execution scope (this reference) e.g.:
 <pre><code>{
     fn: this.gridRenderer,
     scope: this
 }</code></pre>
 If not
 specified, the default renderer uses the raw data value. For information about the renderer function (passed parameters,
 etc.), see Ext.grid.ColumnModel.setRenderer. An example of specifying renderer function inline:
 <pre><code>
 var companyColumn = {
    header: 'Company Name',
    dataIndex: 'company',
    renderer: function(value, metaData, record, rowIndex, colIndex, store) {
       // provide the logic depending on business rules
       // name of your own choosing to manipulate the cell depending upon
       // the data in the underlying Record object.
       if (value == 'whatever') {
           // metaData.css : String : A CSS class name to add to the TD element of the cell.
           // metaData.attr : String : An html attribute definition string to apply to
           // the data container element within the table
           // cell (e.g. 'style="color:red;"').
           metaData.css = 'name-of-css-class-you-will-define';
       }
       return value;
    }
 }</code></pre>
 See also scope.]]></description><name>renderer</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. false to disable column resizing. Defaults to true.]]></description><name>resizable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. The scope (this reference) in which to execute the renderer. Defaults to the Column configuration object.]]></description><name>scope</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. true if sorting is to be allowed on this column. Defaults to the value of the
 Ext.grid.ColumnModel.defaultSortable property. Whether local/remote sorting is used is specified in
 Ext.data.Store.remoteSort.]]></description><name>sortable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. A text string to use as the column header's tooltip. If Quicktips are enabled, this value will be used as the
 text of the quick tip, otherwise it will be set as the header's HTML title attribute. Defaults to ''.]]></description><name>tooltip</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The string returned by the renderer when the column value is not falsy (defaults to 'true').]]></description><name>trueText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The string returned by the renderer when the column value is undefined (defaults to '&#160;').]]></description><name>undefinedText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. The initial width in pixels of the column. The width of each column can also be affected if any of the
 following are configured: Ext.grid.GridPanel.autoExpandColumn Ext.grid.GridView.forceFit By specifying forceFit:true,
 non-fixed width columns will be re-proportioned (based on the relative initial widths) to fill the width of the grid so
 that no horizontal scrollbar is shown. Ext.grid.GridView.autoFill Ext.grid.GridPanel.minColumnWidth Note: when the width
 of each column is determined, a space on the right side is reserved for the vertical scrollbar. The
 Ext.grid.GridView.scrollOffset can be modified to reduce or eliminate the reserved offset.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 A custom selection model that renders a column of checkboxes that can be toggled to select or deselect rows.]]></description><name>grid.checkboxSelectionModel</name><tag-class>org.brushingbits.jnap.ui.extjs3.grid.CheckboxSelectionModel</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[true if rows can only be selected by clicking on the checkbox column (defaults to false).]]></description><name>checkOnly</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Any valid text or HTML fragment to display in the header cell for the checkbox column. Defaults to: '<div
 class="x-grid3-hd-checker">&#160;</div>' The default CSS class of 'x-grid3-hd-checker' displays a checkbox in the header
 and provides support for automatic check all/none behavior on header click. This string can be replaced by any valid
 HTML fragment, including a simple text string (e.g., 'Select Rows'), but the automatic check all/none behavior will only
 work if the 'x-grid3-hd-checker' class is supplied.]]></description><name>header</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[false to turn off moving the editor to the next row down when the enter key is pressed or the next row up when shift +
 enter keys are pressed.]]></description><name>moveEditorOnEnter</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to allow selection of only one row at a time (defaults to false allowing multiple selections)]]></description><name>singleSelect</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true if the checkbox column is sortable (defaults to false).]]></description><name>sortable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default width in pixels of the checkbox column (defaults to 20).]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 <p>This class encapsulates column configuration data to be used in the initialization of a <a
 href="output/Ext.grid.ColumnModel.html" ext:cls="Ext.grid.ColumnModel">ColumnModel</a>.</p> 
 <p>While subclasses are
 provided to render data in different ways, this class renders a passed data field unchanged and is usually used for
 textual columns.</p>]]></description><name>grid.column</name><tag-class>org.brushingbits.jnap.ui.extjs3.grid.Column</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[Optional. Set the CSS text-align property of the column. Defaults to undefined.]]></description><name>align</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. An inline style definition string which is applied to all table cells in the column (excluding headers).
 Defaults to undefined.]]></description><name>css</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Required. The name of the field in the grid's Ext.data.Store's Ext.data.Record definition from which to draw the
 column's value.]]></description><name>dataIndex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Defaults to true, enabling the configured editor. Set to false to initially disable editing on this column.
 The initial configuration may be dynamically altered using Ext.grid.ColumnModel.setEditable().]]></description><name>editable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. The Ext.form.Field to use when editing values in this column if editing is supported by the grid. See editable
 also.]]></description><name>editor</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. If the grid is being rendered by an Ext.grid.GroupingView, this option may be used to specify the text to
 display when there is an empty group value. Defaults to the Ext.grid.GroupingView.emptyGroupText.]]></description><name>emptyGroupText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. true if the column width cannot be changed. Defaults to false.]]></description><name>fixed</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. If the grid is being rendered by an Ext.grid.GroupingView, this option may be used to specify the text with
 which to prefix the group field value in the group header line. See also groupRenderer and
 Ext.grid.GroupingView.showGroupName.]]></description><name>groupName</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. If the grid is being rendered by an Ext.grid.GroupingView, this option may be used to specify the function
 used to format the grouping field value for display in the group header. If a groupRenderer is not specified, the
 configured renderer will be called; if a renderer is also not specified the new value of the group field will be used.
 The called function (either the groupRenderer or renderer) will be passed the following parameters: v : Object The new
 value of the group field. unused : undefined Unused parameter. r : Ext.data.Record The Record providing the data for the
 row which caused group change. rowIndex : Number The row index of the Record which caused group change. colIndex :
 Number The column index of the group field. ds : Ext.data.Store The Store which is providing the data Model. The
 function should return a string value.]]></description><name>groupRenderer</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. If the grid is being rendered by an Ext.grid.GroupingView, this option may be used to disable the header menu
 item to group by the column selected. Defaults to true, which enables the header menu group option. Set to false to
 disable (but still show) the group option in the header menu for the column. See also groupName.]]></description><name>groupable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. The header text to be used as innerHTML (html tags are accepted) to display in the Grid view. Note: to have a
 clickable header with no text displayed use '&#160'.]]></description><name>header</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. true to initially hide this column. Defaults to false. A hidden column may be shown via the header row menu.
 If a column is never to be shown, simply do not include this column in the Column Model at all.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify as false to prevent the user from hiding this column (defaults to true). To disallow column hiding
 globally for all columns in the grid, use Ext.grid.GridPanel.enableColumnHide instead.]]></description><name>hideable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. A name which identifies this column (defaults to the column's initial ordinal position.) The id is used to
 create a CSS class name which is applied to all table cells (including headers) in that column (in this context the id
 does not need to be unique). The class name takes the form of x-grid3-td-id Header cells will also receive this class
 name, but will also have the class x-grid3-hd So, to target header cells, use CSS selectors such as: .x-grid3-hd-row
 .x-grid3-td-id The Ext.grid.GridPanel.autoExpandColumn grid config option references the column via this unique
 identifier.]]></description><name>id</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. true to disable the column menu. Defaults to false.]]></description><name>menuDisabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[For an alternative to specifying a renderer see xtype Optional. A renderer is an 'interceptor' method which can be used
 transform data (value, appearance, etc.) before it is rendered). This may be specified in either of three ways: A
 renderer function used to return HTML markup for a cell given the cell's data value. A string which references a
 property name of the Ext.util.Format class which provides a renderer function. An object specifying both the renderer
 function, and its execution scope (this reference) e.g.:
 <pre><code>{
     fn: this.gridRenderer,
     scope: this
 }</code></pre>
 If not
 specified, the default renderer uses the raw data value. For information about the renderer function (passed parameters,
 etc.), see Ext.grid.ColumnModel.setRenderer. An example of specifying renderer function inline:
 <pre><code>
 var companyColumn = {
    header: 'Company Name',
    dataIndex: 'company',
    renderer: function(value, metaData, record, rowIndex, colIndex, store) {
       // provide the logic depending on business rules
       // name of your own choosing to manipulate the cell depending upon
       // the data in the underlying Record object.
       if (value == 'whatever') {
           // metaData.css : String : A CSS class name to add to the TD element of the cell.
           // metaData.attr : String : An html attribute definition string to apply to
           // the data container element within the table
           // cell (e.g. 'style="color:red;"').
           metaData.css = 'name-of-css-class-you-will-define';
       }
       return value;
    }
 }</code></pre>
 See also scope.]]></description><name>renderer</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. false to disable column resizing. Defaults to true.]]></description><name>resizable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. The scope (this reference) in which to execute the renderer. Defaults to the Column configuration object.]]></description><name>scope</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. true if sorting is to be allowed on this column. Defaults to the value of the
 Ext.grid.ColumnModel.defaultSortable property. Whether local/remote sorting is used is specified in
 Ext.data.Store.remoteSort.]]></description><name>sortable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. A text string to use as the column header's tooltip. If Quicktips are enabled, this value will be used as the
 text of the quick tip, otherwise it will be set as the header's HTML title attribute. Defaults to ''.]]></description><name>tooltip</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. The initial width in pixels of the column. The width of each column can also be affected if any of the
 following are configured: Ext.grid.GridPanel.autoExpandColumn Ext.grid.GridView.forceFit By specifying forceFit:true,
 non-fixed width columns will be re-proportioned (based on the relative initial widths) to fill the width of the grid so
 that no horizontal scrollbar is shown. Ext.grid.GridView.autoFill Ext.grid.GridPanel.minColumnWidth Note: when the width
 of each column is determined, a space on the right side is reserved for the vertical scrollbar. The
 Ext.grid.GridView.scrollOffset can be modified to reduce or eliminate the reserved offset.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 <p>After the data has been read into the client side cache (<b><a href="output/Ext.data.Store.html"
 ext:cls="Ext.data.Store">Store</a></b>), the ColumnModel is used to configure how and what parts of that data will be
 displayed in the vertical slices (columns) of the grid. The Ext.grid.ColumnModel Class is the default implementation of
 a ColumnModel used by implentations of <a href="output/Ext.grid.GridPanel.html"
 ext:cls="Ext.grid.GridPanel">GridPanel</a>.</p> 
 <p>Data is mapped into the store's records and then indexed into the
 ColumnModel using the <tt><a href="output/Ext.grid.Column.html#Ext.grid.Column-dataIndex" ext:member="dataIndex"
 ext:cls="Ext.grid.Column">dataIndex</a></tt>:</p> 
 <pre><code>{data source} == mapping ==&gt; {data store} == <b><tt><a
 href="output/Ext.grid.Column.html#Ext.grid.Column-dataIndex" ext:member="dataIndex"
 ext:cls="Ext.grid.Column">dataIndex</a></tt></b> ==&gt; {ColumnModel}</code></pre> 
 <p>Each <a
 href="output/Ext.grid.Column.html" ext:cls="Ext.grid.Column">Column</a> in the grid's ColumnModel is configured with a
 <tt><a href="output/Ext.grid.Column.html#Ext.grid.Column-dataIndex" ext:member="dataIndex"
 ext:cls="Ext.grid.Column">dataIndex</a></tt> to specify how the data within each record in the store is indexed into the
 ColumnModel.</p> 
 <p>There are two ways to initialize the ColumnModel class:</p> 
 <p><u>Initialization Method 1: an
 Array</u></p> 
 <pre><code><b>var</b> colModel = <b>new</b> Ext.grid.ColumnModel([
     { header:
 <em>&quot;Ticker&quot;</em>, width: 60, sortable: true},
     { header: <em>&quot;Company Name&quot;</em>, width: 150,
 sortable: true, id: <em>'company'</em>},
     { header: <em>&quot;Market Cap.&quot;</em>, width: 100, sortable: true},
   
 { header: <em>&quot;$ Sales&quot;</em>, width: 100, sortable: true, renderer: money},
     { header:
 <em>&quot;Employees&quot;</em>, width: 100, sortable: true, resizable: false}
  ]);</code></pre> 
 <p>The ColumnModel may
 be initialized with an Array of <a href="output/Ext.grid.Column.html" ext:cls="Ext.grid.Column">Ext.grid.Column</a>
 column configuration objects to define the initial layout / display of the columns in the Grid. The order of each <a
 href="output/Ext.grid.Column.html" ext:cls="Ext.grid.Column">Ext.grid.Column</a> column configuration object within the
 specified Array defines the initial order of the column display. A Column's display may be initially hidden using the
 <tt><a href="output/Ext.grid.Column.html#Ext.grid.Column-hidden" ext:member="hidden"
 ext:cls="Ext.grid.Column">hidden</a></tt> config property (and then shown using the column header menu). Fields that are
 not included in the ColumnModel will not be displayable at all.</p> 
 <p>How each column in the grid correlates (maps) to
 the <a href="output/Ext.data.Record.html" ext:cls="Ext.data.Record">Ext.data.Record</a> field in the <a
 href="output/Ext.data.Store.html" ext:cls="Ext.data.Store">Store</a> the column draws its data from is configured
 through the <b><tt><a href="output/Ext.grid.Column.html#Ext.grid.Column-dataIndex" ext:member="dataIndex"
 ext:cls="Ext.grid.Column">dataIndex</a></tt></b>. If the <b><tt><a
 href="output/Ext.grid.Column.html#Ext.grid.Column-dataIndex" ext:member="dataIndex"
 ext:cls="Ext.grid.Column">dataIndex</a></tt></b> is not explicitly defined (as shown in the example above) it will use
 the column configuration's index in the Array as the index.</p> 
 <p>See <b><tt><a href="output/Ext.grid.Column.html"
 ext:cls="Ext.grid.Column">Ext.grid.Column</a></tt></b> for additional configuration options for each column.</p>
 
 <p><u>Initialization Method 2: an Object</u></p> 
 <p>In order to use configuration options from
 <tt>Ext.grid.ColumnModel</tt>, an Object may be used to initialize the ColumnModel. The column configuration Array will
 be specified in the <tt><b><a href="output/Ext.grid.ColumnModel.html#Ext.grid.ColumnModel-columns" ext:member="columns"
 ext:cls="Ext.grid.ColumnModel">columns</a></b></tt> config property. The <tt><b><a
 href="output/Ext.grid.ColumnModel.html#Ext.grid.ColumnModel-defaults" ext:member="defaults"
 ext:cls="Ext.grid.ColumnModel">defaults</a></b></tt> config property can be used to apply defaults for all columns,
 e.g.:</p>
 <pre><code><b>var</b> colModel = <b>new</b> Ext.grid.ColumnModel({
     columns: [
         { header:
 <em>&quot;Ticker&quot;</em>, width: 60, menuDisabled: false},
         { header: <em>&quot;Company Name&quot;</em>,
 width: 150, id: <em>'company'</em>},
         { header: <em>&quot;Market Cap.&quot;</em>},
         { header: <em>&quot;$
 Sales&quot;</em>, renderer: money},
         { header: <em>&quot;Employees&quot;</em>, resizable: false}
     ],
    
 defaults: {
         sortable: true,
         menuDisabled: true,
         width: 100
     },
     listeners: {
         <a
 href="output/Ext.grid.ColumnModel.html#Ext.grid.ColumnModel-hiddenchange" ext:member="hiddenchange"
 ext:cls="Ext.grid.ColumnModel">hiddenchange</a>: <b>function</b>(cm, colIndex, hidden) {
            
 saveConfig(colIndex, hidden);
         }
     }
 });</code></pre> 
 <p>In both examples above, the ability to apply a CSS
 class to all cells in a column (including the header) is demonstrated through the use of the <b><tt><a
 href="output/Ext.grid.Column.html#Ext.grid.Column-id" ext:member="id" ext:cls="Ext.grid.Column">id</a></tt></b> config
 option. This column could be styled by including the following css:</p>
 <pre><code><i>//add this css *after* the core
 css is loaded</i>
 .x-grid3-td-company {
     color: red; <i>// entire column will have red font</i>
 }
 <i>// modify the
 header row only, adding an icon to the column header</i>
 .x-grid3-hd-company {
     background: transparent
        
 url(../../resources/images/icons/silk/building.png)
         no-repeat 3px 3px ! important;
        
 padding-left:20px;
 }</code></pre> Note that the &quot;Company Name&quot; column could be specified as the 
 <b><tt><a
 href="output/Ext.grid.GridPanel.html" ext:cls="Ext.grid.GridPanel">Ext.grid.GridPanel</a>.<a
 href="output/Ext.grid.GridPanel.html#Ext.grid.GridPanel-autoExpandColumn" ext:member="autoExpandColumn"
 ext:cls="Ext.grid.GridPanel">autoExpandColumn</a></tt></b>.]]></description><name>grid.columnModel</name><tag-class>org.brushingbits.jnap.ui.extjs3.grid.ColumnModel</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[Default sortable of columns which have no sortable specified (defaults to false). This property shall preferably be
 configured through the defaults config property.]]></description><name>defaultSortable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of columns which have no width specified (defaults to 100). This property shall preferably be configured
 through the defaults config property.]]></description><name>defaultWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Object literal which will be used to apply Ext.grid.Column configuration options to all columns. Configuration options
 specified with individual column configs will supersede these defaults.]]></description><name>defaults</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 <p>A Column definition class which renders a passed date according to the default locale, or a configured <a
 href="output/Ext.grid.DateColumn.html#Ext.grid.DateColumn-format" ext:member="format"
 ext:cls="Ext.grid.DateColumn">format</a>. See the <a href="output/Ext.grid.Column.html#Ext.grid.Column-xtype"
 ext:member="xtype" ext:cls="Ext.grid.Column">xtype</a> config option of <a href="output/Ext.grid.Column.html"
 ext:cls="Ext.grid.Column">Ext.grid.Column</a> for more details.</p>]]></description><name>grid.dateColumn</name><tag-class>org.brushingbits.jnap.ui.extjs3.grid.DateColumn</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[Optional. Set the CSS text-align property of the column. Defaults to undefined.]]></description><name>align</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. An inline style definition string which is applied to all table cells in the column (excluding headers).
 Defaults to undefined.]]></description><name>css</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Required. The name of the field in the grid's Ext.data.Store's Ext.data.Record definition from which to draw the
 column's value.]]></description><name>dataIndex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Defaults to true, enabling the configured editor. Set to false to initially disable editing on this column.
 The initial configuration may be dynamically altered using Ext.grid.ColumnModel.setEditable().]]></description><name>editable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. The Ext.form.Field to use when editing values in this column if editing is supported by the grid. See editable
 also.]]></description><name>editor</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. If the grid is being rendered by an Ext.grid.GroupingView, this option may be used to specify the text to
 display when there is an empty group value. Defaults to the Ext.grid.GroupingView.emptyGroupText.]]></description><name>emptyGroupText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. true if the column width cannot be changed. Defaults to false.]]></description><name>fixed</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A formatting string as used by Date.format to format a Date for this Column (defaults to 'm/d/Y').]]></description><name>format</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. If the grid is being rendered by an Ext.grid.GroupingView, this option may be used to specify the text with
 which to prefix the group field value in the group header line. See also groupRenderer and
 Ext.grid.GroupingView.showGroupName.]]></description><name>groupName</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. If the grid is being rendered by an Ext.grid.GroupingView, this option may be used to specify the function
 used to format the grouping field value for display in the group header. If a groupRenderer is not specified, the
 configured renderer will be called; if a renderer is also not specified the new value of the group field will be used.
 The called function (either the groupRenderer or renderer) will be passed the following parameters: v : Object The new
 value of the group field. unused : undefined Unused parameter. r : Ext.data.Record The Record providing the data for the
 row which caused group change. rowIndex : Number The row index of the Record which caused group change. colIndex :
 Number The column index of the group field. ds : Ext.data.Store The Store which is providing the data Model. The
 function should return a string value.]]></description><name>groupRenderer</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. If the grid is being rendered by an Ext.grid.GroupingView, this option may be used to disable the header menu
 item to group by the column selected. Defaults to true, which enables the header menu group option. Set to false to
 disable (but still show) the group option in the header menu for the column. See also groupName.]]></description><name>groupable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. The header text to be used as innerHTML (html tags are accepted) to display in the Grid view. Note: to have a
 clickable header with no text displayed use '&#160'.]]></description><name>header</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. true to initially hide this column. Defaults to false. A hidden column may be shown via the header row menu.
 If a column is never to be shown, simply do not include this column in the Column Model at all.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify as false to prevent the user from hiding this column (defaults to true). To disallow column hiding
 globally for all columns in the grid, use Ext.grid.GridPanel.enableColumnHide instead.]]></description><name>hideable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. A name which identifies this column (defaults to the column's initial ordinal position.) The id is used to
 create a CSS class name which is applied to all table cells (including headers) in that column (in this context the id
 does not need to be unique). The class name takes the form of x-grid3-td-id Header cells will also receive this class
 name, but will also have the class x-grid3-hd So, to target header cells, use CSS selectors such as: .x-grid3-hd-row
 .x-grid3-td-id The Ext.grid.GridPanel.autoExpandColumn grid config option references the column via this unique
 identifier.]]></description><name>id</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. true to disable the column menu. Defaults to false.]]></description><name>menuDisabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[For an alternative to specifying a renderer see xtype Optional. A renderer is an 'interceptor' method which can be used
 transform data (value, appearance, etc.) before it is rendered). This may be specified in either of three ways: A
 renderer function used to return HTML markup for a cell given the cell's data value. A string which references a
 property name of the Ext.util.Format class which provides a renderer function. An object specifying both the renderer
 function, and its execution scope (this reference) e.g.:
 <pre><code>{
     fn: this.gridRenderer,
     scope: this
 }</code></pre>
 If not
 specified, the default renderer uses the raw data value. For information about the renderer function (passed parameters,
 etc.), see Ext.grid.ColumnModel.setRenderer. An example of specifying renderer function inline:
 <pre><code>
 var companyColumn = {
    header: 'Company Name',
    dataIndex: 'company',
    renderer: function(value, metaData, record, rowIndex, colIndex, store) {
       // provide the logic depending on business rules
       // name of your own choosing to manipulate the cell depending upon
       // the data in the underlying Record object.
       if (value == 'whatever') {
           // metaData.css : String : A CSS class name to add to the TD element of the cell.
           // metaData.attr : String : An html attribute definition string to apply to
           // the data container element within the table
           // cell (e.g. 'style="color:red;"').
           metaData.css = 'name-of-css-class-you-will-define';
       }
       return value;
    }
 }</code></pre>
 See also scope.]]></description><name>renderer</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. false to disable column resizing. Defaults to true.]]></description><name>resizable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. The scope (this reference) in which to execute the renderer. Defaults to the Column configuration object.]]></description><name>scope</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. true if sorting is to be allowed on this column. Defaults to the value of the
 Ext.grid.ColumnModel.defaultSortable property. Whether local/remote sorting is used is specified in
 Ext.data.Store.remoteSort.]]></description><name>sortable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. A text string to use as the column header's tooltip. If Quicktips are enabled, this value will be used as the
 text of the quick tip, otherwise it will be set as the header's HTML title attribute. Defaults to ''.]]></description><name>tooltip</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. The initial width in pixels of the column. The width of each column can also be affected if any of the
 following are configured: Ext.grid.GridPanel.autoExpandColumn Ext.grid.GridView.forceFit By specifying forceFit:true,
 non-fixed width columns will be re-proportioned (based on the relative initial widths) to fill the width of the grid so
 that no horizontal scrollbar is shown. Ext.grid.GridView.autoFill Ext.grid.GridPanel.minColumnWidth Note: when the width
 of each column is determined, a space on the right side is reserved for the vertical scrollbar. The
 Ext.grid.GridView.scrollOffset can be modified to reduce or eliminate the reserved offset.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 <p>This class extends the <a href="output/Ext.grid.GridPanel.html" ext:cls="Ext.grid.GridPanel">GridPanel Class</a> to
 provide cell editing on selected <a href="output/Ext.grid.Column.html" ext:cls="Ext.grid.Column">columns</a>. The
 editable columns are specified by providing an <a href="output/Ext.grid.ColumnModel.html#Ext.grid.ColumnModel-editor"
 ext:member="editor" ext:cls="Ext.grid.ColumnModel">editor</a> in the <a href="output/Ext.grid.Column.html"
 ext:cls="Ext.grid.Column">column configuration</a>.</p> 
 <p>Editability of columns may be controlled programatically by
 inserting an implementation of <a href="output/Ext.grid.ColumnModel.html#Ext.grid.ColumnModel-isCellEditable"
 ext:member="isCellEditable" ext:cls="Ext.grid.ColumnModel">isCellEditable</a> into the <a
 href="output/Ext.grid.ColumnModel.html" ext:cls="Ext.grid.ColumnModel">ColumnModel</a>.</p> 
 <p>Editing is performed on
 the value of the <i>field</i> specified by the column's <tt><a
 href="output/Ext.grid.ColumnModel.html#Ext.grid.ColumnModel-dataIndex" ext:member="dataIndex"
 ext:cls="Ext.grid.ColumnModel">dataIndex</a></tt> in the backing <a href="output/Ext.data.Store.html"
 ext:cls="Ext.data.Store">Store</a> (so if you are using a <a
 href="output/Ext.grid.ColumnModel.html#Ext.grid.ColumnModel-setRenderer" ext:member="setRenderer"
 ext:cls="Ext.grid.ColumnModel">renderer</a> in order to display transformed data, this must be accounted for).</p>
 
 <p>If a value-to-description mapping is used to render a column, then a <a
 href="output/Ext.form.Field.html#Ext.form.Field-ComboBox" ext:member="ComboBox" ext:cls="Ext.form.Field">ComboBox</a>
 which uses the same <a href="output/Ext.form.Field.html#Ext.form.Field-valueField" ext:member="valueField"
 ext:cls="Ext.form.Field">value</a>-to-<a href="output/Ext.form.Field.html#Ext.form.Field-displayFieldField"
 ext:member="displayFieldField" ext:cls="Ext.form.Field">description</a> mapping would be an appropriate editor.</p> If
 there is a more complex mismatch between the visible data in the grid, and the editable data in the 
 <a
 href="output/Edt.data.Store.html" ext:cls="Edt.data.Store">Store</a>, then code to transform the data both before and
 after editing can be injected using the 
 <a
 href="output/Ext.grid.EditorGridPanel.html#Ext.grid.EditorGridPanel-beforeedit" ext:member="beforeedit"
 ext:cls="Ext.grid.EditorGridPanel">beforeedit</a> and 
 <a
 href="output/Ext.grid.EditorGridPanel.html#Ext.grid.EditorGridPanel-afteredit" ext:member="afteredit"
 ext:cls="Ext.grid.EditorGridPanel">afteredit</a> events.]]></description><name>grid.editorGridPanel</name><tag-class>org.brushingbits.jnap.ui.extjs3.grid.EditorGridPanel</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[A string component id or the numeric index of the component that should be initially activated within the container's
 layout on render. For example, activeItem: 'item-1' or activeItem: 0 (index 0 = the first item in the container's
 collection). activeItem only applies to layout styles that can display items one at a time (like
 Ext.layout.AccordionLayout, Ext.layout.CardLayout and Ext.layout.FitLayout). Related to
 Ext.layout.ContainerLayout.activeItem.]]></description><name>activeItem</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Whether the component can move the Dom node when rendering (defaults to true).]]></description><name>allowDomMove</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use an
 AnchorLayout (or subclass thereof). based layout manager, for example: Ext.form.FormPanel specifying layout: 'anchor' //
 or 'form', or 'absolute' See Ext.layout.AnchorLayout.anchor also.]]></description><name>anchor</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to animate the transition when the panel is collapsed, false to skip the animation (defaults to true if the Ext.Fx
 class is available, otherwise false).]]></description><name>animCollapse</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The id of the node, a DOM node or an existing Element corresponding to a DIV that is already present in the document
 that specifies some panel-specific structural markup. When applyTo is used, constituent parts of the panel can be
 specified by CSS class name within the main element, and the panel will automatically create those components from that
 markup. Any required components not specified in the markup will be autogenerated if necessary. The following class
 names are supported (baseCls will be replaced by baseCls): baseCls + '-header' baseCls + '-header-text' baseCls +
 '-bwrap' baseCls + '-tbar' baseCls + '-body' baseCls + '-bbar' baseCls + '-footer' Using this config, a call to render()
 is not required. If applyTo is specified, any value passed for renderTo will be ignored and the target element's parent
 node will automatically be used as the panel's container.]]></description><name>applyTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If true the container will automatically destroy any contained component that is removed from it, else destruction must
 be handled manually (defaults to true).]]></description><name>autoDestroy</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A tag name or DomHelper spec used to create the Element which will encapsulate this Component. You do not normally need
 to specify this. For the base classes Ext.Component, Ext.BoxComponent, and Ext.Container, this defaults to 'div'. The
 more complex Ext classes use a more complex DOM structure created by their own onRender methods. This is intended to
 allow the developer to create application-specific utility Components encapsulated by different DOM elements. Example
 usage: <pre><code>{
     xtype: 'box',
     autoEl: {
         tag: 'img',
         src: 'http://www.example.com/example.jpg'
     }
 },
 {
     xtype: 'box',
     autoEl: {
         tag: 'blockquote',
         html: 'autoEl is cool!'
     }
 }, {
     xtype: 'container',
     autoEl: 'ul',
     cls: 'ux-unordered-list',
     items: {
         xtype: 'box',
         autoEl: 'li',
   
      html: 'First list item'
     }
 }</pre></code>]]></description><name>autoEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically HTML encode and decode values pre and post edit (defaults to false)]]></description><name>autoEncode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The id of a column in this grid that should expand to fill unused space. This value specified here can not be 0. Note:
 If the Grid's view is configured with forceFit=true the autoExpandColumn is ignored. See Ext.grid.Column.width for
 additional details. See autoExpandMax and autoExpandMin also.]]></description><name>autoExpandColumn</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum width the autoExpandColumn can have (if enabled). Defaults to 1000.]]></description><name>autoExpandMax</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum width the autoExpandColumn can have (if enabled). Defaults to 50.]]></description><name>autoExpandMin</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to use height:'auto', false to use fixed height (defaults to false). Note: Setting autoHeight: true means that the
 browser will manage the panel's height based on its contents, and that Ext will not manage it at all. If the panel is
 within a layout that manages dimensions (fit, border, etc.) then setting autoHeight: true can cause issues with
 scrolling and will not generally work as expected since the panel will take on the height of its contents rather than
 the height required by the Ext layout.]]></description><name>autoHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A valid url spec according to the Updater Ext.Updater.update method. If autoLoad is not null, the panel will attempt to
 load its contents immediately upon render. The URL will become the default URL for this panel's body element, so it may
 be refreshed at any time.]]></description><name>autoLoad</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to use overflow:'auto' on the components layout element and show scroll bars automatically when necessary, false to
 clip any overflowing content (defaults to false).]]></description><name>autoScroll</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True if the component should check for hidden classes (e.g. 'x-hidden' or 'x-hide-display') and remove them on render
 (defaults to false).]]></description><name>autoShow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to use width:'auto', false to use fixed width (or allow it to be managed by its parent Container's layout manager.
 Defaults to false. Note: Although many components inherit this config option, not all will function as expected with a
 width of 'auto'. Setting autoWidth:true means that the browser will manage width based on the element's contents, and
 that Ext will not manage it at all. If the browser is managing the width, be aware that resizes performed by the browser
 in response to changes within the structure of the Component cannot be detected. Therefore changes to the width might
 result in elements needing to be synchronized with the new width. For example, where the target element is: <div
 id='grid-container' style='margin-left:25%;width:50%'></div> A Panel rendered into that target element must listen for
 browser window resize in order to relay its child items when the browser changes its width: var myPanel = new
 Ext.Panel({
     renderTo: 'grid-container',
     monitorResize: true, // relay on browser resize
     title: 'Panel',
    
 height: 400,
     autoWidth: true,
     layout: 'hbox',
     layoutConfig: {
         align: 'stretch'
     },
     defaults: {
         flex: 1
     },
     items: [{
         title: 'Box 1',
     }, {
         title: 'Box 2'
     }, {
         title:
 'Box 3'
     }],
 });]]></description><name>autoWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The base CSS class to apply to this panel's element (defaults to 'x-panel'). Another option available by default is to
 specify 'x-plain' which strips all styling except for required attributes for Ext layouts to function (e.g.
 overflow:hidden). See unstyled also.]]></description><name>baseCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to display an interior border on the body element of the panel, false to hide it (defaults to true). This only
 applies when border == true. If border == true and bodyBorder == false, the border will display as a 1px wide inset
 border, giving the entire body element an inset appearance.]]></description><name>bodyBorder</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A DomHelper element specification object may be specified for any Panel Element. By default, the Default element in the
 table below will be used for the html markup to create a child element with the commensurate Default class name (baseCls
 will be replaced by baseCls): 
 Panel      Default  Default             Custom      Additional       Additional
 Element  
 element  class               element     class            style
 ========   ==========================   =========  
 ==============   ===========
 header     div      baseCls+'-header'   headerCfg   headerCssClass   headerStyle
 bwrap     
 div      baseCls+'-bwrap'     bwrapCfg    bwrapCssClass    bwrapStyle
 + tbar     div      baseCls+'-tbar'       tbarCfg 
 tbarCssClass     tbarStyle
 + body     div      baseCls+'-body'       bodyCfg     bodyCssClass     bodyStyle
 + bbar    
 div      baseCls+'-bbar'       bbarCfg     bbarCssClass     bbarStyle
 + footer   div      baseCls+'-footer'   footerCfg 
 footerCssClass   footerStyle
  Configuring a Custom element may be used, for example, to force the body Element to use a
 different form of markup than is created by default. An example of this might be to create a child Panel containing a
 custom content, such as a header, or forcing centering of all Panel content by having the body be a <center> element:
 new Ext.Panel({
     title: 'Message Title',
     renderTo: Ext.getBody(),
     width: 200, height: 130,
     bodyCfg: {
    
 tag: 'center',
         cls: 'x-panel-body',  // Default class not applied if Custom element specified
         html:
 'Message'
     },
     footerCfg: {
         tag: 'h2',
         cls: 'x-panel-footer',        // same as the Default class
 
 html: 'footer html'
     },
     footerCssClass: 'custom-footer', // additional css class, see addClass
     footerStyle:  
 'background-color:red' // see bodyStyle
 }); The example above also explicitly creates a footer with custom markup and
 styling applied.]]></description><name>bodyCfg</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Additional css class selector to be applied to the body element in the format expected by Ext.Element.addClass (defaults
 to null). See bodyCfg.]]></description><name>bodyCssClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Custom CSS styles to be applied to the body element in the format expected by Ext.Element.applyStyles (defaults to
 null). See bodyCfg.]]></description><name>bodyStyle</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to display the borders of the panel's body element, false to hide them (defaults to true). By default, the border
 is a 2px wide inset border, but this can be further altered by setting bodyBorder to false.]]></description><name>border</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to [].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[When set to true (50 milliseconds) or a number of milliseconds, the layout assigned for this container will buffer the
 frequency it calculates and does a re-layout of components. This is useful for heavy containers or containers with a
 large quantity of sub-components for which frequent layout calls would be expensive. Defaults to 50.]]></description><name>bufferResize</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The alignment of any buttons added to this panel. Valid values are 'right', 'left' and 'center' (defaults to 'right').]]></description><name>buttonAlign</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A DomHelper element specification object specifying the element structure of this Panel's bwrap Element. See bodyCfg
 also.]]></description><name>bwrapCfg</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class used to to apply to the special clearing div rendered directly after each form field wrapper to provide
 field clearing (defaults to 'x-form-clear-left'). Note: this config is only used when this Component is rendered by a
 Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or specifying
 layout:'form') and either a fieldLabel is specified or isFormField=true is specified. See Ext.layout.FormLayout.fieldTpl
 also.]]></description><name>clearCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The number of clicks on a cell required to display the cell's editor (defaults to 2). Setting this option to 'auto'
 means that mousedown on the selected cell starts editing that cell.]]></description><name>clicksToEdit</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Panels themselves do not directly support being closed, but some Panel subclasses do (like Ext.Window) or a Panel Class
 within an Ext.TabPanel. Specify true to enable closing in such situations. Defaults to false.]]></description><name>closable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element (defaults to ''). This can be useful for
 adding customized styles to the component or any of its children using standard CSS rules.]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Shorthand for colModel.]]></description><name>cm</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to make sure the collapse/expand toggle button always renders first (to the left of) any other tools in the panel's
 title bar, false to render it last (defaults to true).]]></description><name>collapseFirst</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to render the panel collapsed, false to render it expanded (defaults to false).]]></description><name>collapsed</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS class to add to the panel's element after it has been collapsed (defaults to 'x-panel-collapsed').]]></description><name>collapsedCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to make the panel collapsible and have the expand/collapse toggle button automatically rendered into the header
 tool button area, false to keep the panel statically sized with no button (defaults to false).]]></description><name>collapsible</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to add css for column separation lines. Default is false.]]></description><name>columnLines</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's container. This can be useful for adding customized
 styles to the container or any of its children using standard CSS rules. See Ext.layout.ContainerLayout.extraCls also.
 Note: ctCls defaults to '' except for the following class which assigns a value by default: Box Layout :
 'x-box-layout-ct' To configure the above Class with an extra CSS class append to the default. For example, for BoxLayout
 (Hbox and Vbox): ctCls: 'x-box-layout-ct custom-class']]></description><name>ctCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The DD group this GridPanel belongs to. Defaults to 'GridDD' if not specified.]]></description><name>ddGroup</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Configures the text in the drag proxy. Defaults to: ddText : '{0} selected row{1}' {0} is replaced with the number of
 selected rows.]]></description><name>ddText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default xtype of child Components to create in this Container when a child item is specified as a raw configuration
 object, rather than as an instantiated Component. Defaults to 'panel', except Ext.menu.Menu which defaults to
 'menuitem', and Ext.Toolbar and Ext.ButtonGroup which default to 'button'.]]></description><name>defaultType</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[This option is a means of applying default settings to all added items whether added through the items config or via the
 add or insert methods. If an added item is a config object, and not an instantiated Component, then the default
 properties are unconditionally applied. If the added item is an instantiated Component, then the default properties are
 applied conditionally so as not to override existing properties in the item. If the defaults option is specified as a
 function, then the function will be called using this Container as the scope (this reference) and passing the added item
 as the first parameter. Any resulting object from that call is then applied to the item as default properties. For
 example, to automatically apply padding to the body of each of a set of contained Ext.Panel items, you could pass:
 defaults: {bodyStyle:'padding:15px'}. Usage: defaults: {               // defaults are applied to items, not the
 container
     autoScroll:true
 },
 items: [
     {
         xtype: 'panel',   // defaults do not have precedence over
       
 id: 'panel1',     // options in config objects, so the defaults
         autoScroll: false // will not be applied here,
 panel1 will be autoScroll:false
     },
     new Ext.Panel({       // defaults do have precedence over options
         id:
 'panel2',     // options in components, so the defaults
         autoScroll: false // will be applied here, panel2 will
 be autoScroll:true.
     })
 ]]]></description><name>defaults</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to true to enable deferred row rendering. This allows the GridPanel to be initially rendered empty, with the
 expensive update of the row structure deferred so that layouts with GridPanels appear more quickly.]]></description><name>deferRowRender</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to disable selections in the grid. Defaults to false. Ignored if a SelectionModel is specified.]]></description><name>disableSelection</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this panel disabled (default is false). An important note when using the disabled config on panels is that IE
 will often fail to initialize the disabled mask element correectly if the panel's layout has not yet completed by the
 time the Panel is disabled during the render process. If you experience this issue, you may need to instead use the
 afterlayout event to initialize the disabled state: new Ext.Panel({
     ...
     listeners: {
         'afterlayout': {
   
 fn: function(p){
                 p.disable();
             },
             single: true // important, as many layouts can
 occur
         }
     }
 });]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class added to the component when it is disabled (defaults to 'x-item-disabled').]]></description><name>disabledClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to enable dragging of this Panel (defaults to false). For custom drag/drop implementations, an Ext.Panel.DD config
 could also be passed in this config instead of true. Ext.Panel.DD is an internal, undocumented class which moves a proxy
 Element around in place of the Panel's element, but provides no other behaviour during dragging or on drop. It is a
 subclass of Ext.dd.DragSource, so behaviour may be added by implementing the interface methods of Ext.dd.DragDrop e.g.:
 new Ext.Panel({
     title: 'Drag me',
     x: 100,
     y: 100,
     renderTo: Ext.getBody(),
     floating: true,
    
 frame: true,
     width: 400,
     height: 200,
     draggable: {
 //      Config option of Ext.Panel.DD class.
 //      It's
 a floating Panel, so do not show a placeholder proxy in the original position.
         insertProxy: false,
 
 //     
 Called for each mousemove event while dragging the DD object.
         onDrag : function(e){
 //          Record the x,y
 position of the drag proxy so that we can
 //          position the Panel at end of drag.
             var pel =
 this.proxy.getEl();
             this.x = pel.getLeft(true);
             this.y = pel.getTop(true);
 
 //          Keep the
 Shadow aligned if there is one.
             var s = this.panel.getEl().shadow;
             if (s) {
                
 s.realign(this.x, this.y, pel.getWidth(), pel.getHeight());
             }
         },
 
 //      Called on the mouseup
 event.
         endDrag : function(e){
             this.panel.setPosition(this.x, this.y);
         }
     }
 }).show();]]></description><name>draggable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A comma-delimited list of panel elements to initialize when the panel is rendered. Normally, this list will be generated
 automatically based on the items added to the panel at config time, but sometimes it might be useful to make sure a
 structural element is rendered even if not specified at config time (for example, you may want to add a button or
 toolbar dynamically after the panel has been rendered). Adding those elements to this list will allocate the required
 placeholders in the panel when it is rendered. Valid values are header tbar (top bar) body bbar (bottom bar) footer
 Defaults to 'body'.]]></description><name>elements</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to true to enable hiding of columns with the header menu.]]></description><name>enableColumnHide</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to true to enable drag and drop reorder of columns. false to turn off column reordering via drag drop.]]></description><name>enableColumnMove</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[false to turn off column resizing for the whole grid. Defaults to true.]]></description><name>enableColumnResize</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Enables dragging of the selected rows of the GridPanel. Defaults to false. Setting this to true causes this GridPanel's
 GridView to create an instance of Ext.grid.GridDragZone. Note: this is available only after the Grid has been rendered
 as the GridView's dragZone property. A cooperating DropZone must be created who's implementations of onNodeEnter,
 onNodeOver, onNodeOut and onNodeDrop are able to process the data which is provided.]]></description><name>enableDragDrop</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to true to enable the drop down button for menu in the headers.]]></description><name>enableHdMenu</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A Toolbar object, a Toolbar config, or an array of Buttons/Button configs, describing a Toolbar to be rendered into this
 Panel's footer element. After render, the fbar property will be an Toolbar instance. If buttons are specified, they will
 supersede the fbar configuration property. The Panel's buttonAlign configuration affects the layout of these items, for
 example: var w = new Ext.Window({
     height: 250,
     width: 500,
     bbar: new Ext.Toolbar({
         items: [{
        
 text: 'bbar Left'
         },'->',{
             text: 'bbar Right'
         }]
     }),
     buttonAlign: 'left', //
 anything but 'center' or 'right' and you can use '-', and '->'
                                   // to control the
 alignment of fbar items
     fbar: [{
         text: 'fbar Left'
     },'->',{
         text: 'fbar Right'
     }]
 }).show();
 Note: Although a Toolbar may contain Field components, these will not be updated by a load of an ancestor FormPanel. A
 Panel's toolbars are not part of the standard Container->Component hierarchy, and so are not scanned to collect form
 items. However, the values will be submitted because form submission parameters are collected from the DOM tree.]]></description><name>fbar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The label text to display next to this Component (defaults to ''). Note: this config is only used when this Component is
 rendered by a Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or
 specifying layout:'form'). Also see hideLabel and Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
    
 height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name'
    
 }]
 });]]></description><name>fieldLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use a
 BoxLayout. Each child Component with a flex property will be flexed either vertically (by a VBoxLayout) or horizontally
 (by an HBoxLayout) according to the item's relative flex value compared to the sum of all Components with flex value
 specified. Any child items that have either a flex = 0 or flex = undefined will not be 'flexed' (the initial size will
 not be changed).]]></description><name>flex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[This property is used to configure the underlying Ext.Layer. Acceptable values for this configuration property are:
 false : Default. Display the panel inline where it is rendered. true : Float the panel (absolute position it with
 automatic shimming and shadow). Setting floating to true will create an Ext.Layer for this panel and display the panel
 at negative offsets so that it is hidden. Since the panel will be absolute positioned, the position must be set
 explicitly after render (e.g., myPanel.setPosition(100,100);). Note: when floating a panel you should always assign a
 fixed width, otherwise it will be auto width and will expand to fill to the right edge of the viewport. object : The
 specified object will be used as the configuration object for the Ext.Layer that will be created.]]></description><name>floating</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to create the footer element explicitly, false to skip creating it. The footer will be created automatically if
 buttons or a fbar have been configured. See bodyCfg for an example.]]></description><name>footer</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A DomHelper element specification object specifying the element structure of this Panel's footer Element. See bodyCfg
 also.]]></description><name>footerCfg</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If true the container will force a layout initially even if hidden or collapsed. This option is useful for forcing forms
 to render in collapsed or hidden containers. (defaults to false).]]></description><name>forceLayout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to force validation even if the value is unmodified (defaults to false)]]></description><name>forceValidation</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[false by default to render with plain 1px square borders. true to render with 9 elements, complete with custom rounded
 corners (also see Ext.Element.boxWrap). The template generated for each condition is depicted below: // frame =
 false
 <div id="developer-specified-id-goes-here" class="x-panel">
 
     <div class="x-panel-header"><span
 class="x-panel-header-text">Title: (frame:false)</span></div>
 
     <div class="x-panel-bwrap">
         <div
 class="x-panel-body"><p>html value goes here</p></div>
     </div>
 </div>
 
 // frame = true (create 9 elements)
 <div
 id="developer-specified-id-goes-here" class="x-panel">
     <div class="x-panel-tl"><div class="x-panel-tr"><div
 class="x-panel-tc">
         <div class="x-panel-header"><span class="x-panel-header-text">Title:
 (frame:true)</span></div>
     </div></div></div>
 
     <div class="x-panel-bwrap">
         <div class="x-panel-ml"><div
 class="x-panel-mr"><div class="x-panel-mc">
             <div class="x-panel-body"><p>html value goes here</p></div>
     
 </div></div></div>
 
         <div class="x-panel-bl"><div class="x-panel-br"><div class="x-panel-bc"/>
        
 </div></div></div>
 </div>]]></description><name>frame</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to create the Panel's header element explicitly, false to skip creating it. If a title is set the header will be
 created automatically, otherwise it will not. If a title is set but header is explicitly set to false, the header will
 not be rendered.]]></description><name>header</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to display the panel title in the header, false to hide it (defaults to true).]]></description><name>headerAsText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A DomHelper element specification object specifying the element structure of this Panel's header Element. See bodyCfg
 also.]]></description><name>headerCfg</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component hidden (default is false). If true, the hide method will be called internally.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide the borders of each contained component, false to defer to the component's existing border settings
 (defaults to false).]]></description><name>hideBorders</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to hide the expand/collapse toggle button when collapsible == true, false to display it (defaults to false).]]></description><name>hideCollapseTool</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide the grid's header. Defaults to false.]]></description><name>hideHeaders</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to completely hide the label element (label and separator). Defaults to false. By default, even if you do not
 specify a fieldLabel the space will still be reserved so that the field will line up with other fields that do have
 labels. Setting this to true will cause the field to not reserve that space. Note: see the note for clearCls. Example
 use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield'
        
 hideLabel: true
     }]
 });]]></description><name>hideLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[How this component should be hidden. Supported values are 'visibility' (css visibility), 'offsets' (negative offset
 position) and 'display' (css display). Note: the default of 'display' is generally preferred since items are
 automatically laid out when they are first shown (no sizing is done while hidden).]]></description><name>hideMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide and show the component's container when hide/show is called on the component, false to hide and show the
 component itself (defaults to false). For example, this can be used as a shortcut for a hide button on a window by
 setting hide:true on the button when adding it to its parent container.]]></description><name>hideParent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class selector that specifies a background image to be used as the header icon (defaults to ''). An example of
 specifying a custom icon class would be something like: // specify the property in the config for the class:
      ...
   
 iconCls: 'my-icon'
 
 // css class that specifies background image to be used as the icon image:
 .my-icon {
 background-image: url(../images/my-icon.gif) 0 6px no-repeat !important; }]]></description><name>iconCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id of this component (defaults to an auto-assigned id). You should assign an id if you need to be able to
 access the component later and you do not have an object reference available (e.g., using Ext.getCmp). Note that this id
 will also be used as the element id for the containing HTML element that is rendered to the page for this component.
 This allows you to write id-based CSS rules to style the specific instance of this component uniquely, and also to
 select sub-elements using this component's id as the parent. Note: to avoid complications imposed by a unique id also
 see itemId and ref. Note: to access the container of an item see ownerCt.]]></description><name>id</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use the
 FormLayout layout manager (e.g. Ext.form.FormPanel or specifying layout:'form'). An additional CSS class to apply to the
 div wrapping the form item element of this field. If supplied, itemCls at the field level will override the default
 itemCls supplied at the container level. The value specified for itemCls will be added to the default class
 ('x-form-item'). Since it is applied to the item wrapper (see Ext.layout.FormLayout.fieldTpl), it allows you to write
 standard CSS rules that can apply to the field, the label (if specified), or any other element within the markup for the
 field. Note: see the note for fieldLabel. Example use: // Apply a style to the field's label:
 <style>
     .required
 .x-form-item-label {font-weight:bold;color:red;}
 </style>
 
 new Ext.FormPanel({
     height: 100,
     renderTo:
 Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         itemCls: 'required' //this
 label will be styled
     },{
         xtype: 'textfield',
         fieldLabel: 'Favorite Color'
     }]
 });]]></description><name>itemCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An itemId can be used as an alternative way to get a reference to a component when no object reference is available.
 Instead of using an id with Ext.getCmp, use itemId with Ext.Container.getComponent which will retrieve itemId's or id's.
 Since itemId's are an index to the container's internal MixedCollection, the itemId is scoped locally to the container
 -- avoiding potential conflicts with Ext.ComponentMgr which requires a unique id. var c = new Ext.Panel({ //
     height:
 300,
     renderTo: document.body,
     layout: 'auto',
     items: [
         {
             itemId: 'p1',
            
 title: 'Panel 1',
             height: 150
         },
         {
             itemId: 'p2',
             title: 'Panel 2',
  
 height: 150
         }
     ]
 })
 p1 = c.getComponent('p1'); // not the same as Ext.getCmp()
 p2 =
 p1.ownerCt.getComponent('p2'); // reference via a sibling Also see id and ref. Note: to access the container of an item
 see ownerCt.]]></description><name>itemId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A Ext.KeyMap config object (in the format expected by Ext.KeyMap.addBinding used to assign custom key handling to this
 panel (defaults to null).]]></description><name>keys</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The separator to display after the text of each fieldLabel. This property may be configured at various levels. The order
 of precedence is: field / component level container level layout level (defaults to colon ':') To display no separator
 for this field's label specify empty string ''. Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 layoutConfig: {
         labelSeparator: '~'   // layout config has lowest priority (defaults to ':')
     },
    
 labelSeparator: '>>',     // config at container level
     items: [{
         xtype: 'textfield',
         fieldLabel:
 'Field 1',
         labelSeparator: '...' // field/component level config supersedes others
     },{
         xtype:
 'textfield',
         fieldLabel: 'Field 2' // labelSeparator will be '='
     }]
 });]]></description><name>labelSeparator</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS style specification string to apply directly to this field's label. Defaults to the container's labelStyle value
 if set (e.g., Ext.layout.FormLayout.labelStyle , or ''). Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         labelStyle: 'font-weight:bold;'
     }]
 });]]></description><name>labelStyle</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[*Important: In order for child items to be correctly sized and positioned, typically a layout manager must be specified
 through the layout configuration option. The sizing and positioning of child items is the responsibility of the
 Container's layout manager which creates and manages the type of layout you have in mind. For example:
 <pre><code>
 new Ext.Window({
 
 width:300, height: 300,
     layout: 'fit', // explicitly set layout manager: override the default (layout:'auto')
    
 items: [{
         title: 'Panel inside a Window'
     }]
 }).show();</pre></code>
 If the layout configuration is not explicitly
 specified for a general purpose container (e.g. Container or Panel) the default layout manager will be used which does
 nothing but render child components sequentially into the Container (no sizing or positioning will be performed in this
 situation). Some container classes implicitly specify a default layout (e.g. FormPanel specifies layout:'form'). Other
 specific purpose classes internally specify/manage their internal layout (e.g. GridPanel, TabPanel, TreePanel, Toolbar,
 Menu, etc.). layout may be specified as either as an Object or as a String: Specify as an Object Example usage: layout:
 {
     type: 'vbox',
     padding: '5',
     align: 'left'
 } type The layout type to be used for this container. If not
 specified, a default Ext.layout.ContainerLayout will be created and used. Valid layout type values are: absolute
 accordion anchor auto Default border card column fit form hbox menu table toolbar vbox Layout specific configuration
 properties Additional layout specific configuration properties may also be specified. For complete details regarding the
 valid config options for each layout type, see the layout class corresponding to the type specified. Specify as a String
 Example usage: layout: 'vbox',
 layoutConfig: {
     padding: '5',
     align: 'left'
 } layout The layout type to be used
 for this container (see list of valid layout type values above). layoutConfig Additional layout specific configuration
 properties. For complete details regarding the valid config options for each layout type, see the layout class
 corresponding to the layout specified.]]></description><name>layout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An Ext.LoadMask config or true to mask the grid while loading. Defaults to false.]]></description><name>loadMask</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout or one of the two BoxLayout subclasses. An object containing margins to apply to this BoxComponent in the
 format: {
     top: (top margin),
     right: (right margin),
     bottom: (bottom margin),
     left: (left margin)
 } May
 also be a string containing space-separated, numeric margin values. The order of the sides associated with each value
 matches the way CSS processes margin values: If there is only one value, it applies to all sides. If there are two
 values, the top and bottom borders are set to the first value and the right and left are set to the second. If there are
 three values, the top is set to the first value, the left and right are set to the second, and the bottom is set to the
 third. If there are four values, they apply to the top, right, bottom, and left, respectively. Defaults to: {top:0,
 right:0, bottom:0, left:0}]]></description><name>margins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to mask the panel when it is disabled, false to not mask it (defaults to true). Either way, the panel will always
 tell its contained elements to disable themselves when it is disabled, but masking the panel can provide an additional
 visual cue that the panel is disabled.]]></description><name>maskDisabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Sets the maximum height of the grid - ignored if autoHeight is not on.]]></description><name>maxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Minimum width in pixels of all buttons in this panel (defaults to 75)]]></description><name>minButtonWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum width a column can be resized to. Defaults to 25.]]></description><name>minColumnWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically monitor window resize events to handle anything that is sensitive to the current size of the
 viewport. This value is typically managed by the chosen layout and should not need to be set manually.]]></description><name>monitorResize</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element when the mouse moves over the Element, and
 removed when the mouse moves out. (defaults to ''). This can be useful for adding customized 'active' or 'hover' styles
 to the component or any of its children using standard CSS rules.]]></description><name>overCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A shortcut for setting a padding style on the body element. The value can either be a number to be applied to all sides,
 or a normal css string describing padding. Defaults to undefined.]]></description><name>padding</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level x coordinate for this component if contained within a positioning container.]]></description><name>pageX</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level y coordinate for this component if contained within a positioning container.]]></description><name>pageY</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to false. When set to true, an extra css class 'x-panel-normal' will be added to the panel's element,
 effectively applying css styles suggested by the W3C (see http://www.w3.org/TR/CSS21/sample.html) to the Panel's body
 element (not the header, footer, etc.).]]></description><name>preventBodyReset</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered ptype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a Plugin is being specified not as a fully
 instantiated Component, but as a Component config object. The ptype will be looked up at render time up to determine
 what type of Plugin to create. If you create your own Plugins, you may register them using
 Ext.ComponentMgr.registerPlugin in order to be able to take advantage of lazy instantiation and rendering.]]></description><name>ptype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A path specification, relative to the Component's ownerCt specifying into which ancestor Container to place a named
 reference to this Component. The ancestor axis can be traversed by using '/' characters in the path. For example, to put
 a reference to a Toolbar Button into the Panel which owns the Toolbar: var myGrid = new Ext.grid.EditorGridPanel({
    
 title: 'My EditorGridPanel',
     store: myStore,
     colModel: myColModel,
     tbar: [{
         text: 'Save',
        
 handler: saveChanges,
         disabled: true,
         ref: '../saveButton'
     }],
     listeners: {
         afteredit:
 function() {
 //          The button reference is in the GridPanel
             myGrid.saveButton.enable();
         }
    
 }
 }); In the code above, if the ref had been 'saveButton' the reference would have been placed into the Toolbar. Each
 '/' in the ref moves up one level from the Component's ownerCt. Also see the added and removed events.]]></description><name>ref</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout layout manager (e.g. specifying layout:'border'). See Ext.layout.BorderLayout also.]]></description><name>region</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The event to listen to for resizing in layouts. Defaults to 'bodyresize'.]]></description><name>resizeEvent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Any subclass of AbstractSelectionModel that will provide the selection model for the grid (defaults to
 Ext.grid.CellSelectionModel if not specified).]]></description><name>selModel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true (or a valid Ext.Shadow Ext.Shadow.mode value) to display a shadow behind the panel, false to display no shadow
 (defaults to 'sides'). Note that this option only applies when floating = true.]]></description><name>shadow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The number of pixels to offset the shadow if displayed (defaults to 4). Note that this option only applies when floating
 = true.]]></description><name>shadowOffset</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[false to disable the iframe shim in browsers which need one (defaults to true). Note that this option only applies when
 floating = true.]]></description><name>shim</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Shorthand for selModel.]]></description><name>sm</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should trigger this component to save its state. Defaults to: stateEvents:
 ['columnmove', 'columnresize', 'sortchange', 'groupchange'] These can be any types of events supported by this
 component, including browser or custom events (e.g., ['click', 'customerchange']). See Ext.Component.stateful for an
 explanation of saving and restoring Component state.]]></description><name>stateEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id for this component to use for state management purposes (defaults to the component id if one was set,
 otherwise null if the component is using a generated id). See stateful for an explanation of saving and restoring
 Component state.]]></description><name>stateId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A flag which causes the Component to attempt to restore the state of internal properties from a saved state on startup.
 The component must have either a stateId or id assigned for state to be managed. Auto-generated ids are not guaranteed
 to be stable across page loads and cannot be relied upon to save and restore the same state for a component. For state
 saving to work, the state manager's provider must have been set to an implementation of Ext.state.Provider which
 overrides the set and get methods to save and recall name/value pairs. A built-in implementation,
 Ext.state.CookieProvider is available. To set the state provider for the current page: Ext.state.Manager.setProvider(new
 Ext.state.CookieProvider({
     expires: new Date(new Date().getTime()+(1000*60*60*24*7)), //7 days from now
 })); A
 stateful Component attempts to save state when one of the events listed in the stateEvents configuration fires. To save
 state, a stateful Component first serializes its state by calling getState. By default, this function does nothing. The
 developer must provide an implementation which returns an object hash which represents the Component's restorable state.
 The value yielded by getState is passed to Ext.state.Manager.set which uses the configured Ext.state.Provider to save
 the object keyed by the Component's stateId, or, if that is not specified, its id. During construction, a stateful
 Component attempts to restore its state by calling Ext.state.Manager.get passing the stateId, or, if that is not
 specified, the id. The resulting object is passed to applyState. The default implementation of applyState simply copies
 properties into the object, but a developer may override this to support more behaviour. You can perform extra
 processing on state save and restore by attaching handlers to the beforestaterestore, staterestore, beforestatesave and
 statesave events.]]></description><name>stateful</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to stripe the rows. Default is false. This causes the CSS class x-grid3-row-alt to be added to alternate rows of
 the grid. A default CSS rule is provided which sets a background colour, but you can override this with a rule which
 either overrides the background-color style using the '!important' modifier, or which uses a CSS selector of higher
 specificity.]]></description><name>stripeRows</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
     title: 'Some Title',
     renderTo: Ext.getBody(),
     width: 400, height:
 300,
     layout: 'form',
     items: [{
         xtype: 'textarea',
         style: {
             width: '95%',
            
 marginBottom: '10px'
         }
     },
         new Ext.Button({
             text: 'Send',
             minWidth: '100',
   
          style: {
                 marginBottom: '10px'
             }
         })
     ]
 });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is a child item of a TabPanel. A string to be used as innerHTML
 (html tags are accepted) to show in a tooltip when mousing over the associated tab selector element.
 Ext.QuickTips.init() must be called in order for the tips to render.]]></description><name>tabTip</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The title text to be used as innerHTML (html tags are accepted) to display in the panel header (defaults to ''). When a
 title is specified the header element will automatically be created and displayed unless header is explicitly set to
 false. If you do not want to specify a title at config time, but you may want one later, you must either specify a
 non-empty title (a blank space ' ' will do) or header:true so that the container element will get created.]]></description><name>title</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to allow expanding and collapsing the panel (when collapsible = true) by clicking anywhere in the header bar,
 false) to allow it only by clicking to tool button (defaults to false)). If this panel is a child item of a border
 layout also see the BorderLayout.Region floatable config option.]]></description><name>titleCollapse</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A Template used to create tools in the header Element. Defaults to: new Ext.Template('<div class="x-tool
 x-tool-{id}">&#160;</div>') This may may be overridden to provide a custom DOM structure for tools based upon a more
 complex XTemplate. The template's data is a single tool configuration object (Not the entire Array) as specified in
 tools. In the following example an <a> tag is used to provide a visual indication when hovering over the tool: var win =
 new Ext.Window({
     tools: [{
         id: 'download',
         href: '/MyPdfDoc.pdf'
     }],
     toolTemplate: new
 Ext.XTemplate(
         '<tpl if="id==\'download\'">',
             '<a class="x-tool x-tool-pdf" href="{href}"></a>',
    
 '</tpl>',
         '<tpl if="id!=\'download\'">',
             '<div class="x-tool x-tool-{id}">&#160;</div>',
        
 '</tpl>'
     ),
     width:500,
     height:300,
     closeAction:'hide'
 }); Note that the CSS class 'x-tool-pdf' should
 have an associated style rule which provides an appropriate background image, something like: a.x-tool-pdf
 {background-image: url(../shared/extjs/images/pdf.gif)!important;}]]></description><name>toolTemplate</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of tool button configs to be added to the header tool area. When rendered, each tool is stored as an Element
 referenced by a public property called tools.<tool-type> Each tool config may contain the following properties: id :
 String Required. The type of tool to create. By default, this assigns a CSS class of the form x-tool-<tool-type> to the
 resulting tool Element. Ext provides CSS rules, and an icon sprite containing images for the tool types listed below.
 The developer may implement custom tools by supplying alternate CSS rules and background images: toggle (Created by
 default when collapsible is true) close minimize maximize restore gear pin unpin right left up down refresh minus plus
 help search save print handler : Function Required. The function to call when clicked. Arguments passed are: event :
 Ext.EventObject The click event. toolEl : Ext.Element The tool Element. panel : Ext.Panel The host Panel tc : Object The
 tool configuration object stopEvent : Boolean Defaults to true. Specify as false to allow click event to propagate.
 scope : Object The scope in which to call the handler. qtip : String/Object A tip string, or a config argument to
 Ext.QuickTip.register hidden : Boolean True to initially render hidden. on : Object A listener config object specifiying
 event listeners in the format of an argument to addListener Note that, apart from the toggle tool which is provided when
 a panel is collapsible, these tools only provide the visual button. Any required functionality must be provided by
 adding handlers that implement the necessary behavior. Example usage: tools:[{
     id:'refresh',
     qtip: 'Refresh form
 Data',
     // hidden:true,
     handler: function(event, toolEl, panel){
         // refresh logic
     }
 },
 {
    
 id:'help',
     qtip: 'Get Help',
     handler: function(event, toolEl, panel){
         // whatever
     }
 }] For the
 custom id of 'help' define two relevant css classes with a link to a 15x15 image: .x-tool-help {background-image:
 url(images/help.png);}
 .x-tool-help-over {background-image: url(images/help_over.png);}
 // if using an image
 sprite:
 .x-tool-help {background-image: url(images/help.png) no-repeat 0 0;}
 .x-tool-help-over
 {background-position:-15px 0;}]]></description><name>tools</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to highlight rows when the mouse is over. Default is true for GridPanel, but false for EditorGridPanel.]]></description><name>trackMouseOver</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Overrides the baseCls setting to baseCls = 'x-plain' which renders the panel unstyled except for required attributes for
 Ext layouts to function (e.g. overflow:hidden).]]></description><name>unstyled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.grid.GridView used by the grid. This can be set before a call to render().]]></description><name>view</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A config object that will be applied to the grid's UI view. Any of the config options available for Ext.grid.GridView
 can be specified here. This option is ignored if view is specified.]]></description><name>viewConfig</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local x (left) coordinate for this component if contained within a positioning container.]]></description><name>x</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered xtype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a child item of a Container is being specified not
 as a fully instantiated Component, but as a Component config object. The xtype will be looked up at render time up to
 determine what type of child Component to create. The predefined xtypes are listed here. If you subclass Components to
 create your own Components, you may register them using Ext.ComponentMgr.registerType in order to be able to take
 advantage of lazy instantiation and rendering.]]></description><name>xtype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local y (top) coordinate for this component if contained within a positioning container.]]></description><name>y</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 Adds the ability for single level grouping to the grid. A 
 <a href="output/Ext.data.GroupingStore.html"
 ext:cls="Ext.data.GroupingStore">GroupingStore</a> must be used to enable grouping. Some grouping characteristics may
 also be configured at the 
 <a href="output/Ext.grid.Column.html" ext:cls="Ext.grid.Column">Column level</a>
 <div
 class="mdetail-params">
  <ul> 
   <li><code><a href="output/Ext.grid.Column.html#Ext.grid.Column-emptyGroupText"
 ext:member="emptyGroupText" ext:cls="Ext.grid.Column">emptyGroupText</a></code></li> 
   <li><code><a
 href="output/Ext.grid.Column.html#Ext.grid.Column-groupable" ext:member="groupable"
 ext:cls="Ext.grid.Column">groupable</a></code></li> 
   <li><code><a
 href="output/Ext.grid.Column.html#Ext.grid.Column-groupName" ext:member="groupName"
 ext:cls="Ext.grid.Column">groupName</a></code></li> 
   <li><code><a
 href="output/Ext.grid.Column.html#Ext.grid.Column-groupRender" ext:member="groupRender"
 ext:cls="Ext.grid.Column">groupRender</a></code></li> 
  </ul>
 </div> 
 <p>Sample usage:</p> 
 <pre><code><b>var</b> grid =
 <b>new</b> Ext.grid.GridPanel({
     <i>// A groupingStore is required <b>for</b> a GroupingView</i>
     store:
 <b>new</b> <a href="output/Ext.data.GroupingStore.html" ext:cls="Ext.data.GroupingStore">Ext.data.GroupingStore</a>({
   
 autoDestroy: true,
         reader: reader,
         data: xg.dummyData,
         sortInfo: {field: <em>'company'</em>,
 direction: <em>'ASC'</em>},
         <a href="output/Ext.data.GroupingStore.html#Ext.data.GroupingStore-groupOnSort"
 ext:member="groupOnSort" ext:cls="Ext.data.GroupingStore">groupOnSort</a>: true,
         <a
 href="output/Ext.data.GroupingStore.html#Ext.data.GroupingStore-remoteGroup" ext:member="remoteGroup"
 ext:cls="Ext.data.GroupingStore">remoteGroup</a>: true,
         <a
 href="output/Ext.data.GroupingStore.html#Ext.data.GroupingStore-groupField" ext:member="groupField"
 ext:cls="Ext.data.GroupingStore">groupField</a>: <em>'industry'</em>
     }),
     colModel: <b>new</b> <a
 href="output/Ext.grid.ColumnModel.html" ext:cls="Ext.grid.ColumnModel">Ext.grid.ColumnModel</a>({
         columns:[
     
 {id:<em>'company'</em>,header: <em>'Company'</em>, width: 60, dataIndex: <em>'company'</em>},
             <i>// <a
 href="output/Ext.grid.Column.html#Ext.grid.Column-groupable" ext:member="groupable"
 ext:cls="Ext.grid.Column">groupable</a>, <a href="output/Ext.grid.Column.html#Ext.grid.Column-groupName"
 ext:member="groupName" ext:cls="Ext.grid.Column">groupName</a>, <a
 href="output/Ext.grid.Column.html#Ext.grid.Column-groupRender" ext:member="groupRender"
 ext:cls="Ext.grid.Column">groupRender</a> are also configurable at column level</i>
             {header:
 <em>'Price'</em>, renderer: Ext.util.Format.usMoney, dataIndex: <em>'price'</em>, <a
 href="output/Ext.grid.Column.html#Ext.grid.Column-groupable" ext:member="groupable"
 ext:cls="Ext.grid.Column">groupable</a>: false},
             {header: <em>'Change'</em>, dataIndex: <em>'change'</em>,
 renderer: Ext.util.Format.usMoney},
             {header: <em>'Industry'</em>, dataIndex: <em>'industry'</em>},
          
 {header: <em>'Last Updated'</em>, renderer: Ext.util.Format.dateRenderer(<em>'m/d/Y'</em>), dataIndex:
 <em>'lastChange'</em>}
         ],
         defaults: {
             sortable: true,
             menuDisabled: false,
      
 width: 20
         }
     }),
 
     view: <b>new</b> Ext.grid.GroupingView({
         <a
 href="output/Ext.grid.GridView.html#Ext.grid.GridView-forceFit" ext:member="forceFit"
 ext:cls="Ext.grid.GridView">forceFit</a>: true,
         <i>// custom grouping text template to display the number of
 items per group</i>
         <a href="output/Ext.grid.GroupingView.html#Ext.grid.GroupingView-groupTextTpl"
 ext:member="groupTextTpl" ext:cls="Ext.grid.GroupingView">groupTextTpl</a>: <em>'{text} ({[values.rs.length]}
 {[values.rs.length &gt; 1 ? <em>&quot;Items&quot;</em> : <em>&quot;Item&quot;</em>]})'</em>
     }),
 
     frame:true,
    
 width: 700,
     height: 450,
     collapsible: true,
     animCollapse: false,
     title: <em>'Grouping Example'</em>,
    
 iconCls: <em>'icon-grid'</em>,
     renderTo: document.body
 });</code></pre>]]></description><name>grid.groupingView</name><tag-class>org.brushingbits.jnap.ui.extjs3.grid.GroupingView</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[Defaults to false. Specify true to have the column widths re-proportioned when the grid is initially rendered. The
 initially configured width of each column will be adjusted to fit the grid width and prevent horizontal scrolling. If
 columns are later resized (manually or programmatically), the other columns in the grid will not be resized to fit the
 grid width. See forceFit also.]]></description><name>autoFill</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to cancel any editing when the group header is toggled. Defaults to true.]]></description><name>cancelEditOnToggle</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The selector used to find cells internally (defaults to 'td.x-grid3-cell')]]></description><name>cellSelector</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The number of levels to search for cells in event delegation (defaults to 4)]]></description><name>cellSelectorDepth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The text displayed in the 'Columns' menu item (defaults to 'Columns')]]></description><name>columnsText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to defer emptyText being applied until the store's first load (defaults to true).]]></description><name>deferEmptyText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The text to display when there is an empty group value (defaults to '(None)'). May also be specified per column, see
 Ext.grid.Column.emptyGroupText.]]></description><name>emptyGroupText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Default text (html tags are accepted) to display in the grid body when no rows are available (defaults to ''). This
 value will be used to update the mainBody: this.mainBody.update('<div class="x-grid-empty">' + this.emptyText +
 '</div>');]]></description><name>emptyText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[false to disable grouping functionality (defaults to true)]]></description><name>enableGrouping</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to enable the grouping control in the column menu (defaults to true)]]></description><name>enableGroupingMenu</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to allow the user to turn off grouping (defaults to true)]]></description><name>enableNoGroups</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to add a second TR element per row that can be used to provide a row body that spans beneath the data row. Use the
 getRowClass method's rowParams config to customize the row body.]]></description><name>enableRowBody</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to false. Specify true to have the column widths re-proportioned at all times. The initially configured width
 of each column will be adjusted to fit the grid width and prevent horizontal scrolling. If columns are later resized
 (manually or programmatically), the other columns in the grid will be resized to fit the grid width. Columns which are
 configured with fixed: true are omitted from being resized. See autoFill.]]></description><name>forceFit</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Text displayed in the grid header menu for grouping by a column (defaults to 'Group By This Field').]]></description><name>groupByText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Indicates how to construct the group identifier. 'value' constructs the id using raw value, 'display' constructs the id
 using the rendered value. Defaults to 'value'.]]></description><name>groupMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[This property must be configured in the Ext.grid.Column for each column.]]></description><name>groupRenderer</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The template used to render the group header (defaults to '{text}'). This is used to format an object which contains the
 following properties: group : String The rendered value of the group field. By default this is the unchanged value of
 the group field. If a groupRenderer is specified, it is the result of a call to that function. gvalue : Object The raw
 value of the group field. text : String The configured header (as described in showGroupName) if showGroupName is true)
 plus the rendered group field value. groupId : String A unique, generated ID which is applied to the View Element which
 contains the group. startRow : Number The row index of the Record which caused group change. rs : Array Contains a
 single element: The Record providing the data for the row which caused group change. cls : String The generated class
 name string to apply to the group header Element. style : String The inline style rules to apply to the group header
 Element. See Ext.XTemplate for information on how to format data using a template. Possible usage: var grid = new
 Ext.grid.GridPanel({
     ...
     view: new Ext.grid.GroupingView({
         groupTextTpl: '{text} ({[values.rs.length]}
 {[values.rs.length > 1 ? "Items" : "Item"]})'
     }),
 });]]></description><name>groupTextTpl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class to add to the header cell when its menu is visible. Defaults to 'x-grid3-hd-menu-open']]></description><name>headerMenuOpenCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to disable the grid column headers (defaults to false). Use the ColumnModel menuDisabled config to disable the menu
 for individual columns. While this config is true the following will be disabled: clicking on header to sort the trigger
 to reveal the menu.]]></description><name>headersDisabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to hide the column that is currently grouped (defaults to false)]]></description><name>hideGroupedColumn</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to skip refreshing the view when new rows are added (defaults to false)]]></description><name>ignoreAdd</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to show the dirty cell indicator when a cell has been modified. Defaults to true.]]></description><name>markDirty</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The selector used to find row bodies internally (defaults to 'div.x-grid3-row')]]></description><name>rowBodySelector</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The number of levels to search for row bodies in event delegation (defaults to 10)]]></description><name>rowBodySelectorDepth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class added to each row when it is hovered over. Defaults to 'x-grid3-row-over']]></description><name>rowOverCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The selector used to find rows internally (defaults to 'div.x-grid3-row')]]></description><name>rowSelector</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The number of levels to search for rows in event delegation (defaults to 10)]]></description><name>rowSelectorDepth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The amount of space to reserve for the vertical scrollbar (defaults to undefined). If an explicit value isn't specified,
 this will be automatically calculated.]]></description><name>scrollOffset</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class applied to a selected row (defaults to 'x-grid3-row-selected'). An example overriding the default styling:
 .x-grid3-row-selected {background-color: yellow;} Note that this only controls the row, and will not do anything for the
 text inside it. To style inner facets (like text) use something like: .x-grid3-row-selected .x-grid3-cell-inner {
       
  color: #FFCC00;
     }]]></description><name>selectedRowClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If true will display a prefix plus a ': ' before the group field value in the group header line. The prefix will consist
 of the groupName (or the configured header if not provided) configured in the Ext.grid.Column for each set of grouped
 rows (defaults to true).]]></description><name>showGroupName</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Text displayed in the grid header for enabling/disabling grouping (defaults to 'Show in Groups').]]></description><name>showGroupsText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The text displayed in the 'Sort Ascending' menu item (defaults to 'Sort Ascending')]]></description><name>sortAscText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS classes applied to a header when it is sorted. (defaults to ['sort-asc', 'sort-desc'])]]></description><name>sortClasses</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The text displayed in the 'Sort Descending' menu item (defaults to 'Sort Descending')]]></description><name>sortDescText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to start all groups collapsed (defaults to false)]]></description><name>startCollapsed</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 <p>A Column definition class which renders a numeric data field according to a <a
 href="output/Ext.grid.NumberColumn.html#Ext.grid.NumberColumn-format" ext:member="format"
 ext:cls="Ext.grid.NumberColumn">format</a> string. See the <a href="output/Ext.grid.Column.html#Ext.grid.Column-xtype"
 ext:member="xtype" ext:cls="Ext.grid.Column">xtype</a> config option of <a href="output/Ext.grid.Column.html"
 ext:cls="Ext.grid.Column">Ext.grid.Column</a> for more details.</p>]]></description><name>grid.numberColumn</name><tag-class>org.brushingbits.jnap.ui.extjs3.grid.NumberColumn</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[Optional. Set the CSS text-align property of the column. Defaults to undefined.]]></description><name>align</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. An inline style definition string which is applied to all table cells in the column (excluding headers).
 Defaults to undefined.]]></description><name>css</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Required. The name of the field in the grid's Ext.data.Store's Ext.data.Record definition from which to draw the
 column's value.]]></description><name>dataIndex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Defaults to true, enabling the configured editor. Set to false to initially disable editing on this column.
 The initial configuration may be dynamically altered using Ext.grid.ColumnModel.setEditable().]]></description><name>editable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. The Ext.form.Field to use when editing values in this column if editing is supported by the grid. See editable
 also.]]></description><name>editor</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. If the grid is being rendered by an Ext.grid.GroupingView, this option may be used to specify the text to
 display when there is an empty group value. Defaults to the Ext.grid.GroupingView.emptyGroupText.]]></description><name>emptyGroupText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. true if the column width cannot be changed. Defaults to false.]]></description><name>fixed</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A formatting string as used by Ext.util.Format.number to format a numeric value for this Column (defaults to
 '0,000.00').]]></description><name>format</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. If the grid is being rendered by an Ext.grid.GroupingView, this option may be used to specify the text with
 which to prefix the group field value in the group header line. See also groupRenderer and
 Ext.grid.GroupingView.showGroupName.]]></description><name>groupName</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. If the grid is being rendered by an Ext.grid.GroupingView, this option may be used to specify the function
 used to format the grouping field value for display in the group header. If a groupRenderer is not specified, the
 configured renderer will be called; if a renderer is also not specified the new value of the group field will be used.
 The called function (either the groupRenderer or renderer) will be passed the following parameters: v : Object The new
 value of the group field. unused : undefined Unused parameter. r : Ext.data.Record The Record providing the data for the
 row which caused group change. rowIndex : Number The row index of the Record which caused group change. colIndex :
 Number The column index of the group field. ds : Ext.data.Store The Store which is providing the data Model. The
 function should return a string value.]]></description><name>groupRenderer</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. If the grid is being rendered by an Ext.grid.GroupingView, this option may be used to disable the header menu
 item to group by the column selected. Defaults to true, which enables the header menu group option. Set to false to
 disable (but still show) the group option in the header menu for the column. See also groupName.]]></description><name>groupable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. The header text to be used as innerHTML (html tags are accepted) to display in the Grid view. Note: to have a
 clickable header with no text displayed use '&#160'.]]></description><name>header</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. true to initially hide this column. Defaults to false. A hidden column may be shown via the header row menu.
 If a column is never to be shown, simply do not include this column in the Column Model at all.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify as false to prevent the user from hiding this column (defaults to true). To disallow column hiding
 globally for all columns in the grid, use Ext.grid.GridPanel.enableColumnHide instead.]]></description><name>hideable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. A name which identifies this column (defaults to the column's initial ordinal position.) The id is used to
 create a CSS class name which is applied to all table cells (including headers) in that column (in this context the id
 does not need to be unique). The class name takes the form of x-grid3-td-id Header cells will also receive this class
 name, but will also have the class x-grid3-hd So, to target header cells, use CSS selectors such as: .x-grid3-hd-row
 .x-grid3-td-id The Ext.grid.GridPanel.autoExpandColumn grid config option references the column via this unique
 identifier.]]></description><name>id</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. true to disable the column menu. Defaults to false.]]></description><name>menuDisabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[For an alternative to specifying a renderer see xtype Optional. A renderer is an 'interceptor' method which can be used
 transform data (value, appearance, etc.) before it is rendered). This may be specified in either of three ways: A
 renderer function used to return HTML markup for a cell given the cell's data value. A string which references a
 property name of the Ext.util.Format class which provides a renderer function. An object specifying both the renderer
 function, and its execution scope (this reference) e.g.:
 <pre><code>{
     fn: this.gridRenderer,
     scope: this
 }</code></pre>
 If not
 specified, the default renderer uses the raw data value. For information about the renderer function (passed parameters,
 etc.), see Ext.grid.ColumnModel.setRenderer. An example of specifying renderer function inline:
 <pre><code>
 var companyColumn = {
    header: 'Company Name',
    dataIndex: 'company',
    renderer: function(value, metaData, record, rowIndex, colIndex, store) {
       // provide the logic depending on business rules
       // name of your own choosing to manipulate the cell depending upon
       // the data in the underlying Record object.
       if (value == 'whatever') {
           // metaData.css : String : A CSS class name to add to the TD element of the cell.
           // metaData.attr : String : An html attribute definition string to apply to
           // the data container element within the table
           // cell (e.g. 'style="color:red;"').
           metaData.css = 'name-of-css-class-you-will-define';
       }
       return value;
    }
 }</code></pre>
 See also scope.]]></description><name>renderer</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. false to disable column resizing. Defaults to true.]]></description><name>resizable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. The scope (this reference) in which to execute the renderer. Defaults to the Column configuration object.]]></description><name>scope</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. true if sorting is to be allowed on this column. Defaults to the value of the
 Ext.grid.ColumnModel.defaultSortable property. Whether local/remote sorting is used is specified in
 Ext.data.Store.remoteSort.]]></description><name>sortable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. A text string to use as the column header's tooltip. If Quicktips are enabled, this value will be used as the
 text of the quick tip, otherwise it will be set as the header's HTML title attribute. Defaults to ''.]]></description><name>tooltip</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. The initial width in pixels of the column. The width of each column can also be affected if any of the
 following are configured: Ext.grid.GridPanel.autoExpandColumn Ext.grid.GridView.forceFit By specifying forceFit:true,
 non-fixed width columns will be re-proportioned (based on the relative initial widths) to fill the width of the grid so
 that no horizontal scrollbar is shown. Ext.grid.GridView.autoFill Ext.grid.GridPanel.minColumnWidth Note: when the width
 of each column is determined, a space on the right side is reserved for the vertical scrollbar. The
 Ext.grid.GridView.scrollOffset can be modified to reduce or eliminate the reserved offset.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 <p>This class represents the primary interface of a component based grid control to represent data in a tabular format
 of rows and columns. The GridPanel is composed of the following:</p> 
 <div class="mdetail-params">
  <ul> 
   <li><b><a
 href="output/Ext.data.Store.html" ext:cls="Ext.data.Store">Store</a></b> : The Model holding the data records (rows) 
   
 <div class="sub-desc"></div></li> 
   <li><b><a href="output/Ext.grid.ColumnModel.html"
 ext:cls="Ext.grid.ColumnModel">Column model</a></b> : Column makeup 
    <div class="sub-desc"></div></li> 
   <li><b><a
 href="output/Ext.grid.GridView.html" ext:cls="Ext.grid.GridView">View</a></b> : Encapsulates the user interface 
    <div
 class="sub-desc"></div></li> 
   <li><b><a href="output/Ext.grid.AbstractSelectionModel.html"
 ext:cls="Ext.grid.AbstractSelectionModel">selection model</a></b> : Selection behavior 
    <div
 class="sub-desc"></div></li> 
  </ul>
 </div> 
 <p>Example usage:</p> 
 <pre><code><b>var</b> grid = <b>new</b>
 Ext.grid.GridPanel({
     <a href="output/Ext.grid.GridPanel.html#Ext.grid.GridPanel-store" ext:member="store"
 ext:cls="Ext.grid.GridPanel">store</a>: <b>new</b> <a href="output/Ext.data.Store.html"
 ext:cls="Ext.data.Store">Ext.data.Store</a>({
         <a href="output/Ext.data.Store.html#Ext.data.Store-autoDestroy"
 ext:member="autoDestroy" ext:cls="Ext.data.Store">autoDestroy</a>: true,
         <a
 href="output/Ext.data.Store.html#Ext.data.Store-reader" ext:member="reader" ext:cls="Ext.data.Store">reader</a>:
 reader,
         <a href="output/Ext.data.Store.html#Ext.data.Store-data" ext:member="data"
 ext:cls="Ext.data.Store">data</a>: xg.dummyData
     }),
     <a
 href="output/Ext.grid.GridPanel.html#Ext.grid.GridPanel-colModel" ext:member="colModel"
 ext:cls="Ext.grid.GridPanel">colModel</a>: <b>new</b> <a href="output/Ext.grid.ColumnModel.html"
 ext:cls="Ext.grid.ColumnModel">Ext.grid.ColumnModel</a>({
         <a
 href="output/Ext.grid.ColumnModel.html#Ext.grid.ColumnModel-defaults" ext:member="defaults"
 ext:cls="Ext.grid.ColumnModel">defaults</a>: {
             width: 120,
             sortable: true
         },
         <a
 href="output/Ext.grid.ColumnModel.html#Ext.grid.ColumnModel-columns" ext:member="columns"
 ext:cls="Ext.grid.ColumnModel">columns</a>: [
             {id: <em>'company'</em>, header: <em>'Company'</em>, width:
 200, sortable: true, dataIndex: <em>'company'</em>},
             {header: <em>'Price'</em>, renderer:
 Ext.util.Format.usMoney, dataIndex: <em>'price'</em>},
             {header: <em>'Change'</em>, dataIndex:
 <em>'change'</em>},
             {header: <em>'% Change'</em>, dataIndex: <em>'pctChange'</em>},
             <i>//
 instead of specifying renderer: Ext.util.Format.dateRenderer(<em>'m/d/Y'</em>) use xtype</i>
             {
              
 header: <em>'Last Updated'</em>, width: 135, dataIndex: <em>'lastChange'</em>,
                 xtype:
 <em>'datecolumn'</em>, format: <em>'M d, Y'</em>
             }
         ]
     }),
     <a
 href="output/Ext.grid.GridPanel.html#Ext.grid.GridPanel-viewConfig" ext:member="viewConfig"
 ext:cls="Ext.grid.GridPanel">viewConfig</a>: {
         <a
 href="output/Ext.grid.GridView.html#Ext.grid.GridView-forceFit" ext:member="forceFit"
 ext:cls="Ext.grid.GridView">forceFit</a>: true,
 
 <i>//      Return CSS class to apply to rows depending upon data
 values</i>
         <a href="output/Ext.grid.GridView.html#Ext.grid.GridView-getRowClass" ext:member="getRowClass"
 ext:cls="Ext.grid.GridView">getRowClass</a>: <b>function</b>(record, index) {
             <b>var</b> c = record.<a
 href="output/Ext.data.Record.html#Ext.data.Record-get" ext:member="get"
 ext:cls="Ext.data.Record">get</a>(<em>'change'</em>);
             <b>if</b> (c &lt; 0) {
                 <b>return</b>
 <em>'price-fall'</em>;
             } <b>else</b> <b>if</b> (c &gt; 0) {
                 <b>return</b>
 <em>'price-rise'</em>;
             }
         }
     },
     <a href="output/Ext.grid.GridPanel.html#Ext.grid.GridPanel-sm"
 ext:member="sm" ext:cls="Ext.grid.GridPanel">sm</a>: <b>new</b> Ext.grid.RowSelectionModel({singleSelect:true}),
    
 width: 600,
     height: 300,
     frame: true,
     title: <em>'Framed <b>with</b> Row Selection and Horizontal
 Scrolling'</em>,
     iconCls: <em>'icon-grid'</em>
 });</code></pre> 
 <p><b><u>Notes:</u></b></p> 
 <div
 class="mdetail-params">
  <ul> 
   <li>Although this class inherits many configuration options from base classes, some of
 them (such as autoScroll, autoWidth, layout, items, etc) are not used by this class, and will have no effect.</li> 
  
 <li>A grid <b>requires</b> a width in which to scroll its columns, and a height in which to scroll its rows. These
 dimensions can either be set explicitly through the <tt><a href="output/Ext.BoxComponent.html#Ext.BoxComponent-height"
 ext:member="height" ext:cls="Ext.BoxComponent">height</a></tt> and <tt><a
 href="output/Ext.BoxComponent.html#Ext.BoxComponent-width" ext:member="width" ext:cls="Ext.BoxComponent">width</a></tt>
 configuration options or implicitly set by using the grid as a child item of a <a href="output/Ext.Container.html"
 ext:cls="Ext.Container">Container</a> which will have a <a href="output/Ext.Container.html#Ext.Container-layout"
 ext:member="layout" ext:cls="Ext.Container">layout manager</a> provide the sizing of its child items (for example the
 Container of the Grid may specify <tt><a href="output/Ext.Container.html#Ext.Container-layout" ext:member="layout"
 ext:cls="Ext.Container">layout</a>:'fit'</tt>).</li> 
   <li>To access the data in a Grid, it is necessary to use the
 data model encapsulated by the <a href="output/Ext.grid.GridPanel.html#Ext.grid.GridPanel-store" ext:member="store"
 ext:cls="Ext.grid.GridPanel">Store</a>. See the <a href="output/Ext.grid.GridPanel.html#Ext.grid.GridPanel-cellclick"
 ext:member="cellclick" ext:cls="Ext.grid.GridPanel">cellclick</a> event for more details.</li> 
  </ul>
 </div>]]></description><name>grid.panel</name><tag-class>org.brushingbits.jnap.ui.extjs3.grid.GridPanel</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[A string component id or the numeric index of the component that should be initially activated within the container's
 layout on render. For example, activeItem: 'item-1' or activeItem: 0 (index 0 = the first item in the container's
 collection). activeItem only applies to layout styles that can display items one at a time (like
 Ext.layout.AccordionLayout, Ext.layout.CardLayout and Ext.layout.FitLayout). Related to
 Ext.layout.ContainerLayout.activeItem.]]></description><name>activeItem</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Whether the component can move the Dom node when rendering (defaults to true).]]></description><name>allowDomMove</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use an
 AnchorLayout (or subclass thereof). based layout manager, for example: Ext.form.FormPanel specifying layout: 'anchor' //
 or 'form', or 'absolute' See Ext.layout.AnchorLayout.anchor also.]]></description><name>anchor</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to animate the transition when the panel is collapsed, false to skip the animation (defaults to true if the Ext.Fx
 class is available, otherwise false).]]></description><name>animCollapse</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The id of the node, a DOM node or an existing Element corresponding to a DIV that is already present in the document
 that specifies some panel-specific structural markup. When applyTo is used, constituent parts of the panel can be
 specified by CSS class name within the main element, and the panel will automatically create those components from that
 markup. Any required components not specified in the markup will be autogenerated if necessary. The following class
 names are supported (baseCls will be replaced by baseCls): baseCls + '-header' baseCls + '-header-text' baseCls +
 '-bwrap' baseCls + '-tbar' baseCls + '-body' baseCls + '-bbar' baseCls + '-footer' Using this config, a call to render()
 is not required. If applyTo is specified, any value passed for renderTo will be ignored and the target element's parent
 node will automatically be used as the panel's container.]]></description><name>applyTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If true the container will automatically destroy any contained component that is removed from it, else destruction must
 be handled manually (defaults to true).]]></description><name>autoDestroy</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A tag name or DomHelper spec used to create the Element which will encapsulate this Component. You do not normally need
 to specify this. For the base classes Ext.Component, Ext.BoxComponent, and Ext.Container, this defaults to 'div'. The
 more complex Ext classes use a more complex DOM structure created by their own onRender methods. This is intended to
 allow the developer to create application-specific utility Components encapsulated by different DOM elements. Example
 usage: <pre><code>{
     xtype: 'box',
     autoEl: {
         tag: 'img',
         src: 'http://www.example.com/example.jpg'
     }
 },
 {
     xtype: 'box',
     autoEl: {
         tag: 'blockquote',
         html: 'autoEl is cool!'
     }
 }, {
     xtype: 'container',
     autoEl: 'ul',
     cls: 'ux-unordered-list',
     items: {
         xtype: 'box',
         autoEl: 'li',
   
      html: 'First list item'
     }
 }</pre></code>]]></description><name>autoEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The id of a column in this grid that should expand to fill unused space. This value specified here can not be 0. Note:
 If the Grid's view is configured with forceFit=true the autoExpandColumn is ignored. See Ext.grid.Column.width for
 additional details. See autoExpandMax and autoExpandMin also.]]></description><name>autoExpandColumn</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum width the autoExpandColumn can have (if enabled). Defaults to 1000.]]></description><name>autoExpandMax</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum width the autoExpandColumn can have (if enabled). Defaults to 50.]]></description><name>autoExpandMin</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to use height:'auto', false to use fixed height (defaults to false). Note: Setting autoHeight: true means that the
 browser will manage the panel's height based on its contents, and that Ext will not manage it at all. If the panel is
 within a layout that manages dimensions (fit, border, etc.) then setting autoHeight: true can cause issues with
 scrolling and will not generally work as expected since the panel will take on the height of its contents rather than
 the height required by the Ext layout.]]></description><name>autoHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A valid url spec according to the Updater Ext.Updater.update method. If autoLoad is not null, the panel will attempt to
 load its contents immediately upon render. The URL will become the default URL for this panel's body element, so it may
 be refreshed at any time.]]></description><name>autoLoad</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to use overflow:'auto' on the components layout element and show scroll bars automatically when necessary, false to
 clip any overflowing content (defaults to false).]]></description><name>autoScroll</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True if the component should check for hidden classes (e.g. 'x-hidden' or 'x-hide-display') and remove them on render
 (defaults to false).]]></description><name>autoShow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to use width:'auto', false to use fixed width (or allow it to be managed by its parent Container's layout manager.
 Defaults to false. Note: Although many components inherit this config option, not all will function as expected with a
 width of 'auto'. Setting autoWidth:true means that the browser will manage width based on the element's contents, and
 that Ext will not manage it at all. If the browser is managing the width, be aware that resizes performed by the browser
 in response to changes within the structure of the Component cannot be detected. Therefore changes to the width might
 result in elements needing to be synchronized with the new width. For example, where the target element is: <div
 id='grid-container' style='margin-left:25%;width:50%'></div> A Panel rendered into that target element must listen for
 browser window resize in order to relay its child items when the browser changes its width: var myPanel = new
 Ext.Panel({
     renderTo: 'grid-container',
     monitorResize: true, // relay on browser resize
     title: 'Panel',
    
 height: 400,
     autoWidth: true,
     layout: 'hbox',
     layoutConfig: {
         align: 'stretch'
     },
     defaults: {
         flex: 1
     },
     items: [{
         title: 'Box 1',
     }, {
         title: 'Box 2'
     }, {
         title:
 'Box 3'
     }],
 });]]></description><name>autoWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The base CSS class to apply to this panel's element (defaults to 'x-panel'). Another option available by default is to
 specify 'x-plain' which strips all styling except for required attributes for Ext layouts to function (e.g.
 overflow:hidden). See unstyled also.]]></description><name>baseCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to display an interior border on the body element of the panel, false to hide it (defaults to true). This only
 applies when border == true. If border == true and bodyBorder == false, the border will display as a 1px wide inset
 border, giving the entire body element an inset appearance.]]></description><name>bodyBorder</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A DomHelper element specification object may be specified for any Panel Element. By default, the Default element in the
 table below will be used for the html markup to create a child element with the commensurate Default class name (baseCls
 will be replaced by baseCls): 
 Panel      Default  Default             Custom      Additional       Additional
 Element  
 element  class               element     class            style
 ========   ==========================   =========  
 ==============   ===========
 header     div      baseCls+'-header'   headerCfg   headerCssClass   headerStyle
 bwrap     
 div      baseCls+'-bwrap'     bwrapCfg    bwrapCssClass    bwrapStyle
 + tbar     div      baseCls+'-tbar'       tbarCfg 
 tbarCssClass     tbarStyle
 + body     div      baseCls+'-body'       bodyCfg     bodyCssClass     bodyStyle
 + bbar    
 div      baseCls+'-bbar'       bbarCfg     bbarCssClass     bbarStyle
 + footer   div      baseCls+'-footer'   footerCfg 
 footerCssClass   footerStyle
  Configuring a Custom element may be used, for example, to force the body Element to use a
 different form of markup than is created by default. An example of this might be to create a child Panel containing a
 custom content, such as a header, or forcing centering of all Panel content by having the body be a <center> element:
 new Ext.Panel({
     title: 'Message Title',
     renderTo: Ext.getBody(),
     width: 200, height: 130,
     bodyCfg: {
    
 tag: 'center',
         cls: 'x-panel-body',  // Default class not applied if Custom element specified
         html:
 'Message'
     },
     footerCfg: {
         tag: 'h2',
         cls: 'x-panel-footer',        // same as the Default class
 
 html: 'footer html'
     },
     footerCssClass: 'custom-footer', // additional css class, see addClass
     footerStyle:  
 'background-color:red' // see bodyStyle
 }); The example above also explicitly creates a footer with custom markup and
 styling applied.]]></description><name>bodyCfg</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Additional css class selector to be applied to the body element in the format expected by Ext.Element.addClass (defaults
 to null). See bodyCfg.]]></description><name>bodyCssClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Custom CSS styles to be applied to the body element in the format expected by Ext.Element.applyStyles (defaults to
 null). See bodyCfg.]]></description><name>bodyStyle</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to display the borders of the panel's body element, false to hide them (defaults to true). By default, the border
 is a 2px wide inset border, but this can be further altered by setting bodyBorder to false.]]></description><name>border</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to [].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[When set to true (50 milliseconds) or a number of milliseconds, the layout assigned for this container will buffer the
 frequency it calculates and does a re-layout of components. This is useful for heavy containers or containers with a
 large quantity of sub-components for which frequent layout calls would be expensive. Defaults to 50.]]></description><name>bufferResize</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The alignment of any buttons added to this panel. Valid values are 'right', 'left' and 'center' (defaults to 'right').]]></description><name>buttonAlign</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A DomHelper element specification object specifying the element structure of this Panel's bwrap Element. See bodyCfg
 also.]]></description><name>bwrapCfg</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class used to to apply to the special clearing div rendered directly after each form field wrapper to provide
 field clearing (defaults to 'x-form-clear-left'). Note: this config is only used when this Component is rendered by a
 Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or specifying
 layout:'form') and either a fieldLabel is specified or isFormField=true is specified. See Ext.layout.FormLayout.fieldTpl
 also.]]></description><name>clearCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Panels themselves do not directly support being closed, but some Panel subclasses do (like Ext.Window) or a Panel Class
 within an Ext.TabPanel. Specify true to enable closing in such situations. Defaults to false.]]></description><name>closable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element (defaults to ''). This can be useful for
 adding customized styles to the component or any of its children using standard CSS rules.]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Shorthand for colModel.]]></description><name>cm</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to make sure the collapse/expand toggle button always renders first (to the left of) any other tools in the panel's
 title bar, false to render it last (defaults to true).]]></description><name>collapseFirst</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to render the panel collapsed, false to render it expanded (defaults to false).]]></description><name>collapsed</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS class to add to the panel's element after it has been collapsed (defaults to 'x-panel-collapsed').]]></description><name>collapsedCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to make the panel collapsible and have the expand/collapse toggle button automatically rendered into the header
 tool button area, false to keep the panel statically sized with no button (defaults to false).]]></description><name>collapsible</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to add css for column separation lines. Default is false.]]></description><name>columnLines</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's container. This can be useful for adding customized
 styles to the container or any of its children using standard CSS rules. See Ext.layout.ContainerLayout.extraCls also.
 Note: ctCls defaults to '' except for the following class which assigns a value by default: Box Layout :
 'x-box-layout-ct' To configure the above Class with an extra CSS class append to the default. For example, for BoxLayout
 (Hbox and Vbox): ctCls: 'x-box-layout-ct custom-class']]></description><name>ctCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The DD group this GridPanel belongs to. Defaults to 'GridDD' if not specified.]]></description><name>ddGroup</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Configures the text in the drag proxy. Defaults to: ddText : '{0} selected row{1}' {0} is replaced with the number of
 selected rows.]]></description><name>ddText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default xtype of child Components to create in this Container when a child item is specified as a raw configuration
 object, rather than as an instantiated Component. Defaults to 'panel', except Ext.menu.Menu which defaults to
 'menuitem', and Ext.Toolbar and Ext.ButtonGroup which default to 'button'.]]></description><name>defaultType</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[This option is a means of applying default settings to all added items whether added through the items config or via the
 add or insert methods. If an added item is a config object, and not an instantiated Component, then the default
 properties are unconditionally applied. If the added item is an instantiated Component, then the default properties are
 applied conditionally so as not to override existing properties in the item. If the defaults option is specified as a
 function, then the function will be called using this Container as the scope (this reference) and passing the added item
 as the first parameter. Any resulting object from that call is then applied to the item as default properties. For
 example, to automatically apply padding to the body of each of a set of contained Ext.Panel items, you could pass:
 defaults: {bodyStyle:'padding:15px'}. Usage: defaults: {               // defaults are applied to items, not the
 container
     autoScroll:true
 },
 items: [
     {
         xtype: 'panel',   // defaults do not have precedence over
       
 id: 'panel1',     // options in config objects, so the defaults
         autoScroll: false // will not be applied here,
 panel1 will be autoScroll:false
     },
     new Ext.Panel({       // defaults do have precedence over options
         id:
 'panel2',     // options in components, so the defaults
         autoScroll: false // will be applied here, panel2 will
 be autoScroll:true.
     })
 ]]]></description><name>defaults</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to true to enable deferred row rendering. This allows the GridPanel to be initially rendered empty, with the
 expensive update of the row structure deferred so that layouts with GridPanels appear more quickly.]]></description><name>deferRowRender</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to disable selections in the grid. Defaults to false. Ignored if a SelectionModel is specified.]]></description><name>disableSelection</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this panel disabled (default is false). An important note when using the disabled config on panels is that IE
 will often fail to initialize the disabled mask element correectly if the panel's layout has not yet completed by the
 time the Panel is disabled during the render process. If you experience this issue, you may need to instead use the
 afterlayout event to initialize the disabled state: new Ext.Panel({
     ...
     listeners: {
         'afterlayout': {
   
 fn: function(p){
                 p.disable();
             },
             single: true // important, as many layouts can
 occur
         }
     }
 });]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class added to the component when it is disabled (defaults to 'x-item-disabled').]]></description><name>disabledClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to enable dragging of this Panel (defaults to false). For custom drag/drop implementations, an Ext.Panel.DD config
 could also be passed in this config instead of true. Ext.Panel.DD is an internal, undocumented class which moves a proxy
 Element around in place of the Panel's element, but provides no other behaviour during dragging or on drop. It is a
 subclass of Ext.dd.DragSource, so behaviour may be added by implementing the interface methods of Ext.dd.DragDrop e.g.:
 new Ext.Panel({
     title: 'Drag me',
     x: 100,
     y: 100,
     renderTo: Ext.getBody(),
     floating: true,
    
 frame: true,
     width: 400,
     height: 200,
     draggable: {
 //      Config option of Ext.Panel.DD class.
 //      It's
 a floating Panel, so do not show a placeholder proxy in the original position.
         insertProxy: false,
 
 //     
 Called for each mousemove event while dragging the DD object.
         onDrag : function(e){
 //          Record the x,y
 position of the drag proxy so that we can
 //          position the Panel at end of drag.
             var pel =
 this.proxy.getEl();
             this.x = pel.getLeft(true);
             this.y = pel.getTop(true);
 
 //          Keep the
 Shadow aligned if there is one.
             var s = this.panel.getEl().shadow;
             if (s) {
                
 s.realign(this.x, this.y, pel.getWidth(), pel.getHeight());
             }
         },
 
 //      Called on the mouseup
 event.
         endDrag : function(e){
             this.panel.setPosition(this.x, this.y);
         }
     }
 }).show();]]></description><name>draggable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A comma-delimited list of panel elements to initialize when the panel is rendered. Normally, this list will be generated
 automatically based on the items added to the panel at config time, but sometimes it might be useful to make sure a
 structural element is rendered even if not specified at config time (for example, you may want to add a button or
 toolbar dynamically after the panel has been rendered). Adding those elements to this list will allocate the required
 placeholders in the panel when it is rendered. Valid values are header tbar (top bar) body bbar (bottom bar) footer
 Defaults to 'body'.]]></description><name>elements</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to true to enable hiding of columns with the header menu.]]></description><name>enableColumnHide</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to true to enable drag and drop reorder of columns. false to turn off column reordering via drag drop.]]></description><name>enableColumnMove</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[false to turn off column resizing for the whole grid. Defaults to true.]]></description><name>enableColumnResize</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Enables dragging of the selected rows of the GridPanel. Defaults to false. Setting this to true causes this GridPanel's
 GridView to create an instance of Ext.grid.GridDragZone. Note: this is available only after the Grid has been rendered
 as the GridView's dragZone property. A cooperating DropZone must be created who's implementations of onNodeEnter,
 onNodeOver, onNodeOut and onNodeDrop are able to process the data which is provided.]]></description><name>enableDragDrop</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to true to enable the drop down button for menu in the headers.]]></description><name>enableHdMenu</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A Toolbar object, a Toolbar config, or an array of Buttons/Button configs, describing a Toolbar to be rendered into this
 Panel's footer element. After render, the fbar property will be an Toolbar instance. If buttons are specified, they will
 supersede the fbar configuration property. The Panel's buttonAlign configuration affects the layout of these items, for
 example: var w = new Ext.Window({
     height: 250,
     width: 500,
     bbar: new Ext.Toolbar({
         items: [{
        
 text: 'bbar Left'
         },'->',{
             text: 'bbar Right'
         }]
     }),
     buttonAlign: 'left', //
 anything but 'center' or 'right' and you can use '-', and '->'
                                   // to control the
 alignment of fbar items
     fbar: [{
         text: 'fbar Left'
     },'->',{
         text: 'fbar Right'
     }]
 }).show();
 Note: Although a Toolbar may contain Field components, these will not be updated by a load of an ancestor FormPanel. A
 Panel's toolbars are not part of the standard Container->Component hierarchy, and so are not scanned to collect form
 items. However, the values will be submitted because form submission parameters are collected from the DOM tree.]]></description><name>fbar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The label text to display next to this Component (defaults to ''). Note: this config is only used when this Component is
 rendered by a Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or
 specifying layout:'form'). Also see hideLabel and Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
    
 height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name'
    
 }]
 });]]></description><name>fieldLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use a
 BoxLayout. Each child Component with a flex property will be flexed either vertically (by a VBoxLayout) or horizontally
 (by an HBoxLayout) according to the item's relative flex value compared to the sum of all Components with flex value
 specified. Any child items that have either a flex = 0 or flex = undefined will not be 'flexed' (the initial size will
 not be changed).]]></description><name>flex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[This property is used to configure the underlying Ext.Layer. Acceptable values for this configuration property are:
 false : Default. Display the panel inline where it is rendered. true : Float the panel (absolute position it with
 automatic shimming and shadow). Setting floating to true will create an Ext.Layer for this panel and display the panel
 at negative offsets so that it is hidden. Since the panel will be absolute positioned, the position must be set
 explicitly after render (e.g., myPanel.setPosition(100,100);). Note: when floating a panel you should always assign a
 fixed width, otherwise it will be auto width and will expand to fill to the right edge of the viewport. object : The
 specified object will be used as the configuration object for the Ext.Layer that will be created.]]></description><name>floating</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to create the footer element explicitly, false to skip creating it. The footer will be created automatically if
 buttons or a fbar have been configured. See bodyCfg for an example.]]></description><name>footer</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A DomHelper element specification object specifying the element structure of this Panel's footer Element. See bodyCfg
 also.]]></description><name>footerCfg</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If true the container will force a layout initially even if hidden or collapsed. This option is useful for forcing forms
 to render in collapsed or hidden containers. (defaults to false).]]></description><name>forceLayout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[false by default to render with plain 1px square borders. true to render with 9 elements, complete with custom rounded
 corners (also see Ext.Element.boxWrap). The template generated for each condition is depicted below: // frame =
 false
 <div id="developer-specified-id-goes-here" class="x-panel">
 
     <div class="x-panel-header"><span
 class="x-panel-header-text">Title: (frame:false)</span></div>
 
     <div class="x-panel-bwrap">
         <div
 class="x-panel-body"><p>html value goes here</p></div>
     </div>
 </div>
 
 // frame = true (create 9 elements)
 <div
 id="developer-specified-id-goes-here" class="x-panel">
     <div class="x-panel-tl"><div class="x-panel-tr"><div
 class="x-panel-tc">
         <div class="x-panel-header"><span class="x-panel-header-text">Title:
 (frame:true)</span></div>
     </div></div></div>
 
     <div class="x-panel-bwrap">
         <div class="x-panel-ml"><div
 class="x-panel-mr"><div class="x-panel-mc">
             <div class="x-panel-body"><p>html value goes here</p></div>
     
 </div></div></div>
 
         <div class="x-panel-bl"><div class="x-panel-br"><div class="x-panel-bc"/>
        
 </div></div></div>
 </div>]]></description><name>frame</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to create the Panel's header element explicitly, false to skip creating it. If a title is set the header will be
 created automatically, otherwise it will not. If a title is set but header is explicitly set to false, the header will
 not be rendered.]]></description><name>header</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to display the panel title in the header, false to hide it (defaults to true).]]></description><name>headerAsText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A DomHelper element specification object specifying the element structure of this Panel's header Element. See bodyCfg
 also.]]></description><name>headerCfg</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component hidden (default is false). If true, the hide method will be called internally.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide the borders of each contained component, false to defer to the component's existing border settings
 (defaults to false).]]></description><name>hideBorders</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to hide the expand/collapse toggle button when collapsible == true, false to display it (defaults to false).]]></description><name>hideCollapseTool</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide the grid's header. Defaults to false.]]></description><name>hideHeaders</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to completely hide the label element (label and separator). Defaults to false. By default, even if you do not
 specify a fieldLabel the space will still be reserved so that the field will line up with other fields that do have
 labels. Setting this to true will cause the field to not reserve that space. Note: see the note for clearCls. Example
 use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield'
        
 hideLabel: true
     }]
 });]]></description><name>hideLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[How this component should be hidden. Supported values are 'visibility' (css visibility), 'offsets' (negative offset
 position) and 'display' (css display). Note: the default of 'display' is generally preferred since items are
 automatically laid out when they are first shown (no sizing is done while hidden).]]></description><name>hideMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide and show the component's container when hide/show is called on the component, false to hide and show the
 component itself (defaults to false). For example, this can be used as a shortcut for a hide button on a window by
 setting hide:true on the button when adding it to its parent container.]]></description><name>hideParent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class selector that specifies a background image to be used as the header icon (defaults to ''). An example of
 specifying a custom icon class would be something like: // specify the property in the config for the class:
      ...
   
 iconCls: 'my-icon'
 
 // css class that specifies background image to be used as the icon image:
 .my-icon {
 background-image: url(../images/my-icon.gif) 0 6px no-repeat !important; }]]></description><name>iconCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id of this component (defaults to an auto-assigned id). You should assign an id if you need to be able to
 access the component later and you do not have an object reference available (e.g., using Ext.getCmp). Note that this id
 will also be used as the element id for the containing HTML element that is rendered to the page for this component.
 This allows you to write id-based CSS rules to style the specific instance of this component uniquely, and also to
 select sub-elements using this component's id as the parent. Note: to avoid complications imposed by a unique id also
 see itemId and ref. Note: to access the container of an item see ownerCt.]]></description><name>id</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use the
 FormLayout layout manager (e.g. Ext.form.FormPanel or specifying layout:'form'). An additional CSS class to apply to the
 div wrapping the form item element of this field. If supplied, itemCls at the field level will override the default
 itemCls supplied at the container level. The value specified for itemCls will be added to the default class
 ('x-form-item'). Since it is applied to the item wrapper (see Ext.layout.FormLayout.fieldTpl), it allows you to write
 standard CSS rules that can apply to the field, the label (if specified), or any other element within the markup for the
 field. Note: see the note for fieldLabel. Example use: // Apply a style to the field's label:
 <style>
     .required
 .x-form-item-label {font-weight:bold;color:red;}
 </style>
 
 new Ext.FormPanel({
     height: 100,
     renderTo:
 Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         itemCls: 'required' //this
 label will be styled
     },{
         xtype: 'textfield',
         fieldLabel: 'Favorite Color'
     }]
 });]]></description><name>itemCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An itemId can be used as an alternative way to get a reference to a component when no object reference is available.
 Instead of using an id with Ext.getCmp, use itemId with Ext.Container.getComponent which will retrieve itemId's or id's.
 Since itemId's are an index to the container's internal MixedCollection, the itemId is scoped locally to the container
 -- avoiding potential conflicts with Ext.ComponentMgr which requires a unique id. var c = new Ext.Panel({ //
     height:
 300,
     renderTo: document.body,
     layout: 'auto',
     items: [
         {
             itemId: 'p1',
            
 title: 'Panel 1',
             height: 150
         },
         {
             itemId: 'p2',
             title: 'Panel 2',
  
 height: 150
         }
     ]
 })
 p1 = c.getComponent('p1'); // not the same as Ext.getCmp()
 p2 =
 p1.ownerCt.getComponent('p2'); // reference via a sibling Also see id and ref. Note: to access the container of an item
 see ownerCt.]]></description><name>itemId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A Ext.KeyMap config object (in the format expected by Ext.KeyMap.addBinding used to assign custom key handling to this
 panel (defaults to null).]]></description><name>keys</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The separator to display after the text of each fieldLabel. This property may be configured at various levels. The order
 of precedence is: field / component level container level layout level (defaults to colon ':') To display no separator
 for this field's label specify empty string ''. Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 layoutConfig: {
         labelSeparator: '~'   // layout config has lowest priority (defaults to ':')
     },
    
 labelSeparator: '>>',     // config at container level
     items: [{
         xtype: 'textfield',
         fieldLabel:
 'Field 1',
         labelSeparator: '...' // field/component level config supersedes others
     },{
         xtype:
 'textfield',
         fieldLabel: 'Field 2' // labelSeparator will be '='
     }]
 });]]></description><name>labelSeparator</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS style specification string to apply directly to this field's label. Defaults to the container's labelStyle value
 if set (e.g., Ext.layout.FormLayout.labelStyle , or ''). Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         labelStyle: 'font-weight:bold;'
     }]
 });]]></description><name>labelStyle</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[*Important: In order for child items to be correctly sized and positioned, typically a layout manager must be specified
 through the layout configuration option. The sizing and positioning of child items is the responsibility of the
 Container's layout manager which creates and manages the type of layout you have in mind. For example:
 <pre><code>
 new Ext.Window({
 
 width:300, height: 300,
     layout: 'fit', // explicitly set layout manager: override the default (layout:'auto')
    
 items: [{
         title: 'Panel inside a Window'
     }]
 }).show();</pre></code>
 If the layout configuration is not explicitly
 specified for a general purpose container (e.g. Container or Panel) the default layout manager will be used which does
 nothing but render child components sequentially into the Container (no sizing or positioning will be performed in this
 situation). Some container classes implicitly specify a default layout (e.g. FormPanel specifies layout:'form'). Other
 specific purpose classes internally specify/manage their internal layout (e.g. GridPanel, TabPanel, TreePanel, Toolbar,
 Menu, etc.). layout may be specified as either as an Object or as a String: Specify as an Object Example usage: layout:
 {
     type: 'vbox',
     padding: '5',
     align: 'left'
 } type The layout type to be used for this container. If not
 specified, a default Ext.layout.ContainerLayout will be created and used. Valid layout type values are: absolute
 accordion anchor auto Default border card column fit form hbox menu table toolbar vbox Layout specific configuration
 properties Additional layout specific configuration properties may also be specified. For complete details regarding the
 valid config options for each layout type, see the layout class corresponding to the type specified. Specify as a String
 Example usage: layout: 'vbox',
 layoutConfig: {
     padding: '5',
     align: 'left'
 } layout The layout type to be used
 for this container (see list of valid layout type values above). layoutConfig Additional layout specific configuration
 properties. For complete details regarding the valid config options for each layout type, see the layout class
 corresponding to the layout specified.]]></description><name>layout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An Ext.LoadMask config or true to mask the grid while loading. Defaults to false.]]></description><name>loadMask</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout or one of the two BoxLayout subclasses. An object containing margins to apply to this BoxComponent in the
 format: {
     top: (top margin),
     right: (right margin),
     bottom: (bottom margin),
     left: (left margin)
 } May
 also be a string containing space-separated, numeric margin values. The order of the sides associated with each value
 matches the way CSS processes margin values: If there is only one value, it applies to all sides. If there are two
 values, the top and bottom borders are set to the first value and the right and left are set to the second. If there are
 three values, the top is set to the first value, the left and right are set to the second, and the bottom is set to the
 third. If there are four values, they apply to the top, right, bottom, and left, respectively. Defaults to: {top:0,
 right:0, bottom:0, left:0}]]></description><name>margins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to mask the panel when it is disabled, false to not mask it (defaults to true). Either way, the panel will always
 tell its contained elements to disable themselves when it is disabled, but masking the panel can provide an additional
 visual cue that the panel is disabled.]]></description><name>maskDisabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Sets the maximum height of the grid - ignored if autoHeight is not on.]]></description><name>maxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Minimum width in pixels of all buttons in this panel (defaults to 75)]]></description><name>minButtonWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum width a column can be resized to. Defaults to 25.]]></description><name>minColumnWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically monitor window resize events to handle anything that is sensitive to the current size of the
 viewport. This value is typically managed by the chosen layout and should not need to be set manually.]]></description><name>monitorResize</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element when the mouse moves over the Element, and
 removed when the mouse moves out. (defaults to ''). This can be useful for adding customized 'active' or 'hover' styles
 to the component or any of its children using standard CSS rules.]]></description><name>overCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A shortcut for setting a padding style on the body element. The value can either be a number to be applied to all sides,
 or a normal css string describing padding. Defaults to undefined.]]></description><name>padding</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level x coordinate for this component if contained within a positioning container.]]></description><name>pageX</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level y coordinate for this component if contained within a positioning container.]]></description><name>pageY</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to false. When set to true, an extra css class 'x-panel-normal' will be added to the panel's element,
 effectively applying css styles suggested by the W3C (see http://www.w3.org/TR/CSS21/sample.html) to the Panel's body
 element (not the header, footer, etc.).]]></description><name>preventBodyReset</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered ptype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a Plugin is being specified not as a fully
 instantiated Component, but as a Component config object. The ptype will be looked up at render time up to determine
 what type of Plugin to create. If you create your own Plugins, you may register them using
 Ext.ComponentMgr.registerPlugin in order to be able to take advantage of lazy instantiation and rendering.]]></description><name>ptype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A path specification, relative to the Component's ownerCt specifying into which ancestor Container to place a named
 reference to this Component. The ancestor axis can be traversed by using '/' characters in the path. For example, to put
 a reference to a Toolbar Button into the Panel which owns the Toolbar: var myGrid = new Ext.grid.EditorGridPanel({
    
 title: 'My EditorGridPanel',
     store: myStore,
     colModel: myColModel,
     tbar: [{
         text: 'Save',
        
 handler: saveChanges,
         disabled: true,
         ref: '../saveButton'
     }],
     listeners: {
         afteredit:
 function() {
 //          The button reference is in the GridPanel
             myGrid.saveButton.enable();
         }
    
 }
 }); In the code above, if the ref had been 'saveButton' the reference would have been placed into the Toolbar. Each
 '/' in the ref moves up one level from the Component's ownerCt. Also see the added and removed events.]]></description><name>ref</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout layout manager (e.g. specifying layout:'border'). See Ext.layout.BorderLayout also.]]></description><name>region</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The event to listen to for resizing in layouts. Defaults to 'bodyresize'.]]></description><name>resizeEvent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Any subclass of Ext.grid.AbstractSelectionModel that will provide the selection model for the grid (defaults to
 Ext.grid.RowSelectionModel if not specified).]]></description><name>selModel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true (or a valid Ext.Shadow Ext.Shadow.mode value) to display a shadow behind the panel, false to display no shadow
 (defaults to 'sides'). Note that this option only applies when floating = true.]]></description><name>shadow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The number of pixels to offset the shadow if displayed (defaults to 4). Note that this option only applies when floating
 = true.]]></description><name>shadowOffset</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[false to disable the iframe shim in browsers which need one (defaults to true). Note that this option only applies when
 floating = true.]]></description><name>shim</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Shorthand for selModel.]]></description><name>sm</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should trigger this component to save its state. Defaults to: stateEvents:
 ['columnmove', 'columnresize', 'sortchange', 'groupchange'] These can be any types of events supported by this
 component, including browser or custom events (e.g., ['click', 'customerchange']). See Ext.Component.stateful for an
 explanation of saving and restoring Component state.]]></description><name>stateEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id for this component to use for state management purposes (defaults to the component id if one was set,
 otherwise null if the component is using a generated id). See stateful for an explanation of saving and restoring
 Component state.]]></description><name>stateId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A flag which causes the Component to attempt to restore the state of internal properties from a saved state on startup.
 The component must have either a stateId or id assigned for state to be managed. Auto-generated ids are not guaranteed
 to be stable across page loads and cannot be relied upon to save and restore the same state for a component. For state
 saving to work, the state manager's provider must have been set to an implementation of Ext.state.Provider which
 overrides the set and get methods to save and recall name/value pairs. A built-in implementation,
 Ext.state.CookieProvider is available. To set the state provider for the current page: Ext.state.Manager.setProvider(new
 Ext.state.CookieProvider({
     expires: new Date(new Date().getTime()+(1000*60*60*24*7)), //7 days from now
 })); A
 stateful Component attempts to save state when one of the events listed in the stateEvents configuration fires. To save
 state, a stateful Component first serializes its state by calling getState. By default, this function does nothing. The
 developer must provide an implementation which returns an object hash which represents the Component's restorable state.
 The value yielded by getState is passed to Ext.state.Manager.set which uses the configured Ext.state.Provider to save
 the object keyed by the Component's stateId, or, if that is not specified, its id. During construction, a stateful
 Component attempts to restore its state by calling Ext.state.Manager.get passing the stateId, or, if that is not
 specified, the id. The resulting object is passed to applyState. The default implementation of applyState simply copies
 properties into the object, but a developer may override this to support more behaviour. You can perform extra
 processing on state save and restore by attaching handlers to the beforestaterestore, staterestore, beforestatesave and
 statesave events.]]></description><name>stateful</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to stripe the rows. Default is false. This causes the CSS class x-grid3-row-alt to be added to alternate rows of
 the grid. A default CSS rule is provided which sets a background colour, but you can override this with a rule which
 either overrides the background-color style using the '!important' modifier, or which uses a CSS selector of higher
 specificity.]]></description><name>stripeRows</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
     title: 'Some Title',
     renderTo: Ext.getBody(),
     width: 400, height:
 300,
     layout: 'form',
     items: [{
         xtype: 'textarea',
         style: {
             width: '95%',
            
 marginBottom: '10px'
         }
     },
         new Ext.Button({
             text: 'Send',
             minWidth: '100',
   
          style: {
                 marginBottom: '10px'
             }
         })
     ]
 });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is a child item of a TabPanel. A string to be used as innerHTML
 (html tags are accepted) to show in a tooltip when mousing over the associated tab selector element.
 Ext.QuickTips.init() must be called in order for the tips to render.]]></description><name>tabTip</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The title text to be used as innerHTML (html tags are accepted) to display in the panel header (defaults to ''). When a
 title is specified the header element will automatically be created and displayed unless header is explicitly set to
 false. If you do not want to specify a title at config time, but you may want one later, you must either specify a
 non-empty title (a blank space ' ' will do) or header:true so that the container element will get created.]]></description><name>title</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to allow expanding and collapsing the panel (when collapsible = true) by clicking anywhere in the header bar,
 false) to allow it only by clicking to tool button (defaults to false)). If this panel is a child item of a border
 layout also see the BorderLayout.Region floatable config option.]]></description><name>titleCollapse</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A Template used to create tools in the header Element. Defaults to: new Ext.Template('<div class="x-tool
 x-tool-{id}">&#160;</div>') This may may be overridden to provide a custom DOM structure for tools based upon a more
 complex XTemplate. The template's data is a single tool configuration object (Not the entire Array) as specified in
 tools. In the following example an <a> tag is used to provide a visual indication when hovering over the tool: var win =
 new Ext.Window({
     tools: [{
         id: 'download',
         href: '/MyPdfDoc.pdf'
     }],
     toolTemplate: new
 Ext.XTemplate(
         '<tpl if="id==\'download\'">',
             '<a class="x-tool x-tool-pdf" href="{href}"></a>',
    
 '</tpl>',
         '<tpl if="id!=\'download\'">',
             '<div class="x-tool x-tool-{id}">&#160;</div>',
        
 '</tpl>'
     ),
     width:500,
     height:300,
     closeAction:'hide'
 }); Note that the CSS class 'x-tool-pdf' should
 have an associated style rule which provides an appropriate background image, something like: a.x-tool-pdf
 {background-image: url(../shared/extjs/images/pdf.gif)!important;}]]></description><name>toolTemplate</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of tool button configs to be added to the header tool area. When rendered, each tool is stored as an Element
 referenced by a public property called tools.<tool-type> Each tool config may contain the following properties: id :
 String Required. The type of tool to create. By default, this assigns a CSS class of the form x-tool-<tool-type> to the
 resulting tool Element. Ext provides CSS rules, and an icon sprite containing images for the tool types listed below.
 The developer may implement custom tools by supplying alternate CSS rules and background images: toggle (Created by
 default when collapsible is true) close minimize maximize restore gear pin unpin right left up down refresh minus plus
 help search save print handler : Function Required. The function to call when clicked. Arguments passed are: event :
 Ext.EventObject The click event. toolEl : Ext.Element The tool Element. panel : Ext.Panel The host Panel tc : Object The
 tool configuration object stopEvent : Boolean Defaults to true. Specify as false to allow click event to propagate.
 scope : Object The scope in which to call the handler. qtip : String/Object A tip string, or a config argument to
 Ext.QuickTip.register hidden : Boolean True to initially render hidden. on : Object A listener config object specifiying
 event listeners in the format of an argument to addListener Note that, apart from the toggle tool which is provided when
 a panel is collapsible, these tools only provide the visual button. Any required functionality must be provided by
 adding handlers that implement the necessary behavior. Example usage: tools:[{
     id:'refresh',
     qtip: 'Refresh form
 Data',
     // hidden:true,
     handler: function(event, toolEl, panel){
         // refresh logic
     }
 },
 {
    
 id:'help',
     qtip: 'Get Help',
     handler: function(event, toolEl, panel){
         // whatever
     }
 }] For the
 custom id of 'help' define two relevant css classes with a link to a 15x15 image: .x-tool-help {background-image:
 url(images/help.png);}
 .x-tool-help-over {background-image: url(images/help_over.png);}
 // if using an image
 sprite:
 .x-tool-help {background-image: url(images/help.png) no-repeat 0 0;}
 .x-tool-help-over
 {background-position:-15px 0;}]]></description><name>tools</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to highlight rows when the mouse is over. Default is true for GridPanel, but false for EditorGridPanel.]]></description><name>trackMouseOver</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Overrides the baseCls setting to baseCls = 'x-plain' which renders the panel unstyled except for required attributes for
 Ext layouts to function (e.g. overflow:hidden).]]></description><name>unstyled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.grid.GridView used by the grid. This can be set before a call to render().]]></description><name>view</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A config object that will be applied to the grid's UI view. Any of the config options available for Ext.grid.GridView
 can be specified here. This option is ignored if view is specified.]]></description><name>viewConfig</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local x (left) coordinate for this component if contained within a positioning container.]]></description><name>x</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered xtype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a child item of a Container is being specified not
 as a fully instantiated Component, but as a Component config object. The xtype will be looked up at render time up to
 determine what type of child Component to create. The predefined xtypes are listed here. If you subclass Components to
 create your own Components, you may register them using Ext.ComponentMgr.registerType in order to be able to take
 advantage of lazy instantiation and rendering.]]></description><name>xtype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local y (top) coordinate for this component if contained within a positioning container.]]></description><name>y</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 <p>The PivotGrid component enables rapid summarization of large data sets. It provides a way to reduce a large set of
 data down into a format where trends and insights become more apparent. A classic example is in sales data; a company
 will often have a record of all sales it makes for a given period - this will often encompass thousands of rows of data.
 The PivotGrid allows you to see how well each salesperson performed, which cities generate the most revenue, how
 products perform between cities and so on.</p> 
 <p>A PivotGrid is composed of two axes (left and top), one <a
 href="output/Ext.grid.PivotGrid.html#Ext.grid.PivotGrid-measure" ext:member="measure"
 ext:cls="Ext.grid.PivotGrid">measure</a> and one <a href="output/Ext.grid.PivotGrid.html#Ext.grid.PivotGrid-aggregator"
 ext:member="aggregator" ext:cls="Ext.grid.PivotGrid">aggregation</a> function. Each axis can contain one or more <a
 href="output/Ext.grid.PivotGrid.html#Ext.grid.PivotGrid-dimension" ext:member="dimension"
 ext:cls="Ext.grid.PivotGrid">dimension</a>, which are ordered into a hierarchy. Dimensions on the left axis can also
 specify a width. Each dimension in each axis can specify its sort ordering, defaulting to &quot;ASC&quot;, and must
 specify one of the fields in the <a href="output/Ext.data.Record.html" ext:cls="Ext.data.Record">Record</a> used by the
 PivotGrid's <a href="output/Ext.data.Store.html" ext:cls="Ext.data.Store">Store</a>.</p> 
 <pre><code><i>// This is the
 record representing a single sale</i>
 <b>var</b> SaleRecord = Ext.data.Record.create([
     {name: <em>'person'</em>,  
 type: <em>'string'</em>},
     {name: <em>'product'</em>,  type: <em>'string'</em>},
     {name: <em>'city'</em>,    
 type: <em>'string'</em>},
     {name: <em>'state'</em>,    type: <em>'string'</em>},
     {name: <em>'year'</em>,    
 type: <em>'int'</em>},
     {name: <em>'value'</em>,    type: <em>'int'</em>}
 ]);
 
 <i>// A simple store that loads
 SaleRecord data from a url</i>
 <b>var</b> myStore = <b>new</b> Ext.data.Store({
     url: <em>'data.json'</em>,
    
 autoLoad: true,
     reader: <b>new</b> Ext.data.JsonReader({
         root: <em>'rows'</em>,
         idProperty:
 <em>'id'</em>
     }, SaleRecord)
 });
 
 <i>// Create the PivotGrid itself, referencing the store</i>
 <b>var</b> pivot =
 <b>new</b> Ext.grid.PivotGrid({
     store     : myStore,
     aggregator: <em>'sum'</em>,
     measure   :
 <em>'value'</em>,
 
     leftAxis: [
         {
             width: 60,
             dataIndex: <em>'product'</em>
        
 },
         {
             width: 120,
             dataIndex: <em>'person'</em>,
             direction: <em>'DESC'</em>
   
 }
     ],
 
     topAxis: [
         {
             dataIndex: <em>'year'</em>
         }
     ]
 });</code></pre> 
 <p>The
 specified <a href="output/Ext.grid.PivotGrid.html#Ext.grid.PivotGrid-measure" ext:member="measure"
 ext:cls="Ext.grid.PivotGrid">measure</a> is the field from SaleRecord that is extracted from each combination of product
 and person (on the left axis) and year on the top axis. There may be several SaleRecords in the data set that share this
 combination, so an array of measure fields is produced. This array is then aggregated using the <a
 href="output/Ext.grid.PivotGrid.html#Ext.grid.PivotGrid-aggregator" ext:member="aggregator"
 ext:cls="Ext.grid.PivotGrid">aggregator</a> function.</p> 
 <p>The default aggregator function is sum, which simply adds
 up all of the extracted measure values. Other built-in aggregator functions are count, avg, min and max. In addition,
 you can specify your own function. In this example we show the code used to sum the measures, but you can return any
 value you like. See <a href="output/Ext.grid.PivotGrid.html#Ext.grid.PivotGrid-aggregator" ext:member="aggregator"
 ext:cls="Ext.grid.PivotGrid">aggregator</a> for more details.</p> 
 <pre><code><b>new</b> Ext.grid.PivotGrid({
    
 aggregator: <b>function</b>(records, measure) {
         <b>var</b> length = records.length,
             total  = 0,
     
 i;
 
         <b>for</b> (i = 0; i &lt; length; i++) {
             total += records[i].get(measure);
         }
 
        
 <b>return</b> total;
     },
     
     renderer: <b>function</b>(value) {
         <b>return</b> Math.round(value);
     },
 
 
     <i>//your normal config here</i>
 });</code></pre> 
 <p><u>Renderers</u></p> 
 <p>PivotGrid optionally accepts a <a
 href="output/Ext.grid.PivotGrid.html#Ext.grid.PivotGrid-renderer" ext:member="renderer"
 ext:cls="Ext.grid.PivotGrid">renderer</a> function which can modify the data in each cell before it is rendered. The
 renderer is passed the value that would usually be placed in the cell and is expected to return the new value. For
 example let's imagine we had height data expressed as a decimal - here's how we might use a renderer to display the data
 in feet and inches notation:</p> 
 <pre><code><b>new</b> Ext.grid.PivotGrid({
     <i>//<b>in</b> each <b>case</b> the
 value is a decimal number of feet</i>
     renderer  : <b>function</b>(value) {
         <b>var</b> feet   =
 Math.floor(value),
             inches = Math.round((value - feet) * 12);
 
         <b>return</b>
 String.format(<em>&quot;{0}<em>' {1}\&quot;</em><em>&quot;, feet, inches);
     },
     <i>//normal config
 here</i>
 });</em></em></code></pre>
 <em><em> <p><u>Reconfiguring</u></p> <p>All aspects PivotGrid's configuration can be
 updated at runtime. It is easy to change the <a href="output/Ext.grid.PivotGrid.html#Ext.grid.PivotGrid-setMeasure"
 ext:member="setMeasure" ext:cls="Ext.grid.PivotGrid">measure</a>, <a
 href="output/Ext.grid.PivotGrid.html#Ext.grid.PivotGrid-setAggregator" ext:member="setAggregator"
 ext:cls="Ext.grid.PivotGrid">aggregation function</a>, <a
 href="output/Ext.grid.PivotGrid.html#Ext.grid.PivotGrid-setLeftAxis" ext:member="setLeftAxis"
 ext:cls="Ext.grid.PivotGrid">left</a> and <a href="output/Ext.grid.PivotGrid.html#Ext.grid.PivotGrid-setTopAxis"
 ext:member="setTopAxis" ext:cls="Ext.grid.PivotGrid">top</a> axes and refresh the grid.</p> <p>In this case we
 reconfigure the PivotGrid to have city and year as the top axis dimensions, rendering the average sale value into the
 cells:</p> <pre><code><i>//the left axis can also be changed</i>
 pivot.topAxis.setDimensions([
     {dataIndex:
 <em>'city'</em>, direction: <em>'DESC'</em>},
     {dataIndex: <em>'year'</em>, direction:
 <em>'ASC'</em>}
 ]);
 
 pivot.setMeasure(<em>'value'</em>);
 pivot.setAggregator(<em>'avg'</em>);
 
 pivot.view.refresh(true);</code></pre>
 <p>See the <a href="output/Ext.grid.PivotAxis.html" ext:cls="Ext.grid.PivotAxis">PivotAxis</a> documentation for further
 detail on reconfiguring axes.</p></em></em>]]></description><name>grid.pivot</name><tag-class>org.brushingbits.jnap.ui.extjs3.grid.PivotGrid</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[A string component id or the numeric index of the component that should be initially activated within the container's
 layout on render. For example, activeItem: 'item-1' or activeItem: 0 (index 0 = the first item in the container's
 collection). activeItem only applies to layout styles that can display items one at a time (like
 Ext.layout.AccordionLayout, Ext.layout.CardLayout and Ext.layout.FitLayout). Related to
 Ext.layout.ContainerLayout.activeItem.]]></description><name>activeItem</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The aggregation function to use to combine the measures extracted for each dimension combination. Can be any of the
 built-in aggregators (sum, count, avg, min, max). Can also be a function which accepts two arguments (an array of
 Records to aggregate, and the measure to aggregate them on) and should return a String.]]></description><name>aggregator</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Whether the component can move the Dom node when rendering (defaults to true).]]></description><name>allowDomMove</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use an
 AnchorLayout (or subclass thereof). based layout manager, for example: Ext.form.FormPanel specifying layout: 'anchor' //
 or 'form', or 'absolute' See Ext.layout.AnchorLayout.anchor also.]]></description><name>anchor</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to animate the transition when the panel is collapsed, false to skip the animation (defaults to true if the Ext.Fx
 class is available, otherwise false).]]></description><name>animCollapse</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The id of the node, a DOM node or an existing Element corresponding to a DIV that is already present in the document
 that specifies some panel-specific structural markup. When applyTo is used, constituent parts of the panel can be
 specified by CSS class name within the main element, and the panel will automatically create those components from that
 markup. Any required components not specified in the markup will be autogenerated if necessary. The following class
 names are supported (baseCls will be replaced by baseCls): baseCls + '-header' baseCls + '-header-text' baseCls +
 '-bwrap' baseCls + '-tbar' baseCls + '-body' baseCls + '-bbar' baseCls + '-footer' Using this config, a call to render()
 is not required. If applyTo is specified, any value passed for renderTo will be ignored and the target element's parent
 node will automatically be used as the panel's container.]]></description><name>applyTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If true the container will automatically destroy any contained component that is removed from it, else destruction must
 be handled manually (defaults to true).]]></description><name>autoDestroy</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A tag name or DomHelper spec used to create the Element which will encapsulate this Component. You do not normally need
 to specify this. For the base classes Ext.Component, Ext.BoxComponent, and Ext.Container, this defaults to 'div'. The
 more complex Ext classes use a more complex DOM structure created by their own onRender methods. This is intended to
 allow the developer to create application-specific utility Components encapsulated by different DOM elements. Example
 usage: <pre><code>{
     xtype: 'box',
     autoEl: {
         tag: 'img',
         src: 'http://www.example.com/example.jpg'
     }
 },
 {
     xtype: 'box',
     autoEl: {
         tag: 'blockquote',
         html: 'autoEl is cool!'
     }
 }, {
     xtype: 'container',
     autoEl: 'ul',
     cls: 'ux-unordered-list',
     items: {
         xtype: 'box',
         autoEl: 'li',
   
      html: 'First list item'
     }
 }</pre></code>]]></description><name>autoEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The id of a column in this grid that should expand to fill unused space. This value specified here can not be 0. Note:
 If the Grid's view is configured with forceFit=true the autoExpandColumn is ignored. See Ext.grid.Column.width for
 additional details. See autoExpandMax and autoExpandMin also.]]></description><name>autoExpandColumn</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum width the autoExpandColumn can have (if enabled). Defaults to 1000.]]></description><name>autoExpandMax</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum width the autoExpandColumn can have (if enabled). Defaults to 50.]]></description><name>autoExpandMin</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to use height:'auto', false to use fixed height (defaults to false). Note: Setting autoHeight: true means that the
 browser will manage the panel's height based on its contents, and that Ext will not manage it at all. If the panel is
 within a layout that manages dimensions (fit, border, etc.) then setting autoHeight: true can cause issues with
 scrolling and will not generally work as expected since the panel will take on the height of its contents rather than
 the height required by the Ext layout.]]></description><name>autoHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A valid url spec according to the Updater Ext.Updater.update method. If autoLoad is not null, the panel will attempt to
 load its contents immediately upon render. The URL will become the default URL for this panel's body element, so it may
 be refreshed at any time.]]></description><name>autoLoad</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to use overflow:'auto' on the components layout element and show scroll bars automatically when necessary, false to
 clip any overflowing content (defaults to false).]]></description><name>autoScroll</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True if the component should check for hidden classes (e.g. 'x-hidden' or 'x-hide-display') and remove them on render
 (defaults to false).]]></description><name>autoShow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to use width:'auto', false to use fixed width (or allow it to be managed by its parent Container's layout manager.
 Defaults to false. Note: Although many components inherit this config option, not all will function as expected with a
 width of 'auto'. Setting autoWidth:true means that the browser will manage width based on the element's contents, and
 that Ext will not manage it at all. If the browser is managing the width, be aware that resizes performed by the browser
 in response to changes within the structure of the Component cannot be detected. Therefore changes to the width might
 result in elements needing to be synchronized with the new width. For example, where the target element is: <div
 id='grid-container' style='margin-left:25%;width:50%'></div> A Panel rendered into that target element must listen for
 browser window resize in order to relay its child items when the browser changes its width: var myPanel = new
 Ext.Panel({
     renderTo: 'grid-container',
     monitorResize: true, // relay on browser resize
     title: 'Panel',
    
 height: 400,
     autoWidth: true,
     layout: 'hbox',
     layoutConfig: {
         align: 'stretch'
     },
     defaults: {
         flex: 1
     },
     items: [{
         title: 'Box 1',
     }, {
         title: 'Box 2'
     }, {
         title:
 'Box 3'
     }],
 });]]></description><name>autoWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The base CSS class to apply to this panel's element (defaults to 'x-panel'). Another option available by default is to
 specify 'x-plain' which strips all styling except for required attributes for Ext layouts to function (e.g.
 overflow:hidden). See unstyled also.]]></description><name>baseCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to display an interior border on the body element of the panel, false to hide it (defaults to true). This only
 applies when border == true. If border == true and bodyBorder == false, the border will display as a 1px wide inset
 border, giving the entire body element an inset appearance.]]></description><name>bodyBorder</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A DomHelper element specification object may be specified for any Panel Element. By default, the Default element in the
 table below will be used for the html markup to create a child element with the commensurate Default class name (baseCls
 will be replaced by baseCls): 
 Panel      Default  Default             Custom      Additional       Additional
 Element  
 element  class               element     class            style
 ========   ==========================   =========  
 ==============   ===========
 header     div      baseCls+'-header'   headerCfg   headerCssClass   headerStyle
 bwrap     
 div      baseCls+'-bwrap'     bwrapCfg    bwrapCssClass    bwrapStyle
 + tbar     div      baseCls+'-tbar'       tbarCfg 
 tbarCssClass     tbarStyle
 + body     div      baseCls+'-body'       bodyCfg     bodyCssClass     bodyStyle
 + bbar    
 div      baseCls+'-bbar'       bbarCfg     bbarCssClass     bbarStyle
 + footer   div      baseCls+'-footer'   footerCfg 
 footerCssClass   footerStyle
  Configuring a Custom element may be used, for example, to force the body Element to use a
 different form of markup than is created by default. An example of this might be to create a child Panel containing a
 custom content, such as a header, or forcing centering of all Panel content by having the body be a <center> element:
 new Ext.Panel({
     title: 'Message Title',
     renderTo: Ext.getBody(),
     width: 200, height: 130,
     bodyCfg: {
    
 tag: 'center',
         cls: 'x-panel-body',  // Default class not applied if Custom element specified
         html:
 'Message'
     },
     footerCfg: {
         tag: 'h2',
         cls: 'x-panel-footer',        // same as the Default class
 
 html: 'footer html'
     },
     footerCssClass: 'custom-footer', // additional css class, see addClass
     footerStyle:  
 'background-color:red' // see bodyStyle
 }); The example above also explicitly creates a footer with custom markup and
 styling applied.]]></description><name>bodyCfg</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Additional css class selector to be applied to the body element in the format expected by Ext.Element.addClass (defaults
 to null). See bodyCfg.]]></description><name>bodyCssClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Custom CSS styles to be applied to the body element in the format expected by Ext.Element.applyStyles (defaults to
 null). See bodyCfg.]]></description><name>bodyStyle</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to display the borders of the panel's body element, false to hide them (defaults to true). By default, the border
 is a 2px wide inset border, but this can be further altered by setting bodyBorder to false.]]></description><name>border</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to [].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[When set to true (50 milliseconds) or a number of milliseconds, the layout assigned for this container will buffer the
 frequency it calculates and does a re-layout of components. This is useful for heavy containers or containers with a
 large quantity of sub-components for which frequent layout calls would be expensive. Defaults to 50.]]></description><name>bufferResize</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The alignment of any buttons added to this panel. Valid values are 'right', 'left' and 'center' (defaults to 'right').]]></description><name>buttonAlign</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A DomHelper element specification object specifying the element structure of this Panel's bwrap Element. See bodyCfg
 also.]]></description><name>bwrapCfg</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class used to to apply to the special clearing div rendered directly after each form field wrapper to provide
 field clearing (defaults to 'x-form-clear-left'). Note: this config is only used when this Component is rendered by a
 Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or specifying
 layout:'form') and either a fieldLabel is specified or isFormField=true is specified. See Ext.layout.FormLayout.fieldTpl
 also.]]></description><name>clearCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Panels themselves do not directly support being closed, but some Panel subclasses do (like Ext.Window) or a Panel Class
 within an Ext.TabPanel. Specify true to enable closing in such situations. Defaults to false.]]></description><name>closable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element (defaults to ''). This can be useful for
 adding customized styles to the component or any of its children using standard CSS rules.]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Shorthand for colModel.]]></description><name>cm</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to make sure the collapse/expand toggle button always renders first (to the left of) any other tools in the panel's
 title bar, false to render it last (defaults to true).]]></description><name>collapseFirst</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to render the panel collapsed, false to render it expanded (defaults to false).]]></description><name>collapsed</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS class to add to the panel's element after it has been collapsed (defaults to 'x-panel-collapsed').]]></description><name>collapsedCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to make the panel collapsible and have the expand/collapse toggle button automatically rendered into the header
 tool button area, false to keep the panel statically sized with no button (defaults to false).]]></description><name>collapsible</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to add css for column separation lines. Default is false.]]></description><name>columnLines</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's container. This can be useful for adding customized
 styles to the container or any of its children using standard CSS rules. See Ext.layout.ContainerLayout.extraCls also.
 Note: ctCls defaults to '' except for the following class which assigns a value by default: Box Layout :
 'x-box-layout-ct' To configure the above Class with an extra CSS class append to the default. For example, for BoxLayout
 (Hbox and Vbox): ctCls: 'x-box-layout-ct custom-class']]></description><name>ctCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The DD group this GridPanel belongs to. Defaults to 'GridDD' if not specified.]]></description><name>ddGroup</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Configures the text in the drag proxy. Defaults to: ddText : '{0} selected row{1}' {0} is replaced with the number of
 selected rows.]]></description><name>ddText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default xtype of child Components to create in this Container when a child item is specified as a raw configuration
 object, rather than as an instantiated Component. Defaults to 'panel', except Ext.menu.Menu which defaults to
 'menuitem', and Ext.Toolbar and Ext.ButtonGroup which default to 'button'.]]></description><name>defaultType</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[This option is a means of applying default settings to all added items whether added through the items config or via the
 add or insert methods. If an added item is a config object, and not an instantiated Component, then the default
 properties are unconditionally applied. If the added item is an instantiated Component, then the default properties are
 applied conditionally so as not to override existing properties in the item. If the defaults option is specified as a
 function, then the function will be called using this Container as the scope (this reference) and passing the added item
 as the first parameter. Any resulting object from that call is then applied to the item as default properties. For
 example, to automatically apply padding to the body of each of a set of contained Ext.Panel items, you could pass:
 defaults: {bodyStyle:'padding:15px'}. Usage: defaults: {               // defaults are applied to items, not the
 container
     autoScroll:true
 },
 items: [
     {
         xtype: 'panel',   // defaults do not have precedence over
       
 id: 'panel1',     // options in config objects, so the defaults
         autoScroll: false // will not be applied here,
 panel1 will be autoScroll:false
     },
     new Ext.Panel({       // defaults do have precedence over options
         id:
 'panel2',     // options in components, so the defaults
         autoScroll: false // will be applied here, panel2 will
 be autoScroll:true.
     })
 ]]]></description><name>defaults</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to true to enable deferred row rendering. This allows the GridPanel to be initially rendered empty, with the
 expensive update of the row structure deferred so that layouts with GridPanels appear more quickly.]]></description><name>deferRowRender</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to disable selections in the grid. Defaults to false. Ignored if a SelectionModel is specified.]]></description><name>disableSelection</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this panel disabled (default is false). An important note when using the disabled config on panels is that IE
 will often fail to initialize the disabled mask element correectly if the panel's layout has not yet completed by the
 time the Panel is disabled during the render process. If you experience this issue, you may need to instead use the
 afterlayout event to initialize the disabled state: new Ext.Panel({
     ...
     listeners: {
         'afterlayout': {
   
 fn: function(p){
                 p.disable();
             },
             single: true // important, as many layouts can
 occur
         }
     }
 });]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class added to the component when it is disabled (defaults to 'x-item-disabled').]]></description><name>disabledClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to enable dragging of this Panel (defaults to false). For custom drag/drop implementations, an Ext.Panel.DD config
 could also be passed in this config instead of true. Ext.Panel.DD is an internal, undocumented class which moves a proxy
 Element around in place of the Panel's element, but provides no other behaviour during dragging or on drop. It is a
 subclass of Ext.dd.DragSource, so behaviour may be added by implementing the interface methods of Ext.dd.DragDrop e.g.:
 new Ext.Panel({
     title: 'Drag me',
     x: 100,
     y: 100,
     renderTo: Ext.getBody(),
     floating: true,
    
 frame: true,
     width: 400,
     height: 200,
     draggable: {
 //      Config option of Ext.Panel.DD class.
 //      It's
 a floating Panel, so do not show a placeholder proxy in the original position.
         insertProxy: false,
 
 //     
 Called for each mousemove event while dragging the DD object.
         onDrag : function(e){
 //          Record the x,y
 position of the drag proxy so that we can
 //          position the Panel at end of drag.
             var pel =
 this.proxy.getEl();
             this.x = pel.getLeft(true);
             this.y = pel.getTop(true);
 
 //          Keep the
 Shadow aligned if there is one.
             var s = this.panel.getEl().shadow;
             if (s) {
                
 s.realign(this.x, this.y, pel.getWidth(), pel.getHeight());
             }
         },
 
 //      Called on the mouseup
 event.
         endDrag : function(e){
             this.panel.setPosition(this.x, this.y);
         }
     }
 }).show();]]></description><name>draggable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A comma-delimited list of panel elements to initialize when the panel is rendered. Normally, this list will be generated
 automatically based on the items added to the panel at config time, but sometimes it might be useful to make sure a
 structural element is rendered even if not specified at config time (for example, you may want to add a button or
 toolbar dynamically after the panel has been rendered). Adding those elements to this list will allocate the required
 placeholders in the panel when it is rendered. Valid values are header tbar (top bar) body bbar (bottom bar) footer
 Defaults to 'body'.]]></description><name>elements</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to true to enable hiding of columns with the header menu.]]></description><name>enableColumnHide</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to true to enable drag and drop reorder of columns. false to turn off column reordering via drag drop.]]></description><name>enableColumnMove</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[false to turn off column resizing for the whole grid. Defaults to true.]]></description><name>enableColumnResize</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Enables dragging of the selected rows of the GridPanel. Defaults to false. Setting this to true causes this GridPanel's
 GridView to create an instance of Ext.grid.GridDragZone. Note: this is available only after the Grid has been rendered
 as the GridView's dragZone property. A cooperating DropZone must be created who's implementations of onNodeEnter,
 onNodeOver, onNodeOut and onNodeDrop are able to process the data which is provided.]]></description><name>enableDragDrop</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to true to enable the drop down button for menu in the headers.]]></description><name>enableHdMenu</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A Toolbar object, a Toolbar config, or an array of Buttons/Button configs, describing a Toolbar to be rendered into this
 Panel's footer element. After render, the fbar property will be an Toolbar instance. If buttons are specified, they will
 supersede the fbar configuration property. The Panel's buttonAlign configuration affects the layout of these items, for
 example: var w = new Ext.Window({
     height: 250,
     width: 500,
     bbar: new Ext.Toolbar({
         items: [{
        
 text: 'bbar Left'
         },'->',{
             text: 'bbar Right'
         }]
     }),
     buttonAlign: 'left', //
 anything but 'center' or 'right' and you can use '-', and '->'
                                   // to control the
 alignment of fbar items
     fbar: [{
         text: 'fbar Left'
     },'->',{
         text: 'fbar Right'
     }]
 }).show();
 Note: Although a Toolbar may contain Field components, these will not be updated by a load of an ancestor FormPanel. A
 Panel's toolbars are not part of the standard Container->Component hierarchy, and so are not scanned to collect form
 items. However, the values will be submitted because form submission parameters are collected from the DOM tree.]]></description><name>fbar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The label text to display next to this Component (defaults to ''). Note: this config is only used when this Component is
 rendered by a Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or
 specifying layout:'form'). Also see hideLabel and Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
    
 height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name'
    
 }]
 });]]></description><name>fieldLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use a
 BoxLayout. Each child Component with a flex property will be flexed either vertically (by a VBoxLayout) or horizontally
 (by an HBoxLayout) according to the item's relative flex value compared to the sum of all Components with flex value
 specified. Any child items that have either a flex = 0 or flex = undefined will not be 'flexed' (the initial size will
 not be changed).]]></description><name>flex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[This property is used to configure the underlying Ext.Layer. Acceptable values for this configuration property are:
 false : Default. Display the panel inline where it is rendered. true : Float the panel (absolute position it with
 automatic shimming and shadow). Setting floating to true will create an Ext.Layer for this panel and display the panel
 at negative offsets so that it is hidden. Since the panel will be absolute positioned, the position must be set
 explicitly after render (e.g., myPanel.setPosition(100,100);). Note: when floating a panel you should always assign a
 fixed width, otherwise it will be auto width and will expand to fill to the right edge of the viewport. object : The
 specified object will be used as the configuration object for the Ext.Layer that will be created.]]></description><name>floating</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to create the footer element explicitly, false to skip creating it. The footer will be created automatically if
 buttons or a fbar have been configured. See bodyCfg for an example.]]></description><name>footer</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A DomHelper element specification object specifying the element structure of this Panel's footer Element. See bodyCfg
 also.]]></description><name>footerCfg</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If true the container will force a layout initially even if hidden or collapsed. This option is useful for forcing forms
 to render in collapsed or hidden containers. (defaults to false).]]></description><name>forceLayout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[false by default to render with plain 1px square borders. true to render with 9 elements, complete with custom rounded
 corners (also see Ext.Element.boxWrap). The template generated for each condition is depicted below: // frame =
 false
 <div id="developer-specified-id-goes-here" class="x-panel">
 
     <div class="x-panel-header"><span
 class="x-panel-header-text">Title: (frame:false)</span></div>
 
     <div class="x-panel-bwrap">
         <div
 class="x-panel-body"><p>html value goes here</p></div>
     </div>
 </div>
 
 // frame = true (create 9 elements)
 <div
 id="developer-specified-id-goes-here" class="x-panel">
     <div class="x-panel-tl"><div class="x-panel-tr"><div
 class="x-panel-tc">
         <div class="x-panel-header"><span class="x-panel-header-text">Title:
 (frame:true)</span></div>
     </div></div></div>
 
     <div class="x-panel-bwrap">
         <div class="x-panel-ml"><div
 class="x-panel-mr"><div class="x-panel-mc">
             <div class="x-panel-body"><p>html value goes here</p></div>
     
 </div></div></div>
 
         <div class="x-panel-bl"><div class="x-panel-br"><div class="x-panel-bc"/>
        
 </div></div></div>
 </div>]]></description><name>frame</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to create the Panel's header element explicitly, false to skip creating it. If a title is set the header will be
 created automatically, otherwise it will not. If a title is set but header is explicitly set to false, the header will
 not be rendered.]]></description><name>header</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to display the panel title in the header, false to hide it (defaults to true).]]></description><name>headerAsText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A DomHelper element specification object specifying the element structure of this Panel's header Element. See bodyCfg
 also.]]></description><name>headerCfg</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component hidden (default is false). If true, the hide method will be called internally.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide the borders of each contained component, false to defer to the component's existing border settings
 (defaults to false).]]></description><name>hideBorders</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to hide the expand/collapse toggle button when collapsible == true, false to display it (defaults to false).]]></description><name>hideCollapseTool</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide the grid's header. Defaults to false.]]></description><name>hideHeaders</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to completely hide the label element (label and separator). Defaults to false. By default, even if you do not
 specify a fieldLabel the space will still be reserved so that the field will line up with other fields that do have
 labels. Setting this to true will cause the field to not reserve that space. Note: see the note for clearCls. Example
 use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield'
        
 hideLabel: true
     }]
 });]]></description><name>hideLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[How this component should be hidden. Supported values are 'visibility' (css visibility), 'offsets' (negative offset
 position) and 'display' (css display). Note: the default of 'display' is generally preferred since items are
 automatically laid out when they are first shown (no sizing is done while hidden).]]></description><name>hideMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide and show the component's container when hide/show is called on the component, false to hide and show the
 component itself (defaults to false). For example, this can be used as a shortcut for a hide button on a window by
 setting hide:true on the button when adding it to its parent container.]]></description><name>hideParent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class selector that specifies a background image to be used as the header icon (defaults to ''). An example of
 specifying a custom icon class would be something like: // specify the property in the config for the class:
      ...
   
 iconCls: 'my-icon'
 
 // css class that specifies background image to be used as the icon image:
 .my-icon {
 background-image: url(../images/my-icon.gif) 0 6px no-repeat !important; }]]></description><name>iconCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id of this component (defaults to an auto-assigned id). You should assign an id if you need to be able to
 access the component later and you do not have an object reference available (e.g., using Ext.getCmp). Note that this id
 will also be used as the element id for the containing HTML element that is rendered to the page for this component.
 This allows you to write id-based CSS rules to style the specific instance of this component uniquely, and also to
 select sub-elements using this component's id as the parent. Note: to avoid complications imposed by a unique id also
 see itemId and ref. Note: to access the container of an item see ownerCt.]]></description><name>id</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use the
 FormLayout layout manager (e.g. Ext.form.FormPanel or specifying layout:'form'). An additional CSS class to apply to the
 div wrapping the form item element of this field. If supplied, itemCls at the field level will override the default
 itemCls supplied at the container level. The value specified for itemCls will be added to the default class
 ('x-form-item'). Since it is applied to the item wrapper (see Ext.layout.FormLayout.fieldTpl), it allows you to write
 standard CSS rules that can apply to the field, the label (if specified), or any other element within the markup for the
 field. Note: see the note for fieldLabel. Example use: // Apply a style to the field's label:
 <style>
     .required
 .x-form-item-label {font-weight:bold;color:red;}
 </style>
 
 new Ext.FormPanel({
     height: 100,
     renderTo:
 Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         itemCls: 'required' //this
 label will be styled
     },{
         xtype: 'textfield',
         fieldLabel: 'Favorite Color'
     }]
 });]]></description><name>itemCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An itemId can be used as an alternative way to get a reference to a component when no object reference is available.
 Instead of using an id with Ext.getCmp, use itemId with Ext.Container.getComponent which will retrieve itemId's or id's.
 Since itemId's are an index to the container's internal MixedCollection, the itemId is scoped locally to the container
 -- avoiding potential conflicts with Ext.ComponentMgr which requires a unique id. var c = new Ext.Panel({ //
     height:
 300,
     renderTo: document.body,
     layout: 'auto',
     items: [
         {
             itemId: 'p1',
            
 title: 'Panel 1',
             height: 150
         },
         {
             itemId: 'p2',
             title: 'Panel 2',
  
 height: 150
         }
     ]
 })
 p1 = c.getComponent('p1'); // not the same as Ext.getCmp()
 p2 =
 p1.ownerCt.getComponent('p2'); // reference via a sibling Also see id and ref. Note: to access the container of an item
 see ownerCt.]]></description><name>itemId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A Ext.KeyMap config object (in the format expected by Ext.KeyMap.addBinding used to assign custom key handling to this
 panel (defaults to null).]]></description><name>keys</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The separator to display after the text of each fieldLabel. This property may be configured at various levels. The order
 of precedence is: field / component level container level layout level (defaults to colon ':') To display no separator
 for this field's label specify empty string ''. Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 layoutConfig: {
         labelSeparator: '~'   // layout config has lowest priority (defaults to ':')
     },
    
 labelSeparator: '>>',     // config at container level
     items: [{
         xtype: 'textfield',
         fieldLabel:
 'Field 1',
         labelSeparator: '...' // field/component level config supersedes others
     },{
         xtype:
 'textfield',
         fieldLabel: 'Field 2' // labelSeparator will be '='
     }]
 });]]></description><name>labelSeparator</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS style specification string to apply directly to this field's label. Defaults to the container's labelStyle value
 if set (e.g., Ext.layout.FormLayout.labelStyle , or ''). Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         labelStyle: 'font-weight:bold;'
     }]
 });]]></description><name>labelStyle</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[*Important: In order for child items to be correctly sized and positioned, typically a layout manager must be specified
 through the layout configuration option. The sizing and positioning of child items is the responsibility of the
 Container's layout manager which creates and manages the type of layout you have in mind. For example:
 <pre><code>
 new Ext.Window({
 
 width:300, height: 300,
     layout: 'fit', // explicitly set layout manager: override the default (layout:'auto')
    
 items: [{
         title: 'Panel inside a Window'
     }]
 }).show();</pre></code>
 If the layout configuration is not explicitly
 specified for a general purpose container (e.g. Container or Panel) the default layout manager will be used which does
 nothing but render child components sequentially into the Container (no sizing or positioning will be performed in this
 situation). Some container classes implicitly specify a default layout (e.g. FormPanel specifies layout:'form'). Other
 specific purpose classes internally specify/manage their internal layout (e.g. GridPanel, TabPanel, TreePanel, Toolbar,
 Menu, etc.). layout may be specified as either as an Object or as a String: Specify as an Object Example usage: layout:
 {
     type: 'vbox',
     padding: '5',
     align: 'left'
 } type The layout type to be used for this container. If not
 specified, a default Ext.layout.ContainerLayout will be created and used. Valid layout type values are: absolute
 accordion anchor auto Default border card column fit form hbox menu table toolbar vbox Layout specific configuration
 properties Additional layout specific configuration properties may also be specified. For complete details regarding the
 valid config options for each layout type, see the layout class corresponding to the type specified. Specify as a String
 Example usage: layout: 'vbox',
 layoutConfig: {
     padding: '5',
     align: 'left'
 } layout The layout type to be used
 for this container (see list of valid layout type values above). layoutConfig Additional layout specific configuration
 properties. For complete details regarding the valid config options for each layout type, see the layout class
 corresponding to the layout specified.]]></description><name>layout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Either and array of dimension to use on the left axis, or a Ext.grid.PivotAxis instance. If an array is passed, it is
 turned into a PivotAxis internally.]]></description><name>leftAxis</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An Ext.LoadMask config or true to mask the grid while loading. Defaults to false.]]></description><name>loadMask</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout or one of the two BoxLayout subclasses. An object containing margins to apply to this BoxComponent in the
 format: {
     top: (top margin),
     right: (right margin),
     bottom: (bottom margin),
     left: (left margin)
 } May
 also be a string containing space-separated, numeric margin values. The order of the sides associated with each value
 matches the way CSS processes margin values: If there is only one value, it applies to all sides. If there are two
 values, the top and bottom borders are set to the first value and the right and left are set to the second. If there are
 three values, the top is set to the first value, the left and right are set to the second, and the bottom is set to the
 third. If there are four values, they apply to the top, right, bottom, and left, respectively. Defaults to: {top:0,
 right:0, bottom:0, left:0}]]></description><name>margins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to mask the panel when it is disabled, false to not mask it (defaults to true). Either way, the panel will always
 tell its contained elements to disable themselves when it is disabled, but masking the panel can provide an additional
 visual cue that the panel is disabled.]]></description><name>maskDisabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Sets the maximum height of the grid - ignored if autoHeight is not on.]]></description><name>maxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The field to extract from each Record when pivoting around the two axes. See the class introduction docs for usage]]></description><name>measure</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Minimum width in pixels of all buttons in this panel (defaults to 75)]]></description><name>minButtonWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum width a column can be resized to. Defaults to 25.]]></description><name>minColumnWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically monitor window resize events to handle anything that is sensitive to the current size of the
 viewport. This value is typically managed by the chosen layout and should not need to be set manually.]]></description><name>monitorResize</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element when the mouse moves over the Element, and
 removed when the mouse moves out. (defaults to ''). This can be useful for adding customized 'active' or 'hover' styles
 to the component or any of its children using standard CSS rules.]]></description><name>overCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A shortcut for setting a padding style on the body element. The value can either be a number to be applied to all sides,
 or a normal css string describing padding. Defaults to undefined.]]></description><name>padding</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level x coordinate for this component if contained within a positioning container.]]></description><name>pageX</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level y coordinate for this component if contained within a positioning container.]]></description><name>pageY</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to false. When set to true, an extra css class 'x-panel-normal' will be added to the panel's element,
 effectively applying css styles suggested by the W3C (see http://www.w3.org/TR/CSS21/sample.html) to the Panel's body
 element (not the header, footer, etc.).]]></description><name>preventBodyReset</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered ptype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a Plugin is being specified not as a fully
 instantiated Component, but as a Component config object. The ptype will be looked up at render time up to determine
 what type of Plugin to create. If you create your own Plugins, you may register them using
 Ext.ComponentMgr.registerPlugin in order to be able to take advantage of lazy instantiation and rendering.]]></description><name>ptype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A path specification, relative to the Component's ownerCt specifying into which ancestor Container to place a named
 reference to this Component. The ancestor axis can be traversed by using '/' characters in the path. For example, to put
 a reference to a Toolbar Button into the Panel which owns the Toolbar: var myGrid = new Ext.grid.EditorGridPanel({
    
 title: 'My EditorGridPanel',
     store: myStore,
     colModel: myColModel,
     tbar: [{
         text: 'Save',
        
 handler: saveChanges,
         disabled: true,
         ref: '../saveButton'
     }],
     listeners: {
         afteredit:
 function() {
 //          The button reference is in the GridPanel
             myGrid.saveButton.enable();
         }
    
 }
 }); In the code above, if the ref had been 'saveButton' the reference would have been placed into the Toolbar. Each
 '/' in the ref moves up one level from the Component's ownerCt. Also see the added and removed events.]]></description><name>ref</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout layout manager (e.g. specifying layout:'border'). See Ext.layout.BorderLayout also.]]></description><name>region</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional renderer to pass values through before they are rendered to the dom. This gives an opportunity to modify cell
 contents after the value has been computed.]]></description><name>renderer</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The event to listen to for resizing in layouts. Defaults to 'bodyresize'.]]></description><name>resizeEvent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Any subclass of Ext.grid.AbstractSelectionModel that will provide the selection model for the grid (defaults to
 Ext.grid.RowSelectionModel if not specified).]]></description><name>selModel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true (or a valid Ext.Shadow Ext.Shadow.mode value) to display a shadow behind the panel, false to display no shadow
 (defaults to 'sides'). Note that this option only applies when floating = true.]]></description><name>shadow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The number of pixels to offset the shadow if displayed (defaults to 4). Note that this option only applies when floating
 = true.]]></description><name>shadowOffset</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[false to disable the iframe shim in browsers which need one (defaults to true). Note that this option only applies when
 floating = true.]]></description><name>shim</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Shorthand for selModel.]]></description><name>sm</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should trigger this component to save its state. Defaults to: stateEvents:
 ['columnmove', 'columnresize', 'sortchange', 'groupchange'] These can be any types of events supported by this
 component, including browser or custom events (e.g., ['click', 'customerchange']). See Ext.Component.stateful for an
 explanation of saving and restoring Component state.]]></description><name>stateEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id for this component to use for state management purposes (defaults to the component id if one was set,
 otherwise null if the component is using a generated id). See stateful for an explanation of saving and restoring
 Component state.]]></description><name>stateId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A flag which causes the Component to attempt to restore the state of internal properties from a saved state on startup.
 The component must have either a stateId or id assigned for state to be managed. Auto-generated ids are not guaranteed
 to be stable across page loads and cannot be relied upon to save and restore the same state for a component. For state
 saving to work, the state manager's provider must have been set to an implementation of Ext.state.Provider which
 overrides the set and get methods to save and recall name/value pairs. A built-in implementation,
 Ext.state.CookieProvider is available. To set the state provider for the current page: Ext.state.Manager.setProvider(new
 Ext.state.CookieProvider({
     expires: new Date(new Date().getTime()+(1000*60*60*24*7)), //7 days from now
 })); A
 stateful Component attempts to save state when one of the events listed in the stateEvents configuration fires. To save
 state, a stateful Component first serializes its state by calling getState. By default, this function does nothing. The
 developer must provide an implementation which returns an object hash which represents the Component's restorable state.
 The value yielded by getState is passed to Ext.state.Manager.set which uses the configured Ext.state.Provider to save
 the object keyed by the Component's stateId, or, if that is not specified, its id. During construction, a stateful
 Component attempts to restore its state by calling Ext.state.Manager.get passing the stateId, or, if that is not
 specified, the id. The resulting object is passed to applyState. The default implementation of applyState simply copies
 properties into the object, but a developer may override this to support more behaviour. You can perform extra
 processing on state save and restore by attaching handlers to the beforestaterestore, staterestore, beforestatesave and
 statesave events.]]></description><name>stateful</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to stripe the rows. Default is false. This causes the CSS class x-grid3-row-alt to be added to alternate rows of
 the grid. A default CSS rule is provided which sets a background colour, but you can override this with a rule which
 either overrides the background-color style using the '!important' modifier, or which uses a CSS selector of higher
 specificity.]]></description><name>stripeRows</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
     title: 'Some Title',
     renderTo: Ext.getBody(),
     width: 400, height:
 300,
     layout: 'form',
     items: [{
         xtype: 'textarea',
         style: {
             width: '95%',
            
 marginBottom: '10px'
         }
     },
         new Ext.Button({
             text: 'Send',
             minWidth: '100',
   
          style: {
                 marginBottom: '10px'
             }
         })
     ]
 });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is a child item of a TabPanel. A string to be used as innerHTML
 (html tags are accepted) to show in a tooltip when mousing over the associated tab selector element.
 Ext.QuickTips.init() must be called in order for the tips to render.]]></description><name>tabTip</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The title text to be used as innerHTML (html tags are accepted) to display in the panel header (defaults to ''). When a
 title is specified the header element will automatically be created and displayed unless header is explicitly set to
 false. If you do not want to specify a title at config time, but you may want one later, you must either specify a
 non-empty title (a blank space ' ' will do) or header:true so that the container element will get created.]]></description><name>title</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to allow expanding and collapsing the panel (when collapsible = true) by clicking anywhere in the header bar,
 false) to allow it only by clicking to tool button (defaults to false)). If this panel is a child item of a border
 layout also see the BorderLayout.Region floatable config option.]]></description><name>titleCollapse</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A Template used to create tools in the header Element. Defaults to: new Ext.Template('<div class="x-tool
 x-tool-{id}">&#160;</div>') This may may be overridden to provide a custom DOM structure for tools based upon a more
 complex XTemplate. The template's data is a single tool configuration object (Not the entire Array) as specified in
 tools. In the following example an <a> tag is used to provide a visual indication when hovering over the tool: var win =
 new Ext.Window({
     tools: [{
         id: 'download',
         href: '/MyPdfDoc.pdf'
     }],
     toolTemplate: new
 Ext.XTemplate(
         '<tpl if="id==\'download\'">',
             '<a class="x-tool x-tool-pdf" href="{href}"></a>',
    
 '</tpl>',
         '<tpl if="id!=\'download\'">',
             '<div class="x-tool x-tool-{id}">&#160;</div>',
        
 '</tpl>'
     ),
     width:500,
     height:300,
     closeAction:'hide'
 }); Note that the CSS class 'x-tool-pdf' should
 have an associated style rule which provides an appropriate background image, something like: a.x-tool-pdf
 {background-image: url(../shared/extjs/images/pdf.gif)!important;}]]></description><name>toolTemplate</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of tool button configs to be added to the header tool area. When rendered, each tool is stored as an Element
 referenced by a public property called tools.<tool-type> Each tool config may contain the following properties: id :
 String Required. The type of tool to create. By default, this assigns a CSS class of the form x-tool-<tool-type> to the
 resulting tool Element. Ext provides CSS rules, and an icon sprite containing images for the tool types listed below.
 The developer may implement custom tools by supplying alternate CSS rules and background images: toggle (Created by
 default when collapsible is true) close minimize maximize restore gear pin unpin right left up down refresh minus plus
 help search save print handler : Function Required. The function to call when clicked. Arguments passed are: event :
 Ext.EventObject The click event. toolEl : Ext.Element The tool Element. panel : Ext.Panel The host Panel tc : Object The
 tool configuration object stopEvent : Boolean Defaults to true. Specify as false to allow click event to propagate.
 scope : Object The scope in which to call the handler. qtip : String/Object A tip string, or a config argument to
 Ext.QuickTip.register hidden : Boolean True to initially render hidden. on : Object A listener config object specifiying
 event listeners in the format of an argument to addListener Note that, apart from the toggle tool which is provided when
 a panel is collapsible, these tools only provide the visual button. Any required functionality must be provided by
 adding handlers that implement the necessary behavior. Example usage: tools:[{
     id:'refresh',
     qtip: 'Refresh form
 Data',
     // hidden:true,
     handler: function(event, toolEl, panel){
         // refresh logic
     }
 },
 {
    
 id:'help',
     qtip: 'Get Help',
     handler: function(event, toolEl, panel){
         // whatever
     }
 }] For the
 custom id of 'help' define two relevant css classes with a link to a 15x15 image: .x-tool-help {background-image:
 url(images/help.png);}
 .x-tool-help-over {background-image: url(images/help_over.png);}
 // if using an image
 sprite:
 .x-tool-help {background-image: url(images/help.png) no-repeat 0 0;}
 .x-tool-help-over
 {background-position:-15px 0;}]]></description><name>tools</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Either and array of dimension to use on the top axis, or a Ext.grid.PivotAxis instance. If an array is passed, it is
 turned into a PivotAxis internally.]]></description><name>topAxis</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to highlight rows when the mouse is over. Default is true for GridPanel, but false for EditorGridPanel.]]></description><name>trackMouseOver</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Overrides the baseCls setting to baseCls = 'x-plain' which renders the panel unstyled except for required attributes for
 Ext layouts to function (e.g. overflow:hidden).]]></description><name>unstyled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.grid.GridView used by the grid. This can be set before a call to render().]]></description><name>view</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A config object that will be applied to the grid's UI view. Any of the config options available for Ext.grid.GridView
 can be specified here. This option is ignored if view is specified.]]></description><name>viewConfig</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local x (left) coordinate for this component if contained within a positioning container.]]></description><name>x</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered xtype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a child item of a Container is being specified not
 as a fully instantiated Component, but as a Component config object. The xtype will be looked up at render time up to
 determine what type of child Component to create. The predefined xtypes are listed here. If you subclass Components to
 create your own Components, you may register them using Ext.ComponentMgr.registerType in order to be able to take
 advantage of lazy instantiation and rendering.]]></description><name>xtype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local y (top) coordinate for this component if contained within a positioning container.]]></description><name>y</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 <p>PivotAxis is a class that supports a <a href="output/Ext.grid.PivotGrid.html"
 ext:cls="Ext.grid.PivotGrid">Ext.grid.PivotGrid</a>. Each PivotGrid contains two PivotAxis instances - the left axis and
 the top axis. Each PivotAxis defines an ordered set of dimensions, each of which should correspond to a field in a
 Store's Record (see <a href="output/Ext.grid.PivotGrid.html" ext:cls="Ext.grid.PivotGrid">Ext.grid.PivotGrid</a>
 documentation for further explanation).</p> 
 <p>Developers should have little interaction with the PivotAxis instances
 directly as most of their management is performed by the PivotGrid. An exception is the dynamic reconfiguration of axes
 at run time - to achieve this we use PivotAxis's <a
 href="output/Ext.grid.PivotAxis.html#Ext.grid.PivotAxis-setDimensions" ext:member="setDimensions"
 ext:cls="Ext.grid.PivotAxis">setDimensions</a> function and refresh the grid:</p> 
 <pre><code><b>var</b> pivotGrid =
 <b>new</b> Ext.grid.PivotGrid({
     <i>//some PivotGrid config here</i>
 });
 
 <i>//change the left axis
 dimensions</i>
 pivotGrid.leftAxis.setDimensions([
     {
         dataIndex: <em>'person'</em>,
         direction:
 <em>'DESC'</em>,
         width    : 100
     },
     {
         dataIndex: <em>'product'</em>,
         direction:
 <em>'ASC'</em>,
         width    : 80
     }
 ]);
 
 pivotGrid.view.refresh(true);</code></pre> This clears the previous
 dimensions on the axis and redraws the grid with the new dimensions.]]></description><name>grid.pivotAxis</name><tag-class>org.brushingbits.jnap.ui.extjs3.grid.PivotAxis</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[Whether the component can move the Dom node when rendering (defaults to true).]]></description><name>allowDomMove</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element corresponding to a DIV that is already present in
 the document that specifies some structural markup for this component. Description : When applyTo is used, constituent
 parts of the component can also be specified by id or CSS class name within the main element, and the component being
 created may attempt to create its subcomponents from that markup if applicable. Notes : When using this config, a call
 to render() is not required. If applyTo is specified, any value passed for renderTo will be ignored and the target
 element's parent node will automatically be used as the component's container.]]></description><name>applyTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A tag name or DomHelper spec used to create the Element which will encapsulate this Component. You do not normally need
 to specify this. For the base classes Ext.Component, Ext.BoxComponent, and Ext.Container, this defaults to 'div'. The
 more complex Ext classes use a more complex DOM structure created by their own onRender methods. This is intended to
 allow the developer to create application-specific utility Components encapsulated by different DOM elements. Example
 usage: <pre><code>{
     xtype: 'box',
     autoEl: {
         tag: 'img',
         src: 'http://www.example.com/example.jpg'
     }
 },
 {
     xtype: 'box',
     autoEl: {
         tag: 'blockquote',
         html: 'autoEl is cool!'
     }
 }, {
     xtype: 'container',
     autoEl: 'ul',
     cls: 'ux-unordered-list',
     items: {
         xtype: 'box',
         autoEl: 'li',
   
      html: 'First list item'
     }
 }</pre></code>]]></description><name>autoEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True if the component should check for hidden classes (e.g. 'x-hidden' or 'x-hide-display') and remove them on render
 (defaults to false).]]></description><name>autoShow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to [].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class used to to apply to the special clearing div rendered directly after each form field wrapper to provide
 field clearing (defaults to 'x-form-clear-left'). Note: this config is only used when this Component is rendered by a
 Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or specifying
 layout:'form') and either a fieldLabel is specified or isFormField=true is specified. See Ext.layout.FormLayout.fieldTpl
 also.]]></description><name>clearCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element (defaults to ''). This can be useful for
 adding customized styles to the component or any of its children using standard CSS rules.]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's container. This can be useful for adding customized
 styles to the container or any of its children using standard CSS rules. See Ext.layout.ContainerLayout.extraCls also.
 Note: ctCls defaults to '' except for the following class which assigns a value by default: Box Layout :
 'x-box-layout-ct' To configure the above Class with an extra CSS class append to the default. For example, for BoxLayout
 (Hbox and Vbox): ctCls: 'x-box-layout-ct custom-class']]></description><name>ctCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width to render each row header that does not have a width specified via getRowGroupHeaders. Defaults to 80.]]></description><name>defaultHeaderWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component disabled (default is false).]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class added to the component when it is disabled (defaults to 'x-item-disabled').]]></description><name>disabledClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The label text to display next to this Component (defaults to ''). Note: this config is only used when this Component is
 rendered by a Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or
 specifying layout:'form'). Also see hideLabel and Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
    
 height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name'
    
 }]
 });]]></description><name>fieldLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component hidden (default is false). If true, the hide method will be called internally.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to completely hide the label element (label and separator). Defaults to false. By default, even if you do not
 specify a fieldLabel the space will still be reserved so that the field will line up with other fields that do have
 labels. Setting this to true will cause the field to not reserve that space. Note: see the note for clearCls. Example
 use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield'
        
 hideLabel: true
     }]
 });]]></description><name>hideLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[How this component should be hidden. Supported values are 'visibility' (css visibility), 'offsets' (negative offset
 position) and 'display' (css display). Note: the default of 'display' is generally preferred since items are
 automatically laid out when they are first shown (no sizing is done while hidden).]]></description><name>hideMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide and show the component's container when hide/show is called on the component, false to hide and show the
 component itself (defaults to false). For example, this can be used as a shortcut for a hide button on a window by
 setting hide:true on the button when adding it to its parent container.]]></description><name>hideParent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id of this component (defaults to an auto-assigned id). You should assign an id if you need to be able to
 access the component later and you do not have an object reference available (e.g., using Ext.getCmp). Note that this id
 will also be used as the element id for the containing HTML element that is rendered to the page for this component.
 This allows you to write id-based CSS rules to style the specific instance of this component uniquely, and also to
 select sub-elements using this component's id as the parent. Note: to avoid complications imposed by a unique id also
 see itemId and ref. Note: to access the container of an item see ownerCt.]]></description><name>id</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use the
 FormLayout layout manager (e.g. Ext.form.FormPanel or specifying layout:'form'). An additional CSS class to apply to the
 div wrapping the form item element of this field. If supplied, itemCls at the field level will override the default
 itemCls supplied at the container level. The value specified for itemCls will be added to the default class
 ('x-form-item'). Since it is applied to the item wrapper (see Ext.layout.FormLayout.fieldTpl), it allows you to write
 standard CSS rules that can apply to the field, the label (if specified), or any other element within the markup for the
 field. Note: see the note for fieldLabel. Example use: // Apply a style to the field's label:
 <style>
     .required
 .x-form-item-label {font-weight:bold;color:red;}
 </style>
 
 new Ext.FormPanel({
     height: 100,
     renderTo:
 Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         itemCls: 'required' //this
 label will be styled
     },{
         xtype: 'textfield',
         fieldLabel: 'Favorite Color'
     }]
 });]]></description><name>itemCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An itemId can be used as an alternative way to get a reference to a component when no object reference is available.
 Instead of using an id with Ext.getCmp, use itemId with Ext.Container.getComponent which will retrieve itemId's or id's.
 Since itemId's are an index to the container's internal MixedCollection, the itemId is scoped locally to the container
 -- avoiding potential conflicts with Ext.ComponentMgr which requires a unique id. var c = new Ext.Panel({ //
     height:
 300,
     renderTo: document.body,
     layout: 'auto',
     items: [
         {
             itemId: 'p1',
            
 title: 'Panel 1',
             height: 150
         },
         {
             itemId: 'p2',
             title: 'Panel 2',
  
 height: 150
         }
     ]
 })
 p1 = c.getComponent('p1'); // not the same as Ext.getCmp()
 p2 =
 p1.ownerCt.getComponent('p2'); // reference via a sibling Also see id and ref. Note: to access the container of an item
 see ownerCt.]]></description><name>itemId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The separator to display after the text of each fieldLabel. This property may be configured at various levels. The order
 of precedence is: field / component level container level layout level (defaults to colon ':') To display no separator
 for this field's label specify empty string ''. Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 layoutConfig: {
         labelSeparator: '~'   // layout config has lowest priority (defaults to ':')
     },
    
 labelSeparator: '>>',     // config at container level
     items: [{
         xtype: 'textfield',
         fieldLabel:
 'Field 1',
         labelSeparator: '...' // field/component level config supersedes others
     },{
         xtype:
 'textfield',
         fieldLabel: 'Field 2' // labelSeparator will be '='
     }]
 });]]></description><name>labelSeparator</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS style specification string to apply directly to this field's label. Defaults to the container's labelStyle value
 if set (e.g., Ext.layout.FormLayout.labelStyle , or ''). Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         labelStyle: 'font-weight:bold;'
     }]
 });]]></description><name>labelStyle</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[One of 'vertical' or 'horizontal'. Defaults to horizontal]]></description><name>orientation</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element when the mouse moves over the Element, and
 removed when the mouse moves out. (defaults to ''). This can be useful for adding customized 'active' or 'hover' styles
 to the component or any of its children using standard CSS rules.]]></description><name>overCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered ptype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a Plugin is being specified not as a fully
 instantiated Component, but as a Component config object. The ptype will be looked up at render time up to determine
 what type of Plugin to create. If you create your own Plugins, you may register them using
 Ext.ComponentMgr.registerPlugin in order to be able to take advantage of lazy instantiation and rendering.]]></description><name>ptype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A path specification, relative to the Component's ownerCt specifying into which ancestor Container to place a named
 reference to this Component. The ancestor axis can be traversed by using '/' characters in the path. For example, to put
 a reference to a Toolbar Button into the Panel which owns the Toolbar: var myGrid = new Ext.grid.EditorGridPanel({
    
 title: 'My EditorGridPanel',
     store: myStore,
     colModel: myColModel,
     tbar: [{
         text: 'Save',
        
 handler: saveChanges,
         disabled: true,
         ref: '../saveButton'
     }],
     listeners: {
         afteredit:
 function() {
 //          The button reference is in the GridPanel
             myGrid.saveButton.enable();
         }
    
 }
 }); In the code above, if the ref had been 'saveButton' the reference would have been placed into the Toolbar. Each
 '/' in the ref moves up one level from the Component's ownerCt. Also see the added and removed events.]]></description><name>ref</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should trigger this component to save its state (defaults to none). stateEvents may
 be any type of event supported by this component, including browser or custom events (e.g., ['click',
 'customerchange']). See stateful for an explanation of saving and restoring Component state.]]></description><name>stateEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id for this component to use for state management purposes (defaults to the component id if one was set,
 otherwise null if the component is using a generated id). See stateful for an explanation of saving and restoring
 Component state.]]></description><name>stateId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A flag which causes the Component to attempt to restore the state of internal properties from a saved state on startup.
 The component must have either a stateId or id assigned for state to be managed. Auto-generated ids are not guaranteed
 to be stable across page loads and cannot be relied upon to save and restore the same state for a component. For state
 saving to work, the state manager's provider must have been set to an implementation of Ext.state.Provider which
 overrides the set and get methods to save and recall name/value pairs. A built-in implementation,
 Ext.state.CookieProvider is available. To set the state provider for the current page: Ext.state.Manager.setProvider(new
 Ext.state.CookieProvider({
     expires: new Date(new Date().getTime()+(1000*60*60*24*7)), //7 days from now
 })); A
 stateful Component attempts to save state when one of the events listed in the stateEvents configuration fires. To save
 state, a stateful Component first serializes its state by calling getState. By default, this function does nothing. The
 developer must provide an implementation which returns an object hash which represents the Component's restorable state.
 The value yielded by getState is passed to Ext.state.Manager.set which uses the configured Ext.state.Provider to save
 the object keyed by the Component's stateId, or, if that is not specified, its id. During construction, a stateful
 Component attempts to restore its state by calling Ext.state.Manager.get passing the stateId, or, if that is not
 specified, the id. The resulting object is passed to applyState. The default implementation of applyState simply copies
 properties into the object, but a developer may override this to support more behaviour. You can perform extra
 processing on state save and restore by attaching handlers to the beforestaterestore, staterestore, beforestatesave and
 statesave events.]]></description><name>stateful</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
     title: 'Some Title',
     renderTo: Ext.getBody(),
     width: 400, height:
 300,
     layout: 'form',
     items: [{
         xtype: 'textarea',
         style: {
             width: '95%',
            
 marginBottom: '10px'
         }
     },
         new Ext.Button({
             text: 'Send',
             minWidth: '100',
   
          style: {
                 marginBottom: '10px'
             }
         })
     ]
 });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered xtype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a child item of a Container is being specified not
 as a fully instantiated Component, but as a Component config object. The xtype will be looked up at render time up to
 determine what type of child Component to create. The predefined xtypes are listed here. If you subclass Components to
 create your own Components, you may register them using Ext.ComponentMgr.registerType in order to be able to take
 advantage of lazy instantiation and rendering.]]></description><name>xtype</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 Specialised GridView for rendering Pivot Grid components. Config can be passed to the PivotGridView via the PivotGrid
 constructor's viewConfig option: 
 <pre><code><b>new</b> Ext.grid.PivotGrid({
     viewConfig: {
         title: <em>'My
 Pivot Grid'</em>,
         getCellCls: <b>function</b>(value) {
             <b>return</b> value &gt; 10 <em>'red'</em> :
 <em>'green'</em>;
         }
     }
 });</code></pre> 
 <p>Currently <a
 href="output/Ext.grid.PivotGridView.html#Ext.grid.PivotGridView-title" ext:member="title"
 ext:cls="Ext.grid.PivotGridView">title</a> and <a
 href="output/Ext.grid.PivotGridView.html#Ext.grid.PivotGridView-getCellCls" ext:member="getCellCls"
 ext:cls="Ext.grid.PivotGridView">getCellCls</a> are the only configuration options accepted by PivotGridView. All other
 interaction is performed via the <a href="output/Ext.grid.PivotGrid.html" ext:cls="Ext.grid.PivotGrid">PivotGrid</a>
 class.</p>]]></description><name>grid.pivotView</name><tag-class>org.brushingbits.jnap.ui.extjs3.grid.PivotGridView</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[Defaults to false. Specify true to have the column widths re-proportioned when the grid is initially rendered. The
 initially configured width of each column will be adjusted to fit the grid width and prevent horizontal scrolling. If
 columns are later resized (manually or programmatically), the other columns in the grid will not be resized to fit the
 grid width. See forceFit also.]]></description><name>autoFill</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The selector used to find cells internally (defaults to 'td.x-grid3-cell')]]></description><name>cellSelector</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The number of levels to search for cells in event delegation (defaults to 4)]]></description><name>cellSelectorDepth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The text displayed in the 'Columns' menu item (defaults to 'Columns')]]></description><name>columnsText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to defer emptyText being applied until the store's first load (defaults to true).]]></description><name>deferEmptyText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Default text (html tags are accepted) to display in the grid body when no rows are available (defaults to ''). This
 value will be used to update the mainBody: this.mainBody.update('<div class="x-grid-empty">' + this.emptyText +
 '</div>');]]></description><name>emptyText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to add a second TR element per row that can be used to provide a row body that spans beneath the data row. Use the
 getRowClass method's rowParams config to customize the row body.]]></description><name>enableRowBody</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to false. Specify true to have the column widths re-proportioned at all times. The initially configured width
 of each column will be adjusted to fit the grid width and prevent horizontal scrolling. If columns are later resized
 (manually or programmatically), the other columns in the grid will be resized to fit the grid width. Columns which are
 configured with fixed: true are omitted from being resized. See autoFill.]]></description><name>forceFit</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional function which should return a CSS class name for each cell value. This is useful when color coding cells based
 on their value. Defaults to undefined.]]></description><name>getCellCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class to add to the header cell when its menu is visible. Defaults to 'x-grid3-hd-menu-open']]></description><name>headerMenuOpenCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to disable the grid column headers (defaults to false). Use the ColumnModel menuDisabled config to disable the menu
 for individual columns. While this config is true the following will be disabled: clicking on header to sort the trigger
 to reveal the menu.]]></description><name>headersDisabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to show the dirty cell indicator when a cell has been modified. Defaults to true.]]></description><name>markDirty</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The selector used to find row bodies internally (defaults to 'div.x-grid3-row')]]></description><name>rowBodySelector</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The number of levels to search for row bodies in event delegation (defaults to 10)]]></description><name>rowBodySelectorDepth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class added to each row when it is hovered over. Defaults to 'x-grid3-row-over']]></description><name>rowOverCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The selector used to find rows internally (defaults to 'div.x-grid3-row')]]></description><name>rowSelector</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The number of levels to search for rows in event delegation (defaults to 10)]]></description><name>rowSelectorDepth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The amount of space to reserve for the vertical scrollbar (defaults to undefined). If an explicit value isn't specified,
 this will be automatically calculated.]]></description><name>scrollOffset</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class applied to a selected row (defaults to 'x-grid3-row-selected'). An example overriding the default styling:
 .x-grid3-row-selected {background-color: yellow;} Note that this only controls the row, and will not do anything for the
 text inside it. To style inner facets (like text) use something like: .x-grid3-row-selected .x-grid3-cell-inner {
       
  color: #FFCC00;
     }]]></description><name>selectedRowClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The text displayed in the 'Sort Ascending' menu item (defaults to 'Sort Ascending')]]></description><name>sortAscText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS classes applied to a header when it is sorted. (defaults to ['sort-asc', 'sort-desc'])]]></description><name>sortClasses</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The text displayed in the 'Sort Descending' menu item (defaults to 'Sort Descending')]]></description><name>sortDescText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional title to be placed in the top left corner of the PivotGrid. Defaults to an empty string.]]></description><name>title</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 A specialized grid implementation intended to mimic the traditional property grid as typically seen in development IDEs.
 Each row in the grid represents a property of some object, and the data is stored as a set of name/value pairs in 
 <a
 href="output/Ext.grid.PropertyRecord.html" ext:cls="Ext.grid.PropertyRecord">Ext.grid.PropertyRecord</a>s. Example
 usage: 
 <pre><code><b>var</b> grid = <b>new</b> Ext.grid.PropertyGrid({
     title: <em>'Properties Grid'</em>,
    
 autoHeight: true,
     width: 300,
     renderTo: <em>'grid-ct'</em>,
     source: {
         <em>&quot;(name)&quot;</em>:
 <em>&quot;My Object&quot;</em>,
         <em>&quot;Created&quot;</em>: <b>new</b>
 Date(Date.parse(<em>'10/15/2006'</em>)),
         <em>&quot;Available&quot;</em>: false,
        
 <em>&quot;Version&quot;</em>: .01,
         <em>&quot;Description&quot;</em>: <em>&quot;A test object&quot;</em>
    
 }
 });</code></pre>]]></description><name>grid.propertyGrid</name><tag-class>org.brushingbits.jnap.ui.extjs3.grid.PropertyGrid</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[A string component id or the numeric index of the component that should be initially activated within the container's
 layout on render. For example, activeItem: 'item-1' or activeItem: 0 (index 0 = the first item in the container's
 collection). activeItem only applies to layout styles that can display items one at a time (like
 Ext.layout.AccordionLayout, Ext.layout.CardLayout and Ext.layout.FitLayout). Related to
 Ext.layout.ContainerLayout.activeItem.]]></description><name>activeItem</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Whether the component can move the Dom node when rendering (defaults to true).]]></description><name>allowDomMove</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use an
 AnchorLayout (or subclass thereof). based layout manager, for example: Ext.form.FormPanel specifying layout: 'anchor' //
 or 'form', or 'absolute' See Ext.layout.AnchorLayout.anchor also.]]></description><name>anchor</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to animate the transition when the panel is collapsed, false to skip the animation (defaults to true if the Ext.Fx
 class is available, otherwise false).]]></description><name>animCollapse</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The id of the node, a DOM node or an existing Element corresponding to a DIV that is already present in the document
 that specifies some panel-specific structural markup. When applyTo is used, constituent parts of the panel can be
 specified by CSS class name within the main element, and the panel will automatically create those components from that
 markup. Any required components not specified in the markup will be autogenerated if necessary. The following class
 names are supported (baseCls will be replaced by baseCls): baseCls + '-header' baseCls + '-header-text' baseCls +
 '-bwrap' baseCls + '-tbar' baseCls + '-body' baseCls + '-bbar' baseCls + '-footer' Using this config, a call to render()
 is not required. If applyTo is specified, any value passed for renderTo will be ignored and the target element's parent
 node will automatically be used as the panel's container.]]></description><name>applyTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If true the container will automatically destroy any contained component that is removed from it, else destruction must
 be handled manually (defaults to true).]]></description><name>autoDestroy</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A tag name or DomHelper spec used to create the Element which will encapsulate this Component. You do not normally need
 to specify this. For the base classes Ext.Component, Ext.BoxComponent, and Ext.Container, this defaults to 'div'. The
 more complex Ext classes use a more complex DOM structure created by their own onRender methods. This is intended to
 allow the developer to create application-specific utility Components encapsulated by different DOM elements. Example
 usage: <pre><code>{
     xtype: 'box',
     autoEl: {
         tag: 'img',
         src: 'http://www.example.com/example.jpg'
     }
 },
 {
     xtype: 'box',
     autoEl: {
         tag: 'blockquote',
         html: 'autoEl is cool!'
     }
 }, {
     xtype: 'container',
     autoEl: 'ul',
     cls: 'ux-unordered-list',
     items: {
         xtype: 'box',
         autoEl: 'li',
   
      html: 'First list item'
     }
 }</pre></code>]]></description><name>autoEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically HTML encode and decode values pre and post edit (defaults to false)]]></description><name>autoEncode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The id of a column in this grid that should expand to fill unused space. This value specified here can not be 0. Note:
 If the Grid's view is configured with forceFit=true the autoExpandColumn is ignored. See Ext.grid.Column.width for
 additional details. See autoExpandMax and autoExpandMin also.]]></description><name>autoExpandColumn</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum width the autoExpandColumn can have (if enabled). Defaults to 1000.]]></description><name>autoExpandMax</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum width the autoExpandColumn can have (if enabled). Defaults to 50.]]></description><name>autoExpandMin</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to use height:'auto', false to use fixed height (defaults to false). Note: Setting autoHeight: true means that the
 browser will manage the panel's height based on its contents, and that Ext will not manage it at all. If the panel is
 within a layout that manages dimensions (fit, border, etc.) then setting autoHeight: true can cause issues with
 scrolling and will not generally work as expected since the panel will take on the height of its contents rather than
 the height required by the Ext layout.]]></description><name>autoHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A valid url spec according to the Updater Ext.Updater.update method. If autoLoad is not null, the panel will attempt to
 load its contents immediately upon render. The URL will become the default URL for this panel's body element, so it may
 be refreshed at any time.]]></description><name>autoLoad</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to use overflow:'auto' on the components layout element and show scroll bars automatically when necessary, false to
 clip any overflowing content (defaults to false).]]></description><name>autoScroll</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True if the component should check for hidden classes (e.g. 'x-hidden' or 'x-hide-display') and remove them on render
 (defaults to false).]]></description><name>autoShow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to use width:'auto', false to use fixed width (or allow it to be managed by its parent Container's layout manager.
 Defaults to false. Note: Although many components inherit this config option, not all will function as expected with a
 width of 'auto'. Setting autoWidth:true means that the browser will manage width based on the element's contents, and
 that Ext will not manage it at all. If the browser is managing the width, be aware that resizes performed by the browser
 in response to changes within the structure of the Component cannot be detected. Therefore changes to the width might
 result in elements needing to be synchronized with the new width. For example, where the target element is: <div
 id='grid-container' style='margin-left:25%;width:50%'></div> A Panel rendered into that target element must listen for
 browser window resize in order to relay its child items when the browser changes its width: var myPanel = new
 Ext.Panel({
     renderTo: 'grid-container',
     monitorResize: true, // relay on browser resize
     title: 'Panel',
    
 height: 400,
     autoWidth: true,
     layout: 'hbox',
     layoutConfig: {
         align: 'stretch'
     },
     defaults: {
         flex: 1
     },
     items: [{
         title: 'Box 1',
     }, {
         title: 'Box 2'
     }, {
         title:
 'Box 3'
     }],
 });]]></description><name>autoWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The base CSS class to apply to this panel's element (defaults to 'x-panel'). Another option available by default is to
 specify 'x-plain' which strips all styling except for required attributes for Ext layouts to function (e.g.
 overflow:hidden). See unstyled also.]]></description><name>baseCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to display an interior border on the body element of the panel, false to hide it (defaults to true). This only
 applies when border == true. If border == true and bodyBorder == false, the border will display as a 1px wide inset
 border, giving the entire body element an inset appearance.]]></description><name>bodyBorder</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A DomHelper element specification object may be specified for any Panel Element. By default, the Default element in the
 table below will be used for the html markup to create a child element with the commensurate Default class name (baseCls
 will be replaced by baseCls): 
 Panel      Default  Default             Custom      Additional       Additional
 Element  
 element  class               element     class            style
 ========   ==========================   =========  
 ==============   ===========
 header     div      baseCls+'-header'   headerCfg   headerCssClass   headerStyle
 bwrap     
 div      baseCls+'-bwrap'     bwrapCfg    bwrapCssClass    bwrapStyle
 + tbar     div      baseCls+'-tbar'       tbarCfg 
 tbarCssClass     tbarStyle
 + body     div      baseCls+'-body'       bodyCfg     bodyCssClass     bodyStyle
 + bbar    
 div      baseCls+'-bbar'       bbarCfg     bbarCssClass     bbarStyle
 + footer   div      baseCls+'-footer'   footerCfg 
 footerCssClass   footerStyle
  Configuring a Custom element may be used, for example, to force the body Element to use a
 different form of markup than is created by default. An example of this might be to create a child Panel containing a
 custom content, such as a header, or forcing centering of all Panel content by having the body be a <center> element:
 new Ext.Panel({
     title: 'Message Title',
     renderTo: Ext.getBody(),
     width: 200, height: 130,
     bodyCfg: {
    
 tag: 'center',
         cls: 'x-panel-body',  // Default class not applied if Custom element specified
         html:
 'Message'
     },
     footerCfg: {
         tag: 'h2',
         cls: 'x-panel-footer',        // same as the Default class
 
 html: 'footer html'
     },
     footerCssClass: 'custom-footer', // additional css class, see addClass
     footerStyle:  
 'background-color:red' // see bodyStyle
 }); The example above also explicitly creates a footer with custom markup and
 styling applied.]]></description><name>bodyCfg</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Additional css class selector to be applied to the body element in the format expected by Ext.Element.addClass (defaults
 to null). See bodyCfg.]]></description><name>bodyCssClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Custom CSS styles to be applied to the body element in the format expected by Ext.Element.applyStyles (defaults to
 null). See bodyCfg.]]></description><name>bodyStyle</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to display the borders of the panel's body element, false to hide them (defaults to true). By default, the border
 is a 2px wide inset border, but this can be further altered by setting bodyBorder to false.]]></description><name>border</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to [].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[When set to true (50 milliseconds) or a number of milliseconds, the layout assigned for this container will buffer the
 frequency it calculates and does a re-layout of components. This is useful for heavy containers or containers with a
 large quantity of sub-components for which frequent layout calls would be expensive. Defaults to 50.]]></description><name>bufferResize</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The alignment of any buttons added to this panel. Valid values are 'right', 'left' and 'center' (defaults to 'right').]]></description><name>buttonAlign</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A DomHelper element specification object specifying the element structure of this Panel's bwrap Element. See bodyCfg
 also.]]></description><name>bwrapCfg</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class used to to apply to the special clearing div rendered directly after each form field wrapper to provide
 field clearing (defaults to 'x-form-clear-left'). Note: this config is only used when this Component is rendered by a
 Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or specifying
 layout:'form') and either a fieldLabel is specified or isFormField=true is specified. See Ext.layout.FormLayout.fieldTpl
 also.]]></description><name>clearCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The number of clicks on a cell required to display the cell's editor (defaults to 2). Setting this option to 'auto'
 means that mousedown on the selected cell starts editing that cell.]]></description><name>clicksToEdit</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Panels themselves do not directly support being closed, but some Panel subclasses do (like Ext.Window) or a Panel Class
 within an Ext.TabPanel. Specify true to enable closing in such situations. Defaults to false.]]></description><name>closable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element (defaults to ''). This can be useful for
 adding customized styles to the component or any of its children using standard CSS rules.]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Shorthand for colModel.]]></description><name>cm</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to make sure the collapse/expand toggle button always renders first (to the left of) any other tools in the panel's
 title bar, false to render it last (defaults to true).]]></description><name>collapseFirst</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to render the panel collapsed, false to render it expanded (defaults to false).]]></description><name>collapsed</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS class to add to the panel's element after it has been collapsed (defaults to 'x-panel-collapsed').]]></description><name>collapsedCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to make the panel collapsible and have the expand/collapse toggle button automatically rendered into the header
 tool button area, false to keep the panel statically sized with no button (defaults to false).]]></description><name>collapsible</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to add css for column separation lines. Default is false.]]></description><name>columnLines</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's container. This can be useful for adding customized
 styles to the container or any of its children using standard CSS rules. See Ext.layout.ContainerLayout.extraCls also.
 Note: ctCls defaults to '' except for the following class which assigns a value by default: Box Layout :
 'x-box-layout-ct' To configure the above Class with an extra CSS class append to the default. For example, for BoxLayout
 (Hbox and Vbox): ctCls: 'x-box-layout-ct custom-class']]></description><name>ctCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object containing name/value pairs of custom editor type definitions that allow the grid to support additional types
 of editable fields. By default, the grid supports strongly-typed editing of strings, dates, numbers and booleans using
 built-in form editors, but any custom type can be supported and associated with a custom input control by specifying a
 custom editor. The name of the editor type should correspond with the name of the property that will use the editor.
 Example usage: var grid = new Ext.grid.PropertyGrid({
     ...
     customEditors: {
         'Start Time': new
 Ext.grid.GridEditor(new Ext.form.TimeField({selectOnFocus:true}))
     },
     source: {
         'Start Time': '10:00 AM'
 
    }
 });]]></description><name>customEditors</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object containing name/value pairs of custom renderer type definitions that allow the grid to support custom
 rendering of fields. By default, the grid supports strongly-typed rendering of strings, dates, numbers and booleans
 using built-in form editors, but any custom type can be supported and associated with the type of the value. The name of
 the renderer type should correspond with the name of the property that it will render. Example usage: var grid = new
 Ext.grid.PropertyGrid({
     ...
     customRenderers: {
         Available: function(v){
             if(v){
               
 return '"color: green;">Yes';
             }else{
                 return '"color: red;">No';
             }
         }
    
 },
     source: {
         Available: true
     }
 });]]></description><name>customRenderers</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The DD group this GridPanel belongs to. Defaults to 'GridDD' if not specified.]]></description><name>ddGroup</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Configures the text in the drag proxy. Defaults to: ddText : '{0} selected row{1}' {0} is replaced with the number of
 selected rows.]]></description><name>ddText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default xtype of child Components to create in this Container when a child item is specified as a raw configuration
 object, rather than as an instantiated Component. Defaults to 'panel', except Ext.menu.Menu which defaults to
 'menuitem', and Ext.Toolbar and Ext.ButtonGroup which default to 'button'.]]></description><name>defaultType</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[This option is a means of applying default settings to all added items whether added through the items config or via the
 add or insert methods. If an added item is a config object, and not an instantiated Component, then the default
 properties are unconditionally applied. If the added item is an instantiated Component, then the default properties are
 applied conditionally so as not to override existing properties in the item. If the defaults option is specified as a
 function, then the function will be called using this Container as the scope (this reference) and passing the added item
 as the first parameter. Any resulting object from that call is then applied to the item as default properties. For
 example, to automatically apply padding to the body of each of a set of contained Ext.Panel items, you could pass:
 defaults: {bodyStyle:'padding:15px'}. Usage: defaults: {               // defaults are applied to items, not the
 container
     autoScroll:true
 },
 items: [
     {
         xtype: 'panel',   // defaults do not have precedence over
       
 id: 'panel1',     // options in config objects, so the defaults
         autoScroll: false // will not be applied here,
 panel1 will be autoScroll:false
     },
     new Ext.Panel({       // defaults do have precedence over options
         id:
 'panel2',     // options in components, so the defaults
         autoScroll: false // will be applied here, panel2 will
 be autoScroll:true.
     })
 ]]]></description><name>defaults</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to true to enable deferred row rendering. This allows the GridPanel to be initially rendered empty, with the
 expensive update of the row structure deferred so that layouts with GridPanels appear more quickly.]]></description><name>deferRowRender</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to disable selections in the grid. Defaults to false. Ignored if a SelectionModel is specified.]]></description><name>disableSelection</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this panel disabled (default is false). An important note when using the disabled config on panels is that IE
 will often fail to initialize the disabled mask element correectly if the panel's layout has not yet completed by the
 time the Panel is disabled during the render process. If you experience this issue, you may need to instead use the
 afterlayout event to initialize the disabled state: new Ext.Panel({
     ...
     listeners: {
         'afterlayout': {
   
 fn: function(p){
                 p.disable();
             },
             single: true // important, as many layouts can
 occur
         }
     }
 });]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class added to the component when it is disabled (defaults to 'x-item-disabled').]]></description><name>disabledClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to enable dragging of this Panel (defaults to false). For custom drag/drop implementations, an Ext.Panel.DD config
 could also be passed in this config instead of true. Ext.Panel.DD is an internal, undocumented class which moves a proxy
 Element around in place of the Panel's element, but provides no other behaviour during dragging or on drop. It is a
 subclass of Ext.dd.DragSource, so behaviour may be added by implementing the interface methods of Ext.dd.DragDrop e.g.:
 new Ext.Panel({
     title: 'Drag me',
     x: 100,
     y: 100,
     renderTo: Ext.getBody(),
     floating: true,
    
 frame: true,
     width: 400,
     height: 200,
     draggable: {
 //      Config option of Ext.Panel.DD class.
 //      It's
 a floating Panel, so do not show a placeholder proxy in the original position.
         insertProxy: false,
 
 //     
 Called for each mousemove event while dragging the DD object.
         onDrag : function(e){
 //          Record the x,y
 position of the drag proxy so that we can
 //          position the Panel at end of drag.
             var pel =
 this.proxy.getEl();
             this.x = pel.getLeft(true);
             this.y = pel.getTop(true);
 
 //          Keep the
 Shadow aligned if there is one.
             var s = this.panel.getEl().shadow;
             if (s) {
                
 s.realign(this.x, this.y, pel.getWidth(), pel.getHeight());
             }
         },
 
 //      Called on the mouseup
 event.
         endDrag : function(e){
             this.panel.setPosition(this.x, this.y);
         }
     }
 }).show();]]></description><name>draggable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A comma-delimited list of panel elements to initialize when the panel is rendered. Normally, this list will be generated
 automatically based on the items added to the panel at config time, but sometimes it might be useful to make sure a
 structural element is rendered even if not specified at config time (for example, you may want to add a button or
 toolbar dynamically after the panel has been rendered). Adding those elements to this list will allocate the required
 placeholders in the panel when it is rendered. Valid values are header tbar (top bar) body bbar (bottom bar) footer
 Defaults to 'body'.]]></description><name>elements</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to true to enable hiding of columns with the header menu.]]></description><name>enableColumnHide</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to true to enable drag and drop reorder of columns. false to turn off column reordering via drag drop.]]></description><name>enableColumnMove</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[false to turn off column resizing for the whole grid. Defaults to true.]]></description><name>enableColumnResize</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Enables dragging of the selected rows of the GridPanel. Defaults to false. Setting this to true causes this GridPanel's
 GridView to create an instance of Ext.grid.GridDragZone. Note: this is available only after the Grid has been rendered
 as the GridView's dragZone property. A cooperating DropZone must be created who's implementations of onNodeEnter,
 onNodeOver, onNodeOut and onNodeDrop are able to process the data which is provided.]]></description><name>enableDragDrop</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to true to enable the drop down button for menu in the headers.]]></description><name>enableHdMenu</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A Toolbar object, a Toolbar config, or an array of Buttons/Button configs, describing a Toolbar to be rendered into this
 Panel's footer element. After render, the fbar property will be an Toolbar instance. If buttons are specified, they will
 supersede the fbar configuration property. The Panel's buttonAlign configuration affects the layout of these items, for
 example: var w = new Ext.Window({
     height: 250,
     width: 500,
     bbar: new Ext.Toolbar({
         items: [{
        
 text: 'bbar Left'
         },'->',{
             text: 'bbar Right'
         }]
     }),
     buttonAlign: 'left', //
 anything but 'center' or 'right' and you can use '-', and '->'
                                   // to control the
 alignment of fbar items
     fbar: [{
         text: 'fbar Left'
     },'->',{
         text: 'fbar Right'
     }]
 }).show();
 Note: Although a Toolbar may contain Field components, these will not be updated by a load of an ancestor FormPanel. A
 Panel's toolbars are not part of the standard Container->Component hierarchy, and so are not scanned to collect form
 items. However, the values will be submitted because form submission parameters are collected from the DOM tree.]]></description><name>fbar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The label text to display next to this Component (defaults to ''). Note: this config is only used when this Component is
 rendered by a Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or
 specifying layout:'form'). Also see hideLabel and Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
    
 height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name'
    
 }]
 });]]></description><name>fieldLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use a
 BoxLayout. Each child Component with a flex property will be flexed either vertically (by a VBoxLayout) or horizontally
 (by an HBoxLayout) according to the item's relative flex value compared to the sum of all Components with flex value
 specified. Any child items that have either a flex = 0 or flex = undefined will not be 'flexed' (the initial size will
 not be changed).]]></description><name>flex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[This property is used to configure the underlying Ext.Layer. Acceptable values for this configuration property are:
 false : Default. Display the panel inline where it is rendered. true : Float the panel (absolute position it with
 automatic shimming and shadow). Setting floating to true will create an Ext.Layer for this panel and display the panel
 at negative offsets so that it is hidden. Since the panel will be absolute positioned, the position must be set
 explicitly after render (e.g., myPanel.setPosition(100,100);). Note: when floating a panel you should always assign a
 fixed width, otherwise it will be auto width and will expand to fill to the right edge of the viewport. object : The
 specified object will be used as the configuration object for the Ext.Layer that will be created.]]></description><name>floating</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to create the footer element explicitly, false to skip creating it. The footer will be created automatically if
 buttons or a fbar have been configured. See bodyCfg for an example.]]></description><name>footer</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A DomHelper element specification object specifying the element structure of this Panel's footer Element. See bodyCfg
 also.]]></description><name>footerCfg</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If true the container will force a layout initially even if hidden or collapsed. This option is useful for forcing forms
 to render in collapsed or hidden containers. (defaults to false).]]></description><name>forceLayout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to force validation even if the value is unmodified (defaults to false)]]></description><name>forceValidation</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[false by default to render with plain 1px square borders. true to render with 9 elements, complete with custom rounded
 corners (also see Ext.Element.boxWrap). The template generated for each condition is depicted below: // frame =
 false
 <div id="developer-specified-id-goes-here" class="x-panel">
 
     <div class="x-panel-header"><span
 class="x-panel-header-text">Title: (frame:false)</span></div>
 
     <div class="x-panel-bwrap">
         <div
 class="x-panel-body"><p>html value goes here</p></div>
     </div>
 </div>
 
 // frame = true (create 9 elements)
 <div
 id="developer-specified-id-goes-here" class="x-panel">
     <div class="x-panel-tl"><div class="x-panel-tr"><div
 class="x-panel-tc">
         <div class="x-panel-header"><span class="x-panel-header-text">Title:
 (frame:true)</span></div>
     </div></div></div>
 
     <div class="x-panel-bwrap">
         <div class="x-panel-ml"><div
 class="x-panel-mr"><div class="x-panel-mc">
             <div class="x-panel-body"><p>html value goes here</p></div>
     
 </div></div></div>
 
         <div class="x-panel-bl"><div class="x-panel-br"><div class="x-panel-bc"/>
        
 </div></div></div>
 </div>]]></description><name>frame</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to create the Panel's header element explicitly, false to skip creating it. If a title is set the header will be
 created automatically, otherwise it will not. If a title is set but header is explicitly set to false, the header will
 not be rendered.]]></description><name>header</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to display the panel title in the header, false to hide it (defaults to true).]]></description><name>headerAsText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A DomHelper element specification object specifying the element structure of this Panel's header Element. See bodyCfg
 also.]]></description><name>headerCfg</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component hidden (default is false). If true, the hide method will be called internally.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide the borders of each contained component, false to defer to the component's existing border settings
 (defaults to false).]]></description><name>hideBorders</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to hide the expand/collapse toggle button when collapsible == true, false to display it (defaults to false).]]></description><name>hideCollapseTool</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide the grid's header. Defaults to false.]]></description><name>hideHeaders</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to completely hide the label element (label and separator). Defaults to false. By default, even if you do not
 specify a fieldLabel the space will still be reserved so that the field will line up with other fields that do have
 labels. Setting this to true will cause the field to not reserve that space. Note: see the note for clearCls. Example
 use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield'
        
 hideLabel: true
     }]
 });]]></description><name>hideLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[How this component should be hidden. Supported values are 'visibility' (css visibility), 'offsets' (negative offset
 position) and 'display' (css display). Note: the default of 'display' is generally preferred since items are
 automatically laid out when they are first shown (no sizing is done while hidden).]]></description><name>hideMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide and show the component's container when hide/show is called on the component, false to hide and show the
 component itself (defaults to false). For example, this can be used as a shortcut for a hide button on a window by
 setting hide:true on the button when adding it to its parent container.]]></description><name>hideParent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class selector that specifies a background image to be used as the header icon (defaults to ''). An example of
 specifying a custom icon class would be something like: // specify the property in the config for the class:
      ...
   
 iconCls: 'my-icon'
 
 // css class that specifies background image to be used as the icon image:
 .my-icon {
 background-image: url(../images/my-icon.gif) 0 6px no-repeat !important; }]]></description><name>iconCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id of this component (defaults to an auto-assigned id). You should assign an id if you need to be able to
 access the component later and you do not have an object reference available (e.g., using Ext.getCmp). Note that this id
 will also be used as the element id for the containing HTML element that is rendered to the page for this component.
 This allows you to write id-based CSS rules to style the specific instance of this component uniquely, and also to
 select sub-elements using this component's id as the parent. Note: to avoid complications imposed by a unique id also
 see itemId and ref. Note: to access the container of an item see ownerCt.]]></description><name>id</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use the
 FormLayout layout manager (e.g. Ext.form.FormPanel or specifying layout:'form'). An additional CSS class to apply to the
 div wrapping the form item element of this field. If supplied, itemCls at the field level will override the default
 itemCls supplied at the container level. The value specified for itemCls will be added to the default class
 ('x-form-item'). Since it is applied to the item wrapper (see Ext.layout.FormLayout.fieldTpl), it allows you to write
 standard CSS rules that can apply to the field, the label (if specified), or any other element within the markup for the
 field. Note: see the note for fieldLabel. Example use: // Apply a style to the field's label:
 <style>
     .required
 .x-form-item-label {font-weight:bold;color:red;}
 </style>
 
 new Ext.FormPanel({
     height: 100,
     renderTo:
 Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         itemCls: 'required' //this
 label will be styled
     },{
         xtype: 'textfield',
         fieldLabel: 'Favorite Color'
     }]
 });]]></description><name>itemCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An itemId can be used as an alternative way to get a reference to a component when no object reference is available.
 Instead of using an id with Ext.getCmp, use itemId with Ext.Container.getComponent which will retrieve itemId's or id's.
 Since itemId's are an index to the container's internal MixedCollection, the itemId is scoped locally to the container
 -- avoiding potential conflicts with Ext.ComponentMgr which requires a unique id. var c = new Ext.Panel({ //
     height:
 300,
     renderTo: document.body,
     layout: 'auto',
     items: [
         {
             itemId: 'p1',
            
 title: 'Panel 1',
             height: 150
         },
         {
             itemId: 'p2',
             title: 'Panel 2',
  
 height: 150
         }
     ]
 })
 p1 = c.getComponent('p1'); // not the same as Ext.getCmp()
 p2 =
 p1.ownerCt.getComponent('p2'); // reference via a sibling Also see id and ref. Note: to access the container of an item
 see ownerCt.]]></description><name>itemId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A Ext.KeyMap config object (in the format expected by Ext.KeyMap.addBinding used to assign custom key handling to this
 panel (defaults to null).]]></description><name>keys</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The separator to display after the text of each fieldLabel. This property may be configured at various levels. The order
 of precedence is: field / component level container level layout level (defaults to colon ':') To display no separator
 for this field's label specify empty string ''. Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 layoutConfig: {
         labelSeparator: '~'   // layout config has lowest priority (defaults to ':')
     },
    
 labelSeparator: '>>',     // config at container level
     items: [{
         xtype: 'textfield',
         fieldLabel:
 'Field 1',
         labelSeparator: '...' // field/component level config supersedes others
     },{
         xtype:
 'textfield',
         fieldLabel: 'Field 2' // labelSeparator will be '='
     }]
 });]]></description><name>labelSeparator</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS style specification string to apply directly to this field's label. Defaults to the container's labelStyle value
 if set (e.g., Ext.layout.FormLayout.labelStyle , or ''). Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         labelStyle: 'font-weight:bold;'
     }]
 });]]></description><name>labelStyle</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[*Important: In order for child items to be correctly sized and positioned, typically a layout manager must be specified
 through the layout configuration option. The sizing and positioning of child items is the responsibility of the
 Container's layout manager which creates and manages the type of layout you have in mind. For example:
 <pre><code>
 new Ext.Window({
 
 width:300, height: 300,
     layout: 'fit', // explicitly set layout manager: override the default (layout:'auto')
    
 items: [{
         title: 'Panel inside a Window'
     }]
 }).show();</pre></code>
 If the layout configuration is not explicitly
 specified for a general purpose container (e.g. Container or Panel) the default layout manager will be used which does
 nothing but render child components sequentially into the Container (no sizing or positioning will be performed in this
 situation). Some container classes implicitly specify a default layout (e.g. FormPanel specifies layout:'form'). Other
 specific purpose classes internally specify/manage their internal layout (e.g. GridPanel, TabPanel, TreePanel, Toolbar,
 Menu, etc.). layout may be specified as either as an Object or as a String: Specify as an Object Example usage: layout:
 {
     type: 'vbox',
     padding: '5',
     align: 'left'
 } type The layout type to be used for this container. If not
 specified, a default Ext.layout.ContainerLayout will be created and used. Valid layout type values are: absolute
 accordion anchor auto Default border card column fit form hbox menu table toolbar vbox Layout specific configuration
 properties Additional layout specific configuration properties may also be specified. For complete details regarding the
 valid config options for each layout type, see the layout class corresponding to the type specified. Specify as a String
 Example usage: layout: 'vbox',
 layoutConfig: {
     padding: '5',
     align: 'left'
 } layout The layout type to be used
 for this container (see list of valid layout type values above). layoutConfig Additional layout specific configuration
 properties. For complete details regarding the valid config options for each layout type, see the layout class
 corresponding to the layout specified.]]></description><name>layout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An Ext.LoadMask config or true to mask the grid while loading. Defaults to false.]]></description><name>loadMask</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout or one of the two BoxLayout subclasses. An object containing margins to apply to this BoxComponent in the
 format: {
     top: (top margin),
     right: (right margin),
     bottom: (bottom margin),
     left: (left margin)
 } May
 also be a string containing space-separated, numeric margin values. The order of the sides associated with each value
 matches the way CSS processes margin values: If there is only one value, it applies to all sides. If there are two
 values, the top and bottom borders are set to the first value and the right and left are set to the second. If there are
 three values, the top is set to the first value, the left and right are set to the second, and the bottom is set to the
 third. If there are four values, they apply to the top, right, bottom, and left, respectively. Defaults to: {top:0,
 right:0, bottom:0, left:0}]]></description><name>margins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to mask the panel when it is disabled, false to not mask it (defaults to true). Either way, the panel will always
 tell its contained elements to disable themselves when it is disabled, but masking the panel can provide an additional
 visual cue that the panel is disabled.]]></description><name>maskDisabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Sets the maximum height of the grid - ignored if autoHeight is not on.]]></description><name>maxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Minimum width in pixels of all buttons in this panel (defaults to 75)]]></description><name>minButtonWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum width a column can be resized to. Defaults to 25.]]></description><name>minColumnWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically monitor window resize events to handle anything that is sensitive to the current size of the
 viewport. This value is typically managed by the chosen layout and should not need to be set manually.]]></description><name>monitorResize</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element when the mouse moves over the Element, and
 removed when the mouse moves out. (defaults to ''). This can be useful for adding customized 'active' or 'hover' styles
 to the component or any of its children using standard CSS rules.]]></description><name>overCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A shortcut for setting a padding style on the body element. The value can either be a number to be applied to all sides,
 or a normal css string describing padding. Defaults to undefined.]]></description><name>padding</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level x coordinate for this component if contained within a positioning container.]]></description><name>pageX</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level y coordinate for this component if contained within a positioning container.]]></description><name>pageY</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to false. When set to true, an extra css class 'x-panel-normal' will be added to the panel's element,
 effectively applying css styles suggested by the W3C (see http://www.w3.org/TR/CSS21/sample.html) to the Panel's body
 element (not the header, footer, etc.).]]></description><name>preventBodyReset</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object containing property name/display name pairs. If specified, the display name will be shown in the name column
 instead of the property name.]]></description><name>propertyNames</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered ptype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a Plugin is being specified not as a fully
 instantiated Component, but as a Component config object. The ptype will be looked up at render time up to determine
 what type of Plugin to create. If you create your own Plugins, you may register them using
 Ext.ComponentMgr.registerPlugin in order to be able to take advantage of lazy instantiation and rendering.]]></description><name>ptype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A path specification, relative to the Component's ownerCt specifying into which ancestor Container to place a named
 reference to this Component. The ancestor axis can be traversed by using '/' characters in the path. For example, to put
 a reference to a Toolbar Button into the Panel which owns the Toolbar: var myGrid = new Ext.grid.EditorGridPanel({
    
 title: 'My EditorGridPanel',
     store: myStore,
     colModel: myColModel,
     tbar: [{
         text: 'Save',
        
 handler: saveChanges,
         disabled: true,
         ref: '../saveButton'
     }],
     listeners: {
         afteredit:
 function() {
 //          The button reference is in the GridPanel
             myGrid.saveButton.enable();
         }
    
 }
 }); In the code above, if the ref had been 'saveButton' the reference would have been placed into the Toolbar. Each
 '/' in the ref moves up one level from the Component's ownerCt. Also see the added and removed events.]]></description><name>ref</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout layout manager (e.g. specifying layout:'border'). See Ext.layout.BorderLayout also.]]></description><name>region</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The event to listen to for resizing in layouts. Defaults to 'bodyresize'.]]></description><name>resizeEvent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Any subclass of AbstractSelectionModel that will provide the selection model for the grid (defaults to
 Ext.grid.CellSelectionModel if not specified).]]></description><name>selModel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true (or a valid Ext.Shadow Ext.Shadow.mode value) to display a shadow behind the panel, false to display no shadow
 (defaults to 'sides'). Note that this option only applies when floating = true.]]></description><name>shadow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The number of pixels to offset the shadow if displayed (defaults to 4). Note that this option only applies when floating
 = true.]]></description><name>shadowOffset</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[false to disable the iframe shim in browsers which need one (defaults to true). Note that this option only applies when
 floating = true.]]></description><name>shim</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Shorthand for selModel.]]></description><name>sm</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A data object to use as the data source of the grid (see setSource for details).]]></description><name>source</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should trigger this component to save its state. Defaults to: stateEvents:
 ['columnmove', 'columnresize', 'sortchange', 'groupchange'] These can be any types of events supported by this
 component, including browser or custom events (e.g., ['click', 'customerchange']). See Ext.Component.stateful for an
 explanation of saving and restoring Component state.]]></description><name>stateEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id for this component to use for state management purposes (defaults to the component id if one was set,
 otherwise null if the component is using a generated id). See stateful for an explanation of saving and restoring
 Component state.]]></description><name>stateId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A flag which causes the Component to attempt to restore the state of internal properties from a saved state on startup.
 The component must have either a stateId or id assigned for state to be managed. Auto-generated ids are not guaranteed
 to be stable across page loads and cannot be relied upon to save and restore the same state for a component. For state
 saving to work, the state manager's provider must have been set to an implementation of Ext.state.Provider which
 overrides the set and get methods to save and recall name/value pairs. A built-in implementation,
 Ext.state.CookieProvider is available. To set the state provider for the current page: Ext.state.Manager.setProvider(new
 Ext.state.CookieProvider({
     expires: new Date(new Date().getTime()+(1000*60*60*24*7)), //7 days from now
 })); A
 stateful Component attempts to save state when one of the events listed in the stateEvents configuration fires. To save
 state, a stateful Component first serializes its state by calling getState. By default, this function does nothing. The
 developer must provide an implementation which returns an object hash which represents the Component's restorable state.
 The value yielded by getState is passed to Ext.state.Manager.set which uses the configured Ext.state.Provider to save
 the object keyed by the Component's stateId, or, if that is not specified, its id. During construction, a stateful
 Component attempts to restore its state by calling Ext.state.Manager.get passing the stateId, or, if that is not
 specified, the id. The resulting object is passed to applyState. The default implementation of applyState simply copies
 properties into the object, but a developer may override this to support more behaviour. You can perform extra
 processing on state save and restore by attaching handlers to the beforestaterestore, staterestore, beforestatesave and
 statesave events.]]></description><name>stateful</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to stripe the rows. Default is false. This causes the CSS class x-grid3-row-alt to be added to alternate rows of
 the grid. A default CSS rule is provided which sets a background colour, but you can override this with a rule which
 either overrides the background-color style using the '!important' modifier, or which uses a CSS selector of higher
 specificity.]]></description><name>stripeRows</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
     title: 'Some Title',
     renderTo: Ext.getBody(),
     width: 400, height:
 300,
     layout: 'form',
     items: [{
         xtype: 'textarea',
         style: {
             width: '95%',
            
 marginBottom: '10px'
         }
     },
         new Ext.Button({
             text: 'Send',
             minWidth: '100',
   
          style: {
                 marginBottom: '10px'
             }
         })
     ]
 });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is a child item of a TabPanel. A string to be used as innerHTML
 (html tags are accepted) to show in a tooltip when mousing over the associated tab selector element.
 Ext.QuickTips.init() must be called in order for the tips to render.]]></description><name>tabTip</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The title text to be used as innerHTML (html tags are accepted) to display in the panel header (defaults to ''). When a
 title is specified the header element will automatically be created and displayed unless header is explicitly set to
 false. If you do not want to specify a title at config time, but you may want one later, you must either specify a
 non-empty title (a blank space ' ' will do) or header:true so that the container element will get created.]]></description><name>title</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to allow expanding and collapsing the panel (when collapsible = true) by clicking anywhere in the header bar,
 false) to allow it only by clicking to tool button (defaults to false)). If this panel is a child item of a border
 layout also see the BorderLayout.Region floatable config option.]]></description><name>titleCollapse</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A Template used to create tools in the header Element. Defaults to: new Ext.Template('<div class="x-tool
 x-tool-{id}">&#160;</div>') This may may be overridden to provide a custom DOM structure for tools based upon a more
 complex XTemplate. The template's data is a single tool configuration object (Not the entire Array) as specified in
 tools. In the following example an <a> tag is used to provide a visual indication when hovering over the tool: var win =
 new Ext.Window({
     tools: [{
         id: 'download',
         href: '/MyPdfDoc.pdf'
     }],
     toolTemplate: new
 Ext.XTemplate(
         '<tpl if="id==\'download\'">',
             '<a class="x-tool x-tool-pdf" href="{href}"></a>',
    
 '</tpl>',
         '<tpl if="id!=\'download\'">',
             '<div class="x-tool x-tool-{id}">&#160;</div>',
        
 '</tpl>'
     ),
     width:500,
     height:300,
     closeAction:'hide'
 }); Note that the CSS class 'x-tool-pdf' should
 have an associated style rule which provides an appropriate background image, something like: a.x-tool-pdf
 {background-image: url(../shared/extjs/images/pdf.gif)!important;}]]></description><name>toolTemplate</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of tool button configs to be added to the header tool area. When rendered, each tool is stored as an Element
 referenced by a public property called tools.<tool-type> Each tool config may contain the following properties: id :
 String Required. The type of tool to create. By default, this assigns a CSS class of the form x-tool-<tool-type> to the
 resulting tool Element. Ext provides CSS rules, and an icon sprite containing images for the tool types listed below.
 The developer may implement custom tools by supplying alternate CSS rules and background images: toggle (Created by
 default when collapsible is true) close minimize maximize restore gear pin unpin right left up down refresh minus plus
 help search save print handler : Function Required. The function to call when clicked. Arguments passed are: event :
 Ext.EventObject The click event. toolEl : Ext.Element The tool Element. panel : Ext.Panel The host Panel tc : Object The
 tool configuration object stopEvent : Boolean Defaults to true. Specify as false to allow click event to propagate.
 scope : Object The scope in which to call the handler. qtip : String/Object A tip string, or a config argument to
 Ext.QuickTip.register hidden : Boolean True to initially render hidden. on : Object A listener config object specifiying
 event listeners in the format of an argument to addListener Note that, apart from the toggle tool which is provided when
 a panel is collapsible, these tools only provide the visual button. Any required functionality must be provided by
 adding handlers that implement the necessary behavior. Example usage: tools:[{
     id:'refresh',
     qtip: 'Refresh form
 Data',
     // hidden:true,
     handler: function(event, toolEl, panel){
         // refresh logic
     }
 },
 {
    
 id:'help',
     qtip: 'Get Help',
     handler: function(event, toolEl, panel){
         // whatever
     }
 }] For the
 custom id of 'help' define two relevant css classes with a link to a 15x15 image: .x-tool-help {background-image:
 url(images/help.png);}
 .x-tool-help-over {background-image: url(images/help_over.png);}
 // if using an image
 sprite:
 .x-tool-help {background-image: url(images/help.png) no-repeat 0 0;}
 .x-tool-help-over
 {background-position:-15px 0;}]]></description><name>tools</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to highlight rows when the mouse is over. Default is true for GridPanel, but false for EditorGridPanel.]]></description><name>trackMouseOver</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Overrides the baseCls setting to baseCls = 'x-plain' which renders the panel unstyled except for required attributes for
 Ext layouts to function (e.g. overflow:hidden).]]></description><name>unstyled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.grid.GridView used by the grid. This can be set before a call to render().]]></description><name>view</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A config object that will be applied to the grid's UI view. Any of the config options available for Ext.grid.GridView
 can be specified here. This option is ignored if view is specified.]]></description><name>viewConfig</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local x (left) coordinate for this component if contained within a positioning container.]]></description><name>x</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered xtype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a child item of a Container is being specified not
 as a fully instantiated Component, but as a Component config object. The xtype will be looked up at render time up to
 determine what type of child Component to create. The predefined xtypes are listed here. If you subclass Components to
 create your own Components, you may register them using Ext.ComponentMgr.registerType in order to be able to take
 advantage of lazy instantiation and rendering.]]></description><name>xtype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local y (top) coordinate for this component if contained within a positioning container.]]></description><name>y</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 This is a utility class that can be passed into a 
 <a href="output/Ext.grid.ColumnModel.html"
 ext:cls="Ext.grid.ColumnModel">Ext.grid.ColumnModel</a> as a column config that provides an automatic row numbering
 column. 
 <br />Usage:
 <br /> 
 <pre><code><i>// This is a typical column config <b>with</b> the first column providing
 row numbers</i>
  <b>var</b> colModel = <b>new</b> Ext.grid.ColumnModel([
     <b>new</b> Ext.grid.RowNumberer(),
    
 {header: <em>&quot;Name&quot;</em>, width: 80, sortable: true},
     {header: <em>&quot;Code&quot;</em>, width: 50,
 sortable: true},
     {header: <em>&quot;Description&quot;</em>, width: 200, sortable: true}
  ]);</code></pre>]]></description><name>grid.rowNumberer</name><tag-class>org.brushingbits.jnap.ui.extjs3.grid.RowNumberer</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[Any valid text or HTML fragment to display in the header cell for the row number column (defaults to '').]]></description><name>header</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default width in pixels of the row number column (defaults to 23).]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 The default SelectionModel used by 
 <a href="output/Ext.grid.GridPanel.html"
 ext:cls="Ext.grid.GridPanel">Ext.grid.GridPanel</a>. It supports multiple selections and keyboard selection/navigation.
 The objects stored as selections and returned by 
 <a
 href="output/Ext.grid.RowSelectionModel.html#Ext.grid.RowSelectionModel-getSelected" ext:member="getSelected"
 ext:cls="Ext.grid.RowSelectionModel">getSelected</a>, and 
 <a
 href="output/Ext.grid.RowSelectionModel.html#Ext.grid.RowSelectionModel-getSelections" ext:member="getSelections"
 ext:cls="Ext.grid.RowSelectionModel">getSelections</a> are the 
 <a href="output/Ext.data.Record.html"
 ext:cls="Ext.data.Record">Record</a>s which provide the data for the selected rows.]]></description><name>grid.rowSelectionModel</name><tag-class>org.brushingbits.jnap.ui.extjs3.grid.RowSelectionModel</tag-class><body-content>scriptless</body-content><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[false to turn off moving the editor to the next row down when the enter key is pressed or the next row up when shift +
 enter keys are pressed.]]></description><name>moveEditorOnEnter</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to allow selection of only one row at a time (defaults to false allowing multiple selections)]]></description><name>singleSelect</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 <p>A Column definition class which renders a value by processing a <a href="output/Ext.data.Record.html"
 ext:cls="Ext.data.Record">Record</a>'s <a href="output/Ext.data.Record.html#Ext.data.Record-data" ext:member="data"
 ext:cls="Ext.data.Record">data</a> using a <a href="output/Ext.grid.TemplateColumn.html#Ext.grid.TemplateColumn-tpl"
 ext:member="tpl" ext:cls="Ext.grid.TemplateColumn">configured</a> <a href="output/Ext.XTemplate.html"
 ext:cls="Ext.XTemplate">XTemplate</a>. See the <a href="output/Ext.grid.Column.html#Ext.grid.Column-xtype"
 ext:member="xtype" ext:cls="Ext.grid.Column">xtype</a> config option of <a href="output/Ext.grid.Column.html"
 ext:cls="Ext.grid.Column">Ext.grid.Column</a> for more details.</p>]]></description><name>grid.templateColumn</name><tag-class>org.brushingbits.jnap.ui.extjs3.grid.TemplateColumn</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[Optional. Set the CSS text-align property of the column. Defaults to undefined.]]></description><name>align</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. An inline style definition string which is applied to all table cells in the column (excluding headers).
 Defaults to undefined.]]></description><name>css</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Required. The name of the field in the grid's Ext.data.Store's Ext.data.Record definition from which to draw the
 column's value.]]></description><name>dataIndex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Defaults to true, enabling the configured editor. Set to false to initially disable editing on this column.
 The initial configuration may be dynamically altered using Ext.grid.ColumnModel.setEditable().]]></description><name>editable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. The Ext.form.Field to use when editing values in this column if editing is supported by the grid. See editable
 also.]]></description><name>editor</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. If the grid is being rendered by an Ext.grid.GroupingView, this option may be used to specify the text to
 display when there is an empty group value. Defaults to the Ext.grid.GroupingView.emptyGroupText.]]></description><name>emptyGroupText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. true if the column width cannot be changed. Defaults to false.]]></description><name>fixed</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. If the grid is being rendered by an Ext.grid.GroupingView, this option may be used to specify the text with
 which to prefix the group field value in the group header line. See also groupRenderer and
 Ext.grid.GroupingView.showGroupName.]]></description><name>groupName</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. If the grid is being rendered by an Ext.grid.GroupingView, this option may be used to specify the function
 used to format the grouping field value for display in the group header. If a groupRenderer is not specified, the
 configured renderer will be called; if a renderer is also not specified the new value of the group field will be used.
 The called function (either the groupRenderer or renderer) will be passed the following parameters: v : Object The new
 value of the group field. unused : undefined Unused parameter. r : Ext.data.Record The Record providing the data for the
 row which caused group change. rowIndex : Number The row index of the Record which caused group change. colIndex :
 Number The column index of the group field. ds : Ext.data.Store The Store which is providing the data Model. The
 function should return a string value.]]></description><name>groupRenderer</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. If the grid is being rendered by an Ext.grid.GroupingView, this option may be used to disable the header menu
 item to group by the column selected. Defaults to true, which enables the header menu group option. Set to false to
 disable (but still show) the group option in the header menu for the column. See also groupName.]]></description><name>groupable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. The header text to be used as innerHTML (html tags are accepted) to display in the Grid view. Note: to have a
 clickable header with no text displayed use '&#160'.]]></description><name>header</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. true to initially hide this column. Defaults to false. A hidden column may be shown via the header row menu.
 If a column is never to be shown, simply do not include this column in the Column Model at all.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify as false to prevent the user from hiding this column (defaults to true). To disallow column hiding
 globally for all columns in the grid, use Ext.grid.GridPanel.enableColumnHide instead.]]></description><name>hideable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. A name which identifies this column (defaults to the column's initial ordinal position.) The id is used to
 create a CSS class name which is applied to all table cells (including headers) in that column (in this context the id
 does not need to be unique). The class name takes the form of x-grid3-td-id Header cells will also receive this class
 name, but will also have the class x-grid3-hd So, to target header cells, use CSS selectors such as: .x-grid3-hd-row
 .x-grid3-td-id The Ext.grid.GridPanel.autoExpandColumn grid config option references the column via this unique
 identifier.]]></description><name>id</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. true to disable the column menu. Defaults to false.]]></description><name>menuDisabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[For an alternative to specifying a renderer see xtype Optional. A renderer is an 'interceptor' method which can be used
 transform data (value, appearance, etc.) before it is rendered). This may be specified in either of three ways: A
 renderer function used to return HTML markup for a cell given the cell's data value. A string which references a
 property name of the Ext.util.Format class which provides a renderer function. An object specifying both the renderer
 function, and its execution scope (this reference) e.g.:
 <pre><code>{
     fn: this.gridRenderer,
     scope: this
 }</code></pre>
 If not
 specified, the default renderer uses the raw data value. For information about the renderer function (passed parameters,
 etc.), see Ext.grid.ColumnModel.setRenderer. An example of specifying renderer function inline:
 <pre><code>
 var companyColumn = {
    header: 'Company Name',
    dataIndex: 'company',
    renderer: function(value, metaData, record, rowIndex, colIndex, store) {
       // provide the logic depending on business rules
       // name of your own choosing to manipulate the cell depending upon
       // the data in the underlying Record object.
       if (value == 'whatever') {
           // metaData.css : String : A CSS class name to add to the TD element of the cell.
           // metaData.attr : String : An html attribute definition string to apply to
           // the data container element within the table
           // cell (e.g. 'style="color:red;"').
           metaData.css = 'name-of-css-class-you-will-define';
       }
       return value;
    }
 }</code></pre>
 See also scope.]]></description><name>renderer</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. false to disable column resizing. Defaults to true.]]></description><name>resizable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. The scope (this reference) in which to execute the renderer. Defaults to the Column configuration object.]]></description><name>scope</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. true if sorting is to be allowed on this column. Defaults to the value of the
 Ext.grid.ColumnModel.defaultSortable property. Whether local/remote sorting is used is specified in
 Ext.data.Store.remoteSort.]]></description><name>sortable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. A text string to use as the column header's tooltip. If Quicktips are enabled, this value will be used as the
 text of the quick tip, otherwise it will be set as the header's HTML title attribute. Defaults to ''.]]></description><name>tooltip</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. The initial width in pixels of the column. The width of each column can also be affected if any of the
 following are configured: Ext.grid.GridPanel.autoExpandColumn Ext.grid.GridView.forceFit By specifying forceFit:true,
 non-fixed width columns will be re-proportioned (based on the relative initial widths) to fill the width of the grid so
 that no horizontal scrollbar is shown. Ext.grid.GridView.autoFill Ext.grid.GridPanel.minColumnWidth Note: when the width
 of each column is determined, a space on the right side is reserved for the vertical scrollbar. The
 Ext.grid.GridView.scrollOffset can be modified to reduce or eliminate the reserved offset.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 <p>This class encapsulates the user interface of an <a href="output/Ext.grid.GridPanel.html"
 ext:cls="Ext.grid.GridPanel">Ext.grid.GridPanel</a>. Methods of this class may be used to access user interface elements
 to enable special display effects. Do not change the DOM structure of the user interface.</p> 
 <p>This class does not
 provide ways to manipulate the underlying data. The data model of a Grid is held in an <a
 href="output/Ext.data.Store.html" ext:cls="Ext.data.Store">Ext.data.Store</a>.</p>]]></description><name>grid.view</name><tag-class>org.brushingbits.jnap.ui.extjs3.grid.GridView</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[Defaults to false. Specify true to have the column widths re-proportioned when the grid is initially rendered. The
 initially configured width of each column will be adjusted to fit the grid width and prevent horizontal scrolling. If
 columns are later resized (manually or programmatically), the other columns in the grid will not be resized to fit the
 grid width. See forceFit also.]]></description><name>autoFill</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The selector used to find cells internally (defaults to 'td.x-grid3-cell')]]></description><name>cellSelector</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The number of levels to search for cells in event delegation (defaults to 4)]]></description><name>cellSelectorDepth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The text displayed in the 'Columns' menu item (defaults to 'Columns')]]></description><name>columnsText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to defer emptyText being applied until the store's first load (defaults to true).]]></description><name>deferEmptyText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Default text (html tags are accepted) to display in the grid body when no rows are available (defaults to ''). This
 value will be used to update the mainBody: this.mainBody.update('<div class="x-grid-empty">' + this.emptyText +
 '</div>');]]></description><name>emptyText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to add a second TR element per row that can be used to provide a row body that spans beneath the data row. Use the
 getRowClass method's rowParams config to customize the row body.]]></description><name>enableRowBody</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to false. Specify true to have the column widths re-proportioned at all times. The initially configured width
 of each column will be adjusted to fit the grid width and prevent horizontal scrolling. If columns are later resized
 (manually or programmatically), the other columns in the grid will be resized to fit the grid width. Columns which are
 configured with fixed: true are omitted from being resized. See autoFill.]]></description><name>forceFit</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class to add to the header cell when its menu is visible. Defaults to 'x-grid3-hd-menu-open']]></description><name>headerMenuOpenCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to disable the grid column headers (defaults to false). Use the ColumnModel menuDisabled config to disable the menu
 for individual columns. While this config is true the following will be disabled: clicking on header to sort the trigger
 to reveal the menu.]]></description><name>headersDisabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to show the dirty cell indicator when a cell has been modified. Defaults to true.]]></description><name>markDirty</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The selector used to find row bodies internally (defaults to 'div.x-grid3-row')]]></description><name>rowBodySelector</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The number of levels to search for row bodies in event delegation (defaults to 10)]]></description><name>rowBodySelectorDepth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class added to each row when it is hovered over. Defaults to 'x-grid3-row-over']]></description><name>rowOverCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The selector used to find rows internally (defaults to 'div.x-grid3-row')]]></description><name>rowSelector</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The number of levels to search for rows in event delegation (defaults to 10)]]></description><name>rowSelectorDepth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The amount of space to reserve for the vertical scrollbar (defaults to undefined). If an explicit value isn't specified,
 this will be automatically calculated.]]></description><name>scrollOffset</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class applied to a selected row (defaults to 'x-grid3-row-selected'). An example overriding the default styling:
 .x-grid3-row-selected {background-color: yellow;} Note that this only controls the row, and will not do anything for the
 text inside it. To style inner facets (like text) use something like: .x-grid3-row-selected .x-grid3-cell-inner {
       
  color: #FFCC00;
     }]]></description><name>selectedRowClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The text displayed in the 'Sort Ascending' menu item (defaults to 'Sort Ascending')]]></description><name>sortAscText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS classes applied to a header when it is sorted. (defaults to ['sort-asc', 'sort-desc'])]]></description><name>sortClasses</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The text displayed in the 'Sort Descending' menu item (defaults to 'Sort Descending')]]></description><name>sortDescText</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><name>head</name><tag-class>org.brushingbits.jnap.ui.extjs3.Head</tag-class><body-content>scriptless</body-content><attribute><name>adapter</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>baseRelativePath</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[URL to a 1x1 transparent gif image used by Ext to create inline icons with CSS background images. In older
 versions of IE, this defaults to "http://extjs.com/s.gif" and you should change this to a URL on your server.
 For other browsers it uses an inline data URL.]]></description><name>blankImageUrl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically uncache orphaned Ext.Elements periodically (defaults to true).]]></description><name>enableGarbageCollector</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically purge event listeners during garbageCollection (defaults to false).]]></description><name>enableListenerCollection</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Initialize the global QuickTips instance and prepare any quick tips.]]></description><name>initQuickTips</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[URL to a blank file used by Ext when in secure mode for iframe src and onReady src to prevent the IE insecure
 content warning ('about:blank', except for IE in secure mode, which is 'javascript:""').]]></description><name>sslSecureUrl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Indicates whether to use native browser parsing for JSON methods. This option is ignored if the browser does not
 support native JSON methods. Note: Native JSON methods will not work with objects that have functions. Also, property
 names must be quoted, otherwise the data will not parse. (Defaults to false)]]></description><name>useNativeJson</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[By default, Ext intelligently decides whether floating elements should be shimmed. If you are using flash, you
 may want to set this to true.]]></description><name>useShims</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[TODO write about theming]]></description><name>xtheme</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 <p>This is a layout that manages multiple Panels in an expandable accordion style such that only <b>one Panel can be
 expanded at any given time</b>. Each Panel has built-in support for expanding and collapsing.</p> 
 <p>Note: Only
 Ext.Panels <b>and all subclasses of Ext.Panel</b> may be used in an accordion layout Container.</p> 
 <p>This class is
 intended to be extended or created via the <tt><b><a href="output/Ext.Container.html#Ext.Container-layout"
 ext:member="layout" ext:cls="Ext.Container">layout</a></b></tt> configuration property. See <tt><b><a
 href="output/Ext.Container.html#Ext.Container-layout" ext:member="layout"
 ext:cls="Ext.Container">Ext.Container.layout</a></b></tt> for additional details.</p> 
 <p>Example usage:</p>
 
 <pre><code><b>var</b> accordion = <b>new</b> Ext.Panel({
     title: <em>'Accordion Layout'</em>,
    
 layout:<em>'accordion'</em>,
     defaults: {
         <i>// applied to each contained panel</i>
         bodyStyle:
 <em>'padding:15px'</em>
     },
     layoutConfig: {
         <i>// layout-specific configs go here</i>
        
 titleCollapse: false,
         animate: true,
         activeOnTop: true
     },
     items: [{
         title: <em>'Panel
 1'</em>,
         html: <em>'&lt;p&gt;Panel content!&lt;/p&gt;'</em>
     },{
         title: <em>'Panel 2'</em>,
        
 html: <em>'&lt;p&gt;Panel content!&lt;/p&gt;'</em>
     },{
         title: <em>'Panel 3'</em>,
         html:
 <em>'&lt;p&gt;Panel content!&lt;/p&gt;'</em>
     }]
 });</code></pre>]]></description><name>layout.accordion</name><tag-class>org.brushingbits.jnap.ui.extjs3.layout.AccordionLayout</tag-class><body-content>empty</body-content><attribute><description><![CDATA[True to swap the position of each panel as it is expanded so that it becomes the first item in the container, false to
 keep the panels in the rendered order. This is NOT compatible with "animate:true" (defaults to false).]]></description><name>activeOnTop</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to slide the contained panels open and closed during expand/collapse using animation, false to open and close
 directly with no animation (defaults to false). Note: to defer to the specific config setting of each contained panel
 for this property, set this to undefined at the layout level.]]></description><name>animate</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to set each contained item's width to 'auto', false to use the item's current width (defaults to true). Note that
 some components, in particular the grid, will not function properly within layouts if they have auto width, so in such
 cases this config should be set to false.]]></description><name>autoWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to make sure the collapse/expand toggle button always renders first (to the left of) any other tools in the
 contained panels' title bars, false to render it last (defaults to false).]]></description><name>collapseFirst</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to the container. This can be useful for adding customized styles to the
 container or any of its children using standard CSS rules. See Ext.Component.ctCls also. Note: extraCls defaults to ''
 except for the following classes which assign a value by default: Absolute Layout : 'x-abs-layout-item' Box Layout :
 'x-box-item' Column Layout : 'x-column' To configure the above Classes with an extra CSS class append to the default.
 For example, for ColumnLayout: extraCls: 'x-column custom-class']]></description><name>extraCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to adjust the active item's height to fill the available space in the container, false to use the item's current
 height, or auto height if not explicitly set (defaults to true).]]></description><name>fill</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide the contained panels' collapse/expand toggle buttons, false to display them (defaults to false). When set
 to true, titleCollapse should be true also.]]></description><name>hideCollapseTool</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide each contained item on render (defaults to false).]]></description><name>renderHidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Experimental. If animate is set to true, this will result in each animation running in sequence.]]></description><name>sequence</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to allow expand/collapse of each contained panel by clicking anywhere on the title bar, false to allow
 expand/collapse only when the toggle tool button is clicked (defaults to true). When set to false, hideCollapseTool
 should be false also.]]></description><name>titleCollapse</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 <p>This is a layout that enables anchoring of contained elements relative to the container's dimensions. If the
 container is resized, all anchored items are automatically rerendered according to their <b><tt><a
 href="output/Ext.layout.AnchorLayout.html#Ext.layout.AnchorLayout-anchor" ext:member="anchor"
 ext:cls="Ext.layout.AnchorLayout">anchor</a></tt></b> rules.</p> 
 <p>This class is intended to be extended or created
 via the layout:'anchor' <a href="output/Ext.Container.html#Ext.Container-layout" ext:member="layout"
 ext:cls="Ext.Container">Ext.Container.layout</a> config, and should generally not need to be created directly via the
 new keyword.</p> 
 <p>AnchorLayout does not have any direct config options (other than inherited ones). By default,
 AnchorLayout will calculate anchor measurements based on the size of the container itself. However, the container using
 the AnchorLayout can supply an anchoring-specific config property of <b>anchorSize</b>. If anchorSize is specifed, the
 layout will use it as a virtual container for the purposes of calculating anchor measurements based on it instead,
 allowing the container to be sized independently of the anchoring logic if necessary. For example:</p>
 
 <pre><code><b>var</b> viewport = <b>new</b> Ext.Viewport({
     layout:<em>'anchor'</em>,
     anchorSize: {
         width:800,
         height:600
     },
     items:[{
         title:<em>'Item 1'</em>,
         html:<em>'Content 1'</em>,
         width:800,
        
 anchor:<em>'right 20%'</em>
     },{
         title:<em>'Item 2'</em>,
         html:<em>'Content 2'</em>,
        
 width:300,
         anchor:<em>'50% 30%'</em>
     },{
         title:<em>'Item 3'</em>,
         html:<em>'Content
 3'</em>,
         width:600,
         anchor:<em>'-100 50%'</em>
     }]
 });</code></pre>]]></description><name>layout.anchor</name><tag-class>org.brushingbits.jnap.ui.extjs3.layout.AnchorLayout</tag-class><body-content>empty</body-content><attribute><description><![CDATA[This configuation option is to be applied to child items of a container managed by this layout (ie. configured with
 layout:'anchor'). This value is what tells the layout how an item should be anchored to the container. items added to an
 AnchorLayout accept an anchoring-specific config property of anchor which is a string containing two values: the
 horizontal anchor value and the vertical anchor value (for example, '100% 50%'). The following types of anchor values
 are supported: Percentage : Any value between 1 and 100, expressed as a percentage. The first anchor is the percentage
 width that the item should take up within the container, and the second is the percentage height. For example: // two
 values specified
 anchor: '100% 50%' // render item complete width of the container and
                    // 1/2 height
 of the container
 // one value specified
 anchor: '100%'     // the width value; the height will default to auto Offsets :
 Any positive or negative integer value. This is a raw adjustment where the first anchor is the offset from the right
 edge of the container, and the second is the offset from the bottom edge. For example: // two values specified
 anchor:
 '-50 -100' // render item the complete width of the container
                    // minus 50 pixels and
                 
 // the complete height minus 100 pixels.
 // one value specified
 anchor: '-50'      // anchor value is assumed to be the
 right offset value
                    // bottom offset will default to 0 Sides : Valid values are 'right' (or 'r') and
 'bottom' (or 'b'). Either the container must have a fixed size or an anchorSize config value defined at render time in
 order for these to have any effect. Mixed : Anchor values can also be mixed as needed. For example, to render the width
 offset from the container right edge by 50 pixels and 75% of the container's height use: anchor: '-50 75%']]></description><name>anchor</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[default anchor for all child container items applied if no anchor or specific width is set on the child item. Defaults
 to '100%'.]]></description><name>defaultAnchor</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to the container. This can be useful for adding customized styles to the
 container or any of its children using standard CSS rules. See Ext.Component.ctCls also. Note: extraCls defaults to ''
 except for the following classes which assign a value by default: Absolute Layout : 'x-abs-layout-item' Box Layout :
 'x-box-item' Column Layout : 'x-column' To configure the above Classes with an extra CSS class append to the default.
 For example, for ColumnLayout: extraCls: 'x-column custom-class']]></description><name>extraCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide each contained item on render (defaults to false).]]></description><name>renderHidden</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 <p>This layout manages multiple child Components, each fitted to the Container, where only a single child Component can
 be visible at any given time. This layout style is most commonly used for wizards, tab implementations, etc. This class
 is intended to be extended or created via the layout:'card' <a href="output/Ext.Container.html#Ext.Container-layout"
 ext:member="layout" ext:cls="Ext.Container">Ext.Container.layout</a> config, and should generally not need to be created
 directly via the new keyword.</p> 
 <p>The CardLayout's focal method is <a
 href="output/Ext.layout.CardLayout.html#Ext.layout.CardLayout-setActiveItem" ext:member="setActiveItem"
 ext:cls="Ext.layout.CardLayout">setActiveItem</a>. Since only one panel is displayed at a time, the only way to move
 from one Component to the next is by calling setActiveItem, passing the id or index of the next panel to display. The
 layout itself does not provide a user interface for handling this navigation, so that functionality must be provided by
 the developer.</p> 
 <p>In the following example, a simplistic wizard setup is demonstrated. A button bar is added to the
 footer of the containing panel to provide navigation buttons. The buttons will be handled by a common navigation routine
 -- for this example, the implementation of that routine has been ommitted since it can be any type of custom logic. Note
 that other uses of a CardLayout (like a tab control) would require a completely different implementation. For serious
 implementations, a better approach would be to extend CardLayout to provide the custom functionality needed. Example
 usage:</p> 
 <pre><code><b>var</b> navHandler = <b>function</b>(direction){
     <i>// This routine could contain business
 logic required to manage the navigation steps.</i>
     <i>// It would call setActiveItem as needed, manage navigation
 button state, handle any</i>
     <i>// branching logic that might be required, handle alternate actions like
 cancellation</i>
     <i>// or finalization, etc.  A complete wizard implementation could get pretty</i>
     <i>//
 sophisticated depending on the complexity required, and should probably be</i>
     <i>// done as a subclass of
 CardLayout <b>in</b> a real-world implementation.</i>
 };
 
 <b>var</b> card = <b>new</b> Ext.Panel({
     title:
 <em>'Example Wizard'</em>,
     layout:<em>'card'</em>,
     activeItem: 0, <i>// make sure the active item is set on the
 container config!</i>
     bodyStyle: <em>'padding:15px'</em>,
     defaults: {
         <i>// applied to each contained
 panel</i>
         border:false
     },
     <i>// just an example of one possible navigation scheme, using buttons</i>
    
 bbar: [
         {
             id: <em>'move-prev'</em>,
             text: <em>'Back'</em>,
             handler:
 navHandler.createDelegate(this, [-1]),
             disabled: true
         },
         <em>'-&gt;'</em>, <i>// greedy
 spacer so that the buttons are aligned to each side</i>
         {
             id: <em>'move-next'</em>,
            
 text: <em>'Next'</em>,
             handler: navHandler.createDelegate(this, [1])
         }
     ],
     <i>// the panels
 (or <em>&quot;cards&quot;</em>) within the layout</i>
     items: [{
         id: <em>'card-0'</em>,
         html:
 <em>'&lt;h1&gt;Welcome to the Wizard!&lt;/h1&gt;&lt;p&gt;Step 1 of 3&lt;/p&gt;'</em>
     },{
         id:
 <em>'card-1'</em>,
         html: <em>'&lt;p&gt;Step 2 of 3&lt;/p&gt;'</em>
     },{
         id: <em>'card-2'</em>,
       
  html: <em>'&lt;h1&gt;Congratulations!&lt;/h1&gt;&lt;p&gt;Step 3 of 3 - Complete&lt;/p&gt;'</em>
     }]
 });</code></pre>]]></description><name>layout.card</name><tag-class>org.brushingbits.jnap.ui.extjs3.layout.CardLayout</tag-class><body-content>empty</body-content><attribute><description><![CDATA[True to render each contained item at the time it becomes active, false to render all contained items as soon as the
 layout is rendered (defaults to false). If there is a significant amount of content or a lot of heavy controls being
 rendered into panels that are not displayed by default, setting this to true might improve performance.]]></description><name>deferredRender</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to the container. This can be useful for adding customized styles to the
 container or any of its children using standard CSS rules. See Ext.Component.ctCls also. Note: extraCls defaults to ''
 except for the following classes which assign a value by default: Absolute Layout : 'x-abs-layout-item' Box Layout :
 'x-box-item' Column Layout : 'x-column' To configure the above Classes with an extra CSS class append to the default.
 For example, for ColumnLayout: extraCls: 'x-column custom-class']]></description><name>extraCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to force a layout of the active item when the active card is changed. Defaults to false.]]></description><name>layoutOnCardChange</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide each contained item on render (defaults to false).]]></description><name>renderHidden</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API
 docs: <a
 href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>
 
 This is a base class for layouts that contain a single item that
 automatically expands to fill the layout's container. This class is intended
 to be extended or created via the layout:'fit' Ext.Container.layout config,
 and should generally not need to be created directly via the new keyword.
 
 FitLayout does not have any direct config options (other than inherited
 ones). To fit a panel to a container using FitLayout, simply set layout:'fit'
 on the container and add a single panel to it. If the container has multiple
 panels, only the first one will be displayed. Example usage:
 <pre><code>
 var p = new Ext.Panel({
     title: 'Fit Layout',
     layout:'fit',
     items: {
         title: 'Inner Panel',
         html: '<p>This is the inner panel content</p>',
         border: false
     }
 });
 </code></pre>]]></description><name>layout.fit</name><tag-class>org.brushingbits.jnap.ui.extjs3.layout.FitLayout</tag-class><body-content>empty</body-content><attribute><description><![CDATA[An optional extra CSS class that will be added to the container. This can be useful for adding customized styles to the
 container or any of its children using standard CSS rules. See Ext.Component.ctCls also. Note: extraCls defaults to ''
 except for the following classes which assign a value by default: Absolute Layout : 'x-abs-layout-item' Box Layout :
 'x-box-item' Column Layout : 'x-column' To configure the above Classes with an extra CSS class append to the default.
 For example, for ColumnLayout: extraCls: 'x-column custom-class']]></description><name>extraCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide each contained item on render (defaults to false).]]></description><name>renderHidden</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 <p>This layout manager is specifically designed for rendering and managing child Components of <a
 href="output/Ext.form.FormPanel.html" ext:cls="Ext.form.FormPanel">forms</a>. It is responsible for rendering the labels
 of <a href="output/Ext.form.Field.html" ext:cls="Ext.form.Field">Field</a>s.</p> 
 <p>This layout manager is used when a
 Container is configured with the <tt>layout:'form'</tt> <a href="output/Ext.Container.html#Ext.Container-layout"
 ext:member="layout" ext:cls="Ext.Container">layout</a> config option, and should generally not need to be created
 directly via the new keyword. See <tt><b><a href="output/Ext.Container.html#Ext.Container-layout" ext:member="layout"
 ext:cls="Ext.Container">Ext.Container.layout</a></b></tt> for additional details.</p> 
 <p>In an application, it will
 usually be preferrable to use a <a href="output/Ext.form.FormPanel.html" ext:cls="Ext.form.FormPanel">FormPanel</a>
 (which is configured with FormLayout as its layout class by default) since it also provides built-in functionality for
 <a href="output/Ext.form.BasicForm.html#Ext.form.BasicForm-doAction" ext:member="doAction"
 ext:cls="Ext.form.BasicForm">loading, validating and submitting</a> the form.</p> 
 <p>A <a
 href="output/Ext.Container.html" ext:cls="Ext.Container">Container</a> <i>using</i> the FormLayout layout manager (e.g.
 <a href="output/Ext.form.FormPanel.html" ext:cls="Ext.form.FormPanel">Ext.form.FormPanel</a> or specifying
 <tt>layout:'form'</tt>) can also accept the following layout-specific config properties:</p>
 <div
 class="mdetail-params">
  <ul> 
   <li><b><tt><a href="output/Ext.form.FormPanel.html#Ext.form.FormPanel-hideLabels"
 ext:member="hideLabels" ext:cls="Ext.form.FormPanel">hideLabels</a></tt></b></li> 
   <li><b><tt><a
 href="output/Ext.form.FormPanel.html#Ext.form.FormPanel-labelAlign" ext:member="labelAlign"
 ext:cls="Ext.form.FormPanel">labelAlign</a></tt></b></li> 
   <li><b><tt><a
 href="output/Ext.form.FormPanel.html#Ext.form.FormPanel-labelPad" ext:member="labelPad"
 ext:cls="Ext.form.FormPanel">labelPad</a></tt></b></li> 
   <li><b><tt><a
 href="output/Ext.form.FormPanel.html#Ext.form.FormPanel-labelSeparator" ext:member="labelSeparator"
 ext:cls="Ext.form.FormPanel">labelSeparator</a></tt></b></li> 
   <li><b><tt><a
 href="output/Ext.form.FormPanel.html#Ext.form.FormPanel-labelWidth" ext:member="labelWidth"
 ext:cls="Ext.form.FormPanel">labelWidth</a></tt></b></li> 
  </ul>
 </div>
 <p></p> 
 <p>Any Component (including Fields)
 managed by FormLayout accepts the following as a config option: </p>
 <div class="mdetail-params">
  <ul> 
   <li><b><tt><a
 href="output/Ext.Component.html#Ext.Component-anchor" ext:member="anchor"
 ext:cls="Ext.Component">anchor</a></tt></b></li> 
  </ul>
 </div>
 <p></p> 
 <p>Any Component managed by FormLayout may be
 rendered as a form field (with an associated label) by configuring it with a non-null <b><tt><a
 href="output/Ext.Component.html#Ext.Component-fieldLabel" ext:member="fieldLabel"
 ext:cls="Ext.Component">fieldLabel</a></tt></b>. Components configured in this way may be configured with the following
 options which affect the way the FormLayout renders them: </p>
 <div class="mdetail-params">
  <ul> 
   <li><b><tt><a
 href="output/Ext.Component.html#Ext.Component-clearCls" ext:member="clearCls"
 ext:cls="Ext.Component">clearCls</a></tt></b></li> 
   <li><b><tt><a
 href="output/Ext.Component.html#Ext.Component-fieldLabel" ext:member="fieldLabel"
 ext:cls="Ext.Component">fieldLabel</a></tt></b></li> 
   <li><b><tt><a
 href="output/Ext.Component.html#Ext.Component-hideLabel" ext:member="hideLabel"
 ext:cls="Ext.Component">hideLabel</a></tt></b></li> 
   <li><b><tt><a
 href="output/Ext.Component.html#Ext.Component-itemCls" ext:member="itemCls"
 ext:cls="Ext.Component">itemCls</a></tt></b></li> 
   <li><b><tt><a
 href="output/Ext.Component.html#Ext.Component-labelSeparator" ext:member="labelSeparator"
 ext:cls="Ext.Component">labelSeparator</a></tt></b></li> 
   <li><b><tt><a
 href="output/Ext.Component.html#Ext.Component-labelStyle" ext:member="labelStyle"
 ext:cls="Ext.Component">labelStyle</a></tt></b></li> 
  </ul>
 </div>
 <p></p> 
 <p>Example usage:</p> 
 <pre><code><i>//
 Required <b>if</b> showing validation messages</i>
 Ext.QuickTips.init();
 
 <i>// While you can create a basic Panel
 <b>with</b> layout:<em>'form'</em>, practically</i>
 <i>// you should usually use a FormPanel to also get its form
 functionality</i>
 <i>// since it already creates a FormLayout internally.</i>
 <b>var</b> form = <b>new</b>
 Ext.form.FormPanel({
     title: <em>'Form Layout'</em>,
     bodyStyle: <em>'padding:15px'</em>,
     width: 350,
    
 defaultType: <em>'textfield'</em>,
     defaults: {
         <i>// applied to each contained item</i>
         width: 230,
 
 msgTarget: <em>'side'</em>
     },
     items: [{
             fieldLabel: <em>'First Name'</em>,
             name:
 <em>'first'</em>,
             allowBlank: false,
             <a
 href="output/Ext.Component.html#Ext.Component-labelSeparator" ext:member="labelSeparator"
 ext:cls="Ext.Component">labelSeparator</a>: <em>':'</em> <i>// override labelSeparator layout config</i>
         },{
    
 fieldLabel: <em>'Last Name'</em>,
             name: <em>'last'</em>
         },{
             fieldLabel:
 <em>'Email'</em>,
             name: <em>'email'</em>,
             vtype:<em>'email'</em>
         }, {
             xtype:
 <em>'textarea'</em>,
             hideLabel: true,     <i>// override hideLabels layout config</i>
             name:
 <em>'msg'</em>,
             anchor: <em>'100% -53'</em>
         }
     ],
     buttons: [
         {text:
 <em>'Save'</em>},
         {text: <em>'Cancel'</em>}
     ],
     layoutConfig: {
         <a
 href="output/Ext.layout.FormLayout.html#Ext.layout.FormLayout-labelSeparator" ext:member="labelSeparator"
 ext:cls="Ext.layout.FormLayout">labelSeparator</a>: <em>'~'</em> <i>// superseded by assignment below</i>
     },
    
 <i>// config options applicable to container when layout=<em>'form'</em>:</i>
     hideLabels: false,
     labelAlign:
 <em>'left'</em>,   <i>// or <em>'right'</em> or <em>'top'</em></i>
     <a
 href="output/Ext.form.FormPanel.html#Ext.form.FormPanel-labelSeparator" ext:member="labelSeparator"
 ext:cls="Ext.form.FormPanel">labelSeparator</a>: <em>'&gt;&gt;'</em>, <i>// takes precedence over layoutConfig
 value</i>
     labelWidth: 65,       <i>// defaults to 100</i>
     labelPad: 8           <i>// defaults to 5, must
 specify labelWidth to be honored</i>
 });</code></pre>]]></description><name>layout.form</name><tag-class>org.brushingbits.jnap.ui.extjs3.layout.FormLayout</tag-class><body-content>empty</body-content><attribute><description><![CDATA[This configuation option is to be applied to child items of a container managed by this layout (ie. configured with
 layout:'anchor'). This value is what tells the layout how an item should be anchored to the container. items added to an
 AnchorLayout accept an anchoring-specific config property of anchor which is a string containing two values: the
 horizontal anchor value and the vertical anchor value (for example, '100% 50%'). The following types of anchor values
 are supported: Percentage : Any value between 1 and 100, expressed as a percentage. The first anchor is the percentage
 width that the item should take up within the container, and the second is the percentage height. For example: // two
 values specified
 anchor: '100% 50%' // render item complete width of the container and
                    // 1/2 height
 of the container
 // one value specified
 anchor: '100%'     // the width value; the height will default to auto Offsets :
 Any positive or negative integer value. This is a raw adjustment where the first anchor is the offset from the right
 edge of the container, and the second is the offset from the bottom edge. For example: // two values specified
 anchor:
 '-50 -100' // render item the complete width of the container
                    // minus 50 pixels and
                 
 // the complete height minus 100 pixels.
 // one value specified
 anchor: '-50'      // anchor value is assumed to be the
 right offset value
                    // bottom offset will default to 0 Sides : Valid values are 'right' (or 'r') and
 'bottom' (or 'b'). Either the container must have a fixed size or an anchorSize config value defined at render time in
 order for these to have any effect. Mixed : Anchor values can also be mixed as needed. For example, to render the width
 offset from the container right edge by 50 pixels and 75% of the container's height use: anchor: '-50 75%']]></description><name>anchor</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[default anchor for all child container items applied if no anchor or specific width is set on the child item. Defaults
 to '100%'.]]></description><name>defaultAnchor</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to the container. This can be useful for adding customized styles to the
 container or any of its children using standard CSS rules. See Ext.Component.ctCls also. Note: extraCls defaults to ''
 except for the following classes which assign a value by default: Absolute Layout : 'x-abs-layout-item' Box Layout :
 'x-box-item' Column Layout : 'x-column' To configure the above Classes with an extra CSS class append to the default.
 For example, for ColumnLayout: extraCls: 'x-column custom-class']]></description><name>extraCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A compiled Ext.Template for rendering the fully wrapped, labeled and styled form Field. Defaults to: new Ext.Template(
  
 '<div class="x-form-item {itemCls}" tabIndex="-1">',
         '<label for="{id}" style="{labelStyle}"
 class="x-form-item-label">{label}{labelSeparator}</label>',
         '<div class="x-form-element" id="x-form-el-{id}"
 style="{elementStyle}">',
         '</div><div class="{clearCls}"></div>',
     '</div>'
 ); This may be specified to
 produce a different DOM structure when rendering form Fields. A description of the properties within the template
 follows: itemCls : String The CSS class applied to the outermost div wrapper that contains this field label and field
 element (the default class is 'x-form-item' and itemCls will be added to that). If supplied, itemCls at the field level
 will override the default itemCls supplied at the container level. id : String The id of the Field labelStyle : String A
 CSS style specification string to add to the field label for this field (defaults to '' or the layout's value for
 labelStyle). label : String The text to display as the label for this field (defaults to '') labelSeparator : String The
 separator to display after the text of the label for this field (defaults to a colon ':' or the layout's value for
 labelSeparator). To hide the separator use empty string ''. elementStyle : String The styles text for the input
 element's wrapper. clearCls : String The CSS class to apply to the special clearing div rendered directly after each
 form field wrapper (defaults to 'x-form-clear-left') Also see getTemplateArgs]]></description><name>fieldTpl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[See Ext.form.FormPanel.labelSeparator. Configuration of this property at the container level takes precedence.]]></description><name>labelSeparator</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide each contained item on render (defaults to false).]]></description><name>renderHidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to show/hide the field label when the field is hidden. Defaults to true.]]></description><name>trackLabels</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 <p>A layout that arranges items horizontally across a Container. This layout optionally divides available horizontal
 space between child items containing a numeric <code>flex</code> configuration.</p> This layout may also be used to set
 the heights of child items by configuring it with the 
 <a
 href="output/Ext.layout.HBoxLayout.html#Ext.layout.HBoxLayout-align" ext:member="align"
 ext:cls="Ext.layout.HBoxLayout">align</a> option.]]></description><name>layout.hbox</name><tag-class>org.brushingbits.jnap.ui.extjs3.layout.HBoxLayout</tag-class><body-content>empty</body-content><attribute><description><![CDATA[Controls how the child items of the container are aligned. Acceptable configuration values for this property are: top :
 Default child items are aligned vertically at the top of the container middle : child items are aligned vertically in
 the middle of the container stretch : child items are stretched vertically to fill the height of the container
 stretchmax : child items are stretched vertically to the height of the largest item.]]></description><name>align</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If the individual contained items do not have a margins property specified, the default margins from this property will
 be applied to each item. This property may be specified as an object containing margins to apply in the format:
 <pre><code>{
 top: (top margin),
     right: (right margin),
     bottom: (bottom margin),
     left: (left margin)
 }</pre></code>
 This property may
 also be specified as a string containing space-separated, numeric margin values. The order of the sides associated with
 each value matches the way CSS processes margin values: If there is only one value, it applies to all sides. If there
 are two values, the top and bottom borders are set to the first value and the right and left are set to the second. If
 there are three values, the top is set to the first value, the left and right are set to the second, and the bottom is
 set to the third. If there are four values, they apply to the top, right, bottom, and left, respectively. Defaults to:
 {top:0, right:0, bottom:0, left:0}]]></description><name>defaultMargins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to the container. This can be useful for adding customized styles to the
 container or any of its children using standard CSS rules. See Ext.Component.ctCls also. Note: extraCls defaults to ''
 except for the following classes which assign a value by default: Absolute Layout : 'x-abs-layout-item' Box Layout :
 'x-box-item' Column Layout : 'x-column' To configure the above Classes with an extra CSS class append to the default.
 For example, for ColumnLayout: extraCls: 'x-column custom-class']]></description><name>extraCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[This configuation option is to be applied to child items of the container managed by this layout. Each child item with a
 flex property will be flexed horizontally according to each item's relative flex value compared to the sum of all items
 with a flex value specified. Any child items that have either a flex = 0 or flex = undefined will not be 'flexed' (the
 initial size will not be changed).]]></description><name>flex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Controls how the child items of the container are packed together. Acceptable configuration values for this property
 are: start : Default child items are packed together at left side of container center : child items are packed together
 at mid-width of container end : child items are packed together at right side of container]]></description><name>pack</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Sets the padding to be applied to all child items managed by this layout. This property must be specified as a string
 containing space-separated, numeric padding values. The order of the sides associated with each value matches the way
 CSS processes padding values: If there is only one value, it applies to all sides. If there are two values, the top and
 bottom borders are set to the first value and the right and left are set to the second. If there are three values, the
 top is set to the first value, the left and right are set to the second, and the bottom is set to the third. If there
 are four values, they apply to the top, right, bottom, and left, respectively. Defaults to: "0"]]></description><name>padding</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide each contained item on render (defaults to false).]]></description><name>renderHidden</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 <p>This layout allows you to easily render content into an HTML table. The total number of columns can be specified, and
 rowspan and colspan can be used to create complex layouts within the table. This class is intended to be extended or
 created via the layout:'table' <a href="output/Ext.Container.html#Ext.Container-layout" ext:member="layout"
 ext:cls="Ext.Container">Ext.Container.layout</a> config, and should generally not need to be created directly via the
 new keyword.</p> 
 <p>Note that when creating a layout via config, the layout-specific config properties must be passed
 in via the <a href="output/Ext.Container.html#Ext.Container-layoutConfig" ext:member="layoutConfig"
 ext:cls="Ext.Container">Ext.Container.layoutConfig</a> object which will then be applied internally to the layout. In
 the case of TableLayout, the only valid layout config property is <a
 href="output/Ext.layout.TableLayout.html#Ext.layout.TableLayout-columns" ext:member="columns"
 ext:cls="Ext.layout.TableLayout">columns</a>. However, the items added to a TableLayout can supply the following
 table-specific config properties:</p> 
 <ul> 
  <li><b>rowspan</b> Applied to the table cell containing the item.</li> 
 
 <li><b>colspan</b> Applied to the table cell containing the item.</li> 
  <li><b>cellId</b> An id applied to the table
 cell containing the item.</li> 
  <li><b>cellCls</b> A CSS class name added to the table cell containing the item.</li>
 
 </ul> 
 <p>The basic concept of building up a TableLayout is conceptually very similar to building up a standard HTML
 table. You simply add each panel (or &quot;cell&quot;) that you want to include along with any span attributes specified
 as the special config properties of rowspan and colspan which work exactly like their HTML counterparts. Rather than
 explicitly creating and nesting rows and columns as you would in HTML, you simply specify the total column count in the
 layoutConfig and start adding panels in their natural order from left to right, top to bottom. The layout will
 automatically figure out, based on the column count, rowspans and colspans, how to position each panel within the table.
 Just like with HTML tables, your rowspans and colspans must add up correctly in your overall layout or you'll end up
 with missing and/or extra cells! Example usage:</p> 
 <pre><code><i>// This code will generate a layout table that is 3
 columns by 2 rows</i>
 <i>// <b>with</b> some spanning included.  The basic layout will be:</i>
 <i>//
 +--------+-----------------+</i>
 <i>// |   A    |   B             |</i>
 <i>// |        |--------+--------|</i>
 <i>// |  
 |   C    |   D    |</i>
 <i>// +--------+--------+--------+</i>
 <b>var</b> table = <b>new</b> Ext.Panel({
     title:
 <em>'Table Layout'</em>,
     layout:<em>'table'</em>,
     defaults: {
         <i>// applied to each contained panel</i>
 
 bodyStyle:<em>'padding:20px'</em>
     },
     layoutConfig: {
         <i>// The total column count must be specified
 here</i>
         columns: 3
     },
     items: [{
         html: <em>'&lt;p&gt;Cell A content&lt;/p&gt;'</em>,
        
 rowspan: 2
     },{
         html: <em>'&lt;p&gt;Cell B content&lt;/p&gt;'</em>,
         colspan: 2
     },{
         html:
 <em>'&lt;p&gt;Cell C content&lt;/p&gt;'</em>,
         cellCls: <em>'highlight'</em>
     },{
         html:
 <em>'&lt;p&gt;Cell D content&lt;/p&gt;'</em>
     }]
 });</code></pre>]]></description><name>layout.table</name><tag-class>org.brushingbits.jnap.ui.extjs3.layout.TableLayout</tag-class><body-content>empty</body-content><attribute><description><![CDATA[The total number of columns to create in the table for this layout. If not specified, all Components added to this
 layout will be rendered into a single row using one column per Component.]]></description><name>columns</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to the container. This can be useful for adding customized styles to the
 container or any of its children using standard CSS rules. See Ext.Component.ctCls also. Note: extraCls defaults to ''
 except for the following classes which assign a value by default: Absolute Layout : 'x-abs-layout-item' Box Layout :
 'x-box-item' Column Layout : 'x-column' To configure the above Classes with an extra CSS class append to the default.
 For example, for ColumnLayout: extraCls: 'x-column custom-class']]></description><name>extraCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide each contained item on render (defaults to false).]]></description><name>renderHidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object containing properties which are added to the DomHelper specification used to create the layout's <table>
 element. Example: {
     xtype: 'panel',
     layout: 'table',
     layoutConfig: {
         tableAttrs: {
            
 style: {
                 width: '100%'
             }
         },
         columns: 3
     }
 }]]></description><name>tableAttrs</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 <p>A layout that arranges items vertically down a Container. This layout optionally divides available vertical space
 between child items containing a numeric <code>flex</code> configuration.</p> This layout may also be used to set the
 widths of child items by configuring it with the 
 <a
 href="output/Ext.layout.VBoxLayout.html#Ext.layout.VBoxLayout-align" ext:member="align"
 ext:cls="Ext.layout.VBoxLayout">align</a> option.]]></description><name>layout.vbox</name><tag-class>org.brushingbits.jnap.ui.extjs3.layout.VBoxLayout</tag-class><body-content>empty</body-content><attribute><description><![CDATA[Controls how the child items of the container are aligned. Acceptable configuration values for this property are: left :
 Default child items are aligned horizontally at the left side of the container center : child items are aligned
 horizontally at the mid-width of the container stretch : child items are stretched horizontally to fill the width of the
 container stretchmax : child items are stretched horizontally to the size of the largest item.]]></description><name>align</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If the individual contained items do not have a margins property specified, the default margins from this property will
 be applied to each item. This property may be specified as an object containing margins to apply in the format:
 <pre><code>{
 top: (top margin),
     right: (right margin),
     bottom: (bottom margin),
     left: (left margin)
 }</pre></code>
 This property may
 also be specified as a string containing space-separated, numeric margin values. The order of the sides associated with
 each value matches the way CSS processes margin values: If there is only one value, it applies to all sides. If there
 are two values, the top and bottom borders are set to the first value and the right and left are set to the second. If
 there are three values, the top is set to the first value, the left and right are set to the second, and the bottom is
 set to the third. If there are four values, they apply to the top, right, bottom, and left, respectively. Defaults to:
 {top:0, right:0, bottom:0, left:0}]]></description><name>defaultMargins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to the container. This can be useful for adding customized styles to the
 container or any of its children using standard CSS rules. See Ext.Component.ctCls also. Note: extraCls defaults to ''
 except for the following classes which assign a value by default: Absolute Layout : 'x-abs-layout-item' Box Layout :
 'x-box-item' Column Layout : 'x-column' To configure the above Classes with an extra CSS class append to the default.
 For example, for ColumnLayout: extraCls: 'x-column custom-class']]></description><name>extraCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[This configuation option is to be applied to child items of the container managed by this layout. Each child item with a
 flex property will be flexed vertically according to each item's relative flex value compared to the sum of all items
 with a flex value specified. Any child items that have either a flex = 0 or flex = undefined will not be 'flexed' (the
 initial size will not be changed).]]></description><name>flex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Controls how the child items of the container are packed together. Acceptable configuration values for this property
 are: start : Default child items are packed together at top side of container center : child items are packed together
 at mid-height of container end : child items are packed together at bottom side of container]]></description><name>pack</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Sets the padding to be applied to all child items managed by this layout. This property must be specified as a string
 containing space-separated, numeric padding values. The order of the sides associated with each value matches the way
 CSS processes padding values: If there is only one value, it applies to all sides. If there are two values, the top and
 bottom borders are set to the first value and the right and left are set to the second. If there are three values, the
 top is set to the first value, the left and right are set to the second, and the bottom is set to the third. If there
 are four values, they apply to the top, right, bottom, and left, respectively. Defaults to: "0"]]></description><name>padding</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide each contained item on render (defaults to false).]]></description><name>renderHidden</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 <p>A Column definition class which renders boolean data fields. See the <a
 href="output/Ext.list.Column.html#Ext.list.Column-xtype" ext:member="xtype" ext:cls="Ext.list.Column">xtype</a> config
 option of <a href="output/Ext.list.Column.html" ext:cls="Ext.list.Column">Ext.list.Column</a> for more details.</p>]]></description><name>list.booleanColumn</name><tag-class>org.brushingbits.jnap.ui.extjs3.list.BooleanColumn</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[Set the CSS text-align property of the column. Defaults to 'left'.]]></description><name>align</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. This option can be used to add a CSS class to the cell of each row for this column.]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Required. The name of the field in the ListViews's Ext.data.Store's Ext.data.Record definition from which to draw the
 column's value.]]></description><name>dataIndex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The string returned by the renderer when the column value is falsey (but not undefined) (defaults to 'false').]]></description><name>falseText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. The header text to be used as innerHTML (html tags are accepted) to display in the ListView. Note: to have a
 clickable header with no text displayed use '&#160'.]]></description><name>header</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify a string to pass as the configuration string for Ext.XTemplate. By default an Ext.XTemplate will be
 implicitly created using the dataIndex.]]></description><name>tpl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The string returned by the renderer when the column value is not falsey (defaults to 'true').]]></description><name>trueText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The string returned by the renderer when the column value is undefined (defaults to ' ').]]></description><name>undefinedText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Percentage of the container width this column should be allocated. Columns that have no width specified will
 be allocated with an equal percentage to fill 100% of the container width. To easily take advantage of the full
 container width, leave the width of at least one column undefined. Note that if you do not want to take up the full
 width of the container, the width of every column needs to be explicitly defined.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 <p>This class encapsulates column configuration data to be used in the initialization of a <a
 href="output/Ext.list.ListView.html" ext:cls="Ext.list.ListView">ListView</a>.</p> 
 <p>While subclasses are provided to
 render data in different ways, this class renders a passed data field unchanged and is usually used for textual
 columns.</p>]]></description><name>list.column</name><tag-class>org.brushingbits.jnap.ui.extjs3.list.Column</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[Set the CSS text-align property of the column. Defaults to 'left'.]]></description><name>align</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. This option can be used to add a CSS class to the cell of each row for this column.]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Required. The name of the field in the ListViews's Ext.data.Store's Ext.data.Record definition from which to draw the
 column's value.]]></description><name>dataIndex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. The header text to be used as innerHTML (html tags are accepted) to display in the ListView. Note: to have a
 clickable header with no text displayed use '&#160'.]]></description><name>header</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify a string to pass as the configuration string for Ext.XTemplate. By default an Ext.XTemplate will be
 implicitly created using the dataIndex.]]></description><name>tpl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Percentage of the container width this column should be allocated. Columns that have no width specified will
 be allocated with an equal percentage to fill 100% of the container width. To easily take advantage of the full
 container width, leave the width of at least one column undefined. Note that if you do not want to take up the full
 width of the container, the width of every column needs to be explicitly defined.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 <p>Supporting Class for Ext.list.ListView</p>]]></description><name>list.columnResizer</name><tag-class>org.brushingbits.jnap.ui.extjs3.list.ColumnResizer</tag-class><body-content>scriptless</body-content><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum percentage to allot for any column (defaults to .05)]]></description><name>minPct</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 <p>Ext.list.ListView is a fast and light-weight implentation of a <a href="output/Ext.grid.GridPanel.html"
 ext:cls="Ext.grid.GridPanel">Grid</a> like view with the following characteristics:</p> 
 <div class="mdetail-params">
 
 <ul> 
   <li>resizable columns</li> 
   <li>selectable</li> 
   <li>column widths are initially proportioned by percentage
 based on the container width and number of columns</li> 
   <li>uses templates to render the data in any required
 format</li> 
   <li>no horizontal scrolling</li> 
   <li>no editing</li> 
  </ul>
 </div> 
 <p>Example usage:</p>
 
 <pre><code><i>// consume JSON of this form:</i>
 {
    <em>&quot;images&quot;</em>:[
       {
         
 <em>&quot;name&quot;</em>:<em>&quot;dance_fever.jpg&quot;</em>,
          <em>&quot;size&quot;</em>:2067,
         
 <em>&quot;lastmod&quot;</em>:1236974993000,
         
 <em>&quot;url&quot;</em>:<em>&quot;images\/thumbs\/dance_fever.jpg&quot;</em>
       },
       {
         
 <em>&quot;name&quot;</em>:<em>&quot;zack_sink.jpg&quot;</em>,
          <em>&quot;size&quot;</em>:2303,
         
 <em>&quot;lastmod&quot;</em>:1236974993000,
         
 <em>&quot;url&quot;</em>:<em>&quot;images\/thumbs\/zack_sink.jpg&quot;</em>
       }
    ]
 }
 <b>var</b> store = <b>new</b>
 Ext.data.JsonStore({
     url: <em>'get-images.php'</em>,
     root: <em>'images'</em>,
     fields: [
        
 <em>'name'</em>, <em>'url'</em>,
         {name:<em>'size'</em>, type: <em>'float'</em>},
        
 {name:<em>'lastmod'</em>, type:<em>'date'</em>, dateFormat:<em>'timestamp'</em>}
     ]
 });
 store.load();
 
 <b>var</b>
 listView = <b>new</b> Ext.list.ListView({
     store: store,
     multiSelect: true,
     emptyText: <em>'No images to
 display'</em>,
     reserveScrollOffset: true,
     columns: [{
         header: <em>'File'</em>,
         width: .5,
       
 dataIndex: <em>'name'</em>
     },{
         header: <em>'Last Modified'</em>,
         width: .35,
         dataIndex:
 <em>'lastmod'</em>,
         tpl: <em>'{lastmod:date(<em>&quot;m-d h:i a&quot;</em>)}'</em>
     },{
         header:
 <em>'Size'</em>,
         dataIndex: <em>'size'</em>,
         tpl: <em>'{size:fileSize}'</em>, <i>// format using
 Ext.util.Format.fileSize()</i>
         align: <em>'right'</em>
     }]
 });
 
 <i>// put it <b>in</b> a Panel so it looks
 pretty</i>
 <b>var</b> panel = <b>new</b> Ext.Panel({
     id:<em>'images-view'</em>,
     width:425,
     height:250,
    
 collapsible:true,
     layout:<em>'fit'</em>,
     title:<em>'Simple ListView <i>(0 items selected)</i>'</em>,
     items:
 listView
 });
 panel.render(document.body);
 
 <i>// little bit of feedback</i>
 listView.on(<em>'selectionchange'</em>,
 <b>function</b>(view, nodes){
     <b>var</b> l = nodes.length;
     <b>var</b> s = l != 1 ? <em>'s'</em> : <em>''</em>;
  
 panel.setTitle(<em>'Simple ListView <i>('</i></em><i>+l+<em>' item'</em>+s+<em>'
 selected)</em></i><em>'</em>);
 });</code></pre>]]></description><name>list.listView</name><tag-class>org.brushingbits.jnap.ui.extjs3.list.ListView</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[Whether the component can move the Dom node when rendering (defaults to true).]]></description><name>allowDomMove</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use an
 AnchorLayout (or subclass thereof). based layout manager, for example: Ext.form.FormPanel specifying layout: 'anchor' //
 or 'form', or 'absolute' See Ext.layout.AnchorLayout.anchor also.]]></description><name>anchor</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element corresponding to a DIV that is already present in
 the document that specifies some structural markup for this component. Description : When applyTo is used, constituent
 parts of the component can also be specified by id or CSS class name within the main element, and the component being
 created may attempt to create its subcomponents from that markup if applicable. Notes : When using this config, a call
 to render() is not required. If applyTo is specified, any value passed for renderTo will be ignored and the target
 element's parent node will automatically be used as the component's container.]]></description><name>applyTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A tag name or DomHelper spec used to create the Element which will encapsulate this Component. You do not normally need
 to specify this. For the base classes Ext.Component, Ext.BoxComponent, and Ext.Container, this defaults to 'div'. The
 more complex Ext classes use a more complex DOM structure created by their own onRender methods. This is intended to
 allow the developer to create application-specific utility Components encapsulated by different DOM elements. Example
 usage: <pre><code>{
     xtype: 'box',
     autoEl: {
         tag: 'img',
         src: 'http://www.example.com/example.jpg'
     }
 },
 {
     xtype: 'box',
     autoEl: {
         tag: 'blockquote',
         html: 'autoEl is cool!'
     }
 }, {
     xtype: 'container',
     autoEl: 'ul',
     cls: 'ux-unordered-list',
     items: {
         xtype: 'box',
         autoEl: 'li',
   
      html: 'First list item'
     }
 }</pre></code>]]></description><name>autoEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to use height:'auto', false to use fixed height (or allow it to be managed by its parent Container's layout
 manager. Defaults to false. Note: Although many components inherit this config option, not all will function as expected
 with a height of 'auto'. Setting autoHeight:true means that the browser will manage height based on the element's
 contents, and that Ext will not manage it at all. If the browser is managing the height, be aware that resizes performed
 by the browser in response to changes within the structure of the Component cannot be detected. Therefore changes to the
 height might result in elements needing to be synchronized with the new height. Example: var w = new Ext.Window({
    
 title: 'Window',
     width: 600,
     autoHeight: true,
     items: {
         title: 'Collapse Me',
         height: 400,
  
 collapsible: true,
         border: false,
         listeners: {
             beforecollapse: function() {
                w.el.shadow.hide();
             },
             beforeexpand: function() {
                w.el.shadow.hide();
             },
             collapse: function() {
                w.syncShadow();
             },
             expand: function() {
                w.syncShadow();
             }
         }
     }
 }).show();]]></description><name>autoHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to use overflow:'auto' on the components layout element and show scroll bars automatically when necessary, false to
 clip any overflowing content (defaults to false).]]></description><name>autoScroll</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True if the component should check for hidden classes (e.g. 'x-hidden' or 'x-hide-display') and remove them on render
 (defaults to false).]]></description><name>autoShow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to use width:'auto', false to use fixed width (or allow it to be managed by its parent Container's layout manager.
 Defaults to false. Note: Although many components inherit this config option, not all will function as expected with a
 width of 'auto'. Setting autoWidth:true means that the browser will manage width based on the element's contents, and
 that Ext will not manage it at all. If the browser is managing the width, be aware that resizes performed by the browser
 in response to changes within the structure of the Component cannot be detected. Therefore changes to the width might
 result in elements needing to be synchronized with the new width. For example, where the target element is: <div
 id='grid-container' style='margin-left:25%;width:50%'></div> A Panel rendered into that target element must listen for
 browser window resize in order to relay its child items when the browser changes its width: var myPanel = new
 Ext.Panel({
     renderTo: 'grid-container',
     monitorResize: true, // relay on browser resize
     title: 'Panel',
    
 height: 400,
     autoWidth: true,
     layout: 'hbox',
     layoutConfig: {
         align: 'stretch'
     },
     defaults: {
         flex: 1
     },
     items: [{
         title: 'Box 1',
     }, {
         title: 'Box 2'
     }, {
         title:
 'Box 3'
     }],
 });]]></description><name>autoWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Set this to true to ignore datachanged events on the bound store. This is useful if you wish to provide custom
 transition animations via a plugin (defaults to false)]]></description><name>blockRefresh</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to [].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class used to to apply to the special clearing div rendered directly after each form field wrapper to provide
 field clearing (defaults to 'x-form-clear-left'). Note: this config is only used when this Component is rendered by a
 Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or specifying
 layout:'form') and either a fieldLabel is specified or isFormField=true is specified. See Ext.layout.FormLayout.fieldTpl
 also.]]></description><name>clearCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element (defaults to ''). This can be useful for
 adding customized styles to the component or any of its children using standard CSS rules.]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify true or specify a configuration object for Ext.list.ListView.ColumnResizer to enable the columns to be resizable
 (defaults to true).]]></description><name>columnResize</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify true or specify a configuration object for Ext.list.ListView.Sorter to enable the columns to be sortable
 (defaults to true).]]></description><name>columnSort</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of column configuration objects, for example: {
     align: 'right',
     dataIndex: 'size',
     header: 'Size',
 
 tpl: '{size:fileSize}',
     width: .35
 } Acceptable properties for each column configuration object are: align : String
 Set the CSS text-align property of the column. Defaults to 'left'. dataIndex : String See Ext.grid.Column. dataIndex for
 details. header : String See Ext.grid.Column. header for details. tpl : String Specify a string to pass as the
 configuration string for Ext.XTemplate. By default an Ext.XTemplate will be implicitly created using the dataIndex.
 width : Number Percentage of the container width this column should be allocated. Columns that have no width specified
 will be allocated with an equal percentage to fill 100% of the container width. To easily take advantage of the full
 container width, leave the width of at least one column undefined. Note that if you do not want to take up the full
 width of the container, the width of every column needs to be explicitly defined.]]></description><name>columns</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's container. This can be useful for adding customized
 styles to the container or any of its children using standard CSS rules. See Ext.layout.ContainerLayout.extraCls also.
 Note: ctCls defaults to '' except for the following class which assigns a value by default: Box Layout :
 'x-box-layout-ct' To configure the above Class with an extra CSS class append to the default. For example, for BoxLayout
 (Hbox and Vbox): ctCls: 'x-box-layout-ct custom-class']]></description><name>ctCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to defer emptyText being applied until the store's first load]]></description><name>deferEmptyText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component disabled (default is false).]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class added to the component when it is disabled (defaults to 'x-item-disabled').]]></description><name>disabledClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The text to display in the view when there is no data to display (defaults to '').]]></description><name>emptyText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The label text to display next to this Component (defaults to ''). Note: this config is only used when this Component is
 rendered by a Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or
 specifying layout:'form'). Also see hideLabel and Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
    
 height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name'
    
 }]
 });]]></description><name>fieldLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use a
 BoxLayout. Each child Component with a flex property will be flexed either vertically (by a VBoxLayout) or horizontally
 (by an HBoxLayout) according to the item's relative flex value compared to the sum of all Components with flex value
 specified. Any child items that have either a flex = 0 or flex = undefined will not be 'flexed' (the initial size will
 not be changed).]]></description><name>flex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component hidden (default is false). If true, the hide method will be called internally.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to hide the header row (defaults to false so the header row will be shown).]]></description><name>hideHeaders</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to completely hide the label element (label and separator). Defaults to false. By default, even if you do not
 specify a fieldLabel the space will still be reserved so that the field will line up with other fields that do have
 labels. Setting this to true will cause the field to not reserve that space. Note: see the note for clearCls. Example
 use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield'
        
 hideLabel: true
     }]
 });]]></description><name>hideLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[How this component should be hidden. Supported values are 'visibility' (css visibility), 'offsets' (negative offset
 position) and 'display' (css display). Note: the default of 'display' is generally preferred since items are
 automatically laid out when they are first shown (no sizing is done while hidden).]]></description><name>hideMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide and show the component's container when hide/show is called on the component, false to hide and show the
 component itself (defaults to false). For example, this can be used as a shortcut for a hide button on a window by
 setting hide:true on the button when adding it to its parent container.]]></description><name>hideParent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id of this component (defaults to an auto-assigned id). You should assign an id if you need to be able to
 access the component later and you do not have an object reference available (e.g., using Ext.getCmp). Note that this id
 will also be used as the element id for the containing HTML element that is rendered to the page for this component.
 This allows you to write id-based CSS rules to style the specific instance of this component uniquely, and also to
 select sub-elements using this component's id as the parent. Note: to avoid complications imposed by a unique id also
 see itemId and ref. Note: to access the container of an item see ownerCt.]]></description><name>id</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The template to be used for the header row. See tpl for more details.]]></description><name>internalTpl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use the
 FormLayout layout manager (e.g. Ext.form.FormPanel or specifying layout:'form'). An additional CSS class to apply to the
 div wrapping the form item element of this field. If supplied, itemCls at the field level will override the default
 itemCls supplied at the container level. The value specified for itemCls will be added to the default class
 ('x-form-item'). Since it is applied to the item wrapper (see Ext.layout.FormLayout.fieldTpl), it allows you to write
 standard CSS rules that can apply to the field, the label (if specified), or any other element within the markup for the
 field. Note: see the note for fieldLabel. Example use: // Apply a style to the field's label:
 <style>
     .required
 .x-form-item-label {font-weight:bold;color:red;}
 </style>
 
 new Ext.FormPanel({
     height: 100,
     renderTo:
 Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         itemCls: 'required' //this
 label will be styled
     },{
         xtype: 'textfield',
         fieldLabel: 'Favorite Color'
     }]
 });]]></description><name>itemCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An itemId can be used as an alternative way to get a reference to a component when no object reference is available.
 Instead of using an id with Ext.getCmp, use itemId with Ext.Container.getComponent which will retrieve itemId's or id's.
 Since itemId's are an index to the container's internal MixedCollection, the itemId is scoped locally to the container
 -- avoiding potential conflicts with Ext.ComponentMgr which requires a unique id. var c = new Ext.Panel({ //
     height:
 300,
     renderTo: document.body,
     layout: 'auto',
     items: [
         {
             itemId: 'p1',
            
 title: 'Panel 1',
             height: 150
         },
         {
             itemId: 'p2',
             title: 'Panel 2',
  
 height: 150
         }
     ]
 })
 p1 = c.getComponent('p1'); // not the same as Ext.getCmp()
 p2 =
 p1.ownerCt.getComponent('p2'); // reference via a sibling Also see id and ref. Note: to access the container of an item
 see ownerCt.]]></description><name>itemId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to 'dl' to work with the preconfigured tpl. This setting specifies the CSS selector (e.g. div.some-class or
 span:first-child) that will be used to determine what nodes the ListView will be working with.]]></description><name>itemSelector</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The separator to display after the text of each fieldLabel. This property may be configured at various levels. The order
 of precedence is: field / component level container level layout level (defaults to colon ':') To display no separator
 for this field's label specify empty string ''. Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 layoutConfig: {
         labelSeparator: '~'   // layout config has lowest priority (defaults to ':')
     },
    
 labelSeparator: '>>',     // config at container level
     items: [{
         xtype: 'textfield',
         fieldLabel:
 'Field 1',
         labelSeparator: '...' // field/component level config supersedes others
     },{
         xtype:
 'textfield',
         fieldLabel: 'Field 2' // labelSeparator will be '='
     }]
 });]]></description><name>labelSeparator</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS style specification string to apply directly to this field's label. Defaults to the container's labelStyle value
 if set (e.g., Ext.layout.FormLayout.labelStyle , or ''). Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         labelStyle: 'font-weight:bold;'
     }]
 });]]></description><name>labelStyle</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A string to display during data load operations (defaults to undefined). If specified, this text will be displayed in a
 loading div and the view's contents will be cleared while loading, otherwise the view's contents will continue to
 display normally until the new data is loaded and the contents are replaced.]]></description><name>loadingText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout or one of the two BoxLayout subclasses. An object containing margins to apply to this BoxComponent in the
 format: {
     top: (top margin),
     right: (right margin),
     bottom: (bottom margin),
     left: (left margin)
 } May
 also be a string containing space-separated, numeric margin values. The order of the sides associated with each value
 matches the way CSS processes margin values: If there is only one value, it applies to all sides. If there are two
 values, the top and bottom borders are set to the first value and the right and left are set to the second. If there are
 three values, the top is set to the first value, the left and right are set to the second, and the bottom is set to the
 third. If there are four values, they apply to the top, right, bottom, and left, respectively. Defaults to: {top:0,
 right:0, bottom:0, left:0}]]></description><name>margins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to allow selection of more than one item at a time, false to allow selection of only a single item at a time or no
 selection at all, depending on the value of singleSelect (defaults to false).]]></description><name>multiSelect</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class applied when over a row (defaults to 'x-list-over'). An example overriding the default styling:
 .x-list-over {background-color: orange;}]]></description><name>overClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element when the mouse moves over the Element, and
 removed when the mouse moves out. (defaults to ''). This can be useful for adding customized 'active' or 'hover' styles
 to the component or any of its children using standard CSS rules.]]></description><name>overCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level x coordinate for this component if contained within a positioning container.]]></description><name>pageX</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level y coordinate for this component if contained within a positioning container.]]></description><name>pageY</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered ptype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a Plugin is being specified not as a fully
 instantiated Component, but as a Component config object. The ptype will be looked up at render time up to determine
 what type of Plugin to create. If you create your own Plugins, you may register them using
 Ext.ComponentMgr.registerPlugin in order to be able to take advantage of lazy instantiation and rendering.]]></description><name>ptype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A path specification, relative to the Component's ownerCt specifying into which ancestor Container to place a named
 reference to this Component. The ancestor axis can be traversed by using '/' characters in the path. For example, to put
 a reference to a Toolbar Button into the Panel which owns the Toolbar: var myGrid = new Ext.grid.EditorGridPanel({
    
 title: 'My EditorGridPanel',
     store: myStore,
     colModel: myColModel,
     tbar: [{
         text: 'Save',
        
 handler: saveChanges,
         disabled: true,
         ref: '../saveButton'
     }],
     listeners: {
         afteredit:
 function() {
 //          The button reference is in the GridPanel
             myGrid.saveButton.enable();
         }
    
 }
 }); In the code above, if the ref had been 'saveButton' the reference would have been placed into the Toolbar. Each
 '/' in the ref moves up one level from the Component's ownerCt. Also see the added and removed events.]]></description><name>ref</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout layout manager (e.g. specifying layout:'border'). See Ext.layout.BorderLayout also.]]></description><name>region</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[By default will defer accounting for the configured scrollOffset for 10 milliseconds. Specify true to account for the
 configured scrollOffset immediately.]]></description><name>reserveScrollOffset</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The amount of space to reserve for the scrollbar (defaults to undefined). If an explicit value isn't specified, this
 will be automatically calculated.]]></description><name>scrollOffset</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class applied to a selected row (defaults to 'x-list-selected'). An example overriding the default styling:
 .x-list-selected {background-color: yellow;}]]></description><name>selectedClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to enable multiselection by clicking on multiple items without requiring the user to hold Shift or Ctrl, false to
 force the user to hold Ctrl or Shift to select more than on item (defaults to false).]]></description><name>simpleSelect</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to allow selection of exactly one item at a time, false to allow no selection at all (defaults to false). Note that
 if multiSelect = true, this value will be ignored.]]></description><name>singleSelect</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should trigger this component to save its state (defaults to none). stateEvents may
 be any type of event supported by this component, including browser or custom events (e.g., ['click',
 'customerchange']). See stateful for an explanation of saving and restoring Component state.]]></description><name>stateEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id for this component to use for state management purposes (defaults to the component id if one was set,
 otherwise null if the component is using a generated id). See stateful for an explanation of saving and restoring
 Component state.]]></description><name>stateId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A flag which causes the Component to attempt to restore the state of internal properties from a saved state on startup.
 The component must have either a stateId or id assigned for state to be managed. Auto-generated ids are not guaranteed
 to be stable across page loads and cannot be relied upon to save and restore the same state for a component. For state
 saving to work, the state manager's provider must have been set to an implementation of Ext.state.Provider which
 overrides the set and get methods to save and recall name/value pairs. A built-in implementation,
 Ext.state.CookieProvider is available. To set the state provider for the current page: Ext.state.Manager.setProvider(new
 Ext.state.CookieProvider({
     expires: new Date(new Date().getTime()+(1000*60*60*24*7)), //7 days from now
 })); A
 stateful Component attempts to save state when one of the events listed in the stateEvents configuration fires. To save
 state, a stateful Component first serializes its state by calling getState. By default, this function does nothing. The
 developer must provide an implementation which returns an object hash which represents the Component's restorable state.
 The value yielded by getState is passed to Ext.state.Manager.set which uses the configured Ext.state.Provider to save
 the object keyed by the Component's stateId, or, if that is not specified, its id. During construction, a stateful
 Component attempts to restore its state by calling Ext.state.Manager.get passing the stateId, or, if that is not
 specified, the id. The resulting object is passed to applyState. The default implementation of applyState simply copies
 properties into the object, but a developer may override this to support more behaviour. You can perform extra
 processing on state save and restore by attaching handlers to the beforestaterestore, staterestore, beforestatesave and
 statesave events.]]></description><name>stateful</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
     title: 'Some Title',
     renderTo: Ext.getBody(),
     width: 400, height:
 300,
     layout: 'form',
     items: [{
         xtype: 'textarea',
         style: {
             width: '95%',
            
 marginBottom: '10px'
         }
     },
         new Ext.Button({
             text: 'Send',
             minWidth: '100',
   
          style: {
                 marginBottom: '10px'
             }
         })
     ]
 });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is a child item of a TabPanel. A string to be used as innerHTML
 (html tags are accepted) to show in a tooltip when mousing over the associated tab selector element.
 Ext.QuickTips.init() must be called in order for the tips to render.]]></description><name>tabTip</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to enable mouseenter and mouseleave events]]></description><name>trackOver</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local x (left) coordinate for this component if contained within a positioning container.]]></description><name>x</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered xtype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a child item of a Container is being specified not
 as a fully instantiated Component, but as a Component config object. The xtype will be looked up at render time up to
 determine what type of child Component to create. The predefined xtypes are listed here. If you subclass Components to
 create your own Components, you may register them using Ext.ComponentMgr.registerType in order to be able to take
 advantage of lazy instantiation and rendering.]]></description><name>xtype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local y (top) coordinate for this component if contained within a positioning container.]]></description><name>y</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 <p>A Column definition class which renders a numeric data field according to a <a
 href="output/Ext.list.NumberColumn.html#Ext.list.NumberColumn-format" ext:member="format"
 ext:cls="Ext.list.NumberColumn">format</a> string. See the <a href="output/Ext.list.Column.html#Ext.list.Column-xtype"
 ext:member="xtype" ext:cls="Ext.list.Column">xtype</a> config option of <a href="output/Ext.list.Column.html"
 ext:cls="Ext.list.Column">Ext.list.Column</a> for more details.</p>]]></description><name>list.numberColumn</name><tag-class>org.brushingbits.jnap.ui.extjs3.list.NumberColumn</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[Set the CSS text-align property of the column. Defaults to 'left'.]]></description><name>align</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. This option can be used to add a CSS class to the cell of each row for this column.]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Required. The name of the field in the ListViews's Ext.data.Store's Ext.data.Record definition from which to draw the
 column's value.]]></description><name>dataIndex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A formatting string as used by Ext.util.Format.number to format a numeric value for this Column (defaults to
 '0,000.00').]]></description><name>format</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. The header text to be used as innerHTML (html tags are accepted) to display in the ListView. Note: to have a
 clickable header with no text displayed use '&#160'.]]></description><name>header</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify a string to pass as the configuration string for Ext.XTemplate. By default an Ext.XTemplate will be
 implicitly created using the dataIndex.]]></description><name>tpl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Percentage of the container width this column should be allocated. Columns that have no width specified will
 be allocated with an equal percentage to fill 100% of the container width. To easily take advantage of the full
 container width, leave the width of at least one column undefined. Note that if you do not want to take up the full
 width of the container, the width of every column needs to be explicitly defined.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><name>listener</name><tag-class>org.brushingbits.jnap.ui.extjs3.Listener</tag-class><body-content>scriptless</body-content><attribute><name>eventName</name><required>true</required><rtexprvalue>true</rtexprvalue></attribute><attribute><name>buffer</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>delay</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>handler</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>scope</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>single</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 A simple utility class for generically masking elements while loading data. If the 
 <a
 href="output/Ext.LoadMask.html#Ext.LoadMask-store" ext:member="store" ext:cls="Ext.LoadMask">store</a> config option is
 specified, the masking will be automatically synchronized with the store's loading process and the mask element will be
 cached for reuse. For all other elements, this mask will replace the element's Updater load indicator and will be
 destroyed after the initial load. 
 <p>Example usage:</p> 
 <pre><code><i>// Basic mask:</i>
 <b>var</b> myMask = <b>new</b> Ext.LoadMask(Ext.getBody(), {msg:<em>&quot;Please wait...&quot;</em>});
 myMask.show();</code></pre>]]></description><name>loadMask</name><tag-class>org.brushingbits.jnap.ui.extjs3.LoadMask</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[The element or DOM node, or its id.]]></description><name>el</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The text to display in a centered loading message box (defaults to 'Loading...')]]></description><name>msg</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class to apply to the loading message element (defaults to "x-mask-loading")]]></description><name>msgCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to create a single-use mask that is automatically destroyed after loading (useful for page loads), False to persist
 the mask element reference for multiple uses (e.g., for paged data widgets). Defaults to false.]]></description><name>removeMask</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional Store to which the mask is bound. The mask is displayed when a load request is issued, and hidden on either
 load sucess, or load fail.]]></description><name>store</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 <p>A menu object. This is the container to which you may add menu items. Menu can also serve as a base class when you
 want a specialized menu based off of another component (like <a href="output/Ext.menu.DateMenu.html"
 ext:cls="Ext.menu.DateMenu">Ext.menu.DateMenu</a> for example).</p> 
 <p>Menus may contain either <a
 href="output/Ext.menu.Item.html" ext:cls="Ext.menu.Item">menu items</a>, or general <a href="output/Ext.Component.html"
 ext:cls="Ext.Component">Component</a>s.</p> 
 <p>To make a contained general <a href="output/Ext.Component.html"
 ext:cls="Ext.Component">Component</a> line up with other <a href="output/Ext.menu.Item.html"
 ext:cls="Ext.menu.Item">menu items</a> specify <tt>iconCls: 'no-icon'</tt>. This reserves a space for an icon, and
 indents the Component in line with the other menu items. See <a href="output/Ext.form.ComboBox.html"
 ext:cls="Ext.form.ComboBox">Ext.form.ComboBox</a>.<a
 href="output/Ext.form.ComboBox.html#Ext.form.ComboBox-getListParent" ext:member="getListParent"
 ext:cls="Ext.form.ComboBox">getListParent</a> for an example.</p> 
 <p>By default, Menus are absolutely positioned,
 floating Components. By configuring a Menu with <b><tt><a href="output/Ext.menu.Menu.html#Ext.menu.Menu-floating"
 ext:member="floating" ext:cls="Ext.menu.Menu">floating</a>:false</tt></b>, a Menu may be used as child of a
 Container.</p>]]></description><name>menu</name><tag-class>org.brushingbits.jnap.ui.extjs3.menu.Menu</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[A string component id or the numeric index of the component that should be initially activated within the container's
 layout on render. For example, activeItem: 'item-1' or activeItem: 0 (index 0 = the first item in the container's
 collection). activeItem only applies to layout styles that can display items one at a time (like
 Ext.layout.AccordionLayout, Ext.layout.CardLayout and Ext.layout.FitLayout). Related to
 Ext.layout.ContainerLayout.activeItem.]]></description><name>activeItem</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Whether the component can move the Dom node when rendering (defaults to true).]]></description><name>allowDomMove</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to allow multiple menus to be displayed at the same time (defaults to false)]]></description><name>allowOtherMenus</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use an
 AnchorLayout (or subclass thereof). based layout manager, for example: Ext.form.FormPanel specifying layout: 'anchor' //
 or 'form', or 'absolute' See Ext.layout.AnchorLayout.anchor also.]]></description><name>anchor</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element corresponding to a DIV that is already present in
 the document that specifies some structural markup for this component. Description : When applyTo is used, constituent
 parts of the component can also be specified by id or CSS class name within the main element, and the component being
 created may attempt to create its subcomponents from that markup if applicable. Notes : When using this config, a call
 to render() is not required. If applyTo is specified, any value passed for renderTo will be ignored and the target
 element's parent node will automatically be used as the component's container.]]></description><name>applyTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If true the container will automatically destroy any contained component that is removed from it, else destruction must
 be handled manually (defaults to true).]]></description><name>autoDestroy</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A tag name or DomHelper spec used to create the Element which will encapsulate this Component. You do not normally need
 to specify this. For the base classes Ext.Component, Ext.BoxComponent, and Ext.Container, this defaults to 'div'. The
 more complex Ext classes use a more complex DOM structure created by their own onRender methods. This is intended to
 allow the developer to create application-specific utility Components encapsulated by different DOM elements. Example
 usage: <pre><code>{
     xtype: 'box',
     autoEl: {
         tag: 'img',
         src: 'http://www.example.com/example.jpg'
     }
 },
 {
     xtype: 'box',
     autoEl: {
         tag: 'blockquote',
         html: 'autoEl is cool!'
     }
 }, {
     xtype: 'container',
     autoEl: 'ul',
     cls: 'ux-unordered-list',
     items: {
         xtype: 'box',
         autoEl: 'li',
   
      html: 'First list item'
     }
 }</pre></code>]]></description><name>autoEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to use height:'auto', false to use fixed height (or allow it to be managed by its parent Container's layout
 manager. Defaults to false. Note: Although many components inherit this config option, not all will function as expected
 with a height of 'auto'. Setting autoHeight:true means that the browser will manage height based on the element's
 contents, and that Ext will not manage it at all. If the browser is managing the height, be aware that resizes performed
 by the browser in response to changes within the structure of the Component cannot be detected. Therefore changes to the
 height might result in elements needing to be synchronized with the new height. Example: var w = new Ext.Window({
    
 title: 'Window',
     width: 600,
     autoHeight: true,
     items: {
         title: 'Collapse Me',
         height: 400,
  
 collapsible: true,
         border: false,
         listeners: {
             beforecollapse: function() {
                w.el.shadow.hide();
             },
             beforeexpand: function() {
                w.el.shadow.hide();
             },
             collapse: function() {
                w.syncShadow();
             },
             expand: function() {
                w.syncShadow();
             }
         }
     }
 }).show();]]></description><name>autoHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to use overflow:'auto' on the components layout element and show scroll bars automatically when necessary, false to
 clip any overflowing content (defaults to false).]]></description><name>autoScroll</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True if the component should check for hidden classes (e.g. 'x-hidden' or 'x-hide-display') and remove them on render
 (defaults to false).]]></description><name>autoShow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to use width:'auto', false to use fixed width (or allow it to be managed by its parent Container's layout manager.
 Defaults to false. Note: Although many components inherit this config option, not all will function as expected with a
 width of 'auto'. Setting autoWidth:true means that the browser will manage width based on the element's contents, and
 that Ext will not manage it at all. If the browser is managing the width, be aware that resizes performed by the browser
 in response to changes within the structure of the Component cannot be detected. Therefore changes to the width might
 result in elements needing to be synchronized with the new width. For example, where the target element is: <div
 id='grid-container' style='margin-left:25%;width:50%'></div> A Panel rendered into that target element must listen for
 browser window resize in order to relay its child items when the browser changes its width: var myPanel = new
 Ext.Panel({
     renderTo: 'grid-container',
     monitorResize: true, // relay on browser resize
     title: 'Panel',
    
 height: 400,
     autoWidth: true,
     layout: 'hbox',
     layoutConfig: {
         align: 'stretch'
     },
     defaults: {
         flex: 1
     },
     items: [{
         title: 'Box 1',
     }, {
         title: 'Box 2'
     }, {
         title:
 'Box 3'
     }],
 });]]></description><name>autoWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to ['add', 'remove'].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[When set to true (50 milliseconds) or a number of milliseconds, the layout assigned for this container will buffer the
 frequency it calculates and does a re-layout of components. This is useful for heavy containers or containers with a
 large quantity of sub-components for which frequent layout calls would be expensive. Defaults to 50.]]></description><name>bufferResize</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class used to to apply to the special clearing div rendered directly after each form field wrapper to provide
 field clearing (defaults to 'x-form-clear-left'). Note: this config is only used when this Component is rendered by a
 Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or specifying
 layout:'form') and either a fieldLabel is specified or isFormField=true is specified. See Ext.layout.FormLayout.fieldTpl
 also.]]></description><name>clearCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element (defaults to ''). This can be useful for
 adding customized styles to the component or any of its children using standard CSS rules.]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's container. This can be useful for adding customized
 styles to the container or any of its children using standard CSS rules. See Ext.layout.ContainerLayout.extraCls also.
 Note: ctCls defaults to '' except for the following class which assigns a value by default: Box Layout :
 'x-box-layout-ct' To configure the above Class with an extra CSS class append to the default. For example, for BoxLayout
 (Hbox and Vbox): ctCls: 'x-box-layout-ct custom-class']]></description><name>ctCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default Ext.Element.alignTo anchor position value for this menu relative to its element of origin (defaults to
 'tl-bl?')]]></description><name>defaultAlign</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array specifying the [x, y] offset in pixels by which to change the default Menu popup position after aligning
 according to the defaultAlign configuration. Defaults to [0, 0].]]></description><name>defaultOffsets</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default xtype of child Components to create in this Container when a child item is specified as a raw configuration
 object, rather than as an instantiated Component. Defaults to 'panel', except Ext.menu.Menu which defaults to
 'menuitem', and Ext.Toolbar and Ext.ButtonGroup which default to 'button'.]]></description><name>defaultType</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A config object that will be applied to all items added to this container either via the items config or via the add
 method. The defaults config can contain any number of name/value property pairs to be added to each item, and should be
 valid for the types of items being added to the menu.]]></description><name>defaults</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component disabled (default is false).]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class added to the component when it is disabled (defaults to 'x-item-disabled').]]></description><name>disabledClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to allow the menu container to have scroller controls if the menu is too long (defaults to true).]]></description><name>enableScrolling</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The label text to display next to this Component (defaults to ''). Note: this config is only used when this Component is
 rendered by a Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or
 specifying layout:'form'). Also see hideLabel and Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
    
 height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name'
    
 }]
 });]]></description><name>fieldLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use a
 BoxLayout. Each child Component with a flex property will be flexed either vertically (by a VBoxLayout) or horizontally
 (by an HBoxLayout) according to the item's relative flex value compared to the sum of all Components with flex value
 specified. Any child items that have either a flex = 0 or flex = undefined will not be 'flexed' (the initial size will
 not be changed).]]></description><name>flex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[By default, a Menu configured as floating:true will be rendered as an Ext.Layer (an absolutely positioned, floating
 Component with zindex=15000). If configured as floating:false, the Menu may be used as child item of another Container
 instead of a free-floating Layer.]]></description><name>floating</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If true the container will force a layout initially even if hidden or collapsed. This option is useful for forcing forms
 to render in collapsed or hidden containers. (defaults to false).]]></description><name>forceLayout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component hidden (default is false). If true, the hide method will be called internally.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide the borders of each contained component, false to defer to the component's existing border settings
 (defaults to false).]]></description><name>hideBorders</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to completely hide the label element (label and separator). Defaults to false. By default, even if you do not
 specify a fieldLabel the space will still be reserved so that the field will line up with other fields that do have
 labels. Setting this to true will cause the field to not reserve that space. Note: see the note for clearCls. Example
 use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield'
        
 hideLabel: true
     }]
 });]]></description><name>hideLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[How this component should be hidden. Supported values are 'visibility' (css visibility), 'offsets' (negative offset
 position) and 'display' (css display). Note: the default of 'display' is generally preferred since items are
 automatically laid out when they are first shown (no sizing is done while hidden).]]></description><name>hideMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide and show the component's container when hide/show is called on the component, false to hide and show the
 component itself (defaults to false). For example, this can be used as a shortcut for a hide button on a window by
 setting hide:true on the button when adding it to its parent container.]]></description><name>hideParent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id of this component (defaults to an auto-assigned id). You should assign an id if you need to be able to
 access the component later and you do not have an object reference available (e.g., using Ext.getCmp). Note that this id
 will also be used as the element id for the containing HTML element that is rendered to the page for this component.
 This allows you to write id-based CSS rules to style the specific instance of this component uniquely, and also to
 select sub-elements using this component's id as the parent. Note: to avoid complications imposed by a unique id also
 see itemId and ref. Note: to access the container of an item see ownerCt.]]></description><name>id</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to ignore clicks on any item in this menu that is a parent item (displays a submenu) so that the submenu is not
 dismissed when clicking the parent item (defaults to false).]]></description><name>ignoreParentClicks</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use the
 FormLayout layout manager (e.g. Ext.form.FormPanel or specifying layout:'form'). An additional CSS class to apply to the
 div wrapping the form item element of this field. If supplied, itemCls at the field level will override the default
 itemCls supplied at the container level. The value specified for itemCls will be added to the default class
 ('x-form-item'). Since it is applied to the item wrapper (see Ext.layout.FormLayout.fieldTpl), it allows you to write
 standard CSS rules that can apply to the field, the label (if specified), or any other element within the markup for the
 field. Note: see the note for fieldLabel. Example use: // Apply a style to the field's label:
 <style>
     .required
 .x-form-item-label {font-weight:bold;color:red;}
 </style>
 
 new Ext.FormPanel({
     height: 100,
     renderTo:
 Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         itemCls: 'required' //this
 label will be styled
     },{
         xtype: 'textfield',
         fieldLabel: 'Favorite Color'
     }]
 });]]></description><name>itemCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An itemId can be used as an alternative way to get a reference to a component when no object reference is available.
 Instead of using an id with Ext.getCmp, use itemId with Ext.Container.getComponent which will retrieve itemId's or id's.
 Since itemId's are an index to the container's internal MixedCollection, the itemId is scoped locally to the container
 -- avoiding potential conflicts with Ext.ComponentMgr which requires a unique id. var c = new Ext.Panel({ //
     height:
 300,
     renderTo: document.body,
     layout: 'auto',
     items: [
         {
             itemId: 'p1',
            
 title: 'Panel 1',
             height: 150
         },
         {
             itemId: 'p2',
             title: 'Panel 2',
  
 height: 150
         }
     ]
 })
 p1 = c.getComponent('p1'); // not the same as Ext.getCmp()
 p2 =
 p1.ownerCt.getComponent('p2'); // reference via a sibling Also see id and ref. Note: to access the container of an item
 see ownerCt.]]></description><name>itemId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The separator to display after the text of each fieldLabel. This property may be configured at various levels. The order
 of precedence is: field / component level container level layout level (defaults to colon ':') To display no separator
 for this field's label specify empty string ''. Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 layoutConfig: {
         labelSeparator: '~'   // layout config has lowest priority (defaults to ':')
     },
    
 labelSeparator: '>>',     // config at container level
     items: [{
         xtype: 'textfield',
         fieldLabel:
 'Field 1',
         labelSeparator: '...' // field/component level config supersedes others
     },{
         xtype:
 'textfield',
         fieldLabel: 'Field 2' // labelSeparator will be '='
     }]
 });]]></description><name>labelSeparator</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS style specification string to apply directly to this field's label. Defaults to the container's labelStyle value
 if set (e.g., Ext.layout.FormLayout.labelStyle , or ''). Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         labelStyle: 'font-weight:bold;'
     }]
 });]]></description><name>labelStyle</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[This class assigns a default layout (layout:'menu'). Developers may override this configuration option if another layout
 is required. See Ext.Container.layout for additional information.]]></description><name>layout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout or one of the two BoxLayout subclasses. An object containing margins to apply to this BoxComponent in the
 format: {
     top: (top margin),
     right: (right margin),
     bottom: (bottom margin),
     left: (left margin)
 } May
 also be a string containing space-separated, numeric margin values. The order of the sides associated with each value
 matches the way CSS processes margin values: If there is only one value, it applies to all sides. If there are two
 values, the top and bottom borders are set to the first value and the right and left are set to the second. If there are
 three values, the top is set to the first value, the left and right are set to the second, and the bottom is set to the
 third. If there are four values, they apply to the top, right, bottom, and left, respectively. Defaults to: {top:0,
 right:0, bottom:0, left:0}]]></description><name>margins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum height of the menu. Only applies when enableScrolling is set to True (defaults to null).]]></description><name>maxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum width of the menu in pixels (defaults to 120)]]></description><name>minWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically monitor window resize events to handle anything that is sensitive to the current size of the
 viewport. This value is typically managed by the chosen layout and should not need to be set manually.]]></description><name>monitorResize</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element when the mouse moves over the Element, and
 removed when the mouse moves out. (defaults to ''). This can be useful for adding customized 'active' or 'hover' styles
 to the component or any of its children using standard CSS rules.]]></description><name>overCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level x coordinate for this component if contained within a positioning container.]]></description><name>pageX</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level y coordinate for this component if contained within a positioning container.]]></description><name>pageY</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to remove the incised line down the left side of the menu. Defaults to false.]]></description><name>plain</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered ptype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a Plugin is being specified not as a fully
 instantiated Component, but as a Component config object. The ptype will be looked up at render time up to determine
 what type of Plugin to create. If you create your own Plugins, you may register them using
 Ext.ComponentMgr.registerPlugin in order to be able to take advantage of lazy instantiation and rendering.]]></description><name>ptype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A path specification, relative to the Component's ownerCt specifying into which ancestor Container to place a named
 reference to this Component. The ancestor axis can be traversed by using '/' characters in the path. For example, to put
 a reference to a Toolbar Button into the Panel which owns the Toolbar: var myGrid = new Ext.grid.EditorGridPanel({
    
 title: 'My EditorGridPanel',
     store: myStore,
     colModel: myColModel,
     tbar: [{
         text: 'Save',
        
 handler: saveChanges,
         disabled: true,
         ref: '../saveButton'
     }],
     listeners: {
         afteredit:
 function() {
 //          The button reference is in the GridPanel
             myGrid.saveButton.enable();
         }
    
 }
 }); In the code above, if the ref had been 'saveButton' the reference would have been placed into the Toolbar. Each
 '/' in the ref moves up one level from the Component's ownerCt. Also see the added and removed events.]]></description><name>ref</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout layout manager (e.g. specifying layout:'border'). See Ext.layout.BorderLayout also.]]></description><name>region</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The event to listen to for resizing in layouts. Defaults to 'resize'.]]></description><name>resizeEvent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The amount to scroll the menu. Only applies when enableScrolling is set to True (defaults to 24).]]></description><name>scrollIncrement</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True or 'sides' for the default effect, 'frame' for 4-way shadow, and 'drop' for bottom-right shadow (defaults to
 'sides')]]></description><name>shadow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to show the icon separator. (defaults to true).]]></description><name>showSeparator</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should trigger this component to save its state (defaults to none). stateEvents may
 be any type of event supported by this component, including browser or custom events (e.g., ['click',
 'customerchange']). See stateful for an explanation of saving and restoring Component state.]]></description><name>stateEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id for this component to use for state management purposes (defaults to the component id if one was set,
 otherwise null if the component is using a generated id). See stateful for an explanation of saving and restoring
 Component state.]]></description><name>stateId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A flag which causes the Component to attempt to restore the state of internal properties from a saved state on startup.
 The component must have either a stateId or id assigned for state to be managed. Auto-generated ids are not guaranteed
 to be stable across page loads and cannot be relied upon to save and restore the same state for a component. For state
 saving to work, the state manager's provider must have been set to an implementation of Ext.state.Provider which
 overrides the set and get methods to save and recall name/value pairs. A built-in implementation,
 Ext.state.CookieProvider is available. To set the state provider for the current page: Ext.state.Manager.setProvider(new
 Ext.state.CookieProvider({
     expires: new Date(new Date().getTime()+(1000*60*60*24*7)), //7 days from now
 })); A
 stateful Component attempts to save state when one of the events listed in the stateEvents configuration fires. To save
 state, a stateful Component first serializes its state by calling getState. By default, this function does nothing. The
 developer must provide an implementation which returns an object hash which represents the Component's restorable state.
 The value yielded by getState is passed to Ext.state.Manager.set which uses the configured Ext.state.Provider to save
 the object keyed by the Component's stateId, or, if that is not specified, its id. During construction, a stateful
 Component attempts to restore its state by calling Ext.state.Manager.get passing the stateId, or, if that is not
 specified, the id. The resulting object is passed to applyState. The default implementation of applyState simply copies
 properties into the object, but a developer may override this to support more behaviour. You can perform extra
 processing on state save and restore by attaching handlers to the beforestaterestore, staterestore, beforestatesave and
 statesave events.]]></description><name>stateful</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
     title: 'Some Title',
     renderTo: Ext.getBody(),
     width: 400, height:
 300,
     layout: 'form',
     items: [{
         xtype: 'textarea',
         style: {
             width: '95%',
            
 marginBottom: '10px'
         }
     },
         new Ext.Button({
             text: 'Send',
             minWidth: '100',
   
          style: {
                 marginBottom: '10px'
             }
         })
     ]
 });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.Element.alignTo anchor position value to use for submenus of this menu (defaults to 'tl-tr?')]]></description><name>subMenuAlign</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is a child item of a TabPanel. A string to be used as innerHTML
 (html tags are accepted) to show in a tooltip when mousing over the associated tab selector element.
 Ext.QuickTips.init() must be called in order for the tips to render.]]></description><name>tabTip</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local x (left) coordinate for this component if contained within a positioning container.]]></description><name>x</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered xtype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a child item of a Container is being specified not
 as a fully instantiated Component, but as a Component config object. The xtype will be looked up at render time up to
 determine what type of child Component to create. The predefined xtypes are listed here. If you subclass Components to
 create your own Components, you may register them using Ext.ComponentMgr.registerType in order to be able to take
 advantage of lazy instantiation and rendering.]]></description><name>xtype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local y (top) coordinate for this component if contained within a positioning container.]]></description><name>y</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[zIndex to use when the menu is floating.]]></description><name>zIndex</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 The base class for all items that render into menus. BaseItem provides default rendering, activated state management and
 base configuration options shared by all menu components.]]></description><name>menu.baseItem</name><tag-class>org.brushingbits.jnap.ui.extjs3.menu.BaseItem</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[The CSS class to use when the item becomes activated (defaults to "x-menu-item-active")]]></description><name>activeClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Whether the component can move the Dom node when rendering (defaults to true).]]></description><name>allowDomMove</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element corresponding to a DIV that is already present in
 the document that specifies some structural markup for this component. Description : When applyTo is used, constituent
 parts of the component can also be specified by id or CSS class name within the main element, and the component being
 created may attempt to create its subcomponents from that markup if applicable. Notes : When using this config, a call
 to render() is not required. If applyTo is specified, any value passed for renderTo will be ignored and the target
 element's parent node will automatically be used as the component's container.]]></description><name>applyTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A tag name or DomHelper spec used to create the Element which will encapsulate this Component. You do not normally need
 to specify this. For the base classes Ext.Component, Ext.BoxComponent, and Ext.Container, this defaults to 'div'. The
 more complex Ext classes use a more complex DOM structure created by their own onRender methods. This is intended to
 allow the developer to create application-specific utility Components encapsulated by different DOM elements. Example
 usage: <pre><code>{
     xtype: 'box',
     autoEl: {
         tag: 'img',
         src: 'http://www.example.com/example.jpg'
     }
 },
 {
     xtype: 'box',
     autoEl: {
         tag: 'blockquote',
         html: 'autoEl is cool!'
     }
 }, {
     xtype: 'container',
     autoEl: 'ul',
     cls: 'ux-unordered-list',
     items: {
         xtype: 'box',
         autoEl: 'li',
   
      html: 'First list item'
     }
 }</pre></code>]]></description><name>autoEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True if the component should check for hidden classes (e.g. 'x-hidden' or 'x-hide-display') and remove them on render
 (defaults to false).]]></description><name>autoShow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to [].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True if this item can be visually activated (defaults to false)]]></description><name>canActivate</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class used to to apply to the special clearing div rendered directly after each form field wrapper to provide
 field clearing (defaults to 'x-form-clear-left'). Note: this config is only used when this Component is rendered by a
 Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or specifying
 layout:'form') and either a fieldLabel is specified or isFormField=true is specified. See Ext.layout.FormLayout.fieldTpl
 also.]]></description><name>clearCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Length of time in milliseconds to wait before hiding after a click (defaults to 1)]]></description><name>clickHideDelay</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element (defaults to ''). This can be useful for
 adding customized styles to the component or any of its children using standard CSS rules.]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's container. This can be useful for adding customized
 styles to the container or any of its children using standard CSS rules. See Ext.layout.ContainerLayout.extraCls also.
 Note: ctCls defaults to '' except for the following class which assigns a value by default: Box Layout :
 'x-box-layout-ct' To configure the above Class with an extra CSS class append to the default. For example, for BoxLayout
 (Hbox and Vbox): ctCls: 'x-box-layout-ct custom-class']]></description><name>ctCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component disabled (default is false).]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class added to the component when it is disabled (defaults to 'x-item-disabled').]]></description><name>disabledClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The label text to display next to this Component (defaults to ''). Note: this config is only used when this Component is
 rendered by a Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or
 specifying layout:'form'). Also see hideLabel and Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
    
 height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name'
    
 }]
 });]]></description><name>fieldLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A function that will handle the click event of this menu item (optional). The handler is passed the following
 parameters: b : Item This menu Item. e : EventObject The click event.]]></description><name>handler</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component hidden (default is false). If true, the hide method will be called internally.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to completely hide the label element (label and separator). Defaults to false. By default, even if you do not
 specify a fieldLabel the space will still be reserved so that the field will line up with other fields that do have
 labels. Setting this to true will cause the field to not reserve that space. Note: see the note for clearCls. Example
 use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield'
        
 hideLabel: true
     }]
 });]]></description><name>hideLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[How this component should be hidden. Supported values are 'visibility' (css visibility), 'offsets' (negative offset
 position) and 'display' (css display). Note: the default of 'display' is generally preferred since items are
 automatically laid out when they are first shown (no sizing is done while hidden).]]></description><name>hideMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide the containing menu after this item is clicked (defaults to true)]]></description><name>hideOnClick</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide and show the component's container when hide/show is called on the component, false to hide and show the
 component itself (defaults to false). For example, this can be used as a shortcut for a hide button on a window by
 setting hide:true on the button when adding it to its parent container.]]></description><name>hideParent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id of this component (defaults to an auto-assigned id). You should assign an id if you need to be able to
 access the component later and you do not have an object reference available (e.g., using Ext.getCmp). Note that this id
 will also be used as the element id for the containing HTML element that is rendered to the page for this component.
 This allows you to write id-based CSS rules to style the specific instance of this component uniquely, and also to
 select sub-elements using this component's id as the parent. Note: to avoid complications imposed by a unique id also
 see itemId and ref. Note: to access the container of an item see ownerCt.]]></description><name>id</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use the
 FormLayout layout manager (e.g. Ext.form.FormPanel or specifying layout:'form'). An additional CSS class to apply to the
 div wrapping the form item element of this field. If supplied, itemCls at the field level will override the default
 itemCls supplied at the container level. The value specified for itemCls will be added to the default class
 ('x-form-item'). Since it is applied to the item wrapper (see Ext.layout.FormLayout.fieldTpl), it allows you to write
 standard CSS rules that can apply to the field, the label (if specified), or any other element within the markup for the
 field. Note: see the note for fieldLabel. Example use: // Apply a style to the field's label:
 <style>
     .required
 .x-form-item-label {font-weight:bold;color:red;}
 </style>
 
 new Ext.FormPanel({
     height: 100,
     renderTo:
 Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         itemCls: 'required' //this
 label will be styled
     },{
         xtype: 'textfield',
         fieldLabel: 'Favorite Color'
     }]
 });]]></description><name>itemCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An itemId can be used as an alternative way to get a reference to a component when no object reference is available.
 Instead of using an id with Ext.getCmp, use itemId with Ext.Container.getComponent which will retrieve itemId's or id's.
 Since itemId's are an index to the container's internal MixedCollection, the itemId is scoped locally to the container
 -- avoiding potential conflicts with Ext.ComponentMgr which requires a unique id. var c = new Ext.Panel({ //
     height:
 300,
     renderTo: document.body,
     layout: 'auto',
     items: [
         {
             itemId: 'p1',
            
 title: 'Panel 1',
             height: 150
         },
         {
             itemId: 'p2',
             title: 'Panel 2',
  
 height: 150
         }
     ]
 })
 p1 = c.getComponent('p1'); // not the same as Ext.getCmp()
 p2 =
 p1.ownerCt.getComponent('p2'); // reference via a sibling Also see id and ref. Note: to access the container of an item
 see ownerCt.]]></description><name>itemId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The separator to display after the text of each fieldLabel. This property may be configured at various levels. The order
 of precedence is: field / component level container level layout level (defaults to colon ':') To display no separator
 for this field's label specify empty string ''. Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 layoutConfig: {
         labelSeparator: '~'   // layout config has lowest priority (defaults to ':')
     },
    
 labelSeparator: '>>',     // config at container level
     items: [{
         xtype: 'textfield',
         fieldLabel:
 'Field 1',
         labelSeparator: '...' // field/component level config supersedes others
     },{
         xtype:
 'textfield',
         fieldLabel: 'Field 2' // labelSeparator will be '='
     }]
 });]]></description><name>labelSeparator</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS style specification string to apply directly to this field's label. Defaults to the container's labelStyle value
 if set (e.g., Ext.layout.FormLayout.labelStyle , or ''). Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         labelStyle: 'font-weight:bold;'
     }]
 });]]></description><name>labelStyle</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element when the mouse moves over the Element, and
 removed when the mouse moves out. (defaults to ''). This can be useful for adding customized 'active' or 'hover' styles
 to the component or any of its children using standard CSS rules.]]></description><name>overCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered ptype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a Plugin is being specified not as a fully
 instantiated Component, but as a Component config object. The ptype will be looked up at render time up to determine
 what type of Plugin to create. If you create your own Plugins, you may register them using
 Ext.ComponentMgr.registerPlugin in order to be able to take advantage of lazy instantiation and rendering.]]></description><name>ptype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A path specification, relative to the Component's ownerCt specifying into which ancestor Container to place a named
 reference to this Component. The ancestor axis can be traversed by using '/' characters in the path. For example, to put
 a reference to a Toolbar Button into the Panel which owns the Toolbar: var myGrid = new Ext.grid.EditorGridPanel({
    
 title: 'My EditorGridPanel',
     store: myStore,
     colModel: myColModel,
     tbar: [{
         text: 'Save',
        
 handler: saveChanges,
         disabled: true,
         ref: '../saveButton'
     }],
     listeners: {
         afteredit:
 function() {
 //          The button reference is in the GridPanel
             myGrid.saveButton.enable();
         }
    
 }
 }); In the code above, if the ref had been 'saveButton' the reference would have been placed into the Toolbar. Each
 '/' in the ref moves up one level from the Component's ownerCt. Also see the added and removed events.]]></description><name>ref</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The scope (this reference) in which the handler function will be called.]]></description><name>scope</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should trigger this component to save its state (defaults to none). stateEvents may
 be any type of event supported by this component, including browser or custom events (e.g., ['click',
 'customerchange']). See stateful for an explanation of saving and restoring Component state.]]></description><name>stateEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id for this component to use for state management purposes (defaults to the component id if one was set,
 otherwise null if the component is using a generated id). See stateful for an explanation of saving and restoring
 Component state.]]></description><name>stateId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A flag which causes the Component to attempt to restore the state of internal properties from a saved state on startup.
 The component must have either a stateId or id assigned for state to be managed. Auto-generated ids are not guaranteed
 to be stable across page loads and cannot be relied upon to save and restore the same state for a component. For state
 saving to work, the state manager's provider must have been set to an implementation of Ext.state.Provider which
 overrides the set and get methods to save and recall name/value pairs. A built-in implementation,
 Ext.state.CookieProvider is available. To set the state provider for the current page: Ext.state.Manager.setProvider(new
 Ext.state.CookieProvider({
     expires: new Date(new Date().getTime()+(1000*60*60*24*7)), //7 days from now
 })); A
 stateful Component attempts to save state when one of the events listed in the stateEvents configuration fires. To save
 state, a stateful Component first serializes its state by calling getState. By default, this function does nothing. The
 developer must provide an implementation which returns an object hash which represents the Component's restorable state.
 The value yielded by getState is passed to Ext.state.Manager.set which uses the configured Ext.state.Provider to save
 the object keyed by the Component's stateId, or, if that is not specified, its id. During construction, a stateful
 Component attempts to restore its state by calling Ext.state.Manager.get passing the stateId, or, if that is not
 specified, the id. The resulting object is passed to applyState. The default implementation of applyState simply copies
 properties into the object, but a developer may override this to support more behaviour. You can perform extra
 processing on state save and restore by attaching handlers to the beforestaterestore, staterestore, beforestatesave and
 statesave events.]]></description><name>stateful</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
     title: 'Some Title',
     renderTo: Ext.getBody(),
     width: 400, height:
 300,
     layout: 'form',
     items: [{
         xtype: 'textarea',
         style: {
             width: '95%',
            
 marginBottom: '10px'
         }
     },
         new Ext.Button({
             text: 'Send',
             minWidth: '100',
   
          style: {
                 marginBottom: '10px'
             }
         })
     ]
 });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered xtype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a child item of a Container is being specified not
 as a fully instantiated Component, but as a Component config object. The xtype will be looked up at render time up to
 determine what type of child Component to create. The predefined xtypes are listed here. If you subclass Components to
 create your own Components, you may register them using Ext.ComponentMgr.registerType in order to be able to take
 advantage of lazy instantiation and rendering.]]></description><name>xtype</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 Adds a menu item that contains a checkbox by default, but can also be part of a radio group.]]></description><name>menu.checkItem</name><tag-class>org.brushingbits.jnap.ui.extjs3.menu.CheckItem</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[The CSS class to use when the item becomes activated (defaults to "x-menu-item-active")]]></description><name>activeClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Whether the component can move the Dom node when rendering (defaults to true).]]></description><name>allowDomMove</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The altText to use for the icon, if it exists. Defaults to ''.]]></description><name>altText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element corresponding to a DIV that is already present in
 the document that specifies some structural markup for this component. Description : When applyTo is used, constituent
 parts of the component can also be specified by id or CSS class name within the main element, and the component being
 created may attempt to create its subcomponents from that markup if applicable. Notes : When using this config, a call
 to render() is not required. If applyTo is specified, any value passed for renderTo will be ignored and the target
 element's parent node will automatically be used as the component's container.]]></description><name>applyTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A tag name or DomHelper spec used to create the Element which will encapsulate this Component. You do not normally need
 to specify this. For the base classes Ext.Component, Ext.BoxComponent, and Ext.Container, this defaults to 'div'. The
 more complex Ext classes use a more complex DOM structure created by their own onRender methods. This is intended to
 allow the developer to create application-specific utility Components encapsulated by different DOM elements. Example
 usage: <pre><code>{
     xtype: 'box',
     autoEl: {
         tag: 'img',
         src: 'http://www.example.com/example.jpg'
     }
 },
 {
     xtype: 'box',
     autoEl: {
         tag: 'blockquote',
         html: 'autoEl is cool!'
     }
 }, {
     xtype: 'container',
     autoEl: 'ul',
     cls: 'ux-unordered-list',
     items: {
         xtype: 'box',
         autoEl: 'li',
   
      html: 'First list item'
     }
 }</pre></code>]]></description><name>autoEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True if the component should check for hidden classes (e.g. 'x-hidden' or 'x-hide-display') and remove them on render
 (defaults to false).]]></description><name>autoShow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to [].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True if this item can be visually activated (defaults to true)]]></description><name>canActivate</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to initialize this checkbox as checked (defaults to false). Note that if this checkbox is part of a radio group
 (group = true) only the first item in the group that is initialized with checked = true will be rendered as checked.]]></description><name>checked</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class used to to apply to the special clearing div rendered directly after each form field wrapper to provide
 field clearing (defaults to 'x-form-clear-left'). Note: this config is only used when this Component is rendered by a
 Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or specifying
 layout:'form') and either a fieldLabel is specified or isFormField=true is specified. See Ext.layout.FormLayout.fieldTpl
 also.]]></description><name>clearCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Length of time in milliseconds to wait before hiding after a click (defaults to 1)]]></description><name>clickHideDelay</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element (defaults to ''). This can be useful for
 adding customized styles to the component or any of its children using standard CSS rules.]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's container. This can be useful for adding customized
 styles to the container or any of its children using standard CSS rules. See Ext.layout.ContainerLayout.extraCls also.
 Note: ctCls defaults to '' except for the following class which assigns a value by default: Box Layout :
 'x-box-layout-ct' To configure the above Class with an extra CSS class append to the default. For example, for BoxLayout
 (Hbox and Vbox): ctCls: 'x-box-layout-ct custom-class']]></description><name>ctCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component disabled (default is false).]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class added to the component when it is disabled (defaults to 'x-item-disabled').]]></description><name>disabledClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The label text to display next to this Component (defaults to ''). Note: this config is only used when this Component is
 rendered by a Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or
 specifying layout:'form'). Also see hideLabel and Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
    
 height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name'
    
 }]
 });]]></description><name>fieldLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[All check items with the same group name will automatically be grouped into a single-select radio button group (defaults
 to '')]]></description><name>group</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default CSS class to use for radio group check items (defaults to "x-menu-group-item")]]></description><name>groupClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A function that will handle the click event of this menu item (optional). The handler is passed the following
 parameters: b : Item This menu Item. e : EventObject The click event.]]></description><name>handler</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component hidden (default is false). If true, the hide method will be called internally.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to completely hide the label element (label and separator). Defaults to false. By default, even if you do not
 specify a fieldLabel the space will still be reserved so that the field will line up with other fields that do have
 labels. Setting this to true will cause the field to not reserve that space. Note: see the note for clearCls. Example
 use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield'
        
 hideLabel: true
     }]
 });]]></description><name>hideLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[How this component should be hidden. Supported values are 'visibility' (css visibility), 'offsets' (negative offset
 position) and 'display' (css display). Note: the default of 'display' is generally preferred since items are
 automatically laid out when they are first shown (no sizing is done while hidden).]]></description><name>hideMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide the containing menu after this item is clicked (defaults to true)]]></description><name>hideOnClick</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide and show the component's container when hide/show is called on the component, false to hide and show the
 component itself (defaults to false). For example, this can be used as a shortcut for a hide button on a window by
 setting hide:true on the button when adding it to its parent container.]]></description><name>hideParent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The href attribute to use for the underlying anchor link (defaults to '#').]]></description><name>href</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The target attribute to use for the underlying anchor link (defaults to '').]]></description><name>hrefTarget</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The path to an icon to display in this item (defaults to Ext.BLANK_IMAGE_URL). If icon is specified iconCls should not
 be.]]></description><name>icon</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS class that specifies a background image that will be used as the icon for this item (defaults to ''). If iconCls
 is specified icon should not be.]]></description><name>iconCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id of this component (defaults to an auto-assigned id). You should assign an id if you need to be able to
 access the component later and you do not have an object reference available (e.g., using Ext.getCmp). Note that this id
 will also be used as the element id for the containing HTML element that is rendered to the page for this component.
 This allows you to write id-based CSS rules to style the specific instance of this component uniquely, and also to
 select sub-elements using this component's id as the parent. Note: to avoid complications imposed by a unique id also
 see itemId and ref. Note: to access the container of an item see ownerCt.]]></description><name>id</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default CSS class to use for check items (defaults to "x-menu-item x-menu-check-item")]]></description><name>itemCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An itemId can be used as an alternative way to get a reference to a component when no object reference is available.
 Instead of using an id with Ext.getCmp, use itemId with Ext.Container.getComponent which will retrieve itemId's or id's.
 Since itemId's are an index to the container's internal MixedCollection, the itemId is scoped locally to the container
 -- avoiding potential conflicts with Ext.ComponentMgr which requires a unique id. var c = new Ext.Panel({ //
     height:
 300,
     renderTo: document.body,
     layout: 'auto',
     items: [
         {
             itemId: 'p1',
            
 title: 'Panel 1',
             height: 150
         },
         {
             itemId: 'p2',
             title: 'Panel 2',
  
 height: 150
         }
     ]
 })
 p1 = c.getComponent('p1'); // not the same as Ext.getCmp()
 p2 =
 p1.ownerCt.getComponent('p2'); // reference via a sibling Also see id and ref. Note: to access the container of an item
 see ownerCt.]]></description><name>itemId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The separator to display after the text of each fieldLabel. This property may be configured at various levels. The order
 of precedence is: field / component level container level layout level (defaults to colon ':') To display no separator
 for this field's label specify empty string ''. Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 layoutConfig: {
         labelSeparator: '~'   // layout config has lowest priority (defaults to ':')
     },
    
 labelSeparator: '>>',     // config at container level
     items: [{
         xtype: 'textfield',
         fieldLabel:
 'Field 1',
         labelSeparator: '...' // field/component level config supersedes others
     },{
         xtype:
 'textfield',
         fieldLabel: 'Field 2' // labelSeparator will be '='
     }]
 });]]></description><name>labelSeparator</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS style specification string to apply directly to this field's label. Defaults to the container's labelStyle value
 if set (e.g., Ext.layout.FormLayout.labelStyle , or ''). Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         labelStyle: 'font-weight:bold;'
     }]
 });]]></description><name>labelStyle</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Either an instance of Ext.menu.Menu or the config object for an Ext.menu.Menu which acts as the submenu when this item
 is activated.]]></description><name>menu</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element when the mouse moves over the Element, and
 removed when the mouse moves out. (defaults to ''). This can be useful for adding customized 'active' or 'hover' styles
 to the component or any of its children using standard CSS rules.]]></description><name>overCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered ptype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a Plugin is being specified not as a fully
 instantiated Component, but as a Component config object. The ptype will be looked up at render time up to determine
 what type of Plugin to create. If you create your own Plugins, you may register them using
 Ext.ComponentMgr.registerPlugin in order to be able to take advantage of lazy instantiation and rendering.]]></description><name>ptype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A path specification, relative to the Component's ownerCt specifying into which ancestor Container to place a named
 reference to this Component. The ancestor axis can be traversed by using '/' characters in the path. For example, to put
 a reference to a Toolbar Button into the Panel which owns the Toolbar: var myGrid = new Ext.grid.EditorGridPanel({
    
 title: 'My EditorGridPanel',
     store: myStore,
     colModel: myColModel,
     tbar: [{
         text: 'Save',
        
 handler: saveChanges,
         disabled: true,
         ref: '../saveButton'
     }],
     listeners: {
         afteredit:
 function() {
 //          The button reference is in the GridPanel
             myGrid.saveButton.enable();
         }
    
 }
 }); In the code above, if the ref had been 'saveButton' the reference would have been placed into the Toolbar. Each
 '/' in the ref moves up one level from the Component's ownerCt. Also see the added and removed events.]]></description><name>ref</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The scope (this reference) in which the handler function will be called.]]></description><name>scope</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Length of time in milliseconds to wait before showing this item (defaults to 200)]]></description><name>showDelay</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should trigger this component to save its state (defaults to none). stateEvents may
 be any type of event supported by this component, including browser or custom events (e.g., ['click',
 'customerchange']). See stateful for an explanation of saving and restoring Component state.]]></description><name>stateEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id for this component to use for state management purposes (defaults to the component id if one was set,
 otherwise null if the component is using a generated id). See stateful for an explanation of saving and restoring
 Component state.]]></description><name>stateId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A flag which causes the Component to attempt to restore the state of internal properties from a saved state on startup.
 The component must have either a stateId or id assigned for state to be managed. Auto-generated ids are not guaranteed
 to be stable across page loads and cannot be relied upon to save and restore the same state for a component. For state
 saving to work, the state manager's provider must have been set to an implementation of Ext.state.Provider which
 overrides the set and get methods to save and recall name/value pairs. A built-in implementation,
 Ext.state.CookieProvider is available. To set the state provider for the current page: Ext.state.Manager.setProvider(new
 Ext.state.CookieProvider({
     expires: new Date(new Date().getTime()+(1000*60*60*24*7)), //7 days from now
 })); A
 stateful Component attempts to save state when one of the events listed in the stateEvents configuration fires. To save
 state, a stateful Component first serializes its state by calling getState. By default, this function does nothing. The
 developer must provide an implementation which returns an object hash which represents the Component's restorable state.
 The value yielded by getState is passed to Ext.state.Manager.set which uses the configured Ext.state.Provider to save
 the object keyed by the Component's stateId, or, if that is not specified, its id. During construction, a stateful
 Component attempts to restore its state by calling Ext.state.Manager.get passing the stateId, or, if that is not
 specified, the id. The resulting object is passed to applyState. The default implementation of applyState simply copies
 properties into the object, but a developer may override this to support more behaviour. You can perform extra
 processing on state save and restore by attaching handlers to the beforestaterestore, staterestore, beforestatesave and
 statesave events.]]></description><name>stateful</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
     title: 'Some Title',
     renderTo: Ext.getBody(),
     width: 400, height:
 300,
     layout: 'form',
     items: [{
         xtype: 'textarea',
         style: {
             width: '95%',
            
 marginBottom: '10px'
         }
     },
         new Ext.Button({
             text: 'Send',
             minWidth: '100',
   
          style: {
                 marginBottom: '10px'
             }
         })
     ]
 });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The text to display in this item (defaults to '').]]></description><name>text</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered xtype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a child item of a Container is being specified not
 as a fully instantiated Component, but as a Component config object. The xtype will be looked up at render time up to
 determine what type of child Component to create. The predefined xtypes are listed here. If you subclass Components to
 create your own Components, you may register them using Ext.ComponentMgr.registerType in order to be able to take
 advantage of lazy instantiation and rendering.]]></description><name>xtype</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 <p>A menu containing a <a href="output/Ext.ColorPalette.html" ext:cls="Ext.ColorPalette">Ext.ColorPalette</a>
 Component.</p> 
 <p>Notes:</p>
 <div class="mdetail-params">
  <ul> 
   <li>Although not listed here, the <b>constructor</b>
 for this class accepts all of the configuration options of <b><a href="output/Ext.ColorPalette.html"
 ext:cls="Ext.ColorPalette">Ext.ColorPalette</a></b>.</li> 
   <li>If subclassing ColorMenu, any configuration options for
 the ColorPalette must be applied to the <tt><b>initialConfig</b></tt> property of the ColorMenu. Applying <a
 href="output/Ext.ColorPalette.html" ext:cls="Ext.ColorPalette">ColorPalette</a> configuration settings to
 <b><tt>this</tt></b> will <b>not</b> affect the ColorPalette's configuration.</li> 
  </ul>
 </div> *]]></description><name>menu.colorMenu</name><tag-class>org.brushingbits.jnap.ui.extjs3.menu.ColorMenu</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[A string component id or the numeric index of the component that should be initially activated within the container's
 layout on render. For example, activeItem: 'item-1' or activeItem: 0 (index 0 = the first item in the container's
 collection). activeItem only applies to layout styles that can display items one at a time (like
 Ext.layout.AccordionLayout, Ext.layout.CardLayout and Ext.layout.FitLayout). Related to
 Ext.layout.ContainerLayout.activeItem.]]></description><name>activeItem</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Whether the component can move the Dom node when rendering (defaults to true).]]></description><name>allowDomMove</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to allow multiple menus to be displayed at the same time (defaults to false)]]></description><name>allowOtherMenus</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use an
 AnchorLayout (or subclass thereof). based layout manager, for example: Ext.form.FormPanel specifying layout: 'anchor' //
 or 'form', or 'absolute' See Ext.layout.AnchorLayout.anchor also.]]></description><name>anchor</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element corresponding to a DIV that is already present in
 the document that specifies some structural markup for this component. Description : When applyTo is used, constituent
 parts of the component can also be specified by id or CSS class name within the main element, and the component being
 created may attempt to create its subcomponents from that markup if applicable. Notes : When using this config, a call
 to render() is not required. If applyTo is specified, any value passed for renderTo will be ignored and the target
 element's parent node will automatically be used as the component's container.]]></description><name>applyTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If true the container will automatically destroy any contained component that is removed from it, else destruction must
 be handled manually (defaults to true).]]></description><name>autoDestroy</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A tag name or DomHelper spec used to create the Element which will encapsulate this Component. You do not normally need
 to specify this. For the base classes Ext.Component, Ext.BoxComponent, and Ext.Container, this defaults to 'div'. The
 more complex Ext classes use a more complex DOM structure created by their own onRender methods. This is intended to
 allow the developer to create application-specific utility Components encapsulated by different DOM elements. Example
 usage: <pre><code>{
     xtype: 'box',
     autoEl: {
         tag: 'img',
         src: 'http://www.example.com/example.jpg'
     }
 },
 {
     xtype: 'box',
     autoEl: {
         tag: 'blockquote',
         html: 'autoEl is cool!'
     }
 }, {
     xtype: 'container',
     autoEl: 'ul',
     cls: 'ux-unordered-list',
     items: {
         xtype: 'box',
         autoEl: 'li',
   
      html: 'First list item'
     }
 }</pre></code>]]></description><name>autoEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to use height:'auto', false to use fixed height (or allow it to be managed by its parent Container's layout
 manager. Defaults to false. Note: Although many components inherit this config option, not all will function as expected
 with a height of 'auto'. Setting autoHeight:true means that the browser will manage height based on the element's
 contents, and that Ext will not manage it at all. If the browser is managing the height, be aware that resizes performed
 by the browser in response to changes within the structure of the Component cannot be detected. Therefore changes to the
 height might result in elements needing to be synchronized with the new height. Example: var w = new Ext.Window({
    
 title: 'Window',
     width: 600,
     autoHeight: true,
     items: {
         title: 'Collapse Me',
         height: 400,
  
 collapsible: true,
         border: false,
         listeners: {
             beforecollapse: function() {
                w.el.shadow.hide();
             },
             beforeexpand: function() {
                w.el.shadow.hide();
             },
             collapse: function() {
                w.syncShadow();
             },
             expand: function() {
                w.syncShadow();
             }
         }
     }
 }).show();]]></description><name>autoHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to use overflow:'auto' on the components layout element and show scroll bars automatically when necessary, false to
 clip any overflowing content (defaults to false).]]></description><name>autoScroll</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True if the component should check for hidden classes (e.g. 'x-hidden' or 'x-hide-display') and remove them on render
 (defaults to false).]]></description><name>autoShow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to use width:'auto', false to use fixed width (or allow it to be managed by its parent Container's layout manager.
 Defaults to false. Note: Although many components inherit this config option, not all will function as expected with a
 width of 'auto'. Setting autoWidth:true means that the browser will manage width based on the element's contents, and
 that Ext will not manage it at all. If the browser is managing the width, be aware that resizes performed by the browser
 in response to changes within the structure of the Component cannot be detected. Therefore changes to the width might
 result in elements needing to be synchronized with the new width. For example, where the target element is: <div
 id='grid-container' style='margin-left:25%;width:50%'></div> A Panel rendered into that target element must listen for
 browser window resize in order to relay its child items when the browser changes its width: var myPanel = new
 Ext.Panel({
     renderTo: 'grid-container',
     monitorResize: true, // relay on browser resize
     title: 'Panel',
    
 height: 400,
     autoWidth: true,
     layout: 'hbox',
     layoutConfig: {
         align: 'stretch'
     },
     defaults: {
         flex: 1
     },
     items: [{
         title: 'Box 1',
     }, {
         title: 'Box 2'
     }, {
         title:
 'Box 3'
     }],
 });]]></description><name>autoWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to ['add', 'remove'].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[When set to true (50 milliseconds) or a number of milliseconds, the layout assigned for this container will buffer the
 frequency it calculates and does a re-layout of components. This is useful for heavy containers or containers with a
 large quantity of sub-components for which frequent layout calls would be expensive. Defaults to 50.]]></description><name>bufferResize</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class used to to apply to the special clearing div rendered directly after each form field wrapper to provide
 field clearing (defaults to 'x-form-clear-left'). Note: this config is only used when this Component is rendered by a
 Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or specifying
 layout:'form') and either a fieldLabel is specified or isFormField=true is specified. See Ext.layout.FormLayout.fieldTpl
 also.]]></description><name>clearCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element (defaults to ''). This can be useful for
 adding customized styles to the component or any of its children using standard CSS rules.]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's container. This can be useful for adding customized
 styles to the container or any of its children using standard CSS rules. See Ext.layout.ContainerLayout.extraCls also.
 Note: ctCls defaults to '' except for the following class which assigns a value by default: Box Layout :
 'x-box-layout-ct' To configure the above Class with an extra CSS class append to the default. For example, for BoxLayout
 (Hbox and Vbox): ctCls: 'x-box-layout-ct custom-class']]></description><name>ctCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default Ext.Element.alignTo anchor position value for this menu relative to its element of origin (defaults to
 'tl-bl?')]]></description><name>defaultAlign</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array specifying the [x, y] offset in pixels by which to change the default Menu popup position after aligning
 according to the defaultAlign configuration. Defaults to [0, 0].]]></description><name>defaultOffsets</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default xtype of child Components to create in this Container when a child item is specified as a raw configuration
 object, rather than as an instantiated Component. Defaults to 'panel', except Ext.menu.Menu which defaults to
 'menuitem', and Ext.Toolbar and Ext.ButtonGroup which default to 'button'.]]></description><name>defaultType</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A config object that will be applied to all items added to this container either via the items config or via the add
 method. The defaults config can contain any number of name/value property pairs to be added to each item, and should be
 valid for the types of items being added to the menu.]]></description><name>defaults</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component disabled (default is false).]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class added to the component when it is disabled (defaults to 'x-item-disabled').]]></description><name>disabledClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to allow the menu container to have scroller controls if the menu is too long (defaults to true).]]></description><name>enableScrolling</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The label text to display next to this Component (defaults to ''). Note: this config is only used when this Component is
 rendered by a Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or
 specifying layout:'form'). Also see hideLabel and Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
    
 height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name'
    
 }]
 });]]></description><name>fieldLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use a
 BoxLayout. Each child Component with a flex property will be flexed either vertically (by a VBoxLayout) or horizontally
 (by an HBoxLayout) according to the item's relative flex value compared to the sum of all Components with flex value
 specified. Any child items that have either a flex = 0 or flex = undefined will not be 'flexed' (the initial size will
 not be changed).]]></description><name>flex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[By default, a Menu configured as floating:true will be rendered as an Ext.Layer (an absolutely positioned, floating
 Component with zindex=15000). If configured as floating:false, the Menu may be used as child item of another Container
 instead of a free-floating Layer.]]></description><name>floating</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If true the container will force a layout initially even if hidden or collapsed. This option is useful for forcing forms
 to render in collapsed or hidden containers. (defaults to false).]]></description><name>forceLayout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. A function that will handle the select event of this menu. The handler is passed the following parameters:
 palette : ColorPalette The Ext.ColorPalette. color : String The 6-digit color hex code (without the # symbol).]]></description><name>handler</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component hidden (default is false). If true, the hide method will be called internally.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide the borders of each contained component, false to defer to the component's existing border settings
 (defaults to false).]]></description><name>hideBorders</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to completely hide the label element (label and separator). Defaults to false. By default, even if you do not
 specify a fieldLabel the space will still be reserved so that the field will line up with other fields that do have
 labels. Setting this to true will cause the field to not reserve that space. Note: see the note for clearCls. Example
 use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield'
        
 hideLabel: true
     }]
 });]]></description><name>hideLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[How this component should be hidden. Supported values are 'visibility' (css visibility), 'offsets' (negative offset
 position) and 'display' (css display). Note: the default of 'display' is generally preferred since items are
 automatically laid out when they are first shown (no sizing is done while hidden).]]></description><name>hideMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[False to continue showing the menu after a color is selected, defaults to true.]]></description><name>hideOnClick</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide and show the component's container when hide/show is called on the component, false to hide and show the
 component itself (defaults to false). For example, this can be used as a shortcut for a hide button on a window by
 setting hide:true on the button when adding it to its parent container.]]></description><name>hideParent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id of this component (defaults to an auto-assigned id). You should assign an id if you need to be able to
 access the component later and you do not have an object reference available (e.g., using Ext.getCmp). Note that this id
 will also be used as the element id for the containing HTML element that is rendered to the page for this component.
 This allows you to write id-based CSS rules to style the specific instance of this component uniquely, and also to
 select sub-elements using this component's id as the parent. Note: to avoid complications imposed by a unique id also
 see itemId and ref. Note: to access the container of an item see ownerCt.]]></description><name>id</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to ignore clicks on any item in this menu that is a parent item (displays a submenu) so that the submenu is not
 dismissed when clicking the parent item (defaults to false).]]></description><name>ignoreParentClicks</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use the
 FormLayout layout manager (e.g. Ext.form.FormPanel or specifying layout:'form'). An additional CSS class to apply to the
 div wrapping the form item element of this field. If supplied, itemCls at the field level will override the default
 itemCls supplied at the container level. The value specified for itemCls will be added to the default class
 ('x-form-item'). Since it is applied to the item wrapper (see Ext.layout.FormLayout.fieldTpl), it allows you to write
 standard CSS rules that can apply to the field, the label (if specified), or any other element within the markup for the
 field. Note: see the note for fieldLabel. Example use: // Apply a style to the field's label:
 <style>
     .required
 .x-form-item-label {font-weight:bold;color:red;}
 </style>
 
 new Ext.FormPanel({
     height: 100,
     renderTo:
 Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         itemCls: 'required' //this
 label will be styled
     },{
         xtype: 'textfield',
         fieldLabel: 'Favorite Color'
     }]
 });]]></description><name>itemCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An itemId can be used as an alternative way to get a reference to a component when no object reference is available.
 Instead of using an id with Ext.getCmp, use itemId with Ext.Container.getComponent which will retrieve itemId's or id's.
 Since itemId's are an index to the container's internal MixedCollection, the itemId is scoped locally to the container
 -- avoiding potential conflicts with Ext.ComponentMgr which requires a unique id. var c = new Ext.Panel({ //
     height:
 300,
     renderTo: document.body,
     layout: 'auto',
     items: [
         {
             itemId: 'p1',
            
 title: 'Panel 1',
             height: 150
         },
         {
             itemId: 'p2',
             title: 'Panel 2',
  
 height: 150
         }
     ]
 })
 p1 = c.getComponent('p1'); // not the same as Ext.getCmp()
 p2 =
 p1.ownerCt.getComponent('p2'); // reference via a sibling Also see id and ref. Note: to access the container of an item
 see ownerCt.]]></description><name>itemId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The separator to display after the text of each fieldLabel. This property may be configured at various levels. The order
 of precedence is: field / component level container level layout level (defaults to colon ':') To display no separator
 for this field's label specify empty string ''. Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 layoutConfig: {
         labelSeparator: '~'   // layout config has lowest priority (defaults to ':')
     },
    
 labelSeparator: '>>',     // config at container level
     items: [{
         xtype: 'textfield',
         fieldLabel:
 'Field 1',
         labelSeparator: '...' // field/component level config supersedes others
     },{
         xtype:
 'textfield',
         fieldLabel: 'Field 2' // labelSeparator will be '='
     }]
 });]]></description><name>labelSeparator</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS style specification string to apply directly to this field's label. Defaults to the container's labelStyle value
 if set (e.g., Ext.layout.FormLayout.labelStyle , or ''). Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         labelStyle: 'font-weight:bold;'
     }]
 });]]></description><name>labelStyle</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[This class assigns a default layout (layout:'menu'). Developers may override this configuration option if another layout
 is required. See Ext.Container.layout for additional information.]]></description><name>layout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout or one of the two BoxLayout subclasses. An object containing margins to apply to this BoxComponent in the
 format: {
     top: (top margin),
     right: (right margin),
     bottom: (bottom margin),
     left: (left margin)
 } May
 also be a string containing space-separated, numeric margin values. The order of the sides associated with each value
 matches the way CSS processes margin values: If there is only one value, it applies to all sides. If there are two
 values, the top and bottom borders are set to the first value and the right and left are set to the second. If there are
 three values, the top is set to the first value, the left and right are set to the second, and the bottom is set to the
 third. If there are four values, they apply to the top, right, bottom, and left, respectively. Defaults to: {top:0,
 right:0, bottom:0, left:0}]]></description><name>margins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum height of the menu. Only applies when enableScrolling is set to True (defaults to null).]]></description><name>maxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum width of the menu in pixels (defaults to 120)]]></description><name>minWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically monitor window resize events to handle anything that is sensitive to the current size of the
 viewport. This value is typically managed by the chosen layout and should not need to be set manually.]]></description><name>monitorResize</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element when the mouse moves over the Element, and
 removed when the mouse moves out. (defaults to ''). This can be useful for adding customized 'active' or 'hover' styles
 to the component or any of its children using standard CSS rules.]]></description><name>overCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level x coordinate for this component if contained within a positioning container.]]></description><name>pageX</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level y coordinate for this component if contained within a positioning container.]]></description><name>pageY</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An id to assign to the underlying color palette. Defaults to null.]]></description><name>paletteId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to remove the incised line down the left side of the menu. Defaults to false.]]></description><name>plain</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered ptype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a Plugin is being specified not as a fully
 instantiated Component, but as a Component config object. The ptype will be looked up at render time up to determine
 what type of Plugin to create. If you create your own Plugins, you may register them using
 Ext.ComponentMgr.registerPlugin in order to be able to take advantage of lazy instantiation and rendering.]]></description><name>ptype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A path specification, relative to the Component's ownerCt specifying into which ancestor Container to place a named
 reference to this Component. The ancestor axis can be traversed by using '/' characters in the path. For example, to put
 a reference to a Toolbar Button into the Panel which owns the Toolbar: var myGrid = new Ext.grid.EditorGridPanel({
    
 title: 'My EditorGridPanel',
     store: myStore,
     colModel: myColModel,
     tbar: [{
         text: 'Save',
        
 handler: saveChanges,
         disabled: true,
         ref: '../saveButton'
     }],
     listeners: {
         afteredit:
 function() {
 //          The button reference is in the GridPanel
             myGrid.saveButton.enable();
         }
    
 }
 }); In the code above, if the ref had been 'saveButton' the reference would have been placed into the Toolbar. Each
 '/' in the ref moves up one level from the Component's ownerCt. Also see the added and removed events.]]></description><name>ref</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout layout manager (e.g. specifying layout:'border'). See Ext.layout.BorderLayout also.]]></description><name>region</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The event to listen to for resizing in layouts. Defaults to 'resize'.]]></description><name>resizeEvent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The scope (this reference) in which the handler function will be called. Defaults to this ColorMenu instance.]]></description><name>scope</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The amount to scroll the menu. Only applies when enableScrolling is set to True (defaults to 24).]]></description><name>scrollIncrement</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True or 'sides' for the default effect, 'frame' for 4-way shadow, and 'drop' for bottom-right shadow (defaults to
 'sides')]]></description><name>shadow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to show the icon separator. (defaults to true).]]></description><name>showSeparator</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should trigger this component to save its state (defaults to none). stateEvents may
 be any type of event supported by this component, including browser or custom events (e.g., ['click',
 'customerchange']). See stateful for an explanation of saving and restoring Component state.]]></description><name>stateEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id for this component to use for state management purposes (defaults to the component id if one was set,
 otherwise null if the component is using a generated id). See stateful for an explanation of saving and restoring
 Component state.]]></description><name>stateId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A flag which causes the Component to attempt to restore the state of internal properties from a saved state on startup.
 The component must have either a stateId or id assigned for state to be managed. Auto-generated ids are not guaranteed
 to be stable across page loads and cannot be relied upon to save and restore the same state for a component. For state
 saving to work, the state manager's provider must have been set to an implementation of Ext.state.Provider which
 overrides the set and get methods to save and recall name/value pairs. A built-in implementation,
 Ext.state.CookieProvider is available. To set the state provider for the current page: Ext.state.Manager.setProvider(new
 Ext.state.CookieProvider({
     expires: new Date(new Date().getTime()+(1000*60*60*24*7)), //7 days from now
 })); A
 stateful Component attempts to save state when one of the events listed in the stateEvents configuration fires. To save
 state, a stateful Component first serializes its state by calling getState. By default, this function does nothing. The
 developer must provide an implementation which returns an object hash which represents the Component's restorable state.
 The value yielded by getState is passed to Ext.state.Manager.set which uses the configured Ext.state.Provider to save
 the object keyed by the Component's stateId, or, if that is not specified, its id. During construction, a stateful
 Component attempts to restore its state by calling Ext.state.Manager.get passing the stateId, or, if that is not
 specified, the id. The resulting object is passed to applyState. The default implementation of applyState simply copies
 properties into the object, but a developer may override this to support more behaviour. You can perform extra
 processing on state save and restore by attaching handlers to the beforestaterestore, staterestore, beforestatesave and
 statesave events.]]></description><name>stateful</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
     title: 'Some Title',
     renderTo: Ext.getBody(),
     width: 400, height:
 300,
     layout: 'form',
     items: [{
         xtype: 'textarea',
         style: {
             width: '95%',
            
 marginBottom: '10px'
         }
     },
         new Ext.Button({
             text: 'Send',
             minWidth: '100',
   
          style: {
                 marginBottom: '10px'
             }
         })
     ]
 });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.Element.alignTo anchor position value to use for submenus of this menu (defaults to 'tl-tr?')]]></description><name>subMenuAlign</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is a child item of a TabPanel. A string to be used as innerHTML
 (html tags are accepted) to show in a tooltip when mousing over the associated tab selector element.
 Ext.QuickTips.init() must be called in order for the tips to render.]]></description><name>tabTip</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local x (left) coordinate for this component if contained within a positioning container.]]></description><name>x</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered xtype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a child item of a Container is being specified not
 as a fully instantiated Component, but as a Component config object. The xtype will be looked up at render time up to
 determine what type of child Component to create. The predefined xtypes are listed here. If you subclass Components to
 create your own Components, you may register them using Ext.ComponentMgr.registerType in order to be able to take
 advantage of lazy instantiation and rendering.]]></description><name>xtype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local y (top) coordinate for this component if contained within a positioning container.]]></description><name>y</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[zIndex to use when the menu is floating.]]></description><name>zIndex</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 <p>A menu containing an <a href="output/Ext.DatePicker.html" ext:cls="Ext.DatePicker">Ext.DatePicker</a> Component.</p>
 
 <p>Notes:</p>
 <div class="mdetail-params">
  <ul> 
   <li>Although not listed here, the <b>constructor</b> for this class
 accepts all of the configuration options of <b><a href="output/Ext.DatePicker.html"
 ext:cls="Ext.DatePicker">Ext.DatePicker</a></b>.</li> 
   <li>If subclassing DateMenu, any configuration options for the
 DatePicker must be applied to the <tt><b>initialConfig</b></tt> property of the DateMenu. Applying <a
 href="output/Ext.DatePicker.html" ext:cls="Ext.DatePicker">DatePicker</a> configuration settings to <b><tt>this</tt></b>
 will <b>not</b> affect the DatePicker's configuration.</li> 
  </ul>
 </div>]]></description><name>menu.dateMenu</name><tag-class>org.brushingbits.jnap.ui.extjs3.menu.DateMenu</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[A string component id or the numeric index of the component that should be initially activated within the container's
 layout on render. For example, activeItem: 'item-1' or activeItem: 0 (index 0 = the first item in the container's
 collection). activeItem only applies to layout styles that can display items one at a time (like
 Ext.layout.AccordionLayout, Ext.layout.CardLayout and Ext.layout.FitLayout). Related to
 Ext.layout.ContainerLayout.activeItem.]]></description><name>activeItem</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Whether the component can move the Dom node when rendering (defaults to true).]]></description><name>allowDomMove</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to allow multiple menus to be displayed at the same time (defaults to false)]]></description><name>allowOtherMenus</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use an
 AnchorLayout (or subclass thereof). based layout manager, for example: Ext.form.FormPanel specifying layout: 'anchor' //
 or 'form', or 'absolute' See Ext.layout.AnchorLayout.anchor also.]]></description><name>anchor</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element corresponding to a DIV that is already present in
 the document that specifies some structural markup for this component. Description : When applyTo is used, constituent
 parts of the component can also be specified by id or CSS class name within the main element, and the component being
 created may attempt to create its subcomponents from that markup if applicable. Notes : When using this config, a call
 to render() is not required. If applyTo is specified, any value passed for renderTo will be ignored and the target
 element's parent node will automatically be used as the component's container.]]></description><name>applyTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If true the container will automatically destroy any contained component that is removed from it, else destruction must
 be handled manually (defaults to true).]]></description><name>autoDestroy</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A tag name or DomHelper spec used to create the Element which will encapsulate this Component. You do not normally need
 to specify this. For the base classes Ext.Component, Ext.BoxComponent, and Ext.Container, this defaults to 'div'. The
 more complex Ext classes use a more complex DOM structure created by their own onRender methods. This is intended to
 allow the developer to create application-specific utility Components encapsulated by different DOM elements. Example
 usage: <pre><code>{
     xtype: 'box',
     autoEl: {
         tag: 'img',
         src: 'http://www.example.com/example.jpg'
     }
 },
 {
     xtype: 'box',
     autoEl: {
         tag: 'blockquote',
         html: 'autoEl is cool!'
     }
 }, {
     xtype: 'container',
     autoEl: 'ul',
     cls: 'ux-unordered-list',
     items: {
         xtype: 'box',
         autoEl: 'li',
   
      html: 'First list item'
     }
 }</pre></code>]]></description><name>autoEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to use height:'auto', false to use fixed height (or allow it to be managed by its parent Container's layout
 manager. Defaults to false. Note: Although many components inherit this config option, not all will function as expected
 with a height of 'auto'. Setting autoHeight:true means that the browser will manage height based on the element's
 contents, and that Ext will not manage it at all. If the browser is managing the height, be aware that resizes performed
 by the browser in response to changes within the structure of the Component cannot be detected. Therefore changes to the
 height might result in elements needing to be synchronized with the new height. Example: var w = new Ext.Window({
    
 title: 'Window',
     width: 600,
     autoHeight: true,
     items: {
         title: 'Collapse Me',
         height: 400,
  
 collapsible: true,
         border: false,
         listeners: {
             beforecollapse: function() {
                w.el.shadow.hide();
             },
             beforeexpand: function() {
                w.el.shadow.hide();
             },
             collapse: function() {
                w.syncShadow();
             },
             expand: function() {
                w.syncShadow();
             }
         }
     }
 }).show();]]></description><name>autoHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to use overflow:'auto' on the components layout element and show scroll bars automatically when necessary, false to
 clip any overflowing content (defaults to false).]]></description><name>autoScroll</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True if the component should check for hidden classes (e.g. 'x-hidden' or 'x-hide-display') and remove them on render
 (defaults to false).]]></description><name>autoShow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to use width:'auto', false to use fixed width (or allow it to be managed by its parent Container's layout manager.
 Defaults to false. Note: Although many components inherit this config option, not all will function as expected with a
 width of 'auto'. Setting autoWidth:true means that the browser will manage width based on the element's contents, and
 that Ext will not manage it at all. If the browser is managing the width, be aware that resizes performed by the browser
 in response to changes within the structure of the Component cannot be detected. Therefore changes to the width might
 result in elements needing to be synchronized with the new width. For example, where the target element is: <div
 id='grid-container' style='margin-left:25%;width:50%'></div> A Panel rendered into that target element must listen for
 browser window resize in order to relay its child items when the browser changes its width: var myPanel = new
 Ext.Panel({
     renderTo: 'grid-container',
     monitorResize: true, // relay on browser resize
     title: 'Panel',
    
 height: 400,
     autoWidth: true,
     layout: 'hbox',
     layoutConfig: {
         align: 'stretch'
     },
     defaults: {
         flex: 1
     },
     items: [{
         title: 'Box 1',
     }, {
         title: 'Box 2'
     }, {
         title:
 'Box 3'
     }],
 });]]></description><name>autoWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to ['add', 'remove'].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[When set to true (50 milliseconds) or a number of milliseconds, the layout assigned for this container will buffer the
 frequency it calculates and does a re-layout of components. This is useful for heavy containers or containers with a
 large quantity of sub-components for which frequent layout calls would be expensive. Defaults to 50.]]></description><name>bufferResize</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class used to to apply to the special clearing div rendered directly after each form field wrapper to provide
 field clearing (defaults to 'x-form-clear-left'). Note: this config is only used when this Component is rendered by a
 Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or specifying
 layout:'form') and either a fieldLabel is specified or isFormField=true is specified. See Ext.layout.FormLayout.fieldTpl
 also.]]></description><name>clearCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element (defaults to ''). This can be useful for
 adding customized styles to the component or any of its children using standard CSS rules.]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's container. This can be useful for adding customized
 styles to the container or any of its children using standard CSS rules. See Ext.layout.ContainerLayout.extraCls also.
 Note: ctCls defaults to '' except for the following class which assigns a value by default: Box Layout :
 'x-box-layout-ct' To configure the above Class with an extra CSS class append to the default. For example, for BoxLayout
 (Hbox and Vbox): ctCls: 'x-box-layout-ct custom-class']]></description><name>ctCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default Ext.Element.alignTo anchor position value for this menu relative to its element of origin (defaults to
 'tl-bl?')]]></description><name>defaultAlign</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array specifying the [x, y] offset in pixels by which to change the default Menu popup position after aligning
 according to the defaultAlign configuration. Defaults to [0, 0].]]></description><name>defaultOffsets</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default xtype of child Components to create in this Container when a child item is specified as a raw configuration
 object, rather than as an instantiated Component. Defaults to 'panel', except Ext.menu.Menu which defaults to
 'menuitem', and Ext.Toolbar and Ext.ButtonGroup which default to 'button'.]]></description><name>defaultType</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A config object that will be applied to all items added to this container either via the items config or via the add
 method. The defaults config can contain any number of name/value property pairs to be added to each item, and should be
 valid for the types of items being added to the menu.]]></description><name>defaults</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component disabled (default is false).]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class added to the component when it is disabled (defaults to 'x-item-disabled').]]></description><name>disabledClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to allow the menu container to have scroller controls if the menu is too long (defaults to true).]]></description><name>enableScrolling</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The label text to display next to this Component (defaults to ''). Note: this config is only used when this Component is
 rendered by a Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or
 specifying layout:'form'). Also see hideLabel and Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
    
 height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name'
    
 }]
 });]]></description><name>fieldLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use a
 BoxLayout. Each child Component with a flex property will be flexed either vertically (by a VBoxLayout) or horizontally
 (by an HBoxLayout) according to the item's relative flex value compared to the sum of all Components with flex value
 specified. Any child items that have either a flex = 0 or flex = undefined will not be 'flexed' (the initial size will
 not be changed).]]></description><name>flex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[By default, a Menu configured as floating:true will be rendered as an Ext.Layer (an absolutely positioned, floating
 Component with zindex=15000). If configured as floating:false, the Menu may be used as child item of another Container
 instead of a free-floating Layer.]]></description><name>floating</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If true the container will force a layout initially even if hidden or collapsed. This option is useful for forcing forms
 to render in collapsed or hidden containers. (defaults to false).]]></description><name>forceLayout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. A function that will handle the select event of this menu. The handler is passed the following parameters:
 picker : DatePicker The Ext.DatePicker. date : Date The selected date.]]></description><name>handler</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component hidden (default is false). If true, the hide method will be called internally.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide the borders of each contained component, false to defer to the component's existing border settings
 (defaults to false).]]></description><name>hideBorders</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to completely hide the label element (label and separator). Defaults to false. By default, even if you do not
 specify a fieldLabel the space will still be reserved so that the field will line up with other fields that do have
 labels. Setting this to true will cause the field to not reserve that space. Note: see the note for clearCls. Example
 use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield'
        
 hideLabel: true
     }]
 });]]></description><name>hideLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[How this component should be hidden. Supported values are 'visibility' (css visibility), 'offsets' (negative offset
 position) and 'display' (css display). Note: the default of 'display' is generally preferred since items are
 automatically laid out when they are first shown (no sizing is done while hidden).]]></description><name>hideMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[False to continue showing the menu after a date is selected, defaults to true.]]></description><name>hideOnClick</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide and show the component's container when hide/show is called on the component, false to hide and show the
 component itself (defaults to false). For example, this can be used as a shortcut for a hide button on a window by
 setting hide:true on the button when adding it to its parent container.]]></description><name>hideParent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id of this component (defaults to an auto-assigned id). You should assign an id if you need to be able to
 access the component later and you do not have an object reference available (e.g., using Ext.getCmp). Note that this id
 will also be used as the element id for the containing HTML element that is rendered to the page for this component.
 This allows you to write id-based CSS rules to style the specific instance of this component uniquely, and also to
 select sub-elements using this component's id as the parent. Note: to avoid complications imposed by a unique id also
 see itemId and ref. Note: to access the container of an item see ownerCt.]]></description><name>id</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to ignore clicks on any item in this menu that is a parent item (displays a submenu) so that the submenu is not
 dismissed when clicking the parent item (defaults to false).]]></description><name>ignoreParentClicks</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use the
 FormLayout layout manager (e.g. Ext.form.FormPanel or specifying layout:'form'). An additional CSS class to apply to the
 div wrapping the form item element of this field. If supplied, itemCls at the field level will override the default
 itemCls supplied at the container level. The value specified for itemCls will be added to the default class
 ('x-form-item'). Since it is applied to the item wrapper (see Ext.layout.FormLayout.fieldTpl), it allows you to write
 standard CSS rules that can apply to the field, the label (if specified), or any other element within the markup for the
 field. Note: see the note for fieldLabel. Example use: // Apply a style to the field's label:
 <style>
     .required
 .x-form-item-label {font-weight:bold;color:red;}
 </style>
 
 new Ext.FormPanel({
     height: 100,
     renderTo:
 Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         itemCls: 'required' //this
 label will be styled
     },{
         xtype: 'textfield',
         fieldLabel: 'Favorite Color'
     }]
 });]]></description><name>itemCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An itemId can be used as an alternative way to get a reference to a component when no object reference is available.
 Instead of using an id with Ext.getCmp, use itemId with Ext.Container.getComponent which will retrieve itemId's or id's.
 Since itemId's are an index to the container's internal MixedCollection, the itemId is scoped locally to the container
 -- avoiding potential conflicts with Ext.ComponentMgr which requires a unique id. var c = new Ext.Panel({ //
     height:
 300,
     renderTo: document.body,
     layout: 'auto',
     items: [
         {
             itemId: 'p1',
            
 title: 'Panel 1',
             height: 150
         },
         {
             itemId: 'p2',
             title: 'Panel 2',
  
 height: 150
         }
     ]
 })
 p1 = c.getComponent('p1'); // not the same as Ext.getCmp()
 p2 =
 p1.ownerCt.getComponent('p2'); // reference via a sibling Also see id and ref. Note: to access the container of an item
 see ownerCt.]]></description><name>itemId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The separator to display after the text of each fieldLabel. This property may be configured at various levels. The order
 of precedence is: field / component level container level layout level (defaults to colon ':') To display no separator
 for this field's label specify empty string ''. Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 layoutConfig: {
         labelSeparator: '~'   // layout config has lowest priority (defaults to ':')
     },
    
 labelSeparator: '>>',     // config at container level
     items: [{
         xtype: 'textfield',
         fieldLabel:
 'Field 1',
         labelSeparator: '...' // field/component level config supersedes others
     },{
         xtype:
 'textfield',
         fieldLabel: 'Field 2' // labelSeparator will be '='
     }]
 });]]></description><name>labelSeparator</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS style specification string to apply directly to this field's label. Defaults to the container's labelStyle value
 if set (e.g., Ext.layout.FormLayout.labelStyle , or ''). Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         labelStyle: 'font-weight:bold;'
     }]
 });]]></description><name>labelStyle</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[This class assigns a default layout (layout:'menu'). Developers may override this configuration option if another layout
 is required. See Ext.Container.layout for additional information.]]></description><name>layout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout or one of the two BoxLayout subclasses. An object containing margins to apply to this BoxComponent in the
 format: {
     top: (top margin),
     right: (right margin),
     bottom: (bottom margin),
     left: (left margin)
 } May
 also be a string containing space-separated, numeric margin values. The order of the sides associated with each value
 matches the way CSS processes margin values: If there is only one value, it applies to all sides. If there are two
 values, the top and bottom borders are set to the first value and the right and left are set to the second. If there are
 three values, the top is set to the first value, the left and right are set to the second, and the bottom is set to the
 third. If there are four values, they apply to the top, right, bottom, and left, respectively. Defaults to: {top:0,
 right:0, bottom:0, left:0}]]></description><name>margins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum height of the menu. Only applies when enableScrolling is set to True (defaults to null).]]></description><name>maxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum width of the menu in pixels (defaults to 120)]]></description><name>minWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically monitor window resize events to handle anything that is sensitive to the current size of the
 viewport. This value is typically managed by the chosen layout and should not need to be set manually.]]></description><name>monitorResize</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element when the mouse moves over the Element, and
 removed when the mouse moves out. (defaults to ''). This can be useful for adding customized 'active' or 'hover' styles
 to the component or any of its children using standard CSS rules.]]></description><name>overCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level x coordinate for this component if contained within a positioning container.]]></description><name>pageX</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level y coordinate for this component if contained within a positioning container.]]></description><name>pageY</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An id to assign to the underlying date picker. Defaults to null.]]></description><name>pickerId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to remove the incised line down the left side of the menu. Defaults to false.]]></description><name>plain</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered ptype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a Plugin is being specified not as a fully
 instantiated Component, but as a Component config object. The ptype will be looked up at render time up to determine
 what type of Plugin to create. If you create your own Plugins, you may register them using
 Ext.ComponentMgr.registerPlugin in order to be able to take advantage of lazy instantiation and rendering.]]></description><name>ptype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A path specification, relative to the Component's ownerCt specifying into which ancestor Container to place a named
 reference to this Component. The ancestor axis can be traversed by using '/' characters in the path. For example, to put
 a reference to a Toolbar Button into the Panel which owns the Toolbar: var myGrid = new Ext.grid.EditorGridPanel({
    
 title: 'My EditorGridPanel',
     store: myStore,
     colModel: myColModel,
     tbar: [{
         text: 'Save',
        
 handler: saveChanges,
         disabled: true,
         ref: '../saveButton'
     }],
     listeners: {
         afteredit:
 function() {
 //          The button reference is in the GridPanel
             myGrid.saveButton.enable();
         }
    
 }
 }); In the code above, if the ref had been 'saveButton' the reference would have been placed into the Toolbar. Each
 '/' in the ref moves up one level from the Component's ownerCt. Also see the added and removed events.]]></description><name>ref</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout layout manager (e.g. specifying layout:'border'). See Ext.layout.BorderLayout also.]]></description><name>region</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The event to listen to for resizing in layouts. Defaults to 'resize'.]]></description><name>resizeEvent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The scope (this reference) in which the handler function will be called. Defaults to this DateMenu instance.]]></description><name>scope</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The amount to scroll the menu. Only applies when enableScrolling is set to True (defaults to 24).]]></description><name>scrollIncrement</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True or 'sides' for the default effect, 'frame' for 4-way shadow, and 'drop' for bottom-right shadow (defaults to
 'sides')]]></description><name>shadow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to show the icon separator. (defaults to true).]]></description><name>showSeparator</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should trigger this component to save its state (defaults to none). stateEvents may
 be any type of event supported by this component, including browser or custom events (e.g., ['click',
 'customerchange']). See stateful for an explanation of saving and restoring Component state.]]></description><name>stateEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id for this component to use for state management purposes (defaults to the component id if one was set,
 otherwise null if the component is using a generated id). See stateful for an explanation of saving and restoring
 Component state.]]></description><name>stateId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A flag which causes the Component to attempt to restore the state of internal properties from a saved state on startup.
 The component must have either a stateId or id assigned for state to be managed. Auto-generated ids are not guaranteed
 to be stable across page loads and cannot be relied upon to save and restore the same state for a component. For state
 saving to work, the state manager's provider must have been set to an implementation of Ext.state.Provider which
 overrides the set and get methods to save and recall name/value pairs. A built-in implementation,
 Ext.state.CookieProvider is available. To set the state provider for the current page: Ext.state.Manager.setProvider(new
 Ext.state.CookieProvider({
     expires: new Date(new Date().getTime()+(1000*60*60*24*7)), //7 days from now
 })); A
 stateful Component attempts to save state when one of the events listed in the stateEvents configuration fires. To save
 state, a stateful Component first serializes its state by calling getState. By default, this function does nothing. The
 developer must provide an implementation which returns an object hash which represents the Component's restorable state.
 The value yielded by getState is passed to Ext.state.Manager.set which uses the configured Ext.state.Provider to save
 the object keyed by the Component's stateId, or, if that is not specified, its id. During construction, a stateful
 Component attempts to restore its state by calling Ext.state.Manager.get passing the stateId, or, if that is not
 specified, the id. The resulting object is passed to applyState. The default implementation of applyState simply copies
 properties into the object, but a developer may override this to support more behaviour. You can perform extra
 processing on state save and restore by attaching handlers to the beforestaterestore, staterestore, beforestatesave and
 statesave events.]]></description><name>stateful</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
     title: 'Some Title',
     renderTo: Ext.getBody(),
     width: 400, height:
 300,
     layout: 'form',
     items: [{
         xtype: 'textarea',
         style: {
             width: '95%',
            
 marginBottom: '10px'
         }
     },
         new Ext.Button({
             text: 'Send',
             minWidth: '100',
   
          style: {
                 marginBottom: '10px'
             }
         })
     ]
 });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.Element.alignTo anchor position value to use for submenus of this menu (defaults to 'tl-tr?')]]></description><name>subMenuAlign</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is a child item of a TabPanel. A string to be used as innerHTML
 (html tags are accepted) to show in a tooltip when mousing over the associated tab selector element.
 Ext.QuickTips.init() must be called in order for the tips to render.]]></description><name>tabTip</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local x (left) coordinate for this component if contained within a positioning container.]]></description><name>x</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered xtype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a child item of a Container is being specified not
 as a fully instantiated Component, but as a Component config object. The xtype will be looked up at render time up to
 determine what type of child Component to create. The predefined xtypes are listed here. If you subclass Components to
 create your own Components, you may register them using Ext.ComponentMgr.registerType in order to be able to take
 advantage of lazy instantiation and rendering.]]></description><name>xtype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local y (top) coordinate for this component if contained within a positioning container.]]></description><name>y</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[zIndex to use when the menu is floating.]]></description><name>zIndex</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 A base class for all menu items that require menu-related functionality (like sub-menus) and are not static display
 items. Item extends the base functionality of 
 <a href="output/Ext.menu.BaseItem.html"
 ext:cls="Ext.menu.BaseItem">Ext.menu.BaseItem</a> by adding menu-specific activation and click handling.]]></description><name>menu.item</name><tag-class>org.brushingbits.jnap.ui.extjs3.menu.Item</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[The CSS class to use when the item becomes activated (defaults to "x-menu-item-active")]]></description><name>activeClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Whether the component can move the Dom node when rendering (defaults to true).]]></description><name>allowDomMove</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The altText to use for the icon, if it exists. Defaults to ''.]]></description><name>altText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element corresponding to a DIV that is already present in
 the document that specifies some structural markup for this component. Description : When applyTo is used, constituent
 parts of the component can also be specified by id or CSS class name within the main element, and the component being
 created may attempt to create its subcomponents from that markup if applicable. Notes : When using this config, a call
 to render() is not required. If applyTo is specified, any value passed for renderTo will be ignored and the target
 element's parent node will automatically be used as the component's container.]]></description><name>applyTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A tag name or DomHelper spec used to create the Element which will encapsulate this Component. You do not normally need
 to specify this. For the base classes Ext.Component, Ext.BoxComponent, and Ext.Container, this defaults to 'div'. The
 more complex Ext classes use a more complex DOM structure created by their own onRender methods. This is intended to
 allow the developer to create application-specific utility Components encapsulated by different DOM elements. Example
 usage: <pre><code>{
     xtype: 'box',
     autoEl: {
         tag: 'img',
         src: 'http://www.example.com/example.jpg'
     }
 },
 {
     xtype: 'box',
     autoEl: {
         tag: 'blockquote',
         html: 'autoEl is cool!'
     }
 }, {
     xtype: 'container',
     autoEl: 'ul',
     cls: 'ux-unordered-list',
     items: {
         xtype: 'box',
         autoEl: 'li',
   
      html: 'First list item'
     }
 }</pre></code>]]></description><name>autoEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True if the component should check for hidden classes (e.g. 'x-hidden' or 'x-hide-display') and remove them on render
 (defaults to false).]]></description><name>autoShow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to [].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True if this item can be visually activated (defaults to true)]]></description><name>canActivate</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class used to to apply to the special clearing div rendered directly after each form field wrapper to provide
 field clearing (defaults to 'x-form-clear-left'). Note: this config is only used when this Component is rendered by a
 Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or specifying
 layout:'form') and either a fieldLabel is specified or isFormField=true is specified. See Ext.layout.FormLayout.fieldTpl
 also.]]></description><name>clearCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Length of time in milliseconds to wait before hiding after a click (defaults to 1)]]></description><name>clickHideDelay</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element (defaults to ''). This can be useful for
 adding customized styles to the component or any of its children using standard CSS rules.]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's container. This can be useful for adding customized
 styles to the container or any of its children using standard CSS rules. See Ext.layout.ContainerLayout.extraCls also.
 Note: ctCls defaults to '' except for the following class which assigns a value by default: Box Layout :
 'x-box-layout-ct' To configure the above Class with an extra CSS class append to the default. For example, for BoxLayout
 (Hbox and Vbox): ctCls: 'x-box-layout-ct custom-class']]></description><name>ctCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component disabled (default is false).]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class added to the component when it is disabled (defaults to 'x-item-disabled').]]></description><name>disabledClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The label text to display next to this Component (defaults to ''). Note: this config is only used when this Component is
 rendered by a Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or
 specifying layout:'form'). Also see hideLabel and Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
    
 height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name'
    
 }]
 });]]></description><name>fieldLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A function that will handle the click event of this menu item (optional). The handler is passed the following
 parameters: b : Item This menu Item. e : EventObject The click event.]]></description><name>handler</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component hidden (default is false). If true, the hide method will be called internally.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to completely hide the label element (label and separator). Defaults to false. By default, even if you do not
 specify a fieldLabel the space will still be reserved so that the field will line up with other fields that do have
 labels. Setting this to true will cause the field to not reserve that space. Note: see the note for clearCls. Example
 use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield'
        
 hideLabel: true
     }]
 });]]></description><name>hideLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[How this component should be hidden. Supported values are 'visibility' (css visibility), 'offsets' (negative offset
 position) and 'display' (css display). Note: the default of 'display' is generally preferred since items are
 automatically laid out when they are first shown (no sizing is done while hidden).]]></description><name>hideMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide the containing menu after this item is clicked (defaults to true)]]></description><name>hideOnClick</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide and show the component's container when hide/show is called on the component, false to hide and show the
 component itself (defaults to false). For example, this can be used as a shortcut for a hide button on a window by
 setting hide:true on the button when adding it to its parent container.]]></description><name>hideParent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The href attribute to use for the underlying anchor link (defaults to '#').]]></description><name>href</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The target attribute to use for the underlying anchor link (defaults to '').]]></description><name>hrefTarget</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The path to an icon to display in this item (defaults to Ext.BLANK_IMAGE_URL). If icon is specified iconCls should not
 be.]]></description><name>icon</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS class that specifies a background image that will be used as the icon for this item (defaults to ''). If iconCls
 is specified icon should not be.]]></description><name>iconCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id of this component (defaults to an auto-assigned id). You should assign an id if you need to be able to
 access the component later and you do not have an object reference available (e.g., using Ext.getCmp). Note that this id
 will also be used as the element id for the containing HTML element that is rendered to the page for this component.
 This allows you to write id-based CSS rules to style the specific instance of this component uniquely, and also to
 select sub-elements using this component's id as the parent. Note: to avoid complications imposed by a unique id also
 see itemId and ref. Note: to access the container of an item see ownerCt.]]></description><name>id</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default CSS class to use for menu items (defaults to 'x-menu-item')]]></description><name>itemCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An itemId can be used as an alternative way to get a reference to a component when no object reference is available.
 Instead of using an id with Ext.getCmp, use itemId with Ext.Container.getComponent which will retrieve itemId's or id's.
 Since itemId's are an index to the container's internal MixedCollection, the itemId is scoped locally to the container
 -- avoiding potential conflicts with Ext.ComponentMgr which requires a unique id. var c = new Ext.Panel({ //
     height:
 300,
     renderTo: document.body,
     layout: 'auto',
     items: [
         {
             itemId: 'p1',
            
 title: 'Panel 1',
             height: 150
         },
         {
             itemId: 'p2',
             title: 'Panel 2',
  
 height: 150
         }
     ]
 })
 p1 = c.getComponent('p1'); // not the same as Ext.getCmp()
 p2 =
 p1.ownerCt.getComponent('p2'); // reference via a sibling Also see id and ref. Note: to access the container of an item
 see ownerCt.]]></description><name>itemId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The separator to display after the text of each fieldLabel. This property may be configured at various levels. The order
 of precedence is: field / component level container level layout level (defaults to colon ':') To display no separator
 for this field's label specify empty string ''. Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 layoutConfig: {
         labelSeparator: '~'   // layout config has lowest priority (defaults to ':')
     },
    
 labelSeparator: '>>',     // config at container level
     items: [{
         xtype: 'textfield',
         fieldLabel:
 'Field 1',
         labelSeparator: '...' // field/component level config supersedes others
     },{
         xtype:
 'textfield',
         fieldLabel: 'Field 2' // labelSeparator will be '='
     }]
 });]]></description><name>labelSeparator</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS style specification string to apply directly to this field's label. Defaults to the container's labelStyle value
 if set (e.g., Ext.layout.FormLayout.labelStyle , or ''). Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         labelStyle: 'font-weight:bold;'
     }]
 });]]></description><name>labelStyle</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Either an instance of Ext.menu.Menu or the config object for an Ext.menu.Menu which acts as the submenu when this item
 is activated.]]></description><name>menu</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element when the mouse moves over the Element, and
 removed when the mouse moves out. (defaults to ''). This can be useful for adding customized 'active' or 'hover' styles
 to the component or any of its children using standard CSS rules.]]></description><name>overCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered ptype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a Plugin is being specified not as a fully
 instantiated Component, but as a Component config object. The ptype will be looked up at render time up to determine
 what type of Plugin to create. If you create your own Plugins, you may register them using
 Ext.ComponentMgr.registerPlugin in order to be able to take advantage of lazy instantiation and rendering.]]></description><name>ptype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A path specification, relative to the Component's ownerCt specifying into which ancestor Container to place a named
 reference to this Component. The ancestor axis can be traversed by using '/' characters in the path. For example, to put
 a reference to a Toolbar Button into the Panel which owns the Toolbar: var myGrid = new Ext.grid.EditorGridPanel({
    
 title: 'My EditorGridPanel',
     store: myStore,
     colModel: myColModel,
     tbar: [{
         text: 'Save',
        
 handler: saveChanges,
         disabled: true,
         ref: '../saveButton'
     }],
     listeners: {
         afteredit:
 function() {
 //          The button reference is in the GridPanel
             myGrid.saveButton.enable();
         }
    
 }
 }); In the code above, if the ref had been 'saveButton' the reference would have been placed into the Toolbar. Each
 '/' in the ref moves up one level from the Component's ownerCt. Also see the added and removed events.]]></description><name>ref</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The scope (this reference) in which the handler function will be called.]]></description><name>scope</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Length of time in milliseconds to wait before showing this item (defaults to 200)]]></description><name>showDelay</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should trigger this component to save its state (defaults to none). stateEvents may
 be any type of event supported by this component, including browser or custom events (e.g., ['click',
 'customerchange']). See stateful for an explanation of saving and restoring Component state.]]></description><name>stateEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id for this component to use for state management purposes (defaults to the component id if one was set,
 otherwise null if the component is using a generated id). See stateful for an explanation of saving and restoring
 Component state.]]></description><name>stateId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A flag which causes the Component to attempt to restore the state of internal properties from a saved state on startup.
 The component must have either a stateId or id assigned for state to be managed. Auto-generated ids are not guaranteed
 to be stable across page loads and cannot be relied upon to save and restore the same state for a component. For state
 saving to work, the state manager's provider must have been set to an implementation of Ext.state.Provider which
 overrides the set and get methods to save and recall name/value pairs. A built-in implementation,
 Ext.state.CookieProvider is available. To set the state provider for the current page: Ext.state.Manager.setProvider(new
 Ext.state.CookieProvider({
     expires: new Date(new Date().getTime()+(1000*60*60*24*7)), //7 days from now
 })); A
 stateful Component attempts to save state when one of the events listed in the stateEvents configuration fires. To save
 state, a stateful Component first serializes its state by calling getState. By default, this function does nothing. The
 developer must provide an implementation which returns an object hash which represents the Component's restorable state.
 The value yielded by getState is passed to Ext.state.Manager.set which uses the configured Ext.state.Provider to save
 the object keyed by the Component's stateId, or, if that is not specified, its id. During construction, a stateful
 Component attempts to restore its state by calling Ext.state.Manager.get passing the stateId, or, if that is not
 specified, the id. The resulting object is passed to applyState. The default implementation of applyState simply copies
 properties into the object, but a developer may override this to support more behaviour. You can perform extra
 processing on state save and restore by attaching handlers to the beforestaterestore, staterestore, beforestatesave and
 statesave events.]]></description><name>stateful</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
     title: 'Some Title',
     renderTo: Ext.getBody(),
     width: 400, height:
 300,
     layout: 'form',
     items: [{
         xtype: 'textarea',
         style: {
             width: '95%',
            
 marginBottom: '10px'
         }
     },
         new Ext.Button({
             text: 'Send',
             minWidth: '100',
   
          style: {
                 marginBottom: '10px'
             }
         })
     ]
 });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The text to display in this item (defaults to '').]]></description><name>text</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered xtype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a child item of a Container is being specified not
 as a fully instantiated Component, but as a Component config object. The xtype will be looked up at render time up to
 determine what type of child Component to create. The predefined xtypes are listed here. If you subclass Components to
 create your own Components, you may register them using Ext.ComponentMgr.registerType in order to be able to take
 advantage of lazy instantiation and rendering.]]></description><name>xtype</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 Adds a separator bar to a menu, used to divide logical groups of menu items. Generally you will add one of these by
 using &quot;-&quot; in you call to add() or in your items config rather than creating one directly.]]></description><name>menu.separator</name><tag-class>org.brushingbits.jnap.ui.extjs3.menu.Separator</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[The CSS class to use when the item becomes activated (defaults to "x-menu-item-active")]]></description><name>activeClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Whether the component can move the Dom node when rendering (defaults to true).]]></description><name>allowDomMove</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element corresponding to a DIV that is already present in
 the document that specifies some structural markup for this component. Description : When applyTo is used, constituent
 parts of the component can also be specified by id or CSS class name within the main element, and the component being
 created may attempt to create its subcomponents from that markup if applicable. Notes : When using this config, a call
 to render() is not required. If applyTo is specified, any value passed for renderTo will be ignored and the target
 element's parent node will automatically be used as the component's container.]]></description><name>applyTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A tag name or DomHelper spec used to create the Element which will encapsulate this Component. You do not normally need
 to specify this. For the base classes Ext.Component, Ext.BoxComponent, and Ext.Container, this defaults to 'div'. The
 more complex Ext classes use a more complex DOM structure created by their own onRender methods. This is intended to
 allow the developer to create application-specific utility Components encapsulated by different DOM elements. Example
 usage: <pre><code>{
     xtype: 'box',
     autoEl: {
         tag: 'img',
         src: 'http://www.example.com/example.jpg'
     }
 },
 {
     xtype: 'box',
     autoEl: {
         tag: 'blockquote',
         html: 'autoEl is cool!'
     }
 }, {
     xtype: 'container',
     autoEl: 'ul',
     cls: 'ux-unordered-list',
     items: {
         xtype: 'box',
         autoEl: 'li',
   
      html: 'First list item'
     }
 }</pre></code>]]></description><name>autoEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True if the component should check for hidden classes (e.g. 'x-hidden' or 'x-hide-display') and remove them on render
 (defaults to false).]]></description><name>autoShow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to [].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True if this item can be visually activated (defaults to false)]]></description><name>canActivate</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class used to to apply to the special clearing div rendered directly after each form field wrapper to provide
 field clearing (defaults to 'x-form-clear-left'). Note: this config is only used when this Component is rendered by a
 Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or specifying
 layout:'form') and either a fieldLabel is specified or isFormField=true is specified. See Ext.layout.FormLayout.fieldTpl
 also.]]></description><name>clearCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Length of time in milliseconds to wait before hiding after a click (defaults to 1)]]></description><name>clickHideDelay</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element (defaults to ''). This can be useful for
 adding customized styles to the component or any of its children using standard CSS rules.]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's container. This can be useful for adding customized
 styles to the container or any of its children using standard CSS rules. See Ext.layout.ContainerLayout.extraCls also.
 Note: ctCls defaults to '' except for the following class which assigns a value by default: Box Layout :
 'x-box-layout-ct' To configure the above Class with an extra CSS class append to the default. For example, for BoxLayout
 (Hbox and Vbox): ctCls: 'x-box-layout-ct custom-class']]></description><name>ctCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component disabled (default is false).]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class added to the component when it is disabled (defaults to 'x-item-disabled').]]></description><name>disabledClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The label text to display next to this Component (defaults to ''). Note: this config is only used when this Component is
 rendered by a Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or
 specifying layout:'form'). Also see hideLabel and Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
    
 height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name'
    
 }]
 });]]></description><name>fieldLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A function that will handle the click event of this menu item (optional). The handler is passed the following
 parameters: b : Item This menu Item. e : EventObject The click event.]]></description><name>handler</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component hidden (default is false). If true, the hide method will be called internally.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to completely hide the label element (label and separator). Defaults to false. By default, even if you do not
 specify a fieldLabel the space will still be reserved so that the field will line up with other fields that do have
 labels. Setting this to true will cause the field to not reserve that space. Note: see the note for clearCls. Example
 use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield'
        
 hideLabel: true
     }]
 });]]></description><name>hideLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[How this component should be hidden. Supported values are 'visibility' (css visibility), 'offsets' (negative offset
 position) and 'display' (css display). Note: the default of 'display' is generally preferred since items are
 automatically laid out when they are first shown (no sizing is done while hidden).]]></description><name>hideMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide the containing menu after this item is clicked (defaults to false)]]></description><name>hideOnClick</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide and show the component's container when hide/show is called on the component, false to hide and show the
 component itself (defaults to false). For example, this can be used as a shortcut for a hide button on a window by
 setting hide:true on the button when adding it to its parent container.]]></description><name>hideParent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id of this component (defaults to an auto-assigned id). You should assign an id if you need to be able to
 access the component later and you do not have an object reference available (e.g., using Ext.getCmp). Note that this id
 will also be used as the element id for the containing HTML element that is rendered to the page for this component.
 This allows you to write id-based CSS rules to style the specific instance of this component uniquely, and also to
 select sub-elements using this component's id as the parent. Note: to avoid complications imposed by a unique id also
 see itemId and ref. Note: to access the container of an item see ownerCt.]]></description><name>id</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default CSS class to use for separators (defaults to "x-menu-sep")]]></description><name>itemCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An itemId can be used as an alternative way to get a reference to a component when no object reference is available.
 Instead of using an id with Ext.getCmp, use itemId with Ext.Container.getComponent which will retrieve itemId's or id's.
 Since itemId's are an index to the container's internal MixedCollection, the itemId is scoped locally to the container
 -- avoiding potential conflicts with Ext.ComponentMgr which requires a unique id. var c = new Ext.Panel({ //
     height:
 300,
     renderTo: document.body,
     layout: 'auto',
     items: [
         {
             itemId: 'p1',
            
 title: 'Panel 1',
             height: 150
         },
         {
             itemId: 'p2',
             title: 'Panel 2',
  
 height: 150
         }
     ]
 })
 p1 = c.getComponent('p1'); // not the same as Ext.getCmp()
 p2 =
 p1.ownerCt.getComponent('p2'); // reference via a sibling Also see id and ref. Note: to access the container of an item
 see ownerCt.]]></description><name>itemId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The separator to display after the text of each fieldLabel. This property may be configured at various levels. The order
 of precedence is: field / component level container level layout level (defaults to colon ':') To display no separator
 for this field's label specify empty string ''. Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 layoutConfig: {
         labelSeparator: '~'   // layout config has lowest priority (defaults to ':')
     },
    
 labelSeparator: '>>',     // config at container level
     items: [{
         xtype: 'textfield',
         fieldLabel:
 'Field 1',
         labelSeparator: '...' // field/component level config supersedes others
     },{
         xtype:
 'textfield',
         fieldLabel: 'Field 2' // labelSeparator will be '='
     }]
 });]]></description><name>labelSeparator</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS style specification string to apply directly to this field's label. Defaults to the container's labelStyle value
 if set (e.g., Ext.layout.FormLayout.labelStyle , or ''). Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         labelStyle: 'font-weight:bold;'
     }]
 });]]></description><name>labelStyle</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element when the mouse moves over the Element, and
 removed when the mouse moves out. (defaults to ''). This can be useful for adding customized 'active' or 'hover' styles
 to the component or any of its children using standard CSS rules.]]></description><name>overCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered ptype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a Plugin is being specified not as a fully
 instantiated Component, but as a Component config object. The ptype will be looked up at render time up to determine
 what type of Plugin to create. If you create your own Plugins, you may register them using
 Ext.ComponentMgr.registerPlugin in order to be able to take advantage of lazy instantiation and rendering.]]></description><name>ptype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A path specification, relative to the Component's ownerCt specifying into which ancestor Container to place a named
 reference to this Component. The ancestor axis can be traversed by using '/' characters in the path. For example, to put
 a reference to a Toolbar Button into the Panel which owns the Toolbar: var myGrid = new Ext.grid.EditorGridPanel({
    
 title: 'My EditorGridPanel',
     store: myStore,
     colModel: myColModel,
     tbar: [{
         text: 'Save',
        
 handler: saveChanges,
         disabled: true,
         ref: '../saveButton'
     }],
     listeners: {
         afteredit:
 function() {
 //          The button reference is in the GridPanel
             myGrid.saveButton.enable();
         }
    
 }
 }); In the code above, if the ref had been 'saveButton' the reference would have been placed into the Toolbar. Each
 '/' in the ref moves up one level from the Component's ownerCt. Also see the added and removed events.]]></description><name>ref</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The scope (this reference) in which the handler function will be called.]]></description><name>scope</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should trigger this component to save its state (defaults to none). stateEvents may
 be any type of event supported by this component, including browser or custom events (e.g., ['click',
 'customerchange']). See stateful for an explanation of saving and restoring Component state.]]></description><name>stateEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id for this component to use for state management purposes (defaults to the component id if one was set,
 otherwise null if the component is using a generated id). See stateful for an explanation of saving and restoring
 Component state.]]></description><name>stateId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A flag which causes the Component to attempt to restore the state of internal properties from a saved state on startup.
 The component must have either a stateId or id assigned for state to be managed. Auto-generated ids are not guaranteed
 to be stable across page loads and cannot be relied upon to save and restore the same state for a component. For state
 saving to work, the state manager's provider must have been set to an implementation of Ext.state.Provider which
 overrides the set and get methods to save and recall name/value pairs. A built-in implementation,
 Ext.state.CookieProvider is available. To set the state provider for the current page: Ext.state.Manager.setProvider(new
 Ext.state.CookieProvider({
     expires: new Date(new Date().getTime()+(1000*60*60*24*7)), //7 days from now
 })); A
 stateful Component attempts to save state when one of the events listed in the stateEvents configuration fires. To save
 state, a stateful Component first serializes its state by calling getState. By default, this function does nothing. The
 developer must provide an implementation which returns an object hash which represents the Component's restorable state.
 The value yielded by getState is passed to Ext.state.Manager.set which uses the configured Ext.state.Provider to save
 the object keyed by the Component's stateId, or, if that is not specified, its id. During construction, a stateful
 Component attempts to restore its state by calling Ext.state.Manager.get passing the stateId, or, if that is not
 specified, the id. The resulting object is passed to applyState. The default implementation of applyState simply copies
 properties into the object, but a developer may override this to support more behaviour. You can perform extra
 processing on state save and restore by attaching handlers to the beforestaterestore, staterestore, beforestatesave and
 statesave events.]]></description><name>stateful</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
     title: 'Some Title',
     renderTo: Ext.getBody(),
     width: 400, height:
 300,
     layout: 'form',
     items: [{
         xtype: 'textarea',
         style: {
             width: '95%',
            
 marginBottom: '10px'
         }
     },
         new Ext.Button({
             text: 'Send',
             minWidth: '100',
   
          style: {
                 marginBottom: '10px'
             }
         })
     ]
 });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered xtype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a child item of a Container is being specified not
 as a fully instantiated Component, but as a Component config object. The xtype will be looked up at render time up to
 determine what type of child Component to create. The predefined xtypes are listed here. If you subclass Components to
 create your own Components, you may register them using Ext.ComponentMgr.registerType in order to be able to take
 advantage of lazy instantiation and rendering.]]></description><name>xtype</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 Adds a static text string to a menu, usually used as either a heading or group separator.]]></description><name>menu.textItem</name><tag-class>org.brushingbits.jnap.ui.extjs3.menu.TextItem</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[The CSS class to use when the item becomes activated (defaults to "x-menu-item-active")]]></description><name>activeClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Whether the component can move the Dom node when rendering (defaults to true).]]></description><name>allowDomMove</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element corresponding to a DIV that is already present in
 the document that specifies some structural markup for this component. Description : When applyTo is used, constituent
 parts of the component can also be specified by id or CSS class name within the main element, and the component being
 created may attempt to create its subcomponents from that markup if applicable. Notes : When using this config, a call
 to render() is not required. If applyTo is specified, any value passed for renderTo will be ignored and the target
 element's parent node will automatically be used as the component's container.]]></description><name>applyTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A tag name or DomHelper spec used to create the Element which will encapsulate this Component. You do not normally need
 to specify this. For the base classes Ext.Component, Ext.BoxComponent, and Ext.Container, this defaults to 'div'. The
 more complex Ext classes use a more complex DOM structure created by their own onRender methods. This is intended to
 allow the developer to create application-specific utility Components encapsulated by different DOM elements. Example
 usage: <pre><code>{
     xtype: 'box',
     autoEl: {
         tag: 'img',
         src: 'http://www.example.com/example.jpg'
     }
 },
 {
     xtype: 'box',
     autoEl: {
         tag: 'blockquote',
         html: 'autoEl is cool!'
     }
 }, {
     xtype: 'container',
     autoEl: 'ul',
     cls: 'ux-unordered-list',
     items: {
         xtype: 'box',
         autoEl: 'li',
   
      html: 'First list item'
     }
 }</pre></code>]]></description><name>autoEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True if the component should check for hidden classes (e.g. 'x-hidden' or 'x-hide-display') and remove them on render
 (defaults to false).]]></description><name>autoShow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to [].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True if this item can be visually activated (defaults to false)]]></description><name>canActivate</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class used to to apply to the special clearing div rendered directly after each form field wrapper to provide
 field clearing (defaults to 'x-form-clear-left'). Note: this config is only used when this Component is rendered by a
 Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or specifying
 layout:'form') and either a fieldLabel is specified or isFormField=true is specified. See Ext.layout.FormLayout.fieldTpl
 also.]]></description><name>clearCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Length of time in milliseconds to wait before hiding after a click (defaults to 1)]]></description><name>clickHideDelay</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element (defaults to ''). This can be useful for
 adding customized styles to the component or any of its children using standard CSS rules.]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's container. This can be useful for adding customized
 styles to the container or any of its children using standard CSS rules. See Ext.layout.ContainerLayout.extraCls also.
 Note: ctCls defaults to '' except for the following class which assigns a value by default: Box Layout :
 'x-box-layout-ct' To configure the above Class with an extra CSS class append to the default. For example, for BoxLayout
 (Hbox and Vbox): ctCls: 'x-box-layout-ct custom-class']]></description><name>ctCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component disabled (default is false).]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class added to the component when it is disabled (defaults to 'x-item-disabled').]]></description><name>disabledClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The label text to display next to this Component (defaults to ''). Note: this config is only used when this Component is
 rendered by a Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or
 specifying layout:'form'). Also see hideLabel and Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
    
 height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name'
    
 }]
 });]]></description><name>fieldLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A function that will handle the click event of this menu item (optional). The handler is passed the following
 parameters: b : Item This menu Item. e : EventObject The click event.]]></description><name>handler</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component hidden (default is false). If true, the hide method will be called internally.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to completely hide the label element (label and separator). Defaults to false. By default, even if you do not
 specify a fieldLabel the space will still be reserved so that the field will line up with other fields that do have
 labels. Setting this to true will cause the field to not reserve that space. Note: see the note for clearCls. Example
 use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield'
        
 hideLabel: true
     }]
 });]]></description><name>hideLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[How this component should be hidden. Supported values are 'visibility' (css visibility), 'offsets' (negative offset
 position) and 'display' (css display). Note: the default of 'display' is generally preferred since items are
 automatically laid out when they are first shown (no sizing is done while hidden).]]></description><name>hideMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide the containing menu after this item is clicked (defaults to false)]]></description><name>hideOnClick</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide and show the component's container when hide/show is called on the component, false to hide and show the
 component itself (defaults to false). For example, this can be used as a shortcut for a hide button on a window by
 setting hide:true on the button when adding it to its parent container.]]></description><name>hideParent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id of this component (defaults to an auto-assigned id). You should assign an id if you need to be able to
 access the component later and you do not have an object reference available (e.g., using Ext.getCmp). Note that this id
 will also be used as the element id for the containing HTML element that is rendered to the page for this component.
 This allows you to write id-based CSS rules to style the specific instance of this component uniquely, and also to
 select sub-elements using this component's id as the parent. Note: to avoid complications imposed by a unique id also
 see itemId and ref. Note: to access the container of an item see ownerCt.]]></description><name>id</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default CSS class to use for text items (defaults to "x-menu-text")]]></description><name>itemCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An itemId can be used as an alternative way to get a reference to a component when no object reference is available.
 Instead of using an id with Ext.getCmp, use itemId with Ext.Container.getComponent which will retrieve itemId's or id's.
 Since itemId's are an index to the container's internal MixedCollection, the itemId is scoped locally to the container
 -- avoiding potential conflicts with Ext.ComponentMgr which requires a unique id. var c = new Ext.Panel({ //
     height:
 300,
     renderTo: document.body,
     layout: 'auto',
     items: [
         {
             itemId: 'p1',
            
 title: 'Panel 1',
             height: 150
         },
         {
             itemId: 'p2',
             title: 'Panel 2',
  
 height: 150
         }
     ]
 })
 p1 = c.getComponent('p1'); // not the same as Ext.getCmp()
 p2 =
 p1.ownerCt.getComponent('p2'); // reference via a sibling Also see id and ref. Note: to access the container of an item
 see ownerCt.]]></description><name>itemId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The separator to display after the text of each fieldLabel. This property may be configured at various levels. The order
 of precedence is: field / component level container level layout level (defaults to colon ':') To display no separator
 for this field's label specify empty string ''. Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 layoutConfig: {
         labelSeparator: '~'   // layout config has lowest priority (defaults to ':')
     },
    
 labelSeparator: '>>',     // config at container level
     items: [{
         xtype: 'textfield',
         fieldLabel:
 'Field 1',
         labelSeparator: '...' // field/component level config supersedes others
     },{
         xtype:
 'textfield',
         fieldLabel: 'Field 2' // labelSeparator will be '='
     }]
 });]]></description><name>labelSeparator</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS style specification string to apply directly to this field's label. Defaults to the container's labelStyle value
 if set (e.g., Ext.layout.FormLayout.labelStyle , or ''). Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         labelStyle: 'font-weight:bold;'
     }]
 });]]></description><name>labelStyle</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element when the mouse moves over the Element, and
 removed when the mouse moves out. (defaults to ''). This can be useful for adding customized 'active' or 'hover' styles
 to the component or any of its children using standard CSS rules.]]></description><name>overCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered ptype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a Plugin is being specified not as a fully
 instantiated Component, but as a Component config object. The ptype will be looked up at render time up to determine
 what type of Plugin to create. If you create your own Plugins, you may register them using
 Ext.ComponentMgr.registerPlugin in order to be able to take advantage of lazy instantiation and rendering.]]></description><name>ptype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A path specification, relative to the Component's ownerCt specifying into which ancestor Container to place a named
 reference to this Component. The ancestor axis can be traversed by using '/' characters in the path. For example, to put
 a reference to a Toolbar Button into the Panel which owns the Toolbar: var myGrid = new Ext.grid.EditorGridPanel({
    
 title: 'My EditorGridPanel',
     store: myStore,
     colModel: myColModel,
     tbar: [{
         text: 'Save',
        
 handler: saveChanges,
         disabled: true,
         ref: '../saveButton'
     }],
     listeners: {
         afteredit:
 function() {
 //          The button reference is in the GridPanel
             myGrid.saveButton.enable();
         }
    
 }
 }); In the code above, if the ref had been 'saveButton' the reference would have been placed into the Toolbar. Each
 '/' in the ref moves up one level from the Component's ownerCt. Also see the added and removed events.]]></description><name>ref</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The scope (this reference) in which the handler function will be called.]]></description><name>scope</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should trigger this component to save its state (defaults to none). stateEvents may
 be any type of event supported by this component, including browser or custom events (e.g., ['click',
 'customerchange']). See stateful for an explanation of saving and restoring Component state.]]></description><name>stateEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id for this component to use for state management purposes (defaults to the component id if one was set,
 otherwise null if the component is using a generated id). See stateful for an explanation of saving and restoring
 Component state.]]></description><name>stateId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A flag which causes the Component to attempt to restore the state of internal properties from a saved state on startup.
 The component must have either a stateId or id assigned for state to be managed. Auto-generated ids are not guaranteed
 to be stable across page loads and cannot be relied upon to save and restore the same state for a component. For state
 saving to work, the state manager's provider must have been set to an implementation of Ext.state.Provider which
 overrides the set and get methods to save and recall name/value pairs. A built-in implementation,
 Ext.state.CookieProvider is available. To set the state provider for the current page: Ext.state.Manager.setProvider(new
 Ext.state.CookieProvider({
     expires: new Date(new Date().getTime()+(1000*60*60*24*7)), //7 days from now
 })); A
 stateful Component attempts to save state when one of the events listed in the stateEvents configuration fires. To save
 state, a stateful Component first serializes its state by calling getState. By default, this function does nothing. The
 developer must provide an implementation which returns an object hash which represents the Component's restorable state.
 The value yielded by getState is passed to Ext.state.Manager.set which uses the configured Ext.state.Provider to save
 the object keyed by the Component's stateId, or, if that is not specified, its id. During construction, a stateful
 Component attempts to restore its state by calling Ext.state.Manager.get passing the stateId, or, if that is not
 specified, the id. The resulting object is passed to applyState. The default implementation of applyState simply copies
 properties into the object, but a developer may override this to support more behaviour. You can perform extra
 processing on state save and restore by attaching handlers to the beforestaterestore, staterestore, beforestatesave and
 statesave events.]]></description><name>stateful</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
     title: 'Some Title',
     renderTo: Ext.getBody(),
     width: 400, height:
 300,
     layout: 'form',
     items: [{
         xtype: 'textarea',
         style: {
             width: '95%',
            
 marginBottom: '10px'
         }
     },
         new Ext.Button({
             text: 'Send',
             minWidth: '100',
   
          style: {
                 marginBottom: '10px'
             }
         })
     ]
 });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The text to display for this item (defaults to '')]]></description><name>text</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered xtype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a child item of a Container is being specified not
 as a fully instantiated Component, but as a Component config object. The xtype will be looked up at render time up to
 determine what type of child Component to create. The predefined xtypes are listed here. If you subclass Components to
 create your own Components, you may register them using Ext.ComponentMgr.registerType in order to be able to take
 advantage of lazy instantiation and rendering.]]></description><name>xtype</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 <p>Panel is a container that has specific functionality and structural components that make it the perfect building
 block for application-oriented user interfaces.</p> 
 <p>Panels are, by virtue of their inheritance from <a
 href="output/Ext.Container.html" ext:cls="Ext.Container">Ext.Container</a>, capable of being configured with a <a
 href="output/Ext.Container.html#Ext.Container-layout" ext:member="layout" ext:cls="Ext.Container">layout</a>, and
 containing child Components.</p> 
 <p>When either specifying child <a
 href="output/Ext.Component.html#Ext.Component-items" ext:member="items" ext:cls="Ext.Component">items</a> of a Panel, or
 dynamically <a href="output/Ext.Container.html#Ext.Container-add" ext:member="add" ext:cls="Ext.Container">adding</a>
 Components to a Panel, remember to consider how you wish the Panel to arrange those child elements, and whether those
 child elements need to be sized using one of Ext's built-in <code><b><a
 href="output/Ext.Container.html#Ext.Container-layout" ext:member="layout" ext:cls="Ext.Container">layout</a></b></code>
 schemes. By default, Panels use the <a href="output/Ext.layout.ContainerLayout.html"
 ext:cls="Ext.layout.ContainerLayout">ContainerLayout</a> scheme. This simply renders child components, appending them
 one after the other inside the Container, and <b>does not apply any sizing</b> at all.</p> 
 <p>A Panel may also contain
 <a href="output/Ext.Panel.html#Ext.Panel-bbar" ext:member="bbar" ext:cls="Ext.Panel">bottom</a> and <a
 href="output/Ext.Panel.html#Ext.Panel-tbar" ext:member="tbar" ext:cls="Ext.Panel">top</a> toolbars, along with separate
 <a href="output/Ext.Panel.html#Ext.Panel-header" ext:member="header" ext:cls="Ext.Panel">header</a>, <a
 href="output/Ext.Panel.html#Ext.Panel-footer" ext:member="footer" ext:cls="Ext.Panel">footer</a> and <a
 href="output/Ext.Panel.html#Ext.Panel-body" ext:member="body" ext:cls="Ext.Panel">body</a> sections (see <a
 href="output/Ext.Panel.html#Ext.Panel-frame" ext:member="frame" ext:cls="Ext.Panel">frame</a> for additional
 information).</p> 
 <p>Panel also provides built-in <a href="output/Ext.Panel.html#Ext.Panel-collapsible"
 ext:member="collapsible" ext:cls="Ext.Panel">expandable and collapsible behavior</a>, along with a variety of <a
 href="output/Ext.Panel.html#Ext.Panel-tools" ext:member="tools" ext:cls="Ext.Panel">prebuilt tool buttons</a> that can
 be wired up to provide other customized behavior. Panels can be easily dropped into any <a
 href="output/Ext.Container.html" ext:cls="Ext.Container">Container</a> or layout, and the layout and rendering pipeline
 is <a href="output/Ext.Container.html#Ext.Container-add" ext:member="add" ext:cls="Ext.Container">completely managed by
 the framework</a>.</p>]]></description><name>panel</name><tag-class>org.brushingbits.jnap.ui.extjs3.Panel</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[A string component id or the numeric index of the component that should be initially activated within the container's
 layout on render. For example, activeItem: 'item-1' or activeItem: 0 (index 0 = the first item in the container's
 collection). activeItem only applies to layout styles that can display items one at a time (like
 Ext.layout.AccordionLayout, Ext.layout.CardLayout and Ext.layout.FitLayout). Related to
 Ext.layout.ContainerLayout.activeItem.]]></description><name>activeItem</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Whether the component can move the Dom node when rendering (defaults to true).]]></description><name>allowDomMove</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use an
 AnchorLayout (or subclass thereof). based layout manager, for example: Ext.form.FormPanel specifying layout: 'anchor' //
 or 'form', or 'absolute' See Ext.layout.AnchorLayout.anchor also.]]></description><name>anchor</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to animate the transition when the panel is collapsed, false to skip the animation (defaults to true if the Ext.Fx
 class is available, otherwise false).]]></description><name>animCollapse</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The id of the node, a DOM node or an existing Element corresponding to a DIV that is already present in the document
 that specifies some panel-specific structural markup. When applyTo is used, constituent parts of the panel can be
 specified by CSS class name within the main element, and the panel will automatically create those components from that
 markup. Any required components not specified in the markup will be autogenerated if necessary. The following class
 names are supported (baseCls will be replaced by baseCls): baseCls + '-header' baseCls + '-header-text' baseCls +
 '-bwrap' baseCls + '-tbar' baseCls + '-body' baseCls + '-bbar' baseCls + '-footer' Using this config, a call to render()
 is not required. If applyTo is specified, any value passed for renderTo will be ignored and the target element's parent
 node will automatically be used as the panel's container.]]></description><name>applyTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If true the container will automatically destroy any contained component that is removed from it, else destruction must
 be handled manually (defaults to true).]]></description><name>autoDestroy</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A tag name or DomHelper spec used to create the Element which will encapsulate this Component. You do not normally need
 to specify this. For the base classes Ext.Component, Ext.BoxComponent, and Ext.Container, this defaults to 'div'. The
 more complex Ext classes use a more complex DOM structure created by their own onRender methods. This is intended to
 allow the developer to create application-specific utility Components encapsulated by different DOM elements. Example
 usage: <pre><code>{
     xtype: 'box',
     autoEl: {
         tag: 'img',
         src: 'http://www.example.com/example.jpg'
     }
 },
 {
     xtype: 'box',
     autoEl: {
         tag: 'blockquote',
         html: 'autoEl is cool!'
     }
 }, {
     xtype: 'container',
     autoEl: 'ul',
     cls: 'ux-unordered-list',
     items: {
         xtype: 'box',
         autoEl: 'li',
   
      html: 'First list item'
     }
 }</pre></code>]]></description><name>autoEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to use height:'auto', false to use fixed height (defaults to false). Note: Setting autoHeight: true means that the
 browser will manage the panel's height based on its contents, and that Ext will not manage it at all. If the panel is
 within a layout that manages dimensions (fit, border, etc.) then setting autoHeight: true can cause issues with
 scrolling and will not generally work as expected since the panel will take on the height of its contents rather than
 the height required by the Ext layout.]]></description><name>autoHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A valid url spec according to the Updater Ext.Updater.update method. If autoLoad is not null, the panel will attempt to
 load its contents immediately upon render. The URL will become the default URL for this panel's body element, so it may
 be refreshed at any time.]]></description><name>autoLoad</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to use overflow:'auto' on the components layout element and show scroll bars automatically when necessary, false to
 clip any overflowing content (defaults to false).]]></description><name>autoScroll</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True if the component should check for hidden classes (e.g. 'x-hidden' or 'x-hide-display') and remove them on render
 (defaults to false).]]></description><name>autoShow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to use width:'auto', false to use fixed width (or allow it to be managed by its parent Container's layout manager.
 Defaults to false. Note: Although many components inherit this config option, not all will function as expected with a
 width of 'auto'. Setting autoWidth:true means that the browser will manage width based on the element's contents, and
 that Ext will not manage it at all. If the browser is managing the width, be aware that resizes performed by the browser
 in response to changes within the structure of the Component cannot be detected. Therefore changes to the width might
 result in elements needing to be synchronized with the new width. For example, where the target element is: <div
 id='grid-container' style='margin-left:25%;width:50%'></div> A Panel rendered into that target element must listen for
 browser window resize in order to relay its child items when the browser changes its width: var myPanel = new
 Ext.Panel({
     renderTo: 'grid-container',
     monitorResize: true, // relay on browser resize
     title: 'Panel',
    
 height: 400,
     autoWidth: true,
     layout: 'hbox',
     layoutConfig: {
         align: 'stretch'
     },
     defaults: {
         flex: 1
     },
     items: [{
         title: 'Box 1',
     }, {
         title: 'Box 2'
     }, {
         title:
 'Box 3'
     }],
 });]]></description><name>autoWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The base CSS class to apply to this panel's element (defaults to 'x-panel'). Another option available by default is to
 specify 'x-plain' which strips all styling except for required attributes for Ext layouts to function (e.g.
 overflow:hidden). See unstyled also.]]></description><name>baseCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to display an interior border on the body element of the panel, false to hide it (defaults to true). This only
 applies when border == true. If border == true and bodyBorder == false, the border will display as a 1px wide inset
 border, giving the entire body element an inset appearance.]]></description><name>bodyBorder</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A DomHelper element specification object may be specified for any Panel Element. By default, the Default element in the
 table below will be used for the html markup to create a child element with the commensurate Default class name (baseCls
 will be replaced by baseCls): 
 Panel      Default  Default             Custom      Additional       Additional
 Element  
 element  class               element     class            style
 ========   ==========================   =========  
 ==============   ===========
 header     div      baseCls+'-header'   headerCfg   headerCssClass   headerStyle
 bwrap     
 div      baseCls+'-bwrap'     bwrapCfg    bwrapCssClass    bwrapStyle
 + tbar     div      baseCls+'-tbar'       tbarCfg 
 tbarCssClass     tbarStyle
 + body     div      baseCls+'-body'       bodyCfg     bodyCssClass     bodyStyle
 + bbar    
 div      baseCls+'-bbar'       bbarCfg     bbarCssClass     bbarStyle
 + footer   div      baseCls+'-footer'   footerCfg 
 footerCssClass   footerStyle
  Configuring a Custom element may be used, for example, to force the body Element to use a
 different form of markup than is created by default. An example of this might be to create a child Panel containing a
 custom content, such as a header, or forcing centering of all Panel content by having the body be a <center> element:
 new Ext.Panel({
     title: 'Message Title',
     renderTo: Ext.getBody(),
     width: 200, height: 130,
     bodyCfg: {
    
 tag: 'center',
         cls: 'x-panel-body',  // Default class not applied if Custom element specified
         html:
 'Message'
     },
     footerCfg: {
         tag: 'h2',
         cls: 'x-panel-footer',        // same as the Default class
 
 html: 'footer html'
     },
     footerCssClass: 'custom-footer', // additional css class, see addClass
     footerStyle:  
 'background-color:red' // see bodyStyle
 }); The example above also explicitly creates a footer with custom markup and
 styling applied.]]></description><name>bodyCfg</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Additional css class selector to be applied to the body element in the format expected by Ext.Element.addClass (defaults
 to null). See bodyCfg.]]></description><name>bodyCssClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Custom CSS styles to be applied to the body element in the format expected by Ext.Element.applyStyles (defaults to
 null). See bodyCfg.]]></description><name>bodyStyle</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to display the borders of the panel's body element, false to hide them (defaults to true). By default, the border
 is a 2px wide inset border, but this can be further altered by setting bodyBorder to false.]]></description><name>border</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to ['add', 'remove'].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[When set to true (50 milliseconds) or a number of milliseconds, the layout assigned for this container will buffer the
 frequency it calculates and does a re-layout of components. This is useful for heavy containers or containers with a
 large quantity of sub-components for which frequent layout calls would be expensive. Defaults to 50.]]></description><name>bufferResize</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The alignment of any buttons added to this panel. Valid values are 'right', 'left' and 'center' (defaults to 'right').]]></description><name>buttonAlign</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A DomHelper element specification object specifying the element structure of this Panel's bwrap Element. See bodyCfg
 also.]]></description><name>bwrapCfg</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class used to to apply to the special clearing div rendered directly after each form field wrapper to provide
 field clearing (defaults to 'x-form-clear-left'). Note: this config is only used when this Component is rendered by a
 Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or specifying
 layout:'form') and either a fieldLabel is specified or isFormField=true is specified. See Ext.layout.FormLayout.fieldTpl
 also.]]></description><name>clearCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Panels themselves do not directly support being closed, but some Panel subclasses do (like Ext.Window) or a Panel Class
 within an Ext.TabPanel. Specify true to enable closing in such situations. Defaults to false.]]></description><name>closable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element (defaults to ''). This can be useful for
 adding customized styles to the component or any of its children using standard CSS rules.]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to make sure the collapse/expand toggle button always renders first (to the left of) any other tools in the panel's
 title bar, false to render it last (defaults to true).]]></description><name>collapseFirst</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to render the panel collapsed, false to render it expanded (defaults to false).]]></description><name>collapsed</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS class to add to the panel's element after it has been collapsed (defaults to 'x-panel-collapsed').]]></description><name>collapsedCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to make the panel collapsible and have the expand/collapse toggle button automatically rendered into the header
 tool button area, false to keep the panel statically sized with no button (defaults to false).]]></description><name>collapsible</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's container. This can be useful for adding customized
 styles to the container or any of its children using standard CSS rules. See Ext.layout.ContainerLayout.extraCls also.
 Note: ctCls defaults to '' except for the following class which assigns a value by default: Box Layout :
 'x-box-layout-ct' To configure the above Class with an extra CSS class append to the default. For example, for BoxLayout
 (Hbox and Vbox): ctCls: 'x-box-layout-ct custom-class']]></description><name>ctCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default xtype of child Components to create in this Container when a child item is specified as a raw configuration
 object, rather than as an instantiated Component. Defaults to 'panel', except Ext.menu.Menu which defaults to
 'menuitem', and Ext.Toolbar and Ext.ButtonGroup which default to 'button'.]]></description><name>defaultType</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[This option is a means of applying default settings to all added items whether added through the items config or via the
 add or insert methods. If an added item is a config object, and not an instantiated Component, then the default
 properties are unconditionally applied. If the added item is an instantiated Component, then the default properties are
 applied conditionally so as not to override existing properties in the item. If the defaults option is specified as a
 function, then the function will be called using this Container as the scope (this reference) and passing the added item
 as the first parameter. Any resulting object from that call is then applied to the item as default properties. For
 example, to automatically apply padding to the body of each of a set of contained Ext.Panel items, you could pass:
 defaults: {bodyStyle:'padding:15px'}. Usage: defaults: {               // defaults are applied to items, not the
 container
     autoScroll:true
 },
 items: [
     {
         xtype: 'panel',   // defaults do not have precedence over
       
 id: 'panel1',     // options in config objects, so the defaults
         autoScroll: false // will not be applied here,
 panel1 will be autoScroll:false
     },
     new Ext.Panel({       // defaults do have precedence over options
         id:
 'panel2',     // options in components, so the defaults
         autoScroll: false // will be applied here, panel2 will
 be autoScroll:true.
     })
 ]]]></description><name>defaults</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this panel disabled (default is false). An important note when using the disabled config on panels is that IE
 will often fail to initialize the disabled mask element correectly if the panel's layout has not yet completed by the
 time the Panel is disabled during the render process. If you experience this issue, you may need to instead use the
 afterlayout event to initialize the disabled state: new Ext.Panel({
     ...
     listeners: {
         'afterlayout': {
   
 fn: function(p){
                 p.disable();
             },
             single: true // important, as many layouts can
 occur
         }
     }
 });]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class added to the component when it is disabled (defaults to 'x-item-disabled').]]></description><name>disabledClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to enable dragging of this Panel (defaults to false). For custom drag/drop implementations, an Ext.Panel.DD config
 could also be passed in this config instead of true. Ext.Panel.DD is an internal, undocumented class which moves a proxy
 Element around in place of the Panel's element, but provides no other behaviour during dragging or on drop. It is a
 subclass of Ext.dd.DragSource, so behaviour may be added by implementing the interface methods of Ext.dd.DragDrop e.g.:
 new Ext.Panel({
     title: 'Drag me',
     x: 100,
     y: 100,
     renderTo: Ext.getBody(),
     floating: true,
    
 frame: true,
     width: 400,
     height: 200,
     draggable: {
 //      Config option of Ext.Panel.DD class.
 //      It's
 a floating Panel, so do not show a placeholder proxy in the original position.
         insertProxy: false,
 
 //     
 Called for each mousemove event while dragging the DD object.
         onDrag : function(e){
 //          Record the x,y
 position of the drag proxy so that we can
 //          position the Panel at end of drag.
             var pel =
 this.proxy.getEl();
             this.x = pel.getLeft(true);
             this.y = pel.getTop(true);
 
 //          Keep the
 Shadow aligned if there is one.
             var s = this.panel.getEl().shadow;
             if (s) {
                
 s.realign(this.x, this.y, pel.getWidth(), pel.getHeight());
             }
         },
 
 //      Called on the mouseup
 event.
         endDrag : function(e){
             this.panel.setPosition(this.x, this.y);
         }
     }
 }).show();]]></description><name>draggable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A comma-delimited list of panel elements to initialize when the panel is rendered. Normally, this list will be generated
 automatically based on the items added to the panel at config time, but sometimes it might be useful to make sure a
 structural element is rendered even if not specified at config time (for example, you may want to add a button or
 toolbar dynamically after the panel has been rendered). Adding those elements to this list will allocate the required
 placeholders in the panel when it is rendered. Valid values are header tbar (top bar) body bbar (bottom bar) footer
 Defaults to 'body'.]]></description><name>elements</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A Toolbar object, a Toolbar config, or an array of Buttons/Button configs, describing a Toolbar to be rendered into this
 Panel's footer element. After render, the fbar property will be an Toolbar instance. If buttons are specified, they will
 supersede the fbar configuration property. The Panel's buttonAlign configuration affects the layout of these items, for
 example: var w = new Ext.Window({
     height: 250,
     width: 500,
     bbar: new Ext.Toolbar({
         items: [{
        
 text: 'bbar Left'
         },'->',{
             text: 'bbar Right'
         }]
     }),
     buttonAlign: 'left', //
 anything but 'center' or 'right' and you can use '-', and '->'
                                   // to control the
 alignment of fbar items
     fbar: [{
         text: 'fbar Left'
     },'->',{
         text: 'fbar Right'
     }]
 }).show();
 Note: Although a Toolbar may contain Field components, these will not be updated by a load of an ancestor FormPanel. A
 Panel's toolbars are not part of the standard Container->Component hierarchy, and so are not scanned to collect form
 items. However, the values will be submitted because form submission parameters are collected from the DOM tree.]]></description><name>fbar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The label text to display next to this Component (defaults to ''). Note: this config is only used when this Component is
 rendered by a Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or
 specifying layout:'form'). Also see hideLabel and Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
    
 height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name'
    
 }]
 });]]></description><name>fieldLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use a
 BoxLayout. Each child Component with a flex property will be flexed either vertically (by a VBoxLayout) or horizontally
 (by an HBoxLayout) according to the item's relative flex value compared to the sum of all Components with flex value
 specified. Any child items that have either a flex = 0 or flex = undefined will not be 'flexed' (the initial size will
 not be changed).]]></description><name>flex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[This property is used to configure the underlying Ext.Layer. Acceptable values for this configuration property are:
 false : Default. Display the panel inline where it is rendered. true : Float the panel (absolute position it with
 automatic shimming and shadow). Setting floating to true will create an Ext.Layer for this panel and display the panel
 at negative offsets so that it is hidden. Since the panel will be absolute positioned, the position must be set
 explicitly after render (e.g., myPanel.setPosition(100,100);). Note: when floating a panel you should always assign a
 fixed width, otherwise it will be auto width and will expand to fill to the right edge of the viewport. object : The
 specified object will be used as the configuration object for the Ext.Layer that will be created.]]></description><name>floating</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to create the footer element explicitly, false to skip creating it. The footer will be created automatically if
 buttons or a fbar have been configured. See bodyCfg for an example.]]></description><name>footer</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A DomHelper element specification object specifying the element structure of this Panel's footer Element. See bodyCfg
 also.]]></description><name>footerCfg</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If true the container will force a layout initially even if hidden or collapsed. This option is useful for forcing forms
 to render in collapsed or hidden containers. (defaults to false).]]></description><name>forceLayout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[false by default to render with plain 1px square borders. true to render with 9 elements, complete with custom rounded
 corners (also see Ext.Element.boxWrap). The template generated for each condition is depicted below: // frame =
 false
 <div id="developer-specified-id-goes-here" class="x-panel">
 
     <div class="x-panel-header"><span
 class="x-panel-header-text">Title: (frame:false)</span></div>
 
     <div class="x-panel-bwrap">
         <div
 class="x-panel-body"><p>html value goes here</p></div>
     </div>
 </div>
 
 // frame = true (create 9 elements)
 <div
 id="developer-specified-id-goes-here" class="x-panel">
     <div class="x-panel-tl"><div class="x-panel-tr"><div
 class="x-panel-tc">
         <div class="x-panel-header"><span class="x-panel-header-text">Title:
 (frame:true)</span></div>
     </div></div></div>
 
     <div class="x-panel-bwrap">
         <div class="x-panel-ml"><div
 class="x-panel-mr"><div class="x-panel-mc">
             <div class="x-panel-body"><p>html value goes here</p></div>
     
 </div></div></div>
 
         <div class="x-panel-bl"><div class="x-panel-br"><div class="x-panel-bc"/>
        
 </div></div></div>
 </div>]]></description><name>frame</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to create the Panel's header element explicitly, false to skip creating it. If a title is set the header will be
 created automatically, otherwise it will not. If a title is set but header is explicitly set to false, the header will
 not be rendered.]]></description><name>header</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to display the panel title in the header, false to hide it (defaults to true).]]></description><name>headerAsText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A DomHelper element specification object specifying the element structure of this Panel's header Element. See bodyCfg
 also.]]></description><name>headerCfg</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component hidden (default is false). If true, the hide method will be called internally.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide the borders of each contained component, false to defer to the component's existing border settings
 (defaults to false).]]></description><name>hideBorders</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to hide the expand/collapse toggle button when collapsible == true, false to display it (defaults to false).]]></description><name>hideCollapseTool</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to completely hide the label element (label and separator). Defaults to false. By default, even if you do not
 specify a fieldLabel the space will still be reserved so that the field will line up with other fields that do have
 labels. Setting this to true will cause the field to not reserve that space. Note: see the note for clearCls. Example
 use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield'
        
 hideLabel: true
     }]
 });]]></description><name>hideLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[How this component should be hidden. Supported values are 'visibility' (css visibility), 'offsets' (negative offset
 position) and 'display' (css display). Note: the default of 'display' is generally preferred since items are
 automatically laid out when they are first shown (no sizing is done while hidden).]]></description><name>hideMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide and show the component's container when hide/show is called on the component, false to hide and show the
 component itself (defaults to false). For example, this can be used as a shortcut for a hide button on a window by
 setting hide:true on the button when adding it to its parent container.]]></description><name>hideParent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class selector that specifies a background image to be used as the header icon (defaults to ''). An example of
 specifying a custom icon class would be something like: // specify the property in the config for the class:
      ...
   
 iconCls: 'my-icon'
 
 // css class that specifies background image to be used as the icon image:
 .my-icon {
 background-image: url(../images/my-icon.gif) 0 6px no-repeat !important; }]]></description><name>iconCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id of this component (defaults to an auto-assigned id). You should assign an id if you need to be able to
 access the component later and you do not have an object reference available (e.g., using Ext.getCmp). Note that this id
 will also be used as the element id for the containing HTML element that is rendered to the page for this component.
 This allows you to write id-based CSS rules to style the specific instance of this component uniquely, and also to
 select sub-elements using this component's id as the parent. Note: to avoid complications imposed by a unique id also
 see itemId and ref. Note: to access the container of an item see ownerCt.]]></description><name>id</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use the
 FormLayout layout manager (e.g. Ext.form.FormPanel or specifying layout:'form'). An additional CSS class to apply to the
 div wrapping the form item element of this field. If supplied, itemCls at the field level will override the default
 itemCls supplied at the container level. The value specified for itemCls will be added to the default class
 ('x-form-item'). Since it is applied to the item wrapper (see Ext.layout.FormLayout.fieldTpl), it allows you to write
 standard CSS rules that can apply to the field, the label (if specified), or any other element within the markup for the
 field. Note: see the note for fieldLabel. Example use: // Apply a style to the field's label:
 <style>
     .required
 .x-form-item-label {font-weight:bold;color:red;}
 </style>
 
 new Ext.FormPanel({
     height: 100,
     renderTo:
 Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         itemCls: 'required' //this
 label will be styled
     },{
         xtype: 'textfield',
         fieldLabel: 'Favorite Color'
     }]
 });]]></description><name>itemCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An itemId can be used as an alternative way to get a reference to a component when no object reference is available.
 Instead of using an id with Ext.getCmp, use itemId with Ext.Container.getComponent which will retrieve itemId's or id's.
 Since itemId's are an index to the container's internal MixedCollection, the itemId is scoped locally to the container
 -- avoiding potential conflicts with Ext.ComponentMgr which requires a unique id. var c = new Ext.Panel({ //
     height:
 300,
     renderTo: document.body,
     layout: 'auto',
     items: [
         {
             itemId: 'p1',
            
 title: 'Panel 1',
             height: 150
         },
         {
             itemId: 'p2',
             title: 'Panel 2',
  
 height: 150
         }
     ]
 })
 p1 = c.getComponent('p1'); // not the same as Ext.getCmp()
 p2 =
 p1.ownerCt.getComponent('p2'); // reference via a sibling Also see id and ref. Note: to access the container of an item
 see ownerCt.]]></description><name>itemId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A Ext.KeyMap config object (in the format expected by Ext.KeyMap.addBinding used to assign custom key handling to this
 panel (defaults to null).]]></description><name>keys</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The separator to display after the text of each fieldLabel. This property may be configured at various levels. The order
 of precedence is: field / component level container level layout level (defaults to colon ':') To display no separator
 for this field's label specify empty string ''. Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 layoutConfig: {
         labelSeparator: '~'   // layout config has lowest priority (defaults to ':')
     },
    
 labelSeparator: '>>',     // config at container level
     items: [{
         xtype: 'textfield',
         fieldLabel:
 'Field 1',
         labelSeparator: '...' // field/component level config supersedes others
     },{
         xtype:
 'textfield',
         fieldLabel: 'Field 2' // labelSeparator will be '='
     }]
 });]]></description><name>labelSeparator</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS style specification string to apply directly to this field's label. Defaults to the container's labelStyle value
 if set (e.g., Ext.layout.FormLayout.labelStyle , or ''). Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         labelStyle: 'font-weight:bold;'
     }]
 });]]></description><name>labelStyle</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[*Important: In order for child items to be correctly sized and positioned, typically a layout manager must be specified
 through the layout configuration option. The sizing and positioning of child items is the responsibility of the
 Container's layout manager which creates and manages the type of layout you have in mind. For example:
 <pre><code>
 new Ext.Window({
 
 width:300, height: 300,
     layout: 'fit', // explicitly set layout manager: override the default (layout:'auto')
    
 items: [{
         title: 'Panel inside a Window'
     }]
 }).show();</pre></code>
 If the layout configuration is not explicitly
 specified for a general purpose container (e.g. Container or Panel) the default layout manager will be used which does
 nothing but render child components sequentially into the Container (no sizing or positioning will be performed in this
 situation). Some container classes implicitly specify a default layout (e.g. FormPanel specifies layout:'form'). Other
 specific purpose classes internally specify/manage their internal layout (e.g. GridPanel, TabPanel, TreePanel, Toolbar,
 Menu, etc.). layout may be specified as either as an Object or as a String: Specify as an Object Example usage: layout:
 {
     type: 'vbox',
     padding: '5',
     align: 'left'
 } type The layout type to be used for this container. If not
 specified, a default Ext.layout.ContainerLayout will be created and used. Valid layout type values are: absolute
 accordion anchor auto Default border card column fit form hbox menu table toolbar vbox Layout specific configuration
 properties Additional layout specific configuration properties may also be specified. For complete details regarding the
 valid config options for each layout type, see the layout class corresponding to the type specified. Specify as a String
 Example usage: layout: 'vbox',
 layoutConfig: {
     padding: '5',
     align: 'left'
 } layout The layout type to be used
 for this container (see list of valid layout type values above). layoutConfig Additional layout specific configuration
 properties. For complete details regarding the valid config options for each layout type, see the layout class
 corresponding to the layout specified.]]></description><name>layout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout or one of the two BoxLayout subclasses. An object containing margins to apply to this BoxComponent in the
 format: {
     top: (top margin),
     right: (right margin),
     bottom: (bottom margin),
     left: (left margin)
 } May
 also be a string containing space-separated, numeric margin values. The order of the sides associated with each value
 matches the way CSS processes margin values: If there is only one value, it applies to all sides. If there are two
 values, the top and bottom borders are set to the first value and the right and left are set to the second. If there are
 three values, the top is set to the first value, the left and right are set to the second, and the bottom is set to the
 third. If there are four values, they apply to the top, right, bottom, and left, respectively. Defaults to: {top:0,
 right:0, bottom:0, left:0}]]></description><name>margins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to mask the panel when it is disabled, false to not mask it (defaults to true). Either way, the panel will always
 tell its contained elements to disable themselves when it is disabled, but masking the panel can provide an additional
 visual cue that the panel is disabled.]]></description><name>maskDisabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Minimum width in pixels of all buttons in this panel (defaults to 75)]]></description><name>minButtonWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically monitor window resize events to handle anything that is sensitive to the current size of the
 viewport. This value is typically managed by the chosen layout and should not need to be set manually.]]></description><name>monitorResize</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element when the mouse moves over the Element, and
 removed when the mouse moves out. (defaults to ''). This can be useful for adding customized 'active' or 'hover' styles
 to the component or any of its children using standard CSS rules.]]></description><name>overCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A shortcut for setting a padding style on the body element. The value can either be a number to be applied to all sides,
 or a normal css string describing padding. Defaults to undefined.]]></description><name>padding</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level x coordinate for this component if contained within a positioning container.]]></description><name>pageX</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level y coordinate for this component if contained within a positioning container.]]></description><name>pageY</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to false. When set to true, an extra css class 'x-panel-normal' will be added to the panel's element,
 effectively applying css styles suggested by the W3C (see http://www.w3.org/TR/CSS21/sample.html) to the Panel's body
 element (not the header, footer, etc.).]]></description><name>preventBodyReset</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered ptype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a Plugin is being specified not as a fully
 instantiated Component, but as a Component config object. The ptype will be looked up at render time up to determine
 what type of Plugin to create. If you create your own Plugins, you may register them using
 Ext.ComponentMgr.registerPlugin in order to be able to take advantage of lazy instantiation and rendering.]]></description><name>ptype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A path specification, relative to the Component's ownerCt specifying into which ancestor Container to place a named
 reference to this Component. The ancestor axis can be traversed by using '/' characters in the path. For example, to put
 a reference to a Toolbar Button into the Panel which owns the Toolbar: var myGrid = new Ext.grid.EditorGridPanel({
    
 title: 'My EditorGridPanel',
     store: myStore,
     colModel: myColModel,
     tbar: [{
         text: 'Save',
        
 handler: saveChanges,
         disabled: true,
         ref: '../saveButton'
     }],
     listeners: {
         afteredit:
 function() {
 //          The button reference is in the GridPanel
             myGrid.saveButton.enable();
         }
    
 }
 }); In the code above, if the ref had been 'saveButton' the reference would have been placed into the Toolbar. Each
 '/' in the ref moves up one level from the Component's ownerCt. Also see the added and removed events.]]></description><name>ref</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout layout manager (e.g. specifying layout:'border'). See Ext.layout.BorderLayout also.]]></description><name>region</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The event to listen to for resizing in layouts. Defaults to 'bodyresize'.]]></description><name>resizeEvent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true (or a valid Ext.Shadow Ext.Shadow.mode value) to display a shadow behind the panel, false to display no shadow
 (defaults to 'sides'). Note that this option only applies when floating = true.]]></description><name>shadow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The number of pixels to offset the shadow if displayed (defaults to 4). Note that this option only applies when floating
 = true.]]></description><name>shadowOffset</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[false to disable the iframe shim in browsers which need one (defaults to true). Note that this option only applies when
 floating = true.]]></description><name>shim</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should trigger this component to save its state (defaults to none). stateEvents may
 be any type of event supported by this component, including browser or custom events (e.g., ['click',
 'customerchange']). See stateful for an explanation of saving and restoring Component state.]]></description><name>stateEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id for this component to use for state management purposes (defaults to the component id if one was set,
 otherwise null if the component is using a generated id). See stateful for an explanation of saving and restoring
 Component state.]]></description><name>stateId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A flag which causes the Component to attempt to restore the state of internal properties from a saved state on startup.
 The component must have either a stateId or id assigned for state to be managed. Auto-generated ids are not guaranteed
 to be stable across page loads and cannot be relied upon to save and restore the same state for a component. For state
 saving to work, the state manager's provider must have been set to an implementation of Ext.state.Provider which
 overrides the set and get methods to save and recall name/value pairs. A built-in implementation,
 Ext.state.CookieProvider is available. To set the state provider for the current page: Ext.state.Manager.setProvider(new
 Ext.state.CookieProvider({
     expires: new Date(new Date().getTime()+(1000*60*60*24*7)), //7 days from now
 })); A
 stateful Component attempts to save state when one of the events listed in the stateEvents configuration fires. To save
 state, a stateful Component first serializes its state by calling getState. By default, this function does nothing. The
 developer must provide an implementation which returns an object hash which represents the Component's restorable state.
 The value yielded by getState is passed to Ext.state.Manager.set which uses the configured Ext.state.Provider to save
 the object keyed by the Component's stateId, or, if that is not specified, its id. During construction, a stateful
 Component attempts to restore its state by calling Ext.state.Manager.get passing the stateId, or, if that is not
 specified, the id. The resulting object is passed to applyState. The default implementation of applyState simply copies
 properties into the object, but a developer may override this to support more behaviour. You can perform extra
 processing on state save and restore by attaching handlers to the beforestaterestore, staterestore, beforestatesave and
 statesave events.]]></description><name>stateful</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
     title: 'Some Title',
     renderTo: Ext.getBody(),
     width: 400, height:
 300,
     layout: 'form',
     items: [{
         xtype: 'textarea',
         style: {
             width: '95%',
            
 marginBottom: '10px'
         }
     },
         new Ext.Button({
             text: 'Send',
             minWidth: '100',
   
          style: {
                 marginBottom: '10px'
             }
         })
     ]
 });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is a child item of a TabPanel. A string to be used as innerHTML
 (html tags are accepted) to show in a tooltip when mousing over the associated tab selector element.
 Ext.QuickTips.init() must be called in order for the tips to render.]]></description><name>tabTip</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The title text to be used as innerHTML (html tags are accepted) to display in the panel header (defaults to ''). When a
 title is specified the header element will automatically be created and displayed unless header is explicitly set to
 false. If you do not want to specify a title at config time, but you may want one later, you must either specify a
 non-empty title (a blank space ' ' will do) or header:true so that the container element will get created.]]></description><name>title</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to allow expanding and collapsing the panel (when collapsible = true) by clicking anywhere in the header bar,
 false) to allow it only by clicking to tool button (defaults to false)). If this panel is a child item of a border
 layout also see the BorderLayout.Region floatable config option.]]></description><name>titleCollapse</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A Template used to create tools in the header Element. Defaults to: new Ext.Template('<div class="x-tool
 x-tool-{id}">&#160;</div>') This may may be overridden to provide a custom DOM structure for tools based upon a more
 complex XTemplate. The template's data is a single tool configuration object (Not the entire Array) as specified in
 tools. In the following example an <a> tag is used to provide a visual indication when hovering over the tool: var win =
 new Ext.Window({
     tools: [{
         id: 'download',
         href: '/MyPdfDoc.pdf'
     }],
     toolTemplate: new
 Ext.XTemplate(
         '<tpl if="id==\'download\'">',
             '<a class="x-tool x-tool-pdf" href="{href}"></a>',
    
 '</tpl>',
         '<tpl if="id!=\'download\'">',
             '<div class="x-tool x-tool-{id}">&#160;</div>',
        
 '</tpl>'
     ),
     width:500,
     height:300,
     closeAction:'hide'
 }); Note that the CSS class 'x-tool-pdf' should
 have an associated style rule which provides an appropriate background image, something like: a.x-tool-pdf
 {background-image: url(../shared/extjs/images/pdf.gif)!important;}]]></description><name>toolTemplate</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of tool button configs to be added to the header tool area. When rendered, each tool is stored as an Element
 referenced by a public property called tools.<tool-type> Each tool config may contain the following properties: id :
 String Required. The type of tool to create. By default, this assigns a CSS class of the form x-tool-<tool-type> to the
 resulting tool Element. Ext provides CSS rules, and an icon sprite containing images for the tool types listed below.
 The developer may implement custom tools by supplying alternate CSS rules and background images: toggle (Created by
 default when collapsible is true) close minimize maximize restore gear pin unpin right left up down refresh minus plus
 help search save print handler : Function Required. The function to call when clicked. Arguments passed are: event :
 Ext.EventObject The click event. toolEl : Ext.Element The tool Element. panel : Ext.Panel The host Panel tc : Object The
 tool configuration object stopEvent : Boolean Defaults to true. Specify as false to allow click event to propagate.
 scope : Object The scope in which to call the handler. qtip : String/Object A tip string, or a config argument to
 Ext.QuickTip.register hidden : Boolean True to initially render hidden. on : Object A listener config object specifiying
 event listeners in the format of an argument to addListener Note that, apart from the toggle tool which is provided when
 a panel is collapsible, these tools only provide the visual button. Any required functionality must be provided by
 adding handlers that implement the necessary behavior. Example usage: tools:[{
     id:'refresh',
     qtip: 'Refresh form
 Data',
     // hidden:true,
     handler: function(event, toolEl, panel){
         // refresh logic
     }
 },
 {
    
 id:'help',
     qtip: 'Get Help',
     handler: function(event, toolEl, panel){
         // whatever
     }
 }] For the
 custom id of 'help' define two relevant css classes with a link to a 15x15 image: .x-tool-help {background-image:
 url(images/help.png);}
 .x-tool-help-over {background-image: url(images/help_over.png);}
 // if using an image
 sprite:
 .x-tool-help {background-image: url(images/help.png) no-repeat 0 0;}
 .x-tool-help-over
 {background-position:-15px 0;}]]></description><name>tools</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Overrides the baseCls setting to baseCls = 'x-plain' which renders the panel unstyled except for required attributes for
 Ext layouts to function (e.g. overflow:hidden).]]></description><name>unstyled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local x (left) coordinate for this component if contained within a positioning container.]]></description><name>x</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered xtype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a child item of a Container is being specified not
 as a fully instantiated Component, but as a Component config object. The xtype will be looked up at render time up to
 determine what type of child Component to create. The predefined xtypes are listed here. If you subclass Components to
 create your own Components, you may register them using Ext.ComponentMgr.registerType in order to be able to take
 advantage of lazy instantiation and rendering.]]></description><name>xtype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local y (top) coordinate for this component if contained within a positioning container.]]></description><name>y</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 <p>An updateable progress bar component. The progress bar supports two different modes: manual and automatic.</p> 
 <p>In
 manual mode, you are responsible for showing, updating (via <a
 href="output/Ext.ProgressBar.html#Ext.ProgressBar-updateProgress" ext:member="updateProgress"
 ext:cls="Ext.ProgressBar">updateProgress</a>) and clearing the progress bar as needed from your own code. This method is
 most appropriate when you want to show progress throughout an operation that has predictable points of interest at which
 you can update the control.</p> 
 <p>In automatic mode, you simply call <a
 href="output/Ext.ProgressBar.html#Ext.ProgressBar-wait" ext:member="wait" ext:cls="Ext.ProgressBar">wait</a> and let the
 progress bar run indefinitely, only clearing it once the operation is complete. You can optionally have the progress bar
 wait for a specific amount of time and then clear itself. Automatic mode is most appropriate for timed operations or
 asynchronous operations in which you have no need for indicating intermediate progress.</p>]]></description><name>progressBar</name><tag-class>org.brushingbits.jnap.ui.extjs3.ProgressBar</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[Whether the component can move the Dom node when rendering (defaults to true).]]></description><name>allowDomMove</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use an
 AnchorLayout (or subclass thereof). based layout manager, for example: Ext.form.FormPanel specifying layout: 'anchor' //
 or 'form', or 'absolute' See Ext.layout.AnchorLayout.anchor also.]]></description><name>anchor</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to animate the progress bar during transitions (defaults to false)]]></description><name>animate</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element corresponding to a DIV that is already present in
 the document that specifies some structural markup for this component. Description : When applyTo is used, constituent
 parts of the component can also be specified by id or CSS class name within the main element, and the component being
 created may attempt to create its subcomponents from that markup if applicable. Notes : When using this config, a call
 to render() is not required. If applyTo is specified, any value passed for renderTo will be ignored and the target
 element's parent node will automatically be used as the component's container.]]></description><name>applyTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A tag name or DomHelper spec used to create the Element which will encapsulate this Component. You do not normally need
 to specify this. For the base classes Ext.Component, Ext.BoxComponent, and Ext.Container, this defaults to 'div'. The
 more complex Ext classes use a more complex DOM structure created by their own onRender methods. This is intended to
 allow the developer to create application-specific utility Components encapsulated by different DOM elements. Example
 usage: <pre><code>{
     xtype: 'box',
     autoEl: {
         tag: 'img',
         src: 'http://www.example.com/example.jpg'
     }
 },
 {
     xtype: 'box',
     autoEl: {
         tag: 'blockquote',
         html: 'autoEl is cool!'
     }
 }, {
     xtype: 'container',
     autoEl: 'ul',
     cls: 'ux-unordered-list',
     items: {
         xtype: 'box',
         autoEl: 'li',
   
      html: 'First list item'
     }
 }</pre></code>]]></description><name>autoEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to use height:'auto', false to use fixed height (or allow it to be managed by its parent Container's layout
 manager. Defaults to false. Note: Although many components inherit this config option, not all will function as expected
 with a height of 'auto'. Setting autoHeight:true means that the browser will manage height based on the element's
 contents, and that Ext will not manage it at all. If the browser is managing the height, be aware that resizes performed
 by the browser in response to changes within the structure of the Component cannot be detected. Therefore changes to the
 height might result in elements needing to be synchronized with the new height. Example: var w = new Ext.Window({
    
 title: 'Window',
     width: 600,
     autoHeight: true,
     items: {
         title: 'Collapse Me',
         height: 400,
  
 collapsible: true,
         border: false,
         listeners: {
             beforecollapse: function() {
                w.el.shadow.hide();
             },
             beforeexpand: function() {
                w.el.shadow.hide();
             },
             collapse: function() {
                w.syncShadow();
             },
             expand: function() {
                w.syncShadow();
             }
         }
     }
 }).show();]]></description><name>autoHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to use overflow:'auto' on the components layout element and show scroll bars automatically when necessary, false to
 clip any overflowing content (defaults to false).]]></description><name>autoScroll</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True if the component should check for hidden classes (e.g. 'x-hidden' or 'x-hide-display') and remove them on render
 (defaults to false).]]></description><name>autoShow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to use width:'auto', false to use fixed width (or allow it to be managed by its parent Container's layout manager.
 Defaults to false. Note: Although many components inherit this config option, not all will function as expected with a
 width of 'auto'. Setting autoWidth:true means that the browser will manage width based on the element's contents, and
 that Ext will not manage it at all. If the browser is managing the width, be aware that resizes performed by the browser
 in response to changes within the structure of the Component cannot be detected. Therefore changes to the width might
 result in elements needing to be synchronized with the new width. For example, where the target element is: <div
 id='grid-container' style='margin-left:25%;width:50%'></div> A Panel rendered into that target element must listen for
 browser window resize in order to relay its child items when the browser changes its width: var myPanel = new
 Ext.Panel({
     renderTo: 'grid-container',
     monitorResize: true, // relay on browser resize
     title: 'Panel',
    
 height: 400,
     autoWidth: true,
     layout: 'hbox',
     layoutConfig: {
         align: 'stretch'
     },
     defaults: {
         flex: 1
     },
     items: [{
         title: 'Box 1',
     }, {
         title: 'Box 2'
     }, {
         title:
 'Box 3'
     }],
 });]]></description><name>autoWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The base CSS class to apply to the progress bar's wrapper element (defaults to 'x-progress')]]></description><name>baseCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to [].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class used to to apply to the special clearing div rendered directly after each form field wrapper to provide
 field clearing (defaults to 'x-form-clear-left'). Note: this config is only used when this Component is rendered by a
 Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or specifying
 layout:'form') and either a fieldLabel is specified or isFormField=true is specified. See Ext.layout.FormLayout.fieldTpl
 also.]]></description><name>clearCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element (defaults to ''). This can be useful for
 adding customized styles to the component or any of its children using standard CSS rules.]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's container. This can be useful for adding customized
 styles to the container or any of its children using standard CSS rules. See Ext.layout.ContainerLayout.extraCls also.
 Note: ctCls defaults to '' except for the following class which assigns a value by default: Box Layout :
 'x-box-layout-ct' To configure the above Class with an extra CSS class append to the default. For example, for BoxLayout
 (Hbox and Vbox): ctCls: 'x-box-layout-ct custom-class']]></description><name>ctCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component disabled (default is false).]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class added to the component when it is disabled (defaults to 'x-item-disabled').]]></description><name>disabledClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The label text to display next to this Component (defaults to ''). Note: this config is only used when this Component is
 rendered by a Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or
 specifying layout:'form'). Also see hideLabel and Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
    
 height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name'
    
 }]
 });]]></description><name>fieldLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use a
 BoxLayout. Each child Component with a flex property will be flexed either vertically (by a VBoxLayout) or horizontally
 (by an HBoxLayout) according to the item's relative flex value compared to the sum of all Components with flex value
 specified. Any child items that have either a flex = 0 or flex = undefined will not be 'flexed' (the initial size will
 not be changed).]]></description><name>flex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component hidden (default is false). If true, the hide method will be called internally.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to completely hide the label element (label and separator). Defaults to false. By default, even if you do not
 specify a fieldLabel the space will still be reserved so that the field will line up with other fields that do have
 labels. Setting this to true will cause the field to not reserve that space. Note: see the note for clearCls. Example
 use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield'
        
 hideLabel: true
     }]
 });]]></description><name>hideLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[How this component should be hidden. Supported values are 'visibility' (css visibility), 'offsets' (negative offset
 position) and 'display' (css display). Note: the default of 'display' is generally preferred since items are
 automatically laid out when they are first shown (no sizing is done while hidden).]]></description><name>hideMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide and show the component's container when hide/show is called on the component, false to hide and show the
 component itself (defaults to false). For example, this can be used as a shortcut for a hide button on a window by
 setting hide:true on the button when adding it to its parent container.]]></description><name>hideParent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The progress bar element's id (defaults to an auto-generated id)]]></description><name>id</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use the
 FormLayout layout manager (e.g. Ext.form.FormPanel or specifying layout:'form'). An additional CSS class to apply to the
 div wrapping the form item element of this field. If supplied, itemCls at the field level will override the default
 itemCls supplied at the container level. The value specified for itemCls will be added to the default class
 ('x-form-item'). Since it is applied to the item wrapper (see Ext.layout.FormLayout.fieldTpl), it allows you to write
 standard CSS rules that can apply to the field, the label (if specified), or any other element within the markup for the
 field. Note: see the note for fieldLabel. Example use: // Apply a style to the field's label:
 <style>
     .required
 .x-form-item-label {font-weight:bold;color:red;}
 </style>
 
 new Ext.FormPanel({
     height: 100,
     renderTo:
 Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         itemCls: 'required' //this
 label will be styled
     },{
         xtype: 'textfield',
         fieldLabel: 'Favorite Color'
     }]
 });]]></description><name>itemCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An itemId can be used as an alternative way to get a reference to a component when no object reference is available.
 Instead of using an id with Ext.getCmp, use itemId with Ext.Container.getComponent which will retrieve itemId's or id's.
 Since itemId's are an index to the container's internal MixedCollection, the itemId is scoped locally to the container
 -- avoiding potential conflicts with Ext.ComponentMgr which requires a unique id. var c = new Ext.Panel({ //
     height:
 300,
     renderTo: document.body,
     layout: 'auto',
     items: [
         {
             itemId: 'p1',
            
 title: 'Panel 1',
             height: 150
         },
         {
             itemId: 'p2',
             title: 'Panel 2',
  
 height: 150
         }
     ]
 })
 p1 = c.getComponent('p1'); // not the same as Ext.getCmp()
 p2 =
 p1.ownerCt.getComponent('p2'); // reference via a sibling Also see id and ref. Note: to access the container of an item
 see ownerCt.]]></description><name>itemId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The separator to display after the text of each fieldLabel. This property may be configured at various levels. The order
 of precedence is: field / component level container level layout level (defaults to colon ':') To display no separator
 for this field's label specify empty string ''. Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 layoutConfig: {
         labelSeparator: '~'   // layout config has lowest priority (defaults to ':')
     },
    
 labelSeparator: '>>',     // config at container level
     items: [{
         xtype: 'textfield',
         fieldLabel:
 'Field 1',
         labelSeparator: '...' // field/component level config supersedes others
     },{
         xtype:
 'textfield',
         fieldLabel: 'Field 2' // labelSeparator will be '='
     }]
 });]]></description><name>labelSeparator</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS style specification string to apply directly to this field's label. Defaults to the container's labelStyle value
 if set (e.g., Ext.layout.FormLayout.labelStyle , or ''). Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         labelStyle: 'font-weight:bold;'
     }]
 });]]></description><name>labelStyle</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout or one of the two BoxLayout subclasses. An object containing margins to apply to this BoxComponent in the
 format: {
     top: (top margin),
     right: (right margin),
     bottom: (bottom margin),
     left: (left margin)
 } May
 also be a string containing space-separated, numeric margin values. The order of the sides associated with each value
 matches the way CSS processes margin values: If there is only one value, it applies to all sides. If there are two
 values, the top and bottom borders are set to the first value and the right and left are set to the second. If there are
 three values, the top is set to the first value, the left and right are set to the second, and the bottom is set to the
 third. If there are four values, they apply to the top, right, bottom, and left, respectively. Defaults to: {top:0,
 right:0, bottom:0, left:0}]]></description><name>margins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element when the mouse moves over the Element, and
 removed when the mouse moves out. (defaults to ''). This can be useful for adding customized 'active' or 'hover' styles
 to the component or any of its children using standard CSS rules.]]></description><name>overCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level x coordinate for this component if contained within a positioning container.]]></description><name>pageX</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level y coordinate for this component if contained within a positioning container.]]></description><name>pageY</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered ptype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a Plugin is being specified not as a fully
 instantiated Component, but as a Component config object. The ptype will be looked up at render time up to determine
 what type of Plugin to create. If you create your own Plugins, you may register them using
 Ext.ComponentMgr.registerPlugin in order to be able to take advantage of lazy instantiation and rendering.]]></description><name>ptype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A path specification, relative to the Component's ownerCt specifying into which ancestor Container to place a named
 reference to this Component. The ancestor axis can be traversed by using '/' characters in the path. For example, to put
 a reference to a Toolbar Button into the Panel which owns the Toolbar: var myGrid = new Ext.grid.EditorGridPanel({
    
 title: 'My EditorGridPanel',
     store: myStore,
     colModel: myColModel,
     tbar: [{
         text: 'Save',
        
 handler: saveChanges,
         disabled: true,
         ref: '../saveButton'
     }],
     listeners: {
         afteredit:
 function() {
 //          The button reference is in the GridPanel
             myGrid.saveButton.enable();
         }
    
 }
 }); In the code above, if the ref had been 'saveButton' the reference would have been placed into the Toolbar. Each
 '/' in the ref moves up one level from the Component's ownerCt. Also see the added and removed events.]]></description><name>ref</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout layout manager (e.g. specifying layout:'border'). See Ext.layout.BorderLayout also.]]></description><name>region</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should trigger this component to save its state (defaults to none). stateEvents may
 be any type of event supported by this component, including browser or custom events (e.g., ['click',
 'customerchange']). See stateful for an explanation of saving and restoring Component state.]]></description><name>stateEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id for this component to use for state management purposes (defaults to the component id if one was set,
 otherwise null if the component is using a generated id). See stateful for an explanation of saving and restoring
 Component state.]]></description><name>stateId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A flag which causes the Component to attempt to restore the state of internal properties from a saved state on startup.
 The component must have either a stateId or id assigned for state to be managed. Auto-generated ids are not guaranteed
 to be stable across page loads and cannot be relied upon to save and restore the same state for a component. For state
 saving to work, the state manager's provider must have been set to an implementation of Ext.state.Provider which
 overrides the set and get methods to save and recall name/value pairs. A built-in implementation,
 Ext.state.CookieProvider is available. To set the state provider for the current page: Ext.state.Manager.setProvider(new
 Ext.state.CookieProvider({
     expires: new Date(new Date().getTime()+(1000*60*60*24*7)), //7 days from now
 })); A
 stateful Component attempts to save state when one of the events listed in the stateEvents configuration fires. To save
 state, a stateful Component first serializes its state by calling getState. By default, this function does nothing. The
 developer must provide an implementation which returns an object hash which represents the Component's restorable state.
 The value yielded by getState is passed to Ext.state.Manager.set which uses the configured Ext.state.Provider to save
 the object keyed by the Component's stateId, or, if that is not specified, its id. During construction, a stateful
 Component attempts to restore its state by calling Ext.state.Manager.get passing the stateId, or, if that is not
 specified, the id. The resulting object is passed to applyState. The default implementation of applyState simply copies
 properties into the object, but a developer may override this to support more behaviour. You can perform extra
 processing on state save and restore by attaching handlers to the beforestaterestore, staterestore, beforestatesave and
 statesave events.]]></description><name>stateful</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
     title: 'Some Title',
     renderTo: Ext.getBody(),
     width: 400, height:
 300,
     layout: 'form',
     items: [{
         xtype: 'textarea',
         style: {
             width: '95%',
            
 marginBottom: '10px'
         }
     },
         new Ext.Button({
             text: 'Send',
             minWidth: '100',
   
          style: {
                 marginBottom: '10px'
             }
         })
     ]
 });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is a child item of a TabPanel. A string to be used as innerHTML
 (html tags are accepted) to show in a tooltip when mousing over the associated tab selector element.
 Ext.QuickTips.init() must be called in order for the tips to render.]]></description><name>tabTip</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The progress bar text (defaults to '')]]></description><name>text</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The element to render the progress text to (defaults to the progress bar's internal text element)]]></description><name>textEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A floating point value between 0 and 1 (e.g., .5, defaults to 0)]]></description><name>value</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local x (left) coordinate for this component if contained within a positioning container.]]></description><name>x</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered xtype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a child item of a Container is being specified not
 as a fully instantiated Component, but as a Component config object. The xtype will be looked up at render time up to
 determine what type of child Component to create. The predefined xtypes are listed here. If you subclass Components to
 create your own Components, you may register them using Ext.ComponentMgr.registerType in order to be able to take
 advantage of lazy instantiation and rendering.]]></description><name>xtype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local y (top) coordinate for this component if contained within a positioning container.]]></description><name>y</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>]]></description><name>quickTip</name><tag-class>org.brushingbits.jnap.ui.extjs3.QuickTip</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[A string component id or the numeric index of the component that should be initially activated within the container's
 layout on render. For example, activeItem: 'item-1' or activeItem: 0 (index 0 = the first item in the container's
 collection). activeItem only applies to layout styles that can display items one at a time (like
 Ext.layout.AccordionLayout, Ext.layout.CardLayout and Ext.layout.FitLayout). Related to
 Ext.layout.ContainerLayout.activeItem.]]></description><name>activeItem</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Whether the component can move the Dom node when rendering (defaults to true).]]></description><name>allowDomMove</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use an
 AnchorLayout (or subclass thereof). based layout manager, for example: Ext.form.FormPanel specifying layout: 'anchor' //
 or 'form', or 'absolute' See Ext.layout.AnchorLayout.anchor also.]]></description><name>anchor</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A numeric pixel value used to offset the default position of the anchor arrow (defaults to 0). When the anchor position
 is on the top or bottom of the tooltip, anchorOffset will be used as a horizontal offset. Likewise, when the anchor
 position is on the left or right side, anchorOffset will be used as a vertical offset.]]></description><name>anchorOffset</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to anchor the tooltip to the target element, false to anchor it relative to the mouse coordinates (defaults to
 true). When anchorToTarget is true, use defaultAlign to control tooltip alignment to the target element. When
 anchorToTarget is false, use anchorPosition instead to control alignment.]]></description><name>anchorToTarget</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to animate the transition when the panel is collapsed, false to skip the animation (defaults to true if the Ext.Fx
 class is available, otherwise false).]]></description><name>animCollapse</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The id of the node, a DOM node or an existing Element corresponding to a DIV that is already present in the document
 that specifies some panel-specific structural markup. When applyTo is used, constituent parts of the panel can be
 specified by CSS class name within the main element, and the panel will automatically create those components from that
 markup. Any required components not specified in the markup will be autogenerated if necessary. The following class
 names are supported (baseCls will be replaced by baseCls): baseCls + '-header' baseCls + '-header-text' baseCls +
 '-bwrap' baseCls + '-tbar' baseCls + '-body' baseCls + '-bbar' baseCls + '-footer' Using this config, a call to render()
 is not required. If applyTo is specified, any value passed for renderTo will be ignored and the target element's parent
 node will automatically be used as the panel's container.]]></description><name>applyTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If true the container will automatically destroy any contained component that is removed from it, else destruction must
 be handled manually (defaults to true).]]></description><name>autoDestroy</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A tag name or DomHelper spec used to create the Element which will encapsulate this Component. You do not normally need
 to specify this. For the base classes Ext.Component, Ext.BoxComponent, and Ext.Container, this defaults to 'div'. The
 more complex Ext classes use a more complex DOM structure created by their own onRender methods. This is intended to
 allow the developer to create application-specific utility Components encapsulated by different DOM elements. Example
 usage: <pre><code>{
     xtype: 'box',
     autoEl: {
         tag: 'img',
         src: 'http://www.example.com/example.jpg'
     }
 },
 {
     xtype: 'box',
     autoEl: {
         tag: 'blockquote',
         html: 'autoEl is cool!'
     }
 }, {
     xtype: 'container',
     autoEl: 'ul',
     cls: 'ux-unordered-list',
     items: {
         xtype: 'box',
         autoEl: 'li',
   
      html: 'First list item'
     }
 }</pre></code>]]></description><name>autoEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to use height:'auto', false to use fixed height (defaults to false). Note: Setting autoHeight: true means that the
 browser will manage the panel's height based on its contents, and that Ext will not manage it at all. If the panel is
 within a layout that manages dimensions (fit, border, etc.) then setting autoHeight: true can cause issues with
 scrolling and will not generally work as expected since the panel will take on the height of its contents rather than
 the height required by the Ext layout.]]></description><name>autoHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically hide the tooltip after the mouse exits the target element or after the dismissDelay has expired if
 set (defaults to true). If closable = true a close tool button will be rendered into the tooltip header.]]></description><name>autoHide</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A valid url spec according to the Updater Ext.Updater.update method. If autoLoad is not null, the panel will attempt to
 load its contents immediately upon render. The URL will become the default URL for this panel's body element, so it may
 be refreshed at any time.]]></description><name>autoLoad</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to use overflow:'auto' on the components layout element and show scroll bars automatically when necessary, false to
 clip any overflowing content (defaults to false).]]></description><name>autoScroll</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True if the component should check for hidden classes (e.g. 'x-hidden' or 'x-hide-display') and remove them on render
 (defaults to false).]]></description><name>autoShow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to use width:'auto', false to use fixed width (or allow it to be managed by its parent Container's layout manager.
 Defaults to false. Note: Although many components inherit this config option, not all will function as expected with a
 width of 'auto'. Setting autoWidth:true means that the browser will manage width based on the element's contents, and
 that Ext will not manage it at all. If the browser is managing the width, be aware that resizes performed by the browser
 in response to changes within the structure of the Component cannot be detected. Therefore changes to the width might
 result in elements needing to be synchronized with the new width. For example, where the target element is: <div
 id='grid-container' style='margin-left:25%;width:50%'></div> A Panel rendered into that target element must listen for
 browser window resize in order to relay its child items when the browser changes its width: var myPanel = new
 Ext.Panel({
     renderTo: 'grid-container',
     monitorResize: true, // relay on browser resize
     title: 'Panel',
    
 height: 400,
     autoWidth: true,
     layout: 'hbox',
     layoutConfig: {
         align: 'stretch'
     },
     defaults: {
         flex: 1
     },
     items: [{
         title: 'Box 1',
     }, {
         title: 'Box 2'
     }, {
         title:
 'Box 3'
     }],
 });]]></description><name>autoWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The base CSS class to apply to this panel's element (defaults to 'x-panel'). Another option available by default is to
 specify 'x-plain' which strips all styling except for required attributes for Ext layouts to function (e.g.
 overflow:hidden). See unstyled also.]]></description><name>baseCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to display an interior border on the body element of the panel, false to hide it (defaults to true). This only
 applies when border == true. If border == true and bodyBorder == false, the border will display as a 1px wide inset
 border, giving the entire body element an inset appearance.]]></description><name>bodyBorder</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A DomHelper element specification object may be specified for any Panel Element. By default, the Default element in the
 table below will be used for the html markup to create a child element with the commensurate Default class name (baseCls
 will be replaced by baseCls): 
 Panel      Default  Default             Custom      Additional       Additional
 Element  
 element  class               element     class            style
 ========   ==========================   =========  
 ==============   ===========
 header     div      baseCls+'-header'   headerCfg   headerCssClass   headerStyle
 bwrap     
 div      baseCls+'-bwrap'     bwrapCfg    bwrapCssClass    bwrapStyle
 + tbar     div      baseCls+'-tbar'       tbarCfg 
 tbarCssClass     tbarStyle
 + body     div      baseCls+'-body'       bodyCfg     bodyCssClass     bodyStyle
 + bbar    
 div      baseCls+'-bbar'       bbarCfg     bbarCssClass     bbarStyle
 + footer   div      baseCls+'-footer'   footerCfg 
 footerCssClass   footerStyle
  Configuring a Custom element may be used, for example, to force the body Element to use a
 different form of markup than is created by default. An example of this might be to create a child Panel containing a
 custom content, such as a header, or forcing centering of all Panel content by having the body be a <center> element:
 new Ext.Panel({
     title: 'Message Title',
     renderTo: Ext.getBody(),
     width: 200, height: 130,
     bodyCfg: {
    
 tag: 'center',
         cls: 'x-panel-body',  // Default class not applied if Custom element specified
         html:
 'Message'
     },
     footerCfg: {
         tag: 'h2',
         cls: 'x-panel-footer',        // same as the Default class
 
 html: 'footer html'
     },
     footerCssClass: 'custom-footer', // additional css class, see addClass
     footerStyle:  
 'background-color:red' // see bodyStyle
 }); The example above also explicitly creates a footer with custom markup and
 styling applied.]]></description><name>bodyCfg</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Additional css class selector to be applied to the body element in the format expected by Ext.Element.addClass (defaults
 to null). See bodyCfg.]]></description><name>bodyCssClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Custom CSS styles to be applied to the body element in the format expected by Ext.Element.applyStyles (defaults to
 null). See bodyCfg.]]></description><name>bodyStyle</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to display the borders of the panel's body element, false to hide them (defaults to true). By default, the border
 is a 2px wide inset border, but this can be further altered by setting bodyBorder to false.]]></description><name>border</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to ['add', 'remove'].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[When set to true (50 milliseconds) or a number of milliseconds, the layout assigned for this container will buffer the
 frequency it calculates and does a re-layout of components. This is useful for heavy containers or containers with a
 large quantity of sub-components for which frequent layout calls would be expensive. Defaults to 50.]]></description><name>bufferResize</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The alignment of any buttons added to this panel. Valid values are 'right', 'left' and 'center' (defaults to 'right').]]></description><name>buttonAlign</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A DomHelper element specification object specifying the element structure of this Panel's bwrap Element. See bodyCfg
 also.]]></description><name>bwrapCfg</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class used to to apply to the special clearing div rendered directly after each form field wrapper to provide
 field clearing (defaults to 'x-form-clear-left'). Note: this config is only used when this Component is rendered by a
 Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or specifying
 layout:'form') and either a fieldLabel is specified or isFormField=true is specified. See Ext.layout.FormLayout.fieldTpl
 also.]]></description><name>clearCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to render a close tool button into the tooltip header (defaults to false).]]></description><name>closable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element (defaults to ''). This can be useful for
 adding customized styles to the component or any of its children using standard CSS rules.]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to make sure the collapse/expand toggle button always renders first (to the left of) any other tools in the panel's
 title bar, false to render it last (defaults to true).]]></description><name>collapseFirst</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to render the panel collapsed, false to render it expanded (defaults to false).]]></description><name>collapsed</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS class to add to the panel's element after it has been collapsed (defaults to 'x-panel-collapsed').]]></description><name>collapsedCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to make the panel collapsible and have the expand/collapse toggle button automatically rendered into the header
 tool button area, false to keep the panel statically sized with no button (defaults to false).]]></description><name>collapsible</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's container. This can be useful for adding customized
 styles to the container or any of its children using standard CSS rules. See Ext.layout.ContainerLayout.extraCls also.
 Note: ctCls defaults to '' except for the following class which assigns a value by default: Box Layout :
 'x-box-layout-ct' To configure the above Class with an extra CSS class append to the default. For example, for BoxLayout
 (Hbox and Vbox): ctCls: 'x-box-layout-ct custom-class']]></description><name>ctCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Experimental. The default Ext.Element.alignTo anchor position value for this tip relative to its element of origin
 (defaults to "tl-bl?").]]></description><name>defaultAlign</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default xtype of child Components to create in this Container when a child item is specified as a raw configuration
 object, rather than as an instantiated Component. Defaults to 'panel', except Ext.menu.Menu which defaults to
 'menuitem', and Ext.Toolbar and Ext.ButtonGroup which default to 'button'.]]></description><name>defaultType</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[This option is a means of applying default settings to all added items whether added through the items config or via the
 add or insert methods. If an added item is a config object, and not an instantiated Component, then the default
 properties are unconditionally applied. If the added item is an instantiated Component, then the default properties are
 applied conditionally so as not to override existing properties in the item. If the defaults option is specified as a
 function, then the function will be called using this Container as the scope (this reference) and passing the added item
 as the first parameter. Any resulting object from that call is then applied to the item as default properties. For
 example, to automatically apply padding to the body of each of a set of contained Ext.Panel items, you could pass:
 defaults: {bodyStyle:'padding:15px'}. Usage: defaults: {               // defaults are applied to items, not the
 container
     autoScroll:true
 },
 items: [
     {
         xtype: 'panel',   // defaults do not have precedence over
       
 id: 'panel1',     // options in config objects, so the defaults
         autoScroll: false // will not be applied here,
 panel1 will be autoScroll:false
     },
     new Ext.Panel({       // defaults do have precedence over options
         id:
 'panel2',     // options in components, so the defaults
         autoScroll: false // will be applied here, panel2 will
 be autoScroll:true.
     })
 ]]]></description><name>defaults</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. A DomQuery selector which allows selection of individual elements within the target element to trigger showing
 and hiding the ToolTip as the mouse moves within the target. When specified, the child element of the target which
 caused a show event is placed into the triggerElement property before the ToolTip is shown. This may be useful when a
 Component has regular, repeating elements in it, each of which need a Tooltip which contains information specific to
 that element. For example: var myGrid = new Ext.grid.gridPanel(gridConfig);
 myGrid.on('render', function(grid) {
     var
 store = grid.getStore();  // Capture the Store.
     var view = grid.getView();    // Capture the GridView.
    
 myGrid.tip = new Ext.ToolTip({
         target: view.mainBody,    // The overall target element.
         delegate:
 '.x-grid3-row', // Each grid row causes its own seperate show and hide.
         trackMouse: true,         // Moving
 within the row should not hide the tip.
         renderTo: document.body,  // Render immediately so that tip.body can be
 
 //  referenced prior to the first show.
         listeners: {              // Change content dynamically depending on
 which element
                                   //  triggered the show.
             beforeshow: function
 updateTipBody(tip) {
                 var rowIndex = view.findRowIndex(tip.triggerElement);
                
 tip.body.dom.innerHTML = 'Over Record ID ' + store.getAt(rowIndex).id;
             }
         }
     });
 });]]></description><name>delegate</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this panel disabled (default is false). An important note when using the disabled config on panels is that IE
 will often fail to initialize the disabled mask element correectly if the panel's layout has not yet completed by the
 time the Panel is disabled during the render process. If you experience this issue, you may need to instead use the
 afterlayout event to initialize the disabled state: new Ext.Panel({
     ...
     listeners: {
         'afterlayout': {
   
 fn: function(p){
                 p.disable();
             },
             single: true // important, as many layouts can
 occur
         }
     }
 });]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class added to the component when it is disabled (defaults to 'x-item-disabled').]]></description><name>disabledClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Delay in milliseconds before the tooltip automatically hides (defaults to 5000). To disable automatic hiding, set
 dismissDelay = 0.]]></description><name>dismissDelay</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to enable dragging of this Panel (defaults to false). For custom drag/drop implementations, an Ext.Panel.DD config
 could also be passed in this config instead of true. Ext.Panel.DD is an internal, undocumented class which moves a proxy
 Element around in place of the Panel's element, but provides no other behaviour during dragging or on drop. It is a
 subclass of Ext.dd.DragSource, so behaviour may be added by implementing the interface methods of Ext.dd.DragDrop e.g.:
 new Ext.Panel({
     title: 'Drag me',
     x: 100,
     y: 100,
     renderTo: Ext.getBody(),
     floating: true,
    
 frame: true,
     width: 400,
     height: 200,
     draggable: {
 //      Config option of Ext.Panel.DD class.
 //      It's
 a floating Panel, so do not show a placeholder proxy in the original position.
         insertProxy: false,
 
 //     
 Called for each mousemove event while dragging the DD object.
         onDrag : function(e){
 //          Record the x,y
 position of the drag proxy so that we can
 //          position the Panel at end of drag.
             var pel =
 this.proxy.getEl();
             this.x = pel.getLeft(true);
             this.y = pel.getTop(true);
 
 //          Keep the
 Shadow aligned if there is one.
             var s = this.panel.getEl().shadow;
             if (s) {
                
 s.realign(this.x, this.y, pel.getWidth(), pel.getHeight());
             }
         },
 
 //      Called on the mouseup
 event.
         endDrag : function(e){
             this.panel.setPosition(this.x, this.y);
         }
     }
 }).show();]]></description><name>draggable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A comma-delimited list of panel elements to initialize when the panel is rendered. Normally, this list will be generated
 automatically based on the items added to the panel at config time, but sometimes it might be useful to make sure a
 structural element is rendered even if not specified at config time (for example, you may want to add a button or
 toolbar dynamically after the panel has been rendered). Adding those elements to this list will allocate the required
 placeholders in the panel when it is rendered. Valid values are header tbar (top bar) body bbar (bottom bar) footer
 Defaults to 'body'.]]></description><name>elements</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A Toolbar object, a Toolbar config, or an array of Buttons/Button configs, describing a Toolbar to be rendered into this
 Panel's footer element. After render, the fbar property will be an Toolbar instance. If buttons are specified, they will
 supersede the fbar configuration property. The Panel's buttonAlign configuration affects the layout of these items, for
 example: var w = new Ext.Window({
     height: 250,
     width: 500,
     bbar: new Ext.Toolbar({
         items: [{
        
 text: 'bbar Left'
         },'->',{
             text: 'bbar Right'
         }]
     }),
     buttonAlign: 'left', //
 anything but 'center' or 'right' and you can use '-', and '->'
                                   // to control the
 alignment of fbar items
     fbar: [{
         text: 'fbar Left'
     },'->',{
         text: 'fbar Right'
     }]
 }).show();
 Note: Although a Toolbar may contain Field components, these will not be updated by a load of an ancestor FormPanel. A
 Panel's toolbars are not part of the standard Container->Component hierarchy, and so are not scanned to collect form
 items. However, the values will be submitted because form submission parameters are collected from the DOM tree.]]></description><name>fbar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The label text to display next to this Component (defaults to ''). Note: this config is only used when this Component is
 rendered by a Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or
 specifying layout:'form'). Also see hideLabel and Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
    
 height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name'
    
 }]
 });]]></description><name>fieldLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use a
 BoxLayout. Each child Component with a flex property will be flexed either vertically (by a VBoxLayout) or horizontally
 (by an HBoxLayout) according to the item's relative flex value compared to the sum of all Components with flex value
 specified. Any child items that have either a flex = 0 or flex = undefined will not be 'flexed' (the initial size will
 not be changed).]]></description><name>flex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[This property is used to configure the underlying Ext.Layer. Acceptable values for this configuration property are:
 false : Default. Display the panel inline where it is rendered. true : Float the panel (absolute position it with
 automatic shimming and shadow). Setting floating to true will create an Ext.Layer for this panel and display the panel
 at negative offsets so that it is hidden. Since the panel will be absolute positioned, the position must be set
 explicitly after render (e.g., myPanel.setPosition(100,100);). Note: when floating a panel you should always assign a
 fixed width, otherwise it will be auto width and will expand to fill to the right edge of the viewport. object : The
 specified object will be used as the configuration object for the Ext.Layer that will be created.]]></description><name>floating</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to create the footer element explicitly, false to skip creating it. The footer will be created automatically if
 buttons or a fbar have been configured. See bodyCfg for an example.]]></description><name>footer</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A DomHelper element specification object specifying the element structure of this Panel's footer Element. See bodyCfg
 also.]]></description><name>footerCfg</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If true the container will force a layout initially even if hidden or collapsed. This option is useful for forcing forms
 to render in collapsed or hidden containers. (defaults to false).]]></description><name>forceLayout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[false by default to render with plain 1px square borders. true to render with 9 elements, complete with custom rounded
 corners (also see Ext.Element.boxWrap). The template generated for each condition is depicted below: // frame =
 false
 <div id="developer-specified-id-goes-here" class="x-panel">
 
     <div class="x-panel-header"><span
 class="x-panel-header-text">Title: (frame:false)</span></div>
 
     <div class="x-panel-bwrap">
         <div
 class="x-panel-body"><p>html value goes here</p></div>
     </div>
 </div>
 
 // frame = true (create 9 elements)
 <div
 id="developer-specified-id-goes-here" class="x-panel">
     <div class="x-panel-tl"><div class="x-panel-tr"><div
 class="x-panel-tc">
         <div class="x-panel-header"><span class="x-panel-header-text">Title:
 (frame:true)</span></div>
     </div></div></div>
 
     <div class="x-panel-bwrap">
         <div class="x-panel-ml"><div
 class="x-panel-mr"><div class="x-panel-mc">
             <div class="x-panel-body"><p>html value goes here</p></div>
     
 </div></div></div>
 
         <div class="x-panel-bl"><div class="x-panel-br"><div class="x-panel-bc"/>
        
 </div></div></div>
 </div>]]></description><name>frame</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to create the Panel's header element explicitly, false to skip creating it. If a title is set the header will be
 created automatically, otherwise it will not. If a title is set but header is explicitly set to false, the header will
 not be rendered.]]></description><name>header</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to display the panel title in the header, false to hide it (defaults to true).]]></description><name>headerAsText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A DomHelper element specification object specifying the element structure of this Panel's header Element. See bodyCfg
 also.]]></description><name>headerCfg</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component hidden (default is false). If true, the hide method will be called internally.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide the borders of each contained component, false to defer to the component's existing border settings
 (defaults to false).]]></description><name>hideBorders</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to hide the expand/collapse toggle button when collapsible == true, false to display it (defaults to false).]]></description><name>hideCollapseTool</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Delay in milliseconds after the mouse exits the target element but before the tooltip actually hides (defaults to 200).
 Set to 0 for the tooltip to hide immediately.]]></description><name>hideDelay</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to completely hide the label element (label and separator). Defaults to false. By default, even if you do not
 specify a fieldLabel the space will still be reserved so that the field will line up with other fields that do have
 labels. Setting this to true will cause the field to not reserve that space. Note: see the note for clearCls. Example
 use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield'
        
 hideLabel: true
     }]
 });]]></description><name>hideLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[How this component should be hidden. Supported values are 'visibility' (css visibility), 'offsets' (negative offset
 position) and 'display' (css display). Note: the default of 'display' is generally preferred since items are
 automatically laid out when they are first shown (no sizing is done while hidden).]]></description><name>hideMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide and show the component's container when hide/show is called on the component, false to hide and show the
 component itself (defaults to false). For example, this can be used as a shortcut for a hide button on a window by
 setting hide:true on the button when adding it to its parent container.]]></description><name>hideParent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class selector that specifies a background image to be used as the header icon (defaults to ''). An example of
 specifying a custom icon class would be something like: // specify the property in the config for the class:
      ...
   
 iconCls: 'my-icon'
 
 // css class that specifies background image to be used as the icon image:
 .my-icon {
 background-image: url(../images/my-icon.gif) 0 6px no-repeat !important; }]]></description><name>iconCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id of this component (defaults to an auto-assigned id). You should assign an id if you need to be able to
 access the component later and you do not have an object reference available (e.g., using Ext.getCmp). Note that this id
 will also be used as the element id for the containing HTML element that is rendered to the page for this component.
 This allows you to write id-based CSS rules to style the specific instance of this component uniquely, and also to
 select sub-elements using this component's id as the parent. Note: to avoid complications imposed by a unique id also
 see itemId and ref. Note: to access the container of an item see ownerCt.]]></description><name>id</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically use the element's DOM title value if available (defaults to false).]]></description><name>interceptTitles</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use the
 FormLayout layout manager (e.g. Ext.form.FormPanel or specifying layout:'form'). An additional CSS class to apply to the
 div wrapping the form item element of this field. If supplied, itemCls at the field level will override the default
 itemCls supplied at the container level. The value specified for itemCls will be added to the default class
 ('x-form-item'). Since it is applied to the item wrapper (see Ext.layout.FormLayout.fieldTpl), it allows you to write
 standard CSS rules that can apply to the field, the label (if specified), or any other element within the markup for the
 field. Note: see the note for fieldLabel. Example use: // Apply a style to the field's label:
 <style>
     .required
 .x-form-item-label {font-weight:bold;color:red;}
 </style>
 
 new Ext.FormPanel({
     height: 100,
     renderTo:
 Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         itemCls: 'required' //this
 label will be styled
     },{
         xtype: 'textfield',
         fieldLabel: 'Favorite Color'
     }]
 });]]></description><name>itemCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An itemId can be used as an alternative way to get a reference to a component when no object reference is available.
 Instead of using an id with Ext.getCmp, use itemId with Ext.Container.getComponent which will retrieve itemId's or id's.
 Since itemId's are an index to the container's internal MixedCollection, the itemId is scoped locally to the container
 -- avoiding potential conflicts with Ext.ComponentMgr which requires a unique id. var c = new Ext.Panel({ //
     height:
 300,
     renderTo: document.body,
     layout: 'auto',
     items: [
         {
             itemId: 'p1',
            
 title: 'Panel 1',
             height: 150
         },
         {
             itemId: 'p2',
             title: 'Panel 2',
  
 height: 150
         }
     ]
 })
 p1 = c.getComponent('p1'); // not the same as Ext.getCmp()
 p2 =
 p1.ownerCt.getComponent('p2'); // reference via a sibling Also see id and ref. Note: to access the container of an item
 see ownerCt.]]></description><name>itemId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A Ext.KeyMap config object (in the format expected by Ext.KeyMap.addBinding used to assign custom key handling to this
 panel (defaults to null).]]></description><name>keys</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The separator to display after the text of each fieldLabel. This property may be configured at various levels. The order
 of precedence is: field / component level container level layout level (defaults to colon ':') To display no separator
 for this field's label specify empty string ''. Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 layoutConfig: {
         labelSeparator: '~'   // layout config has lowest priority (defaults to ':')
     },
    
 labelSeparator: '>>',     // config at container level
     items: [{
         xtype: 'textfield',
         fieldLabel:
 'Field 1',
         labelSeparator: '...' // field/component level config supersedes others
     },{
         xtype:
 'textfield',
         fieldLabel: 'Field 2' // labelSeparator will be '='
     }]
 });]]></description><name>labelSeparator</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS style specification string to apply directly to this field's label. Defaults to the container's labelStyle value
 if set (e.g., Ext.layout.FormLayout.labelStyle , or ''). Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         labelStyle: 'font-weight:bold;'
     }]
 });]]></description><name>labelStyle</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[*Important: In order for child items to be correctly sized and positioned, typically a layout manager must be specified
 through the layout configuration option. The sizing and positioning of child items is the responsibility of the
 Container's layout manager which creates and manages the type of layout you have in mind. For example:
 <pre><code>
 new Ext.Window({
 
 width:300, height: 300,
     layout: 'fit', // explicitly set layout manager: override the default (layout:'auto')
    
 items: [{
         title: 'Panel inside a Window'
     }]
 }).show();</pre></code>
 If the layout configuration is not explicitly
 specified for a general purpose container (e.g. Container or Panel) the default layout manager will be used which does
 nothing but render child components sequentially into the Container (no sizing or positioning will be performed in this
 situation). Some container classes implicitly specify a default layout (e.g. FormPanel specifies layout:'form'). Other
 specific purpose classes internally specify/manage their internal layout (e.g. GridPanel, TabPanel, TreePanel, Toolbar,
 Menu, etc.). layout may be specified as either as an Object or as a String: Specify as an Object Example usage: layout:
 {
     type: 'vbox',
     padding: '5',
     align: 'left'
 } type The layout type to be used for this container. If not
 specified, a default Ext.layout.ContainerLayout will be created and used. Valid layout type values are: absolute
 accordion anchor auto Default border card column fit form hbox menu table toolbar vbox Layout specific configuration
 properties Additional layout specific configuration properties may also be specified. For complete details regarding the
 valid config options for each layout type, see the layout class corresponding to the type specified. Specify as a String
 Example usage: layout: 'vbox',
 layoutConfig: {
     padding: '5',
     align: 'left'
 } layout The layout type to be used
 for this container (see list of valid layout type values above). layoutConfig Additional layout specific configuration
 properties. For complete details regarding the valid config options for each layout type, see the layout class
 corresponding to the layout specified.]]></description><name>layout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout or one of the two BoxLayout subclasses. An object containing margins to apply to this BoxComponent in the
 format: {
     top: (top margin),
     right: (right margin),
     bottom: (bottom margin),
     left: (left margin)
 } May
 also be a string containing space-separated, numeric margin values. The order of the sides associated with each value
 matches the way CSS processes margin values: If there is only one value, it applies to all sides. If there are two
 values, the top and bottom borders are set to the first value and the right and left are set to the second. If there are
 three values, the top is set to the first value, the left and right are set to the second, and the bottom is set to the
 third. If there are four values, they apply to the top, right, bottom, and left, respectively. Defaults to: {top:0,
 right:0, bottom:0, left:0}]]></description><name>margins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to mask the panel when it is disabled, false to not mask it (defaults to true). Either way, the panel will always
 tell its contained elements to disable themselves when it is disabled, but masking the panel can provide an additional
 visual cue that the panel is disabled.]]></description><name>maskDisabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum width of the tip in pixels (defaults to 300). The maximum supported value is 500.]]></description><name>maxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Minimum width in pixels of all buttons in this panel (defaults to 75)]]></description><name>minButtonWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum width of the tip in pixels (defaults to 40).]]></description><name>minWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically monitor window resize events to handle anything that is sensitive to the current size of the
 viewport. This value is typically managed by the chosen layout and should not need to be set manually.]]></description><name>monitorResize</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An XY offset from the mouse position where the tooltip should be shown (defaults to [15,18]).]]></description><name>mouseOffset</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element when the mouse moves over the Element, and
 removed when the mouse moves out. (defaults to ''). This can be useful for adding customized 'active' or 'hover' styles
 to the component or any of its children using standard CSS rules.]]></description><name>overCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A shortcut for setting a padding style on the body element. The value can either be a number to be applied to all sides,
 or a normal css string describing padding. Defaults to undefined.]]></description><name>padding</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level x coordinate for this component if contained within a positioning container.]]></description><name>pageX</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level y coordinate for this component if contained within a positioning container.]]></description><name>pageY</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to false. When set to true, an extra css class 'x-panel-normal' will be added to the panel's element,
 effectively applying css styles suggested by the W3C (see http://www.w3.org/TR/CSS21/sample.html) to the Panel's body
 element (not the header, footer, etc.).]]></description><name>preventBodyReset</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered ptype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a Plugin is being specified not as a fully
 instantiated Component, but as a Component config object. The ptype will be looked up at render time up to determine
 what type of Plugin to create. If you create your own Plugins, you may register them using
 Ext.ComponentMgr.registerPlugin in order to be able to take advantage of lazy instantiation and rendering.]]></description><name>ptype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A path specification, relative to the Component's ownerCt specifying into which ancestor Container to place a named
 reference to this Component. The ancestor axis can be traversed by using '/' characters in the path. For example, to put
 a reference to a Toolbar Button into the Panel which owns the Toolbar: var myGrid = new Ext.grid.EditorGridPanel({
    
 title: 'My EditorGridPanel',
     store: myStore,
     colModel: myColModel,
     tbar: [{
         text: 'Save',
        
 handler: saveChanges,
         disabled: true,
         ref: '../saveButton'
     }],
     listeners: {
         afteredit:
 function() {
 //          The button reference is in the GridPanel
             myGrid.saveButton.enable();
         }
    
 }
 }); In the code above, if the ref had been 'saveButton' the reference would have been placed into the Toolbar. Each
 '/' in the ref moves up one level from the Component's ownerCt. Also see the added and removed events.]]></description><name>ref</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout layout manager (e.g. specifying layout:'border'). See Ext.layout.BorderLayout also.]]></description><name>region</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The event to listen to for resizing in layouts. Defaults to 'bodyresize'.]]></description><name>resizeEvent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True or "sides" for the default effect, "frame" for 4-way shadow, and "drop" for bottom-right shadow (defaults to
 "sides").]]></description><name>shadow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The number of pixels to offset the shadow if displayed (defaults to 4). Note that this option only applies when floating
 = true.]]></description><name>shadowOffset</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[false to disable the iframe shim in browsers which need one (defaults to true). Note that this option only applies when
 floating = true.]]></description><name>shim</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Delay in milliseconds before the tooltip displays after the mouse enters the target element (defaults to 500)]]></description><name>showDelay</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should trigger this component to save its state (defaults to none). stateEvents may
 be any type of event supported by this component, including browser or custom events (e.g., ['click',
 'customerchange']). See stateful for an explanation of saving and restoring Component state.]]></description><name>stateEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id for this component to use for state management purposes (defaults to the component id if one was set,
 otherwise null if the component is using a generated id). See stateful for an explanation of saving and restoring
 Component state.]]></description><name>stateId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A flag which causes the Component to attempt to restore the state of internal properties from a saved state on startup.
 The component must have either a stateId or id assigned for state to be managed. Auto-generated ids are not guaranteed
 to be stable across page loads and cannot be relied upon to save and restore the same state for a component. For state
 saving to work, the state manager's provider must have been set to an implementation of Ext.state.Provider which
 overrides the set and get methods to save and recall name/value pairs. A built-in implementation,
 Ext.state.CookieProvider is available. To set the state provider for the current page: Ext.state.Manager.setProvider(new
 Ext.state.CookieProvider({
     expires: new Date(new Date().getTime()+(1000*60*60*24*7)), //7 days from now
 })); A
 stateful Component attempts to save state when one of the events listed in the stateEvents configuration fires. To save
 state, a stateful Component first serializes its state by calling getState. By default, this function does nothing. The
 developer must provide an implementation which returns an object hash which represents the Component's restorable state.
 The value yielded by getState is passed to Ext.state.Manager.set which uses the configured Ext.state.Provider to save
 the object keyed by the Component's stateId, or, if that is not specified, its id. During construction, a stateful
 Component attempts to restore its state by calling Ext.state.Manager.get passing the stateId, or, if that is not
 specified, the id. The resulting object is passed to applyState. The default implementation of applyState simply copies
 properties into the object, but a developer may override this to support more behaviour. You can perform extra
 processing on state save and restore by attaching handlers to the beforestaterestore, staterestore, beforestatesave and
 statesave events.]]></description><name>stateful</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
     title: 'Some Title',
     renderTo: Ext.getBody(),
     width: 400, height:
 300,
     layout: 'form',
     items: [{
         xtype: 'textarea',
         style: {
             width: '95%',
            
 marginBottom: '10px'
         }
     },
         new Ext.Button({
             text: 'Send',
             minWidth: '100',
   
          style: {
                 marginBottom: '10px'
             }
         })
     ]
 });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is a child item of a TabPanel. A string to be used as innerHTML
 (html tags are accepted) to show in a tooltip when mousing over the associated tab selector element.
 Ext.QuickTips.init() must be called in order for the tips to render.]]></description><name>tabTip</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The target HTMLElement, Ext.Element or id to associate with this quicktip (defaults to the document).]]></description><name>target</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The title text to be used as innerHTML (html tags are accepted) to display in the panel header (defaults to ''). When a
 title is specified the header element will automatically be created and displayed unless header is explicitly set to
 false. If you do not want to specify a title at config time, but you may want one later, you must either specify a
 non-empty title (a blank space ' ' will do) or header:true so that the container element will get created.]]></description><name>title</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to allow expanding and collapsing the panel (when collapsible = true) by clicking anywhere in the header bar,
 false) to allow it only by clicking to tool button (defaults to false)). If this panel is a child item of a border
 layout also see the BorderLayout.Region floatable config option.]]></description><name>titleCollapse</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A Template used to create tools in the header Element. Defaults to: new Ext.Template('<div class="x-tool
 x-tool-{id}">&#160;</div>') This may may be overridden to provide a custom DOM structure for tools based upon a more
 complex XTemplate. The template's data is a single tool configuration object (Not the entire Array) as specified in
 tools. In the following example an <a> tag is used to provide a visual indication when hovering over the tool: var win =
 new Ext.Window({
     tools: [{
         id: 'download',
         href: '/MyPdfDoc.pdf'
     }],
     toolTemplate: new
 Ext.XTemplate(
         '<tpl if="id==\'download\'">',
             '<a class="x-tool x-tool-pdf" href="{href}"></a>',
    
 '</tpl>',
         '<tpl if="id!=\'download\'">',
             '<div class="x-tool x-tool-{id}">&#160;</div>',
        
 '</tpl>'
     ),
     width:500,
     height:300,
     closeAction:'hide'
 }); Note that the CSS class 'x-tool-pdf' should
 have an associated style rule which provides an appropriate background image, something like: a.x-tool-pdf
 {background-image: url(../shared/extjs/images/pdf.gif)!important;}]]></description><name>toolTemplate</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of tool button configs to be added to the header tool area. When rendered, each tool is stored as an Element
 referenced by a public property called tools.<tool-type> Each tool config may contain the following properties: id :
 String Required. The type of tool to create. By default, this assigns a CSS class of the form x-tool-<tool-type> to the
 resulting tool Element. Ext provides CSS rules, and an icon sprite containing images for the tool types listed below.
 The developer may implement custom tools by supplying alternate CSS rules and background images: toggle (Created by
 default when collapsible is true) close minimize maximize restore gear pin unpin right left up down refresh minus plus
 help search save print handler : Function Required. The function to call when clicked. Arguments passed are: event :
 Ext.EventObject The click event. toolEl : Ext.Element The tool Element. panel : Ext.Panel The host Panel tc : Object The
 tool configuration object stopEvent : Boolean Defaults to true. Specify as false to allow click event to propagate.
 scope : Object The scope in which to call the handler. qtip : String/Object A tip string, or a config argument to
 Ext.QuickTip.register hidden : Boolean True to initially render hidden. on : Object A listener config object specifiying
 event listeners in the format of an argument to addListener Note that, apart from the toggle tool which is provided when
 a panel is collapsible, these tools only provide the visual button. Any required functionality must be provided by
 adding handlers that implement the necessary behavior. Example usage: tools:[{
     id:'refresh',
     qtip: 'Refresh form
 Data',
     // hidden:true,
     handler: function(event, toolEl, panel){
         // refresh logic
     }
 },
 {
    
 id:'help',
     qtip: 'Get Help',
     handler: function(event, toolEl, panel){
         // whatever
     }
 }] For the
 custom id of 'help' define two relevant css classes with a link to a 15x15 image: .x-tool-help {background-image:
 url(images/help.png);}
 .x-tool-help-over {background-image: url(images/help_over.png);}
 // if using an image
 sprite:
 .x-tool-help {background-image: url(images/help.png) no-repeat 0 0;}
 .x-tool-help-over
 {background-position:-15px 0;}]]></description><name>tools</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to have the tooltip follow the mouse as it moves over the target element (defaults to false).]]></description><name>trackMouse</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Overrides the baseCls setting to baseCls = 'x-plain' which renders the panel unstyled except for required attributes for
 Ext layouts to function (e.g. overflow:hidden).]]></description><name>unstyled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Width in pixels of the tip (defaults to auto). Width will be ignored if it exceeds the bounds of minWidth or maxWidth.
 The maximum supported value is 500.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local x (left) coordinate for this component if contained within a positioning container.]]></description><name>x</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered xtype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a child item of a Container is being specified not
 as a fully instantiated Component, but as a Component config object. The xtype will be looked up at render time up to
 determine what type of child Component to create. The predefined xtypes are listed here. If you subclass Components to
 create your own Components, you may register them using Ext.ComponentMgr.registerType in order to be able to take
 advantage of lazy instantiation and rendering.]]></description><name>xtype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local y (top) coordinate for this component if contained within a positioning container.]]></description><name>y</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 Slider which supports vertical or horizontal orientation, keyboard adjustments, configurable snapping, axis clicking and
 animation. Can be added as an item to any container. Example usage: 
 <pre>
 new Ext.Slider({
     renderTo: Ext.getBody(),
     width: 200,
     value: 50,
     increment: 10,
     minValue: 0,
     maxValue: 100
 });
 </pre> Sliders
 can be created with more than one thumb handle by passing an array of values instead of a single one: 
 <pre>
 new
 Ext.Slider({
     renderTo: Ext.getBody(),
     width: 200,
     values: [25, 50, 75],
     minValue: 0,
     maxValue: 100,
 
     //this defaults to true, setting to false allows the thumbs to pass each other
     <a href="output/Ext.slider.MultiSlider.html#Ext.slider.MultiSlider-constrainThumbs" ext:member="constrainThumbs"
 ext:cls="Ext.slider.MultiSlider">constrainThumbs</a>: false
 });
 </pre>]]></description><name>slider.multi</name><tag-class>org.brushingbits.jnap.ui.extjs3.slider.MultiSlider</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[Whether the component can move the Dom node when rendering (defaults to true).]]></description><name>allowDomMove</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use an
 AnchorLayout (or subclass thereof). based layout manager, for example: Ext.form.FormPanel specifying layout: 'anchor' //
 or 'form', or 'absolute' See Ext.layout.AnchorLayout.anchor also.]]></description><name>anchor</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Turn on or off animation. Defaults to true]]></description><name>animate</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element corresponding to a DIV that is already present in
 the document that specifies some structural markup for this component. Description : When applyTo is used, constituent
 parts of the component can also be specified by id or CSS class name within the main element, and the component being
 created may attempt to create its subcomponents from that markup if applicable. Notes : When using this config, a call
 to render() is not required. If applyTo is specified, any value passed for renderTo will be ignored and the target
 element's parent node will automatically be used as the component's container.]]></description><name>applyTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A tag name or DomHelper spec used to create the Element which will encapsulate this Component. You do not normally need
 to specify this. For the base classes Ext.Component, Ext.BoxComponent, and Ext.Container, this defaults to 'div'. The
 more complex Ext classes use a more complex DOM structure created by their own onRender methods. This is intended to
 allow the developer to create application-specific utility Components encapsulated by different DOM elements. Example
 usage: <pre><code>{
     xtype: 'box',
     autoEl: {
         tag: 'img',
         src: 'http://www.example.com/example.jpg'
     }
 },
 {
     xtype: 'box',
     autoEl: {
         tag: 'blockquote',
         html: 'autoEl is cool!'
     }
 }, {
     xtype: 'container',
     autoEl: 'ul',
     cls: 'ux-unordered-list',
     items: {
         xtype: 'box',
         autoEl: 'li',
   
      html: 'First list item'
     }
 }</pre></code>]]></description><name>autoEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to use height:'auto', false to use fixed height (or allow it to be managed by its parent Container's layout
 manager. Defaults to false. Note: Although many components inherit this config option, not all will function as expected
 with a height of 'auto'. Setting autoHeight:true means that the browser will manage height based on the element's
 contents, and that Ext will not manage it at all. If the browser is managing the height, be aware that resizes performed
 by the browser in response to changes within the structure of the Component cannot be detected. Therefore changes to the
 height might result in elements needing to be synchronized with the new height. Example: var w = new Ext.Window({
    
 title: 'Window',
     width: 600,
     autoHeight: true,
     items: {
         title: 'Collapse Me',
         height: 400,
  
 collapsible: true,
         border: false,
         listeners: {
             beforecollapse: function() {
                w.el.shadow.hide();
             },
             beforeexpand: function() {
                w.el.shadow.hide();
             },
             collapse: function() {
                w.syncShadow();
             },
             expand: function() {
                w.syncShadow();
             }
         }
     }
 }).show();]]></description><name>autoHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to use overflow:'auto' on the components layout element and show scroll bars automatically when necessary, false to
 clip any overflowing content (defaults to false).]]></description><name>autoScroll</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True if the component should check for hidden classes (e.g. 'x-hidden' or 'x-hide-display') and remove them on render
 (defaults to false).]]></description><name>autoShow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to use width:'auto', false to use fixed width (or allow it to be managed by its parent Container's layout manager.
 Defaults to false. Note: Although many components inherit this config option, not all will function as expected with a
 width of 'auto'. Setting autoWidth:true means that the browser will manage width based on the element's contents, and
 that Ext will not manage it at all. If the browser is managing the width, be aware that resizes performed by the browser
 in response to changes within the structure of the Component cannot be detected. Therefore changes to the width might
 result in elements needing to be synchronized with the new width. For example, where the target element is: <div
 id='grid-container' style='margin-left:25%;width:50%'></div> A Panel rendered into that target element must listen for
 browser window resize in order to relay its child items when the browser changes its width: var myPanel = new
 Ext.Panel({
     renderTo: 'grid-container',
     monitorResize: true, // relay on browser resize
     title: 'Panel',
    
 height: 400,
     autoWidth: true,
     layout: 'hbox',
     layoutConfig: {
         align: 'stretch'
     },
     defaults: {
         flex: 1
     },
     items: [{
         title: 'Box 1',
     }, {
         title: 'Box 2'
     }, {
         title:
 'Box 3'
     }],
 });]]></description><name>autoWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to [].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class used to to apply to the special clearing div rendered directly after each form field wrapper to provide
 field clearing (defaults to 'x-form-clear-left'). Note: this config is only used when this Component is rendered by a
 Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or specifying
 layout:'form') and either a fieldLabel is specified or isFormField=true is specified. See Ext.layout.FormLayout.fieldTpl
 also.]]></description><name>clearCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Determines whether or not clicking on the Slider axis will change the slider. Defaults to true]]></description><name>clickToChange</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element (defaults to ''). This can be useful for
 adding customized styles to the component or any of its children using standard CSS rules.]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to disallow thumbs from overlapping one another. Defaults to true]]></description><name>constrainThumbs</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's container. This can be useful for adding customized
 styles to the container or any of its children using standard CSS rules. See Ext.layout.ContainerLayout.extraCls also.
 Note: ctCls defaults to '' except for the following class which assigns a value by default: Box Layout :
 'x-box-layout-ct' To configure the above Class with an extra CSS class append to the default. For example, for BoxLayout
 (Hbox and Vbox): ctCls: 'x-box-layout-ct custom-class']]></description><name>ctCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The number of decimal places to which to round the Slider's value. Defaults to 0. To disable rounding, configure as
 false.]]></description><name>decimalPrecision</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component disabled (default is false).]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class added to the component when it is disabled (defaults to 'x-item-disabled').]]></description><name>disabledClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The label text to display next to this Component (defaults to ''). Note: this config is only used when this Component is
 rendered by a Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or
 specifying layout:'form'). Also see hideLabel and Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
    
 height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name'
    
 }]
 });]]></description><name>fieldLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use a
 BoxLayout. Each child Component with a flex property will be flexed either vertically (by a VBoxLayout) or horizontally
 (by an HBoxLayout) according to the item's relative flex value compared to the sum of all Components with flex value
 specified. Any child items that have either a flex = 0 or flex = undefined will not be 'flexed' (the initial size will
 not be changed).]]></description><name>flex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component hidden (default is false). If true, the hide method will be called internally.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to completely hide the label element (label and separator). Defaults to false. By default, even if you do not
 specify a fieldLabel the space will still be reserved so that the field will line up with other fields that do have
 labels. Setting this to true will cause the field to not reserve that space. Note: see the note for clearCls. Example
 use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield'
        
 hideLabel: true
     }]
 });]]></description><name>hideLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[How this component should be hidden. Supported values are 'visibility' (css visibility), 'offsets' (negative offset
 position) and 'display' (css display). Note: the default of 'display' is generally preferred since items are
 automatically laid out when they are first shown (no sizing is done while hidden).]]></description><name>hideMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide and show the component's container when hide/show is called on the component, false to hide and show the
 component itself (defaults to false). For example, this can be used as a shortcut for a hide button on a window by
 setting hide:true on the button when adding it to its parent container.]]></description><name>hideParent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id of this component (defaults to an auto-assigned id). You should assign an id if you need to be able to
 access the component later and you do not have an object reference available (e.g., using Ext.getCmp). Note that this id
 will also be used as the element id for the containing HTML element that is rendered to the page for this component.
 This allows you to write id-based CSS rules to style the specific instance of this component uniquely, and also to
 select sub-elements using this component's id as the parent. Note: to avoid complications imposed by a unique id also
 see itemId and ref. Note: to access the container of an item see ownerCt.]]></description><name>id</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[How many units to change the slider when adjusting by drag and drop. Use this option to enable 'snapping'.]]></description><name>increment</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use the
 FormLayout layout manager (e.g. Ext.form.FormPanel or specifying layout:'form'). An additional CSS class to apply to the
 div wrapping the form item element of this field. If supplied, itemCls at the field level will override the default
 itemCls supplied at the container level. The value specified for itemCls will be added to the default class
 ('x-form-item'). Since it is applied to the item wrapper (see Ext.layout.FormLayout.fieldTpl), it allows you to write
 standard CSS rules that can apply to the field, the label (if specified), or any other element within the markup for the
 field. Note: see the note for fieldLabel. Example use: // Apply a style to the field's label:
 <style>
     .required
 .x-form-item-label {font-weight:bold;color:red;}
 </style>
 
 new Ext.FormPanel({
     height: 100,
     renderTo:
 Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         itemCls: 'required' //this
 label will be styled
     },{
         xtype: 'textfield',
         fieldLabel: 'Favorite Color'
     }]
 });]]></description><name>itemCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An itemId can be used as an alternative way to get a reference to a component when no object reference is available.
 Instead of using an id with Ext.getCmp, use itemId with Ext.Container.getComponent which will retrieve itemId's or id's.
 Since itemId's are an index to the container's internal MixedCollection, the itemId is scoped locally to the container
 -- avoiding potential conflicts with Ext.ComponentMgr which requires a unique id. var c = new Ext.Panel({ //
     height:
 300,
     renderTo: document.body,
     layout: 'auto',
     items: [
         {
             itemId: 'p1',
            
 title: 'Panel 1',
             height: 150
         },
         {
             itemId: 'p2',
             title: 'Panel 2',
  
 height: 150
         }
     ]
 })
 p1 = c.getComponent('p1'); // not the same as Ext.getCmp()
 p2 =
 p1.ownerCt.getComponent('p2'); // reference via a sibling Also see id and ref. Note: to access the container of an item
 see ownerCt.]]></description><name>itemId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[How many units to change the Slider when adjusting with keyboard navigation. Defaults to 1. If the increment config is
 larger, it will be used instead.]]></description><name>keyIncrement</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The separator to display after the text of each fieldLabel. This property may be configured at various levels. The order
 of precedence is: field / component level container level layout level (defaults to colon ':') To display no separator
 for this field's label specify empty string ''. Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 layoutConfig: {
         labelSeparator: '~'   // layout config has lowest priority (defaults to ':')
     },
    
 labelSeparator: '>>',     // config at container level
     items: [{
         xtype: 'textfield',
         fieldLabel:
 'Field 1',
         labelSeparator: '...' // field/component level config supersedes others
     },{
         xtype:
 'textfield',
         fieldLabel: 'Field 2' // labelSeparator will be '='
     }]
 });]]></description><name>labelSeparator</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS style specification string to apply directly to this field's label. Defaults to the container's labelStyle value
 if set (e.g., Ext.layout.FormLayout.labelStyle , or ''). Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         labelStyle: 'font-weight:bold;'
     }]
 });]]></description><name>labelStyle</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout or one of the two BoxLayout subclasses. An object containing margins to apply to this BoxComponent in the
 format: {
     top: (top margin),
     right: (right margin),
     bottom: (bottom margin),
     left: (left margin)
 } May
 also be a string containing space-separated, numeric margin values. The order of the sides associated with each value
 matches the way CSS processes margin values: If there is only one value, it applies to all sides. If there are two
 values, the top and bottom borders are set to the first value and the right and left are set to the second. If there are
 three values, the top is set to the first value, the left and right are set to the second, and the bottom is set to the
 third. If there are four values, they apply to the top, right, bottom, and left, respectively. Defaults to: {top:0,
 right:0, bottom:0, left:0}]]></description><name>margins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value for the Slider. Defaults to 100.]]></description><name>maxValue</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value for the Slider. Defaults to 0.]]></description><name>minValue</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element when the mouse moves over the Element, and
 removed when the mouse moves out. (defaults to ''). This can be useful for adding customized 'active' or 'hover' styles
 to the component or any of its children using standard CSS rules.]]></description><name>overCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level x coordinate for this component if contained within a positioning container.]]></description><name>pageX</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level y coordinate for this component if contained within a positioning container.]]></description><name>pageY</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered ptype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a Plugin is being specified not as a fully
 instantiated Component, but as a Component config object. The ptype will be looked up at render time up to determine
 what type of Plugin to create. If you create your own Plugins, you may register them using
 Ext.ComponentMgr.registerPlugin in order to be able to take advantage of lazy instantiation and rendering.]]></description><name>ptype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A path specification, relative to the Component's ownerCt specifying into which ancestor Container to place a named
 reference to this Component. The ancestor axis can be traversed by using '/' characters in the path. For example, to put
 a reference to a Toolbar Button into the Panel which owns the Toolbar: var myGrid = new Ext.grid.EditorGridPanel({
    
 title: 'My EditorGridPanel',
     store: myStore,
     colModel: myColModel,
     tbar: [{
         text: 'Save',
        
 handler: saveChanges,
         disabled: true,
         ref: '../saveButton'
     }],
     listeners: {
         afteredit:
 function() {
 //          The button reference is in the GridPanel
             myGrid.saveButton.enable();
         }
    
 }
 }); In the code above, if the ref had been 'saveButton' the reference would have been placed into the Toolbar. Each
 '/' in the ref moves up one level from the Component's ownerCt. Also see the added and removed events.]]></description><name>ref</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout layout manager (e.g. specifying layout:'border'). See Ext.layout.BorderLayout also.]]></description><name>region</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should trigger this component to save its state (defaults to none). stateEvents may
 be any type of event supported by this component, including browser or custom events (e.g., ['click',
 'customerchange']). See stateful for an explanation of saving and restoring Component state.]]></description><name>stateEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id for this component to use for state management purposes (defaults to the component id if one was set,
 otherwise null if the component is using a generated id). See stateful for an explanation of saving and restoring
 Component state.]]></description><name>stateId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A flag which causes the Component to attempt to restore the state of internal properties from a saved state on startup.
 The component must have either a stateId or id assigned for state to be managed. Auto-generated ids are not guaranteed
 to be stable across page loads and cannot be relied upon to save and restore the same state for a component. For state
 saving to work, the state manager's provider must have been set to an implementation of Ext.state.Provider which
 overrides the set and get methods to save and recall name/value pairs. A built-in implementation,
 Ext.state.CookieProvider is available. To set the state provider for the current page: Ext.state.Manager.setProvider(new
 Ext.state.CookieProvider({
     expires: new Date(new Date().getTime()+(1000*60*60*24*7)), //7 days from now
 })); A
 stateful Component attempts to save state when one of the events listed in the stateEvents configuration fires. To save
 state, a stateful Component first serializes its state by calling getState. By default, this function does nothing. The
 developer must provide an implementation which returns an object hash which represents the Component's restorable state.
 The value yielded by getState is passed to Ext.state.Manager.set which uses the configured Ext.state.Provider to save
 the object keyed by the Component's stateId, or, if that is not specified, its id. During construction, a stateful
 Component attempts to restore its state by calling Ext.state.Manager.get passing the stateId, or, if that is not
 specified, the id. The resulting object is passed to applyState. The default implementation of applyState simply copies
 properties into the object, but a developer may override this to support more behaviour. You can perform extra
 processing on state save and restore by attaching handlers to the beforestaterestore, staterestore, beforestatesave and
 statesave events.]]></description><name>stateful</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
     title: 'Some Title',
     renderTo: Ext.getBody(),
     width: 400, height:
 300,
     layout: 'form',
     items: [{
         xtype: 'textarea',
         style: {
             width: '95%',
            
 marginBottom: '10px'
         }
     },
         new Ext.Button({
             text: 'Send',
             minWidth: '100',
   
          style: {
                 marginBottom: '10px'
             }
         })
     ]
 });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is a child item of a TabPanel. A string to be used as innerHTML
 (html tags are accepted) to show in a tooltip when mousing over the associated tab selector element.
 Ext.QuickTips.init() must be called in order for the tips to render.]]></description><name>tabTip</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The value to initialize the slider with. Defaults to minValue.]]></description><name>value</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Orient the Slider vertically rather than horizontally, defaults to false.]]></description><name>vertical</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local x (left) coordinate for this component if contained within a positioning container.]]></description><name>x</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered xtype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a child item of a Container is being specified not
 as a fully instantiated Component, but as a Component config object. The xtype will be looked up at render time up to
 determine what type of child Component to create. The predefined xtypes are listed here. If you subclass Components to
 create your own Components, you may register them using Ext.ComponentMgr.registerType in order to be able to take
 advantage of lazy instantiation and rendering.]]></description><name>xtype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local y (top) coordinate for this component if contained within a positioning container.]]></description><name>y</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 Represents a single thumb element on a Slider. This would not usually be created manually and would instead be created
 internally by an 
 <a href="output/Ext.slider.MultiSlider.html" ext:cls="Ext.slider.MultiSlider">Ext.Slider</a>.]]></description><name>slider.thumb</name><tag-class>org.brushingbits.jnap.ui.extjs3.slider.Thumb</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[True to constrain the thumb so that it cannot overlap its siblings]]></description><name>constrain</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Slider to render to (required)]]></description><name>slider</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 A split button that provides a built-in dropdown arrow that can fire an event separately from the default click event of
 the button. Typically this would be used to display a dropdown menu that provides additional options to the primary
 button action, but any custom handler can provide the arrowclick implementation. Example usage: 
 <pre><code><i>//
 display a dropdown menu:</i>
 <b>new</b> Ext.SplitButton({
 	renderTo: <em>'button-ct'</em>, <i>// the container id</i>
   
 	text: <em>'Options'</em>,
    	handler: optionsHandler, <i>// handle a click on the button itself</i>
    	menu:
 <b>new</b> Ext.menu.Menu({
         items: [
         	<i>// these items will render as dropdown menu items when the arrow
 is clicked:</i>
 	        {text: <em>'Item 1'</em>, handler: item1Handler},
 	        {text: <em>'Item 2'</em>, handler:
 item2Handler}
         ]
    	})
 });
 
 <i>// Instead of showing a menu, you provide any type of custom</i>
 <i>//
 functionality you want when the dropdown arrow is clicked:</i>
 <b>new</b> Ext.SplitButton({
 	renderTo:
 <em>'button-ct'</em>,
    	text: <em>'Options'</em>,
    	handler: optionsHandler,
    	arrowHandler:
 myCustomHandler
 });</code></pre>]]></description><name>splitButton</name><tag-class>org.brushingbits.jnap.ui.extjs3.SplitButton</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[False to not allow a pressed Button to be depressed (defaults to undefined). Only valid when enableToggle is true.]]></description><name>allowDepress</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Whether the component can move the Dom node when rendering (defaults to true).]]></description><name>allowDomMove</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use an
 AnchorLayout (or subclass thereof). based layout manager, for example: Ext.form.FormPanel specifying layout: 'anchor' //
 or 'form', or 'absolute' See Ext.layout.AnchorLayout.anchor also.]]></description><name>anchor</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element corresponding to a DIV that is already present in
 the document that specifies some structural markup for this component. Description : When applyTo is used, constituent
 parts of the component can also be specified by id or CSS class name within the main element, and the component being
 created may attempt to create its subcomponents from that markup if applicable. Notes : When using this config, a call
 to render() is not required. If applyTo is specified, any value passed for renderTo will be ignored and the target
 element's parent node will automatically be used as the component's container.]]></description><name>applyTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[(Optional) The side of the Button box to render the arrow if the button has an associated menu. Two values are allowed:
 'right' 'bottom' Defaults to 'right' .]]></description><name>arrowAlign</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A function called when the arrow button is clicked (can be used instead of click event)]]></description><name>arrowHandler</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The title attribute of the arrow]]></description><name>arrowTooltip</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A tag name or DomHelper spec used to create the Element which will encapsulate this Component. You do not normally need
 to specify this. For the base classes Ext.Component, Ext.BoxComponent, and Ext.Container, this defaults to 'div'. The
 more complex Ext classes use a more complex DOM structure created by their own onRender methods. This is intended to
 allow the developer to create application-specific utility Components encapsulated by different DOM elements. Example
 usage: <pre><code>{
     xtype: 'box',
     autoEl: {
         tag: 'img',
         src: 'http://www.example.com/example.jpg'
     }
 },
 {
     xtype: 'box',
     autoEl: {
         tag: 'blockquote',
         html: 'autoEl is cool!'
     }
 }, {
     xtype: 'container',
     autoEl: 'ul',
     cls: 'ux-unordered-list',
     items: {
         xtype: 'box',
         autoEl: 'li',
   
      html: 'First list item'
     }
 }</pre></code>]]></description><name>autoEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to use height:'auto', false to use fixed height (or allow it to be managed by its parent Container's layout
 manager. Defaults to false. Note: Although many components inherit this config option, not all will function as expected
 with a height of 'auto'. Setting autoHeight:true means that the browser will manage height based on the element's
 contents, and that Ext will not manage it at all. If the browser is managing the height, be aware that resizes performed
 by the browser in response to changes within the structure of the Component cannot be detected. Therefore changes to the
 height might result in elements needing to be synchronized with the new height. Example: var w = new Ext.Window({
    
 title: 'Window',
     width: 600,
     autoHeight: true,
     items: {
         title: 'Collapse Me',
         height: 400,
  
 collapsible: true,
         border: false,
         listeners: {
             beforecollapse: function() {
                w.el.shadow.hide();
             },
             beforeexpand: function() {
                w.el.shadow.hide();
             },
             collapse: function() {
                w.syncShadow();
             },
             expand: function() {
                w.syncShadow();
             }
         }
     }
 }).show();]]></description><name>autoHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to use overflow:'auto' on the components layout element and show scroll bars automatically when necessary, false to
 clip any overflowing content (defaults to false).]]></description><name>autoScroll</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True if the component should check for hidden classes (e.g. 'x-hidden' or 'x-hide-display') and remove them on render
 (defaults to false).]]></description><name>autoShow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[By default, if a width is not specified the button will attempt to stretch horizontally to fit its content. If the
 button is being managed by a width sizing layout (hbox, fit, anchor), set this to false to prevent the button from doing
 this automatic sizing. Defaults to undefined .]]></description><name>autoWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to [].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[(Optional) A DomQuery selector which is used to extract the active, clickable element from the DOM structure created.
 When a custom template is used, you must ensure that this selector results in the selection of a focussable element.
 Defaults to 'button:first-child' .]]></description><name>buttonSelector</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class used to to apply to the special clearing div rendered directly after each form field wrapper to provide
 field clearing (defaults to 'x-form-clear-left'). Note: this config is only used when this Component is rendered by a
 Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or specifying
 layout:'form') and either a fieldLabel is specified or isFormField=true is specified. See Ext.layout.FormLayout.fieldTpl
 also.]]></description><name>clearCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The DOM event that will fire the handler of the button. This can be any valid event name (dblclick, contextmenu).
 Defaults to 'click' .]]></description><name>clickEvent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS class string to apply to the button's main element.]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's container. This can be useful for adding customized
 styles to the container or any of its children using standard CSS rules. See Ext.layout.ContainerLayout.extraCls also.
 Note: ctCls defaults to '' except for the following class which assigns a value by default: Box Layout :
 'x-box-layout-ct' To configure the above Class with an extra CSS class append to the default. For example, for BoxLayout
 (Hbox and Vbox): ctCls: 'x-box-layout-ct custom-class']]></description><name>ctCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to start disabled (defaults to false)]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class added to the component when it is disabled (defaults to 'x-item-disabled').]]></description><name>disabledClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to enable pressed/not pressed toggling (defaults to false)]]></description><name>enableToggle</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The label text to display next to this Component (defaults to ''). Note: this config is only used when this Component is
 rendered by a Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or
 specifying layout:'form'). Also see hideLabel and Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
    
 height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name'
    
 }]
 });]]></description><name>fieldLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use a
 BoxLayout. Each child Component with a flex property will be flexed either vertically (by a VBoxLayout) or horizontally
 (by an HBoxLayout) according to the item's relative flex value compared to the sum of all Components with flex value
 specified. Any child items that have either a flex = 0 or flex = undefined will not be 'flexed' (the initial size will
 not be changed).]]></description><name>flex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[False to disable visual cues on mouseover, mouseout and mousedown (defaults to true)]]></description><name>handleMouseEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A function called when the button is clicked (can be used instead of click event). The handler is passed the following
 parameters: b : Button This Button. e : EventObject The click event.]]></description><name>handler</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to start hidden (defaults to false)]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to completely hide the label element (label and separator). Defaults to false. By default, even if you do not
 specify a fieldLabel the space will still be reserved so that the field will line up with other fields that do have
 labels. Setting this to true will cause the field to not reserve that space. Note: see the note for clearCls. Example
 use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield'
        
 hideLabel: true
     }]
 });]]></description><name>hideLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[How this component should be hidden. Supported values are 'visibility' (css visibility), 'offsets' (negative offset
 position) and 'display' (css display). Note: the default of 'display' is generally preferred since items are
 automatically laid out when they are first shown (no sizing is done while hidden).]]></description><name>hideMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide and show the component's container when hide/show is called on the component, false to hide and show the
 component itself (defaults to false). For example, this can be used as a shortcut for a hide button on a window by
 setting hide:true on the button when adding it to its parent container.]]></description><name>hideParent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The path to an image to display in the button (the image will be set as the background-image CSS property of the button
 by default, so if you want a mixed icon/text button, set cls:'x-btn-text-icon')]]></description><name>icon</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[(Optional) The side of the Button box to render the icon. Four values are allowed: 'top' 'right' 'bottom' 'left'
 Defaults to 'left' .]]></description><name>iconAlign</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A css class which sets a background image to be used as the icon for this button]]></description><name>iconCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id of this component (defaults to an auto-assigned id). You should assign an id if you need to be able to
 access the component later and you do not have an object reference available (e.g., using Ext.getCmp). Note that this id
 will also be used as the element id for the containing HTML element that is rendered to the page for this component.
 This allows you to write id-based CSS rules to style the specific instance of this component uniquely, and also to
 select sub-elements using this component's id as the parent. Note: to avoid complications imposed by a unique id also
 see itemId and ref. Note: to access the container of an item see ownerCt.]]></description><name>id</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use the
 FormLayout layout manager (e.g. Ext.form.FormPanel or specifying layout:'form'). An additional CSS class to apply to the
 div wrapping the form item element of this field. If supplied, itemCls at the field level will override the default
 itemCls supplied at the container level. The value specified for itemCls will be added to the default class
 ('x-form-item'). Since it is applied to the item wrapper (see Ext.layout.FormLayout.fieldTpl), it allows you to write
 standard CSS rules that can apply to the field, the label (if specified), or any other element within the markup for the
 field. Note: see the note for fieldLabel. Example use: // Apply a style to the field's label:
 <style>
     .required
 .x-form-item-label {font-weight:bold;color:red;}
 </style>
 
 new Ext.FormPanel({
     height: 100,
     renderTo:
 Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         itemCls: 'required' //this
 label will be styled
     },{
         xtype: 'textfield',
         fieldLabel: 'Favorite Color'
     }]
 });]]></description><name>itemCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An itemId can be used as an alternative way to get a reference to a component when no object reference is available.
 Instead of using an id with Ext.getCmp, use itemId with Ext.Container.getComponent which will retrieve itemId's or id's.
 Since itemId's are an index to the container's internal MixedCollection, the itemId is scoped locally to the container
 -- avoiding potential conflicts with Ext.ComponentMgr which requires a unique id. var c = new Ext.Panel({ //
     height:
 300,
     renderTo: document.body,
     layout: 'auto',
     items: [
         {
             itemId: 'p1',
            
 title: 'Panel 1',
             height: 150
         },
         {
             itemId: 'p2',
             title: 'Panel 2',
  
 height: 150
         }
     ]
 })
 p1 = c.getComponent('p1'); // not the same as Ext.getCmp()
 p2 =
 p1.ownerCt.getComponent('p2'); // reference via a sibling Also see id and ref. Note: to access the container of an item
 see ownerCt.]]></description><name>itemId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The separator to display after the text of each fieldLabel. This property may be configured at various levels. The order
 of precedence is: field / component level container level layout level (defaults to colon ':') To display no separator
 for this field's label specify empty string ''. Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 layoutConfig: {
         labelSeparator: '~'   // layout config has lowest priority (defaults to ':')
     },
    
 labelSeparator: '>>',     // config at container level
     items: [{
         xtype: 'textfield',
         fieldLabel:
 'Field 1',
         labelSeparator: '...' // field/component level config supersedes others
     },{
         xtype:
 'textfield',
         fieldLabel: 'Field 2' // labelSeparator will be '='
     }]
 });]]></description><name>labelSeparator</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS style specification string to apply directly to this field's label. Defaults to the container's labelStyle value
 if set (e.g., Ext.layout.FormLayout.labelStyle , or ''). Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         labelStyle: 'font-weight:bold;'
     }]
 });]]></description><name>labelStyle</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout or one of the two BoxLayout subclasses. An object containing margins to apply to this BoxComponent in the
 format: {
     top: (top margin),
     right: (right margin),
     bottom: (bottom margin),
     left: (left margin)
 } May
 also be a string containing space-separated, numeric margin values. The order of the sides associated with each value
 matches the way CSS processes margin values: If there is only one value, it applies to all sides. If there are two
 values, the top and bottom borders are set to the first value and the right and left are set to the second. If there are
 three values, the top is set to the first value, the left and right are set to the second, and the bottom is set to the
 third. If there are four values, they apply to the top, right, bottom, and left, respectively. Defaults to: {top:0,
 right:0, bottom:0, left:0}]]></description><name>margins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Standard menu attribute consisting of a reference to a menu object, a menu id or a menu config blob (defaults to
 undefined).]]></description><name>menu</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The position to align the menu to (see Ext.Element.alignTo for more details, defaults to 'tl-bl?').]]></description><name>menuAlign</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum width for this button (used to give a set of buttons a common width). See also Ext.Panel. minButtonWidth .]]></description><name>minWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element when the mouse moves over the Element, and
 removed when the mouse moves out. (defaults to ''). This can be useful for adding customized 'active' or 'hover' styles
 to the component or any of its children using standard CSS rules.]]></description><name>overCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If used in a Toolbar, the text to be used if this item is shown in the overflow menu. See also Ext.Toolbar.Item.
 overflowText .]]></description><name>overflowText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level x coordinate for this component if contained within a positioning container.]]></description><name>pageX</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level y coordinate for this component if contained within a positioning container.]]></description><name>pageY</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to start pressed (only if enableToggle = true)]]></description><name>pressed</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered ptype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a Plugin is being specified not as a fully
 instantiated Component, but as a Component config object. The ptype will be looked up at render time up to determine
 what type of Plugin to create. If you create your own Plugins, you may register them using
 Ext.ComponentMgr.registerPlugin in order to be able to take advantage of lazy instantiation and rendering.]]></description><name>ptype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A path specification, relative to the Component's ownerCt specifying into which ancestor Container to place a named
 reference to this Component. The ancestor axis can be traversed by using '/' characters in the path. For example, to put
 a reference to a Toolbar Button into the Panel which owns the Toolbar: var myGrid = new Ext.grid.EditorGridPanel({
    
 title: 'My EditorGridPanel',
     store: myStore,
     colModel: myColModel,
     tbar: [{
         text: 'Save',
        
 handler: saveChanges,
         disabled: true,
         ref: '../saveButton'
     }],
     listeners: {
         afteredit:
 function() {
 //          The button reference is in the GridPanel
             myGrid.saveButton.enable();
         }
    
 }
 }); In the code above, if the ref had been 'saveButton' the reference would have been placed into the Toolbar. Each
 '/' in the ref moves up one level from the Component's ownerCt. Also see the added and removed events.]]></description><name>ref</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout layout manager (e.g. specifying layout:'border'). See Ext.layout.BorderLayout also.]]></description><name>region</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to repeat fire the click event while the mouse is down. This can also be a ClickRepeater config object (defaults to
 false).]]></description><name>repeat</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[(Optional) The size of the Button. Three values are allowed: 'small' Results in the button element being 16px high.
 'medium' Results in the button element being 24px high. 'large' Results in the button element being 32px high. Defaults
 to 'small' .]]></description><name>scale</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The scope ( this reference) in which the handler and toggleHandler is executed. Defaults to this Button.]]></description><name>scope</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should trigger this component to save its state (defaults to none). stateEvents may
 be any type of event supported by this component, including browser or custom events (e.g., ['click',
 'customerchange']). See stateful for an explanation of saving and restoring Component state.]]></description><name>stateEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id for this component to use for state management purposes (defaults to the component id if one was set,
 otherwise null if the component is using a generated id). See stateful for an explanation of saving and restoring
 Component state.]]></description><name>stateId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A flag which causes the Component to attempt to restore the state of internal properties from a saved state on startup.
 The component must have either a stateId or id assigned for state to be managed. Auto-generated ids are not guaranteed
 to be stable across page loads and cannot be relied upon to save and restore the same state for a component. For state
 saving to work, the state manager's provider must have been set to an implementation of Ext.state.Provider which
 overrides the set and get methods to save and recall name/value pairs. A built-in implementation,
 Ext.state.CookieProvider is available. To set the state provider for the current page: Ext.state.Manager.setProvider(new
 Ext.state.CookieProvider({
     expires: new Date(new Date().getTime()+(1000*60*60*24*7)), //7 days from now
 })); A
 stateful Component attempts to save state when one of the events listed in the stateEvents configuration fires. To save
 state, a stateful Component first serializes its state by calling getState. By default, this function does nothing. The
 developer must provide an implementation which returns an object hash which represents the Component's restorable state.
 The value yielded by getState is passed to Ext.state.Manager.set which uses the configured Ext.state.Provider to save
 the object keyed by the Component's stateId, or, if that is not specified, its id. During construction, a stateful
 Component attempts to restore its state by calling Ext.state.Manager.get passing the stateId, or, if that is not
 specified, the id. The resulting object is passed to applyState. The default implementation of applyState simply copies
 properties into the object, but a developer may override this to support more behaviour. You can perform extra
 processing on state save and restore by attaching handlers to the beforestaterestore, staterestore, beforestatesave and
 statesave events.]]></description><name>stateful</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
     title: 'Some Title',
     renderTo: Ext.getBody(),
     width: 400, height:
 300,
     layout: 'form',
     items: [{
         xtype: 'textarea',
         style: {
             width: '95%',
            
 marginBottom: '10px'
         }
     },
         new Ext.Button({
             text: 'Send',
             minWidth: '100',
   
          style: {
                 marginBottom: '10px'
             }
         })
     ]
 });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Set a DOM tabIndex for this button (defaults to undefined)]]></description><name>tabIndex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is a child item of a TabPanel. A string to be used as innerHTML
 (html tags are accepted) to show in a tooltip when mousing over the associated tab selector element.
 Ext.QuickTips.init() must be called in order for the tips to render.]]></description><name>tabTip</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A Template used to create the Button's DOM structure. Instances, or subclasses which need a different DOM structure may
 provide a different template layout in conjunction with an implementation of getTemplateArgs.]]></description><name>template</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The button text to be used as innerHTML (html tags are accepted)]]></description><name>text</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The group this toggle button is a member of (only 1 per group can be pressed)]]></description><name>toggleGroup</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Function called when a Button with enableToggle set to true is clicked. Two arguments are passed: button : Ext.Button
 this Button object state : Boolean The next state of the Button, true means pressed.]]></description><name>toggleHandler</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The tooltip for the button - can be a string to be used as innerHTML (html tags are accepted) or QuickTips config object]]></description><name>tooltip</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The type of tooltip to use. Either 'qtip' (default) for QuickTips or 'title' for title attribute.]]></description><name>tooltipType</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[submit, reset or button - defaults to 'button']]></description><name>type</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local x (left) coordinate for this component if contained within a positioning container.]]></description><name>x</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered xtype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a child item of a Container is being specified not
 as a fully instantiated Component, but as a Component config object. The xtype will be looked up at render time up to
 determine what type of child Component to create. The predefined xtypes are listed here. If you subclass Components to
 create your own Components, you may register them using Ext.ComponentMgr.registerType in order to be able to take
 advantage of lazy instantiation and rendering.]]></description><name>xtype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local y (top) coordinate for this component if contained within a positioning container.]]></description><name>y</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 <p>A basic tab container. TabPanels can be used exactly like a standard <a href="output/Ext.Panel.html"
 ext:cls="Ext.Panel">Ext.Panel</a> for layout purposes, but also have special support for containing child Components
 (<tt><a href="output/Ext.Container.html#Ext.Container-items" ext:member="items" ext:cls="Ext.Container">items</a></tt>)
 that are managed using a <a href="output/Ext.layout.CardLayout.html" ext:cls="Ext.layout.CardLayout">CardLayout layout
 manager</a>, and displayed as separate tabs.</p> 
 <b>Note:</b> By default, a tab's close tool 
 <i>destroys</i> the child
 tab Component and all its descendants. This makes the child tab Component, and all its descendants 
 <b>unusable</b>. To
 enable re-use of a tab, configure the TabPanel with 
 <b><code><a
 href="output/Ext.TabPanel.html#Ext.TabPanel-autoDestroy" ext:member="autoDestroy" ext:cls="Ext.TabPanel">autoDestroy:
 false</a></code></b>. 
 <p><b><u>TabPanel header/footer elements</u></b></p> 
 <p>TabPanels use their <a
 href="output/Ext.Panel.html#Ext.Panel-header" ext:member="header" ext:cls="Ext.Panel">header</a> or <a
 href="output/Ext.Panel.html#Ext.Panel-footer" ext:member="footer" ext:cls="Ext.Panel">footer</a> element (depending on
 the <a href="output/Ext.TabPanel.html#Ext.TabPanel-tabPosition" ext:member="tabPosition"
 ext:cls="Ext.TabPanel">tabPosition</a> configuration) to accommodate the tab selector buttons. This means that a
 TabPanel will not display any configured title, and will not display any configured header <a
 href="output/Ext.Panel.html#Ext.Panel-tools" ext:member="tools" ext:cls="Ext.Panel">tools</a>.</p> 
 <p>To display a
 header, embed the TabPanel in a <a href="output/Ext.Panel.html" ext:cls="Ext.Panel">Panel</a> which uses <b><tt><a
 href="output/Ext.Container.html#Ext.Container-layout" ext:member="layout"
 ext:cls="Ext.Container">layout:'fit'</a></tt></b>.</p> 
 <p><b><u>Tab Events</u></b></p> 
 <p>There is no actual tab class
 - each tab is simply a <a href="output/Ext.BoxComponent.html" ext:cls="Ext.BoxComponent">Component</a> such as a <a
 href="output/Ext.Panel.html" ext:cls="Ext.Panel">Panel</a>. However, when rendered in a TabPanel, each child Component
 can fire additional events that only exist for tabs and are not available from other Components. These events are:</p>
 
 <div>
  <ul class="mdetail-params"> 
   <li><tt><b><a href="output/Ext.Panel.html#Ext.Panel-activate"
 ext:member="activate" ext:cls="Ext.Panel">activate</a></b></tt> : Fires when this Component becomes the active tab.</li>
 
   <li><tt><b><a href="output/Ext.Panel.html#Ext.Panel-deactivate" ext:member="deactivate"
 ext:cls="Ext.Panel">deactivate</a></b></tt> : Fires when the Component that was the active tab becomes deactivated.</li>
 
   <li><tt><b><a href="output/Ext.Panel.html#Ext.Panel-beforeclose" ext:member="beforeclose"
 ext:cls="Ext.Panel">beforeclose</a></b></tt> : Fires when the user clicks on the close tool of a closeable tab. May be
 vetoed by returning <code>false</code> from a handler.</li> 
   <li><tt><b><a
 href="output/Ext.Panel.html#Ext.Panel-close" ext:member="close" ext:cls="Ext.Panel">close</a></b></tt> : Fires a
 closeable tab has been closed by the user.</li> 
  </ul>
 </div> 
 <p><b><u>Creating TabPanels from Code</u></b></p>
 
 <p>TabPanels can be created and rendered completely in code, as in this example:</p> 
 <pre><code><b>var</b> tabs =
 <b>new</b> Ext.TabPanel({
     renderTo: Ext.getBody(),
     activeTab: 0,
     items: [{
         title: <em>'Tab 1'</em>,
 
 html: <em>'A simple tab'</em>
     },{
         title: <em>'Tab 2'</em>,
         html: <em>'Another one'</em>
    
 }]
 });</code></pre> 
 <p><b><u>Creating TabPanels from Existing Markup</u></b></p> 
 <p>TabPanels can also be rendered
 from pre-existing markup in a couple of ways.</p> 
 <div>
  <ul class="mdetail-params"> 
   <li>Pre-Structured Markup</li>
 
   <div class="sub-desc"> 
    <p>A container div with one or more nested tab divs with class <tt>'x-tab'</tt> can be
 rendered entirely from existing markup (See the <a href="output/Ext.TabPanel.html#Ext.TabPanel-autoTabs"
 ext:member="autoTabs" ext:cls="Ext.TabPanel">autoTabs</a> example).</p> 
   </div> 
   <li>Un-Structured Markup</li> 
  
 <div class="sub-desc"> 
    <p>A TabPanel can also be rendered from markup that is not strictly structured by simply
 specifying by id which elements should be the container and the tabs. Using this method tab content can be pulled from
 different elements within the page by id regardless of page structure. For example:</p> 
    <pre><code><b>var</b> tabs =
 <b>new</b> Ext.TabPanel({
     renderTo: <em>'my-tabs'</em>,
     activeTab: 0,
     items:[
        
 {contentEl:<em>'tab1'</em>, title:<em>'Tab 1'</em>},
         {contentEl:<em>'tab2'</em>, title:<em>'Tab 2'</em>}
    
 ]
 });
 
 <i>// Note that the tabs <b>do</b> not have to be nested within the container (although they can be)</i>
 &lt;div
 id=<em>&quot;my-tabs&quot;</em>&gt;&lt;/div&gt;
 &lt;div id=<em>&quot;tab1&quot;</em>
 class=<em>&quot;x-hide-display&quot;</em>&gt;A simple tab&lt;/div&gt;
 &lt;div id=<em>&quot;tab2&quot;</em>
 class=<em>&quot;x-hide-display&quot;</em>&gt;Another one&lt;/div&gt;</code></pre> Note that the tab divs in this example
 contain the class 
    <tt>'x-hide-display'</tt> so that they can be rendered deferred without displaying outside the
 tabs. You could alternately set 
    <tt><a href="output/Ext.TabPanel.html#Ext.TabPanel-deferredRender"
 ext:member="deferredRender" ext:cls="Ext.TabPanel">deferredRender</a> = false </tt> to render all content tabs on page
 load. 
   </div> 
  </ul>
 </div>]]></description><name>tabPanel</name><tag-class>org.brushingbits.jnap.ui.extjs3.TabPanel</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[A string component id or the numeric index of the component that should be initially activated within the container's
 layout on render. For example, activeItem: 'item-1' or activeItem: 0 (index 0 = the first item in the container's
 collection). activeItem only applies to layout styles that can display items one at a time (like
 Ext.layout.AccordionLayout, Ext.layout.CardLayout and Ext.layout.FitLayout). Related to
 Ext.layout.ContainerLayout.activeItem.]]></description><name>activeItem</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A string id or the numeric index of the tab that should be initially activated on render (defaults to undefined).]]></description><name>activeTab</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Whether the component can move the Dom node when rendering (defaults to true).]]></description><name>allowDomMove</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use an
 AnchorLayout (or subclass thereof). based layout manager, for example: Ext.form.FormPanel specifying layout: 'anchor' //
 or 'form', or 'absolute' See Ext.layout.AnchorLayout.anchor also.]]></description><name>anchor</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to animate the transition when the panel is collapsed, false to skip the animation (defaults to true if the Ext.Fx
 class is available, otherwise false).]]></description><name>animCollapse</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to animate tab scrolling so that hidden tabs slide smoothly into view (defaults to true). Only applies when
 enableTabScroll = true.]]></description><name>animScroll</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The id of the node, a DOM node or an existing Element corresponding to a DIV that is already present in the document
 that specifies some panel-specific structural markup. When applyTo is used, constituent parts of the panel can be
 specified by CSS class name within the main element, and the panel will automatically create those components from that
 markup. Any required components not specified in the markup will be autogenerated if necessary. The following class
 names are supported (baseCls will be replaced by baseCls): baseCls + '-header' baseCls + '-header-text' baseCls +
 '-bwrap' baseCls + '-tbar' baseCls + '-body' baseCls + '-bbar' baseCls + '-footer' Using this config, a call to render()
 is not required. If applyTo is specified, any value passed for renderTo will be ignored and the target element's parent
 node will automatically be used as the panel's container.]]></description><name>applyTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If true the container will automatically destroy any contained component that is removed from it, else destruction must
 be handled manually (defaults to true).]]></description><name>autoDestroy</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A tag name or DomHelper spec used to create the Element which will encapsulate this Component. You do not normally need
 to specify this. For the base classes Ext.Component, Ext.BoxComponent, and Ext.Container, this defaults to 'div'. The
 more complex Ext classes use a more complex DOM structure created by their own onRender methods. This is intended to
 allow the developer to create application-specific utility Components encapsulated by different DOM elements. Example
 usage: <pre><code>{
     xtype: 'box',
     autoEl: {
         tag: 'img',
         src: 'http://www.example.com/example.jpg'
     }
 },
 {
     xtype: 'box',
     autoEl: {
         tag: 'blockquote',
         html: 'autoEl is cool!'
     }
 }, {
     xtype: 'container',
     autoEl: 'ul',
     cls: 'ux-unordered-list',
     items: {
         xtype: 'box',
         autoEl: 'li',
   
      html: 'First list item'
     }
 }</pre></code>]]></description><name>autoEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to use height:'auto', false to use fixed height (defaults to false). Note: Setting autoHeight: true means that the
 browser will manage the panel's height based on its contents, and that Ext will not manage it at all. If the panel is
 within a layout that manages dimensions (fit, border, etc.) then setting autoHeight: true can cause issues with
 scrolling and will not generally work as expected since the panel will take on the height of its contents rather than
 the height required by the Ext layout.]]></description><name>autoHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A valid url spec according to the Updater Ext.Updater.update method. If autoLoad is not null, the panel will attempt to
 load its contents immediately upon render. The URL will become the default URL for this panel's body element, so it may
 be refreshed at any time.]]></description><name>autoLoad</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to use overflow:'auto' on the components layout element and show scroll bars automatically when necessary, false to
 clip any overflowing content (defaults to false).]]></description><name>autoScroll</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True if the component should check for hidden classes (e.g. 'x-hidden' or 'x-hide-display') and remove them on render
 (defaults to false).]]></description><name>autoShow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS selector used to search for tabs in existing markup when autoTabs = true (defaults to 'div.x-tab'). This can be
 any valid selector supported by Ext.DomQuery.select. Note that the query will be executed within the scope of this tab
 panel only (so that multiple tab panels from markup can be supported on a page).]]></description><name>autoTabSelector</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to query the DOM for any divs with a class of 'x-tab' to be automatically converted to tabs and added to this panel
 (defaults to false). Note that the query will be executed within the scope of the container element only (so that
 multiple tab panels from markup can be supported via this method). This method is only possible when the markup is
 structured correctly as a container with nested divs containing the class 'x-tab'. To create TabPanels without these
 limitations, or to pull tab content from other elements on the page, see the example at the top of the class for
 generating tabs from markup. There are a couple of things to note when using this method: When using the autoTabs config
 (as opposed to passing individual tab configs in the TabPanel's items collection), you must use applyTo to correctly use
 the specified id as the tab container. The autoTabs method replaces existing content with the TabPanel components. Make
 sure that you set deferredRender: false so that the content elements for each tab will be rendered into the TabPanel
 immediately upon page load, otherwise they will not be transformed until each tab is activated and will be visible
 outside the TabPanel. Example usage: var tabs = new Ext.TabPanel({
     applyTo: 'my-tabs',
     activeTab: 0,
    
 deferredRender: false,
     autoTabs: true
 });
 
 // This markup will be converted to a TabPanel from the code above
 <div
 id="my-tabs">
     <div class="x-tab" title="Tab 1">A simple tab</div>
     <div class="x-tab" title="Tab 2">Another
 one</div>
 </div>]]></description><name>autoTabs</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to use width:'auto', false to use fixed width (or allow it to be managed by its parent Container's layout manager.
 Defaults to false. Note: Although many components inherit this config option, not all will function as expected with a
 width of 'auto'. Setting autoWidth:true means that the browser will manage width based on the element's contents, and
 that Ext will not manage it at all. If the browser is managing the width, be aware that resizes performed by the browser
 in response to changes within the structure of the Component cannot be detected. Therefore changes to the width might
 result in elements needing to be synchronized with the new width. For example, where the target element is: <div
 id='grid-container' style='margin-left:25%;width:50%'></div> A Panel rendered into that target element must listen for
 browser window resize in order to relay its child items when the browser changes its width: var myPanel = new
 Ext.Panel({
     renderTo: 'grid-container',
     monitorResize: true, // relay on browser resize
     title: 'Panel',
    
 height: 400,
     autoWidth: true,
     layout: 'hbox',
     layoutConfig: {
         align: 'stretch'
     },
     defaults: {
         flex: 1
     },
     items: [{
         title: 'Box 1',
     }, {
         title: 'Box 2'
     }, {
         title:
 'Box 3'
     }],
 });]]></description><name>autoWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The base CSS class applied to the panel (defaults to 'x-tab-panel').]]></description><name>baseCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to display an interior border on the body element of the panel, false to hide it (defaults to true). This only
 applies when border == true. If border == true and bodyBorder == false, the border will display as a 1px wide inset
 border, giving the entire body element an inset appearance.]]></description><name>bodyBorder</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A DomHelper element specification object may be specified for any Panel Element. By default, the Default element in the
 table below will be used for the html markup to create a child element with the commensurate Default class name (baseCls
 will be replaced by baseCls): 
 Panel      Default  Default             Custom      Additional       Additional
 Element  
 element  class               element     class            style
 ========   ==========================   =========  
 ==============   ===========
 header     div      baseCls+'-header'   headerCfg   headerCssClass   headerStyle
 bwrap     
 div      baseCls+'-bwrap'     bwrapCfg    bwrapCssClass    bwrapStyle
 + tbar     div      baseCls+'-tbar'       tbarCfg 
 tbarCssClass     tbarStyle
 + body     div      baseCls+'-body'       bodyCfg     bodyCssClass     bodyStyle
 + bbar    
 div      baseCls+'-bbar'       bbarCfg     bbarCssClass     bbarStyle
 + footer   div      baseCls+'-footer'   footerCfg 
 footerCssClass   footerStyle
  Configuring a Custom element may be used, for example, to force the body Element to use a
 different form of markup than is created by default. An example of this might be to create a child Panel containing a
 custom content, such as a header, or forcing centering of all Panel content by having the body be a <center> element:
 new Ext.Panel({
     title: 'Message Title',
     renderTo: Ext.getBody(),
     width: 200, height: 130,
     bodyCfg: {
    
 tag: 'center',
         cls: 'x-panel-body',  // Default class not applied if Custom element specified
         html:
 'Message'
     },
     footerCfg: {
         tag: 'h2',
         cls: 'x-panel-footer',        // same as the Default class
 
 html: 'footer html'
     },
     footerCssClass: 'custom-footer', // additional css class, see addClass
     footerStyle:  
 'background-color:red' // see bodyStyle
 }); The example above also explicitly creates a footer with custom markup and
 styling applied.]]></description><name>bodyCfg</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Additional css class selector to be applied to the body element in the format expected by Ext.Element.addClass (defaults
 to null). See bodyCfg.]]></description><name>bodyCssClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Custom CSS styles to be applied to the body element in the format expected by Ext.Element.applyStyles (defaults to
 null). See bodyCfg.]]></description><name>bodyStyle</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to display the borders of the panel's body element, false to hide them (defaults to true). By default, the border
 is a 2px wide inset border, but this can be further altered by setting bodyBorder to false.]]></description><name>border</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to ['add', 'remove'].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[When set to true (50 milliseconds) or a number of milliseconds, the layout assigned for this container will buffer the
 frequency it calculates and does a re-layout of components. This is useful for heavy containers or containers with a
 large quantity of sub-components for which frequent layout calls would be expensive. Defaults to 50.]]></description><name>bufferResize</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The alignment of any buttons added to this panel. Valid values are 'right', 'left' and 'center' (defaults to 'right').]]></description><name>buttonAlign</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A DomHelper element specification object specifying the element structure of this Panel's bwrap Element. See bodyCfg
 also.]]></description><name>bwrapCfg</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class used to to apply to the special clearing div rendered directly after each form field wrapper to provide
 field clearing (defaults to 'x-form-clear-left'). Note: this config is only used when this Component is rendered by a
 Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or specifying
 layout:'form') and either a fieldLabel is specified or isFormField=true is specified. See Ext.layout.FormLayout.fieldTpl
 also.]]></description><name>clearCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Panels themselves do not directly support being closed, but some Panel subclasses do (like Ext.Window) or a Panel Class
 within an Ext.TabPanel. Specify true to enable closing in such situations. Defaults to false.]]></description><name>closable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element (defaults to ''). This can be useful for
 adding customized styles to the component or any of its children using standard CSS rules.]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to make sure the collapse/expand toggle button always renders first (to the left of) any other tools in the panel's
 title bar, false to render it last (defaults to true).]]></description><name>collapseFirst</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to render the panel collapsed, false to render it expanded (defaults to false).]]></description><name>collapsed</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS class to add to the panel's element after it has been collapsed (defaults to 'x-panel-collapsed').]]></description><name>collapsedCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to make the panel collapsible and have the expand/collapse toggle button automatically rendered into the header
 tool button area, false to keep the panel statically sized with no button (defaults to false).]]></description><name>collapsible</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's container. This can be useful for adding customized
 styles to the container or any of its children using standard CSS rules. See Ext.layout.ContainerLayout.extraCls also.
 Note: ctCls defaults to '' except for the following class which assigns a value by default: Box Layout :
 'x-box-layout-ct' To configure the above Class with an extra CSS class append to the default. For example, for BoxLayout
 (Hbox and Vbox): ctCls: 'x-box-layout-ct custom-class']]></description><name>ctCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default xtype of child Components to create in this Container when a child item is specified as a raw configuration
 object, rather than as an instantiated Component. Defaults to 'panel', except Ext.menu.Menu which defaults to
 'menuitem', and Ext.Toolbar and Ext.ButtonGroup which default to 'button'.]]></description><name>defaultType</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[This option is a means of applying default settings to all added items whether added through the items config or via the
 add or insert methods. If an added item is a config object, and not an instantiated Component, then the default
 properties are unconditionally applied. If the added item is an instantiated Component, then the default properties are
 applied conditionally so as not to override existing properties in the item. If the defaults option is specified as a
 function, then the function will be called using this Container as the scope (this reference) and passing the added item
 as the first parameter. Any resulting object from that call is then applied to the item as default properties. For
 example, to automatically apply padding to the body of each of a set of contained Ext.Panel items, you could pass:
 defaults: {bodyStyle:'padding:15px'}. Usage: defaults: {               // defaults are applied to items, not the
 container
     autoScroll:true
 },
 items: [
     {
         xtype: 'panel',   // defaults do not have precedence over
       
 id: 'panel1',     // options in config objects, so the defaults
         autoScroll: false // will not be applied here,
 panel1 will be autoScroll:false
     },
     new Ext.Panel({       // defaults do have precedence over options
         id:
 'panel2',     // options in components, so the defaults
         autoScroll: false // will be applied here, panel2 will
 be autoScroll:true.
     })
 ]]]></description><name>defaults</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true by default to defer the rendering of child items to the browsers DOM until a tab is activated. false will render
 all contained items as soon as the layout is rendered. If there is a significant amount of content or a lot of heavy
 controls being rendered into panels that are not displayed by default, setting this to true might improve performance.
 The deferredRender property is internally passed to the layout manager for TabPanels (Ext.layout.CardLayout) as its
 Ext.layout.CardLayout.deferredRender configuration value. Note: leaving deferredRender as true means that the content
 within an unactivated tab will not be available. For example, this means that if the TabPanel is within a form, then
 until a tab is activated, any Fields within unactivated tabs will not be rendered, and will therefore not be submitted
 and will not be available to either getValues or setValues.]]></description><name>deferredRender</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this panel disabled (default is false). An important note when using the disabled config on panels is that IE
 will often fail to initialize the disabled mask element correectly if the panel's layout has not yet completed by the
 time the Panel is disabled during the render process. If you experience this issue, you may need to instead use the
 afterlayout event to initialize the disabled state: new Ext.Panel({
     ...
     listeners: {
         'afterlayout': {
   
 fn: function(p){
                 p.disable();
             },
             single: true // important, as many layouts can
 occur
         }
     }
 });]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class added to the component when it is disabled (defaults to 'x-item-disabled').]]></description><name>disabledClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to enable dragging of this Panel (defaults to false). For custom drag/drop implementations, an Ext.Panel.DD config
 could also be passed in this config instead of true. Ext.Panel.DD is an internal, undocumented class which moves a proxy
 Element around in place of the Panel's element, but provides no other behaviour during dragging or on drop. It is a
 subclass of Ext.dd.DragSource, so behaviour may be added by implementing the interface methods of Ext.dd.DragDrop e.g.:
 new Ext.Panel({
     title: 'Drag me',
     x: 100,
     y: 100,
     renderTo: Ext.getBody(),
     floating: true,
    
 frame: true,
     width: 400,
     height: 200,
     draggable: {
 //      Config option of Ext.Panel.DD class.
 //      It's
 a floating Panel, so do not show a placeholder proxy in the original position.
         insertProxy: false,
 
 //     
 Called for each mousemove event while dragging the DD object.
         onDrag : function(e){
 //          Record the x,y
 position of the drag proxy so that we can
 //          position the Panel at end of drag.
             var pel =
 this.proxy.getEl();
             this.x = pel.getLeft(true);
             this.y = pel.getTop(true);
 
 //          Keep the
 Shadow aligned if there is one.
             var s = this.panel.getEl().shadow;
             if (s) {
                
 s.realign(this.x, this.y, pel.getWidth(), pel.getHeight());
             }
         },
 
 //      Called on the mouseup
 event.
         endDrag : function(e){
             this.panel.setPosition(this.x, this.y);
         }
     }
 }).show();]]></description><name>draggable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A comma-delimited list of panel elements to initialize when the panel is rendered. Normally, this list will be generated
 automatically based on the items added to the panel at config time, but sometimes it might be useful to make sure a
 structural element is rendered even if not specified at config time (for example, you may want to add a button or
 toolbar dynamically after the panel has been rendered). Adding those elements to this list will allocate the required
 placeholders in the panel when it is rendered. Valid values are header tbar (top bar) body bbar (bottom bar) footer
 Defaults to 'body'.]]></description><name>elements</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to enable scrolling to tabs that may be invisible due to overflowing the overall TabPanel width. Only available
 with tabPosition:'top' (defaults to false).]]></description><name>enableTabScroll</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A Toolbar object, a Toolbar config, or an array of Buttons/Button configs, describing a Toolbar to be rendered into this
 Panel's footer element. After render, the fbar property will be an Toolbar instance. If buttons are specified, they will
 supersede the fbar configuration property. The Panel's buttonAlign configuration affects the layout of these items, for
 example: var w = new Ext.Window({
     height: 250,
     width: 500,
     bbar: new Ext.Toolbar({
         items: [{
        
 text: 'bbar Left'
         },'->',{
             text: 'bbar Right'
         }]
     }),
     buttonAlign: 'left', //
 anything but 'center' or 'right' and you can use '-', and '->'
                                   // to control the
 alignment of fbar items
     fbar: [{
         text: 'fbar Left'
     },'->',{
         text: 'fbar Right'
     }]
 }).show();
 Note: Although a Toolbar may contain Field components, these will not be updated by a load of an ancestor FormPanel. A
 Panel's toolbars are not part of the standard Container->Component hierarchy, and so are not scanned to collect form
 items. However, the values will be submitted because form submission parameters are collected from the DOM tree.]]></description><name>fbar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The label text to display next to this Component (defaults to ''). Note: this config is only used when this Component is
 rendered by a Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or
 specifying layout:'form'). Also see hideLabel and Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
    
 height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name'
    
 }]
 });]]></description><name>fieldLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use a
 BoxLayout. Each child Component with a flex property will be flexed either vertically (by a VBoxLayout) or horizontally
 (by an HBoxLayout) according to the item's relative flex value compared to the sum of all Components with flex value
 specified. Any child items that have either a flex = 0 or flex = undefined will not be 'flexed' (the initial size will
 not be changed).]]></description><name>flex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[This property is used to configure the underlying Ext.Layer. Acceptable values for this configuration property are:
 false : Default. Display the panel inline where it is rendered. true : Float the panel (absolute position it with
 automatic shimming and shadow). Setting floating to true will create an Ext.Layer for this panel and display the panel
 at negative offsets so that it is hidden. Since the panel will be absolute positioned, the position must be set
 explicitly after render (e.g., myPanel.setPosition(100,100);). Note: when floating a panel you should always assign a
 fixed width, otherwise it will be auto width and will expand to fill to the right edge of the viewport. object : The
 specified object will be used as the configuration object for the Ext.Layer that will be created.]]></description><name>floating</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to create the footer element explicitly, false to skip creating it. The footer will be created automatically if
 buttons or a fbar have been configured. See bodyCfg for an example.]]></description><name>footer</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A DomHelper element specification object specifying the element structure of this Panel's footer Element. See bodyCfg
 also.]]></description><name>footerCfg</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If true the container will force a layout initially even if hidden or collapsed. This option is useful for forcing forms
 to render in collapsed or hidden containers. (defaults to false).]]></description><name>forceLayout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[false by default to render with plain 1px square borders. true to render with 9 elements, complete with custom rounded
 corners (also see Ext.Element.boxWrap). The template generated for each condition is depicted below: // frame =
 false
 <div id="developer-specified-id-goes-here" class="x-panel">
 
     <div class="x-panel-header"><span
 class="x-panel-header-text">Title: (frame:false)</span></div>
 
     <div class="x-panel-bwrap">
         <div
 class="x-panel-body"><p>html value goes here</p></div>
     </div>
 </div>
 
 // frame = true (create 9 elements)
 <div
 id="developer-specified-id-goes-here" class="x-panel">
     <div class="x-panel-tl"><div class="x-panel-tr"><div
 class="x-panel-tc">
         <div class="x-panel-header"><span class="x-panel-header-text">Title:
 (frame:true)</span></div>
     </div></div></div>
 
     <div class="x-panel-bwrap">
         <div class="x-panel-ml"><div
 class="x-panel-mr"><div class="x-panel-mc">
             <div class="x-panel-body"><p>html value goes here</p></div>
     
 </div></div></div>
 
         <div class="x-panel-bl"><div class="x-panel-br"><div class="x-panel-bc"/>
        
 </div></div></div>
 </div>]]></description><name>frame</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to create the Panel's header element explicitly, false to skip creating it. If a title is set the header will be
 created automatically, otherwise it will not. If a title is set but header is explicitly set to false, the header will
 not be rendered.]]></description><name>header</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to display the panel title in the header, false to hide it (defaults to true).]]></description><name>headerAsText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A DomHelper element specification object specifying the element structure of this Panel's header Element. See bodyCfg
 also.]]></description><name>headerCfg</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component hidden (default is false). If true, the hide method will be called internally.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide the borders of each contained component, false to defer to the component's existing border settings
 (defaults to false).]]></description><name>hideBorders</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to hide the expand/collapse toggle button when collapsible == true, false to display it (defaults to false).]]></description><name>hideCollapseTool</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to completely hide the label element (label and separator). Defaults to false. By default, even if you do not
 specify a fieldLabel the space will still be reserved so that the field will line up with other fields that do have
 labels. Setting this to true will cause the field to not reserve that space. Note: see the note for clearCls. Example
 use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield'
        
 hideLabel: true
     }]
 });]]></description><name>hideLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[How this component should be hidden. Supported values are 'visibility' (css visibility), 'offsets' (negative offset
 position) and 'display' (css display). Note: the default of 'display' is generally preferred since items are
 automatically laid out when they are first shown (no sizing is done while hidden).]]></description><name>hideMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide and show the component's container when hide/show is called on the component, false to hide and show the
 component itself (defaults to false). For example, this can be used as a shortcut for a hide button on a window by
 setting hide:true on the button when adding it to its parent container.]]></description><name>hideParent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class selector that specifies a background image to be used as the header icon (defaults to ''). An example of
 specifying a custom icon class would be something like: // specify the property in the config for the class:
      ...
   
 iconCls: 'my-icon'
 
 // css class that specifies background image to be used as the icon image:
 .my-icon {
 background-image: url(../images/my-icon.gif) 0 6px no-repeat !important; }]]></description><name>iconCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id of this component (defaults to an auto-assigned id). You should assign an id if you need to be able to
 access the component later and you do not have an object reference available (e.g., using Ext.getCmp). Note that this id
 will also be used as the element id for the containing HTML element that is rendered to the page for this component.
 This allows you to write id-based CSS rules to style the specific instance of this component uniquely, and also to
 select sub-elements using this component's id as the parent. Note: to avoid complications imposed by a unique id also
 see itemId and ref. Note: to access the container of an item see ownerCt.]]></description><name>id</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use the
 FormLayout layout manager (e.g. Ext.form.FormPanel or specifying layout:'form'). An additional CSS class to apply to the
 div wrapping the form item element of this field. If supplied, itemCls at the field level will override the default
 itemCls supplied at the container level. The value specified for itemCls will be added to the default class
 ('x-form-item'). Since it is applied to the item wrapper (see Ext.layout.FormLayout.fieldTpl), it allows you to write
 standard CSS rules that can apply to the field, the label (if specified), or any other element within the markup for the
 field. Note: see the note for fieldLabel. Example use: // Apply a style to the field's label:
 <style>
     .required
 .x-form-item-label {font-weight:bold;color:red;}
 </style>
 
 new Ext.FormPanel({
     height: 100,
     renderTo:
 Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         itemCls: 'required' //this
 label will be styled
     },{
         xtype: 'textfield',
         fieldLabel: 'Favorite Color'
     }]
 });]]></description><name>itemCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An itemId can be used as an alternative way to get a reference to a component when no object reference is available.
 Instead of using an id with Ext.getCmp, use itemId with Ext.Container.getComponent which will retrieve itemId's or id's.
 Since itemId's are an index to the container's internal MixedCollection, the itemId is scoped locally to the container
 -- avoiding potential conflicts with Ext.ComponentMgr which requires a unique id. var c = new Ext.Panel({ //
     height:
 300,
     renderTo: document.body,
     layout: 'auto',
     items: [
         {
             itemId: 'p1',
            
 title: 'Panel 1',
             height: 150
         },
         {
             itemId: 'p2',
             title: 'Panel 2',
  
 height: 150
         }
     ]
 })
 p1 = c.getComponent('p1'); // not the same as Ext.getCmp()
 p2 =
 p1.ownerCt.getComponent('p2'); // reference via a sibling Also see id and ref. Note: to access the container of an item
 see ownerCt.]]></description><name>itemId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[(Optional) A Template or XTemplate which may be provided to process the data object returned from getTemplateArgs to
 produce a clickable selector element in the tab strip. The main element created should be a <li> element. In order for a
 click event on a selector element to be connected to its item, it must take its id from the TabPanel's native
 getTemplateArgs. The child element which contains the title text must be marked by the CSS class x-tab-strip-inner. To
 enable closability, the created element should contain an element marked by the CSS class x-tab-strip-close. If a custom
 itemTpl is supplied, it is the developer's responsibility to create CSS style rules to create the desired appearance.
 Below is an example of how to create customized tab selector items: new Ext.TabPanel({
     renderTo: document.body,
    
 minTabWidth: 115,
     tabWidth: 135,
     enableTabScroll: true,
     width: 600,
     height: 250,
     defaults:
 {autoScroll:true},
     itemTpl: new Ext.XTemplate(
     '<li class="{cls}" id="{id}" style="overflow:hidden">',
         
 '<tpl if="closable">',
             '<a class="x-tab-strip-close"></a>',
          '</tpl>',
          '<a
 class="x-tab-right" href="#" style="padding-left:6px">',
             '<em class="x-tab-left">',
                 '<span
 class="x-tab-strip-inner">',
                     '<img src="{src}" style="float:left;margin:3px 3px 0 0">',
             
 '<span style="margin-left:20px" class="x-tab-strip-text {iconCls}">{text} {extra}</span>',
                 '</span>',
   
 '</em>',
         '</a>',
     '</li>'
     ),
     getTemplateArgs: function(item) {
 //      Call the native method to
 collect the base data. Like the ID!
         var result = Ext.TabPanel.prototype.getTemplateArgs.call(this, item);
 
 //   
 Add stuff used in our template
         return Ext.apply(result, {
             closable: item.closable,
             src:
 item.iconSrc,
             extra: item.extraText || ''
         });
     },
     items: [{
         title: 'New Tab 1',
      
 iconSrc: '../shared/icons/fam/grid.png',
         html: 'Tab Body 1',
         closable: true
     }, {
         title: 'New
 Tab 2',
         iconSrc: '../shared/icons/fam/grid.png',
         html: 'Tab Body 2',
         extraText: 'Extra stuff in
 the tab button'
     }]
 });]]></description><name>itemTpl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A Ext.KeyMap config object (in the format expected by Ext.KeyMap.addBinding used to assign custom key handling to this
 panel (defaults to null).]]></description><name>keys</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The separator to display after the text of each fieldLabel. This property may be configured at various levels. The order
 of precedence is: field / component level container level layout level (defaults to colon ':') To display no separator
 for this field's label specify empty string ''. Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 layoutConfig: {
         labelSeparator: '~'   // layout config has lowest priority (defaults to ':')
     },
    
 labelSeparator: '>>',     // config at container level
     items: [{
         xtype: 'textfield',
         fieldLabel:
 'Field 1',
         labelSeparator: '...' // field/component level config supersedes others
     },{
         xtype:
 'textfield',
         fieldLabel: 'Field 2' // labelSeparator will be '='
     }]
 });]]></description><name>labelSeparator</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS style specification string to apply directly to this field's label. Defaults to the container's labelStyle value
 if set (e.g., Ext.layout.FormLayout.labelStyle , or ''). Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         labelStyle: 'font-weight:bold;'
     }]
 });]]></description><name>labelStyle</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[*Important: In order for child items to be correctly sized and positioned, typically a layout manager must be specified
 through the layout configuration option. The sizing and positioning of child items is the responsibility of the
 Container's layout manager which creates and manages the type of layout you have in mind. For example:
 <pre><code>
 new Ext.Window({
 
 width:300, height: 300,
     layout: 'fit', // explicitly set layout manager: override the default (layout:'auto')
    
 items: [{
         title: 'Panel inside a Window'
     }]
 }).show();</pre></code>
 If the layout configuration is not explicitly
 specified for a general purpose container (e.g. Container or Panel) the default layout manager will be used which does
 nothing but render child components sequentially into the Container (no sizing or positioning will be performed in this
 situation). Some container classes implicitly specify a default layout (e.g. FormPanel specifies layout:'form'). Other
 specific purpose classes internally specify/manage their internal layout (e.g. GridPanel, TabPanel, TreePanel, Toolbar,
 Menu, etc.). layout may be specified as either as an Object or as a String: Specify as an Object Example usage: layout:
 {
     type: 'vbox',
     padding: '5',
     align: 'left'
 } type The layout type to be used for this container. If not
 specified, a default Ext.layout.ContainerLayout will be created and used. Valid layout type values are: absolute
 accordion anchor auto Default border card column fit form hbox menu table toolbar vbox Layout specific configuration
 properties Additional layout specific configuration properties may also be specified. For complete details regarding the
 valid config options for each layout type, see the layout class corresponding to the type specified. Specify as a String
 Example usage: layout: 'vbox',
 layoutConfig: {
     padding: '5',
     align: 'left'
 } layout The layout type to be used
 for this container (see list of valid layout type values above). layoutConfig Additional layout specific configuration
 properties. For complete details regarding the valid config options for each layout type, see the layout class
 corresponding to the layout specified.]]></description><name>layout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Set to true to force a layout of the active tab when the tab is changed. Defaults to false. See
 Ext.layout.CardLayout.layoutOnCardChange.]]></description><name>layoutOnTabChange</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout or one of the two BoxLayout subclasses. An object containing margins to apply to this BoxComponent in the
 format: {
     top: (top margin),
     right: (right margin),
     bottom: (bottom margin),
     left: (left margin)
 } May
 also be a string containing space-separated, numeric margin values. The order of the sides associated with each value
 matches the way CSS processes margin values: If there is only one value, it applies to all sides. If there are two
 values, the top and bottom borders are set to the first value and the right and left are set to the second. If there are
 three values, the top is set to the first value, the left and right are set to the second, and the bottom is set to the
 third. If there are four values, they apply to the top, right, bottom, and left, respectively. Defaults to: {top:0,
 right:0, bottom:0, left:0}]]></description><name>margins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to mask the panel when it is disabled, false to not mask it (defaults to true). Either way, the panel will always
 tell its contained elements to disable themselves when it is disabled, but masking the panel can provide an additional
 visual cue that the panel is disabled.]]></description><name>maskDisabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Minimum width in pixels of all buttons in this panel (defaults to 75)]]></description><name>minButtonWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum width in pixels for each tab when resizeTabs = true (defaults to 30).]]></description><name>minTabWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically monitor window resize events to handle anything that is sensitive to the current size of the
 viewport. This value is typically managed by the chosen layout and should not need to be set manually.]]></description><name>monitorResize</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element when the mouse moves over the Element, and
 removed when the mouse moves out. (defaults to ''). This can be useful for adding customized 'active' or 'hover' styles
 to the component or any of its children using standard CSS rules.]]></description><name>overCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A shortcut for setting a padding style on the body element. The value can either be a number to be applied to all sides,
 or a normal css string describing padding. Defaults to undefined.]]></description><name>padding</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level x coordinate for this component if contained within a positioning container.]]></description><name>pageX</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level y coordinate for this component if contained within a positioning container.]]></description><name>pageY</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to render the tab strip without a background container image (defaults to false).]]></description><name>plain</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to false. When set to true, an extra css class 'x-panel-normal' will be added to the panel's element,
 effectively applying css styles suggested by the W3C (see http://www.w3.org/TR/CSS21/sample.html) to the Panel's body
 element (not the header, footer, etc.).]]></description><name>preventBodyReset</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered ptype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a Plugin is being specified not as a fully
 instantiated Component, but as a Component config object. The ptype will be looked up at render time up to determine
 what type of Plugin to create. If you create your own Plugins, you may register them using
 Ext.ComponentMgr.registerPlugin in order to be able to take advantage of lazy instantiation and rendering.]]></description><name>ptype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A path specification, relative to the Component's ownerCt specifying into which ancestor Container to place a named
 reference to this Component. The ancestor axis can be traversed by using '/' characters in the path. For example, to put
 a reference to a Toolbar Button into the Panel which owns the Toolbar: var myGrid = new Ext.grid.EditorGridPanel({
    
 title: 'My EditorGridPanel',
     store: myStore,
     colModel: myColModel,
     tbar: [{
         text: 'Save',
        
 handler: saveChanges,
         disabled: true,
         ref: '../saveButton'
     }],
     listeners: {
         afteredit:
 function() {
 //          The button reference is in the GridPanel
             myGrid.saveButton.enable();
         }
    
 }
 }); In the code above, if the ref had been 'saveButton' the reference would have been placed into the Toolbar. Each
 '/' in the ref moves up one level from the Component's ownerCt. Also see the added and removed events.]]></description><name>ref</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout layout manager (e.g. specifying layout:'border'). See Ext.layout.BorderLayout also.]]></description><name>region</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The event to listen to for resizing in layouts. Defaults to 'bodyresize'.]]></description><name>resizeEvent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically resize each tab so that the tabs will completely fill the tab strip (defaults to false). Setting
 this to true may cause specific widths that might be set per tab to be overridden in order to fit them all into view
 (although minTabWidth will always be honored).]]></description><name>resizeTabs</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The number of milliseconds that each scroll animation should last (defaults to .35). Only applies when animScroll =
 true.]]></description><name>scrollDuration</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The number of pixels to scroll each time a tab scroll button is pressed (defaults to 100, or if resizeTabs = true, the
 calculated tab width). Only applies when enableTabScroll = true.]]></description><name>scrollIncrement</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Number of milliseconds between each scroll while a tab scroll button is continuously pressed (defaults to 400).]]></description><name>scrollRepeatInterval</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true (or a valid Ext.Shadow Ext.Shadow.mode value) to display a shadow behind the panel, false to display no shadow
 (defaults to 'sides'). Note that this option only applies when floating = true.]]></description><name>shadow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The number of pixels to offset the shadow if displayed (defaults to 4). Note that this option only applies when floating
 = true.]]></description><name>shadowOffset</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[false to disable the iframe shim in browsers which need one (defaults to true). Note that this option only applies when
 floating = true.]]></description><name>shim</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should trigger this component to save its state (defaults to none). stateEvents may
 be any type of event supported by this component, including browser or custom events (e.g., ['click',
 'customerchange']). See stateful for an explanation of saving and restoring Component state.]]></description><name>stateEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id for this component to use for state management purposes (defaults to the component id if one was set,
 otherwise null if the component is using a generated id). See stateful for an explanation of saving and restoring
 Component state.]]></description><name>stateId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A flag which causes the Component to attempt to restore the state of internal properties from a saved state on startup.
 The component must have either a stateId or id assigned for state to be managed. Auto-generated ids are not guaranteed
 to be stable across page loads and cannot be relied upon to save and restore the same state for a component. For state
 saving to work, the state manager's provider must have been set to an implementation of Ext.state.Provider which
 overrides the set and get methods to save and recall name/value pairs. A built-in implementation,
 Ext.state.CookieProvider is available. To set the state provider for the current page: Ext.state.Manager.setProvider(new
 Ext.state.CookieProvider({
     expires: new Date(new Date().getTime()+(1000*60*60*24*7)), //7 days from now
 })); A
 stateful Component attempts to save state when one of the events listed in the stateEvents configuration fires. To save
 state, a stateful Component first serializes its state by calling getState. By default, this function does nothing. The
 developer must provide an implementation which returns an object hash which represents the Component's restorable state.
 The value yielded by getState is passed to Ext.state.Manager.set which uses the configured Ext.state.Provider to save
 the object keyed by the Component's stateId, or, if that is not specified, its id. During construction, a stateful
 Component attempts to restore its state by calling Ext.state.Manager.get passing the stateId, or, if that is not
 specified, the id. The resulting object is passed to applyState. The default implementation of applyState simply copies
 properties into the object, but a developer may override this to support more behaviour. You can perform extra
 processing on state save and restore by attaching handlers to the beforestaterestore, staterestore, beforestatesave and
 statesave events.]]></description><name>stateful</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
     title: 'Some Title',
     renderTo: Ext.getBody(),
     width: 400, height:
 300,
     layout: 'form',
     items: [{
         xtype: 'textarea',
         style: {
             width: '95%',
            
 marginBottom: '10px'
         }
     },
         new Ext.Button({
             text: 'Send',
             minWidth: '100',
   
          style: {
                 marginBottom: '10px'
             }
         })
     ]
 });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[This config option is used on child Components of ths TabPanel. A CSS class name applied to the tab strip item
 representing the child Component, allowing special styling to be applied.]]></description><name>tabCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The number of pixels of space to calculate into the sizing and scrolling of tabs. If you change the margin in CSS, you
 will need to update this value so calculations are correct with either resizeTabs or scrolling tabs. (defaults to 2)]]></description><name>tabMargin</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The position where the tab strip should be rendered (defaults to 'top'). The only other supported value is 'bottom'.
 Note: tab scrolling is only supported for tabPosition: 'top'.]]></description><name>tabPosition</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is a child item of a TabPanel. A string to be used as innerHTML
 (html tags are accepted) to show in a tooltip when mousing over the associated tab selector element.
 Ext.QuickTips.init() must be called in order for the tips to render.]]></description><name>tabTip</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial width in pixels of each new tab (defaults to 120).]]></description><name>tabWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The title text to be used as innerHTML (html tags are accepted) to display in the panel header (defaults to ''). When a
 title is specified the header element will automatically be created and displayed unless header is explicitly set to
 false. If you do not want to specify a title at config time, but you may want one later, you must either specify a
 non-empty title (a blank space ' ' will do) or header:true so that the container element will get created.]]></description><name>title</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to allow expanding and collapsing the panel (when collapsible = true) by clicking anywhere in the header bar,
 false) to allow it only by clicking to tool button (defaults to false)). If this panel is a child item of a border
 layout also see the BorderLayout.Region floatable config option.]]></description><name>titleCollapse</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A Template used to create tools in the header Element. Defaults to: new Ext.Template('<div class="x-tool
 x-tool-{id}">&#160;</div>') This may may be overridden to provide a custom DOM structure for tools based upon a more
 complex XTemplate. The template's data is a single tool configuration object (Not the entire Array) as specified in
 tools. In the following example an <a> tag is used to provide a visual indication when hovering over the tool: var win =
 new Ext.Window({
     tools: [{
         id: 'download',
         href: '/MyPdfDoc.pdf'
     }],
     toolTemplate: new
 Ext.XTemplate(
         '<tpl if="id==\'download\'">',
             '<a class="x-tool x-tool-pdf" href="{href}"></a>',
    
 '</tpl>',
         '<tpl if="id!=\'download\'">',
             '<div class="x-tool x-tool-{id}">&#160;</div>',
        
 '</tpl>'
     ),
     width:500,
     height:300,
     closeAction:'hide'
 }); Note that the CSS class 'x-tool-pdf' should
 have an associated style rule which provides an appropriate background image, something like: a.x-tool-pdf
 {background-image: url(../shared/extjs/images/pdf.gif)!important;}]]></description><name>toolTemplate</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of tool button configs to be added to the header tool area. When rendered, each tool is stored as an Element
 referenced by a public property called tools.<tool-type> Each tool config may contain the following properties: id :
 String Required. The type of tool to create. By default, this assigns a CSS class of the form x-tool-<tool-type> to the
 resulting tool Element. Ext provides CSS rules, and an icon sprite containing images for the tool types listed below.
 The developer may implement custom tools by supplying alternate CSS rules and background images: toggle (Created by
 default when collapsible is true) close minimize maximize restore gear pin unpin right left up down refresh minus plus
 help search save print handler : Function Required. The function to call when clicked. Arguments passed are: event :
 Ext.EventObject The click event. toolEl : Ext.Element The tool Element. panel : Ext.Panel The host Panel tc : Object The
 tool configuration object stopEvent : Boolean Defaults to true. Specify as false to allow click event to propagate.
 scope : Object The scope in which to call the handler. qtip : String/Object A tip string, or a config argument to
 Ext.QuickTip.register hidden : Boolean True to initially render hidden. on : Object A listener config object specifiying
 event listeners in the format of an argument to addListener Note that, apart from the toggle tool which is provided when
 a panel is collapsible, these tools only provide the visual button. Any required functionality must be provided by
 adding handlers that implement the necessary behavior. Example usage: tools:[{
     id:'refresh',
     qtip: 'Refresh form
 Data',
     // hidden:true,
     handler: function(event, toolEl, panel){
         // refresh logic
     }
 },
 {
    
 id:'help',
     qtip: 'Get Help',
     handler: function(event, toolEl, panel){
         // whatever
     }
 }] For the
 custom id of 'help' define two relevant css classes with a link to a 15x15 image: .x-tool-help {background-image:
 url(images/help.png);}
 .x-tool-help-over {background-image: url(images/help_over.png);}
 // if using an image
 sprite:
 .x-tool-help {background-image: url(images/help.png) no-repeat 0 0;}
 .x-tool-help-over
 {background-position:-15px 0;}]]></description><name>tools</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Overrides the baseCls setting to baseCls = 'x-plain' which renders the panel unstyled except for required attributes for
 Ext layouts to function (e.g. overflow:hidden).]]></description><name>unstyled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[For scrolling tabs, the number of pixels to increment on mouse wheel scrolling (defaults to 20).]]></description><name>wheelIncrement</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local x (left) coordinate for this component if contained within a positioning container.]]></description><name>x</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered xtype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a child item of a Container is being specified not
 as a fully instantiated Component, but as a Component config object. The xtype will be looked up at render time up to
 determine what type of child Component to create. The predefined xtypes are listed here. If you subclass Components to
 create your own Components, you may register them using Ext.ComponentMgr.registerType in order to be able to take
 advantage of lazy instantiation and rendering.]]></description><name>xtype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local y (top) coordinate for this component if contained within a positioning container.]]></description><name>y</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 <p>Represents an HTML fragment template. Templates may be <a href="output/Ext.Template.html#Ext.Template-compile"
 ext:member="compile" ext:cls="Ext.Template">precompiled</a> for greater performance.</p> 
 <p>For example usage <a
 href="output/Ext.Template.html#Ext.Template-Template" ext:member="Template" ext:cls="Ext.Template">see the
 constructor</a>.</p>]]></description><name>template</name><tag-class>org.brushingbits.jnap.ui.extjs3.Template</tag-class><body-content>JSP</body-content><attribute><name>advanced</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify true to compile the template immediately (see compile). Defaults to false.]]></description><name>compiled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify true to disable format functions in the template. If the template does not contain format functions, setting
 disableFormats to true will reduce apply time. Defaults to false.
 <pre><code>
 var t = new Ext.Template(
     '&lt;div name="{id}"&gt;',
     '&lt;span class="{cls}"&gt;{name} {value}&lt;/span&gt;',
     '&lt;/div&gt;',
     {
         compiled: true,      // compile immediately
         disableFormats: true // reduce apply time since no formatting
     }
 );
 </code></pre>
  For a list of available format functions, see
 Ext.util.Format.]]></description><name>disableFormats</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The regular expression used to match template variables. Defaults to:
 <ul>
 <li>re : <code>/\{([\w\-]+)\}/g</code> // for Ext Core</li>
 <li>re : <code>/\{([\w\-]+)(?:\:([\w\.]*)(?:\((.*?)?\))?)?\}/g</code> // for Ext JS</li>
 </ul>]]></description><name>re</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>]]></description><name>tip</name><tag-class>org.brushingbits.jnap.ui.extjs3.Tip</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[A string component id or the numeric index of the component that should be initially activated within the container's
 layout on render. For example, activeItem: 'item-1' or activeItem: 0 (index 0 = the first item in the container's
 collection). activeItem only applies to layout styles that can display items one at a time (like
 Ext.layout.AccordionLayout, Ext.layout.CardLayout and Ext.layout.FitLayout). Related to
 Ext.layout.ContainerLayout.activeItem.]]></description><name>activeItem</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Whether the component can move the Dom node when rendering (defaults to true).]]></description><name>allowDomMove</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use an
 AnchorLayout (or subclass thereof). based layout manager, for example: Ext.form.FormPanel specifying layout: 'anchor' //
 or 'form', or 'absolute' See Ext.layout.AnchorLayout.anchor also.]]></description><name>anchor</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to animate the transition when the panel is collapsed, false to skip the animation (defaults to true if the Ext.Fx
 class is available, otherwise false).]]></description><name>animCollapse</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The id of the node, a DOM node or an existing Element corresponding to a DIV that is already present in the document
 that specifies some panel-specific structural markup. When applyTo is used, constituent parts of the panel can be
 specified by CSS class name within the main element, and the panel will automatically create those components from that
 markup. Any required components not specified in the markup will be autogenerated if necessary. The following class
 names are supported (baseCls will be replaced by baseCls): baseCls + '-header' baseCls + '-header-text' baseCls +
 '-bwrap' baseCls + '-tbar' baseCls + '-body' baseCls + '-bbar' baseCls + '-footer' Using this config, a call to render()
 is not required. If applyTo is specified, any value passed for renderTo will be ignored and the target element's parent
 node will automatically be used as the panel's container.]]></description><name>applyTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If true the container will automatically destroy any contained component that is removed from it, else destruction must
 be handled manually (defaults to true).]]></description><name>autoDestroy</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A tag name or DomHelper spec used to create the Element which will encapsulate this Component. You do not normally need
 to specify this. For the base classes Ext.Component, Ext.BoxComponent, and Ext.Container, this defaults to 'div'. The
 more complex Ext classes use a more complex DOM structure created by their own onRender methods. This is intended to
 allow the developer to create application-specific utility Components encapsulated by different DOM elements. Example
 usage: <pre><code>{
     xtype: 'box',
     autoEl: {
         tag: 'img',
         src: 'http://www.example.com/example.jpg'
     }
 },
 {
     xtype: 'box',
     autoEl: {
         tag: 'blockquote',
         html: 'autoEl is cool!'
     }
 }, {
     xtype: 'container',
     autoEl: 'ul',
     cls: 'ux-unordered-list',
     items: {
         xtype: 'box',
         autoEl: 'li',
   
      html: 'First list item'
     }
 }</pre></code>]]></description><name>autoEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to use height:'auto', false to use fixed height (defaults to false). Note: Setting autoHeight: true means that the
 browser will manage the panel's height based on its contents, and that Ext will not manage it at all. If the panel is
 within a layout that manages dimensions (fit, border, etc.) then setting autoHeight: true can cause issues with
 scrolling and will not generally work as expected since the panel will take on the height of its contents rather than
 the height required by the Ext layout.]]></description><name>autoHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A valid url spec according to the Updater Ext.Updater.update method. If autoLoad is not null, the panel will attempt to
 load its contents immediately upon render. The URL will become the default URL for this panel's body element, so it may
 be refreshed at any time.]]></description><name>autoLoad</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to use overflow:'auto' on the components layout element and show scroll bars automatically when necessary, false to
 clip any overflowing content (defaults to false).]]></description><name>autoScroll</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True if the component should check for hidden classes (e.g. 'x-hidden' or 'x-hide-display') and remove them on render
 (defaults to false).]]></description><name>autoShow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to use width:'auto', false to use fixed width (or allow it to be managed by its parent Container's layout manager.
 Defaults to false. Note: Although many components inherit this config option, not all will function as expected with a
 width of 'auto'. Setting autoWidth:true means that the browser will manage width based on the element's contents, and
 that Ext will not manage it at all. If the browser is managing the width, be aware that resizes performed by the browser
 in response to changes within the structure of the Component cannot be detected. Therefore changes to the width might
 result in elements needing to be synchronized with the new width. For example, where the target element is: <div
 id='grid-container' style='margin-left:25%;width:50%'></div> A Panel rendered into that target element must listen for
 browser window resize in order to relay its child items when the browser changes its width: var myPanel = new
 Ext.Panel({
     renderTo: 'grid-container',
     monitorResize: true, // relay on browser resize
     title: 'Panel',
    
 height: 400,
     autoWidth: true,
     layout: 'hbox',
     layoutConfig: {
         align: 'stretch'
     },
     defaults: {
         flex: 1
     },
     items: [{
         title: 'Box 1',
     }, {
         title: 'Box 2'
     }, {
         title:
 'Box 3'
     }],
 });]]></description><name>autoWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The base CSS class to apply to this panel's element (defaults to 'x-panel'). Another option available by default is to
 specify 'x-plain' which strips all styling except for required attributes for Ext layouts to function (e.g.
 overflow:hidden). See unstyled also.]]></description><name>baseCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to display an interior border on the body element of the panel, false to hide it (defaults to true). This only
 applies when border == true. If border == true and bodyBorder == false, the border will display as a 1px wide inset
 border, giving the entire body element an inset appearance.]]></description><name>bodyBorder</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A DomHelper element specification object may be specified for any Panel Element. By default, the Default element in the
 table below will be used for the html markup to create a child element with the commensurate Default class name (baseCls
 will be replaced by baseCls): 
 Panel      Default  Default             Custom      Additional       Additional
 Element  
 element  class               element     class            style
 ========   ==========================   =========  
 ==============   ===========
 header     div      baseCls+'-header'   headerCfg   headerCssClass   headerStyle
 bwrap     
 div      baseCls+'-bwrap'     bwrapCfg    bwrapCssClass    bwrapStyle
 + tbar     div      baseCls+'-tbar'       tbarCfg 
 tbarCssClass     tbarStyle
 + body     div      baseCls+'-body'       bodyCfg     bodyCssClass     bodyStyle
 + bbar    
 div      baseCls+'-bbar'       bbarCfg     bbarCssClass     bbarStyle
 + footer   div      baseCls+'-footer'   footerCfg 
 footerCssClass   footerStyle
  Configuring a Custom element may be used, for example, to force the body Element to use a
 different form of markup than is created by default. An example of this might be to create a child Panel containing a
 custom content, such as a header, or forcing centering of all Panel content by having the body be a <center> element:
 new Ext.Panel({
     title: 'Message Title',
     renderTo: Ext.getBody(),
     width: 200, height: 130,
     bodyCfg: {
    
 tag: 'center',
         cls: 'x-panel-body',  // Default class not applied if Custom element specified
         html:
 'Message'
     },
     footerCfg: {
         tag: 'h2',
         cls: 'x-panel-footer',        // same as the Default class
 
 html: 'footer html'
     },
     footerCssClass: 'custom-footer', // additional css class, see addClass
     footerStyle:  
 'background-color:red' // see bodyStyle
 }); The example above also explicitly creates a footer with custom markup and
 styling applied.]]></description><name>bodyCfg</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Additional css class selector to be applied to the body element in the format expected by Ext.Element.addClass (defaults
 to null). See bodyCfg.]]></description><name>bodyCssClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Custom CSS styles to be applied to the body element in the format expected by Ext.Element.applyStyles (defaults to
 null). See bodyCfg.]]></description><name>bodyStyle</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to display the borders of the panel's body element, false to hide them (defaults to true). By default, the border
 is a 2px wide inset border, but this can be further altered by setting bodyBorder to false.]]></description><name>border</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to ['add', 'remove'].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[When set to true (50 milliseconds) or a number of milliseconds, the layout assigned for this container will buffer the
 frequency it calculates and does a re-layout of components. This is useful for heavy containers or containers with a
 large quantity of sub-components for which frequent layout calls would be expensive. Defaults to 50.]]></description><name>bufferResize</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The alignment of any buttons added to this panel. Valid values are 'right', 'left' and 'center' (defaults to 'right').]]></description><name>buttonAlign</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A DomHelper element specification object specifying the element structure of this Panel's bwrap Element. See bodyCfg
 also.]]></description><name>bwrapCfg</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class used to to apply to the special clearing div rendered directly after each form field wrapper to provide
 field clearing (defaults to 'x-form-clear-left'). Note: this config is only used when this Component is rendered by a
 Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or specifying
 layout:'form') and either a fieldLabel is specified or isFormField=true is specified. See Ext.layout.FormLayout.fieldTpl
 also.]]></description><name>clearCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to render a close tool button into the tooltip header (defaults to false).]]></description><name>closable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element (defaults to ''). This can be useful for
 adding customized styles to the component or any of its children using standard CSS rules.]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to make sure the collapse/expand toggle button always renders first (to the left of) any other tools in the panel's
 title bar, false to render it last (defaults to true).]]></description><name>collapseFirst</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to render the panel collapsed, false to render it expanded (defaults to false).]]></description><name>collapsed</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS class to add to the panel's element after it has been collapsed (defaults to 'x-panel-collapsed').]]></description><name>collapsedCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to make the panel collapsible and have the expand/collapse toggle button automatically rendered into the header
 tool button area, false to keep the panel statically sized with no button (defaults to false).]]></description><name>collapsible</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's container. This can be useful for adding customized
 styles to the container or any of its children using standard CSS rules. See Ext.layout.ContainerLayout.extraCls also.
 Note: ctCls defaults to '' except for the following class which assigns a value by default: Box Layout :
 'x-box-layout-ct' To configure the above Class with an extra CSS class append to the default. For example, for BoxLayout
 (Hbox and Vbox): ctCls: 'x-box-layout-ct custom-class']]></description><name>ctCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Experimental. The default Ext.Element.alignTo anchor position value for this tip relative to its element of origin
 (defaults to "tl-bl?").]]></description><name>defaultAlign</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default xtype of child Components to create in this Container when a child item is specified as a raw configuration
 object, rather than as an instantiated Component. Defaults to 'panel', except Ext.menu.Menu which defaults to
 'menuitem', and Ext.Toolbar and Ext.ButtonGroup which default to 'button'.]]></description><name>defaultType</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[This option is a means of applying default settings to all added items whether added through the items config or via the
 add or insert methods. If an added item is a config object, and not an instantiated Component, then the default
 properties are unconditionally applied. If the added item is an instantiated Component, then the default properties are
 applied conditionally so as not to override existing properties in the item. If the defaults option is specified as a
 function, then the function will be called using this Container as the scope (this reference) and passing the added item
 as the first parameter. Any resulting object from that call is then applied to the item as default properties. For
 example, to automatically apply padding to the body of each of a set of contained Ext.Panel items, you could pass:
 defaults: {bodyStyle:'padding:15px'}. Usage: defaults: {               // defaults are applied to items, not the
 container
     autoScroll:true
 },
 items: [
     {
         xtype: 'panel',   // defaults do not have precedence over
       
 id: 'panel1',     // options in config objects, so the defaults
         autoScroll: false // will not be applied here,
 panel1 will be autoScroll:false
     },
     new Ext.Panel({       // defaults do have precedence over options
         id:
 'panel2',     // options in components, so the defaults
         autoScroll: false // will be applied here, panel2 will
 be autoScroll:true.
     })
 ]]]></description><name>defaults</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this panel disabled (default is false). An important note when using the disabled config on panels is that IE
 will often fail to initialize the disabled mask element correectly if the panel's layout has not yet completed by the
 time the Panel is disabled during the render process. If you experience this issue, you may need to instead use the
 afterlayout event to initialize the disabled state: new Ext.Panel({
     ...
     listeners: {
         'afterlayout': {
   
 fn: function(p){
                 p.disable();
             },
             single: true // important, as many layouts can
 occur
         }
     }
 });]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class added to the component when it is disabled (defaults to 'x-item-disabled').]]></description><name>disabledClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to enable dragging of this Panel (defaults to false). For custom drag/drop implementations, an Ext.Panel.DD config
 could also be passed in this config instead of true. Ext.Panel.DD is an internal, undocumented class which moves a proxy
 Element around in place of the Panel's element, but provides no other behaviour during dragging or on drop. It is a
 subclass of Ext.dd.DragSource, so behaviour may be added by implementing the interface methods of Ext.dd.DragDrop e.g.:
 new Ext.Panel({
     title: 'Drag me',
     x: 100,
     y: 100,
     renderTo: Ext.getBody(),
     floating: true,
    
 frame: true,
     width: 400,
     height: 200,
     draggable: {
 //      Config option of Ext.Panel.DD class.
 //      It's
 a floating Panel, so do not show a placeholder proxy in the original position.
         insertProxy: false,
 
 //     
 Called for each mousemove event while dragging the DD object.
         onDrag : function(e){
 //          Record the x,y
 position of the drag proxy so that we can
 //          position the Panel at end of drag.
             var pel =
 this.proxy.getEl();
             this.x = pel.getLeft(true);
             this.y = pel.getTop(true);
 
 //          Keep the
 Shadow aligned if there is one.
             var s = this.panel.getEl().shadow;
             if (s) {
                
 s.realign(this.x, this.y, pel.getWidth(), pel.getHeight());
             }
         },
 
 //      Called on the mouseup
 event.
         endDrag : function(e){
             this.panel.setPosition(this.x, this.y);
         }
     }
 }).show();]]></description><name>draggable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A comma-delimited list of panel elements to initialize when the panel is rendered. Normally, this list will be generated
 automatically based on the items added to the panel at config time, but sometimes it might be useful to make sure a
 structural element is rendered even if not specified at config time (for example, you may want to add a button or
 toolbar dynamically after the panel has been rendered). Adding those elements to this list will allocate the required
 placeholders in the panel when it is rendered. Valid values are header tbar (top bar) body bbar (bottom bar) footer
 Defaults to 'body'.]]></description><name>elements</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A Toolbar object, a Toolbar config, or an array of Buttons/Button configs, describing a Toolbar to be rendered into this
 Panel's footer element. After render, the fbar property will be an Toolbar instance. If buttons are specified, they will
 supersede the fbar configuration property. The Panel's buttonAlign configuration affects the layout of these items, for
 example: var w = new Ext.Window({
     height: 250,
     width: 500,
     bbar: new Ext.Toolbar({
         items: [{
        
 text: 'bbar Left'
         },'->',{
             text: 'bbar Right'
         }]
     }),
     buttonAlign: 'left', //
 anything but 'center' or 'right' and you can use '-', and '->'
                                   // to control the
 alignment of fbar items
     fbar: [{
         text: 'fbar Left'
     },'->',{
         text: 'fbar Right'
     }]
 }).show();
 Note: Although a Toolbar may contain Field components, these will not be updated by a load of an ancestor FormPanel. A
 Panel's toolbars are not part of the standard Container->Component hierarchy, and so are not scanned to collect form
 items. However, the values will be submitted because form submission parameters are collected from the DOM tree.]]></description><name>fbar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The label text to display next to this Component (defaults to ''). Note: this config is only used when this Component is
 rendered by a Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or
 specifying layout:'form'). Also see hideLabel and Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
    
 height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name'
    
 }]
 });]]></description><name>fieldLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use a
 BoxLayout. Each child Component with a flex property will be flexed either vertically (by a VBoxLayout) or horizontally
 (by an HBoxLayout) according to the item's relative flex value compared to the sum of all Components with flex value
 specified. Any child items that have either a flex = 0 or flex = undefined will not be 'flexed' (the initial size will
 not be changed).]]></description><name>flex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[This property is used to configure the underlying Ext.Layer. Acceptable values for this configuration property are:
 false : Default. Display the panel inline where it is rendered. true : Float the panel (absolute position it with
 automatic shimming and shadow). Setting floating to true will create an Ext.Layer for this panel and display the panel
 at negative offsets so that it is hidden. Since the panel will be absolute positioned, the position must be set
 explicitly after render (e.g., myPanel.setPosition(100,100);). Note: when floating a panel you should always assign a
 fixed width, otherwise it will be auto width and will expand to fill to the right edge of the viewport. object : The
 specified object will be used as the configuration object for the Ext.Layer that will be created.]]></description><name>floating</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to create the footer element explicitly, false to skip creating it. The footer will be created automatically if
 buttons or a fbar have been configured. See bodyCfg for an example.]]></description><name>footer</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A DomHelper element specification object specifying the element structure of this Panel's footer Element. See bodyCfg
 also.]]></description><name>footerCfg</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If true the container will force a layout initially even if hidden or collapsed. This option is useful for forcing forms
 to render in collapsed or hidden containers. (defaults to false).]]></description><name>forceLayout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[false by default to render with plain 1px square borders. true to render with 9 elements, complete with custom rounded
 corners (also see Ext.Element.boxWrap). The template generated for each condition is depicted below: // frame =
 false
 <div id="developer-specified-id-goes-here" class="x-panel">
 
     <div class="x-panel-header"><span
 class="x-panel-header-text">Title: (frame:false)</span></div>
 
     <div class="x-panel-bwrap">
         <div
 class="x-panel-body"><p>html value goes here</p></div>
     </div>
 </div>
 
 // frame = true (create 9 elements)
 <div
 id="developer-specified-id-goes-here" class="x-panel">
     <div class="x-panel-tl"><div class="x-panel-tr"><div
 class="x-panel-tc">
         <div class="x-panel-header"><span class="x-panel-header-text">Title:
 (frame:true)</span></div>
     </div></div></div>
 
     <div class="x-panel-bwrap">
         <div class="x-panel-ml"><div
 class="x-panel-mr"><div class="x-panel-mc">
             <div class="x-panel-body"><p>html value goes here</p></div>
     
 </div></div></div>
 
         <div class="x-panel-bl"><div class="x-panel-br"><div class="x-panel-bc"/>
        
 </div></div></div>
 </div>]]></description><name>frame</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to create the Panel's header element explicitly, false to skip creating it. If a title is set the header will be
 created automatically, otherwise it will not. If a title is set but header is explicitly set to false, the header will
 not be rendered.]]></description><name>header</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to display the panel title in the header, false to hide it (defaults to true).]]></description><name>headerAsText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A DomHelper element specification object specifying the element structure of this Panel's header Element. See bodyCfg
 also.]]></description><name>headerCfg</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component hidden (default is false). If true, the hide method will be called internally.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide the borders of each contained component, false to defer to the component's existing border settings
 (defaults to false).]]></description><name>hideBorders</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to hide the expand/collapse toggle button when collapsible == true, false to display it (defaults to false).]]></description><name>hideCollapseTool</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to completely hide the label element (label and separator). Defaults to false. By default, even if you do not
 specify a fieldLabel the space will still be reserved so that the field will line up with other fields that do have
 labels. Setting this to true will cause the field to not reserve that space. Note: see the note for clearCls. Example
 use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield'
        
 hideLabel: true
     }]
 });]]></description><name>hideLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[How this component should be hidden. Supported values are 'visibility' (css visibility), 'offsets' (negative offset
 position) and 'display' (css display). Note: the default of 'display' is generally preferred since items are
 automatically laid out when they are first shown (no sizing is done while hidden).]]></description><name>hideMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide and show the component's container when hide/show is called on the component, false to hide and show the
 component itself (defaults to false). For example, this can be used as a shortcut for a hide button on a window by
 setting hide:true on the button when adding it to its parent container.]]></description><name>hideParent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class selector that specifies a background image to be used as the header icon (defaults to ''). An example of
 specifying a custom icon class would be something like: // specify the property in the config for the class:
      ...
   
 iconCls: 'my-icon'
 
 // css class that specifies background image to be used as the icon image:
 .my-icon {
 background-image: url(../images/my-icon.gif) 0 6px no-repeat !important; }]]></description><name>iconCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id of this component (defaults to an auto-assigned id). You should assign an id if you need to be able to
 access the component later and you do not have an object reference available (e.g., using Ext.getCmp). Note that this id
 will also be used as the element id for the containing HTML element that is rendered to the page for this component.
 This allows you to write id-based CSS rules to style the specific instance of this component uniquely, and also to
 select sub-elements using this component's id as the parent. Note: to avoid complications imposed by a unique id also
 see itemId and ref. Note: to access the container of an item see ownerCt.]]></description><name>id</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use the
 FormLayout layout manager (e.g. Ext.form.FormPanel or specifying layout:'form'). An additional CSS class to apply to the
 div wrapping the form item element of this field. If supplied, itemCls at the field level will override the default
 itemCls supplied at the container level. The value specified for itemCls will be added to the default class
 ('x-form-item'). Since it is applied to the item wrapper (see Ext.layout.FormLayout.fieldTpl), it allows you to write
 standard CSS rules that can apply to the field, the label (if specified), or any other element within the markup for the
 field. Note: see the note for fieldLabel. Example use: // Apply a style to the field's label:
 <style>
     .required
 .x-form-item-label {font-weight:bold;color:red;}
 </style>
 
 new Ext.FormPanel({
     height: 100,
     renderTo:
 Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         itemCls: 'required' //this
 label will be styled
     },{
         xtype: 'textfield',
         fieldLabel: 'Favorite Color'
     }]
 });]]></description><name>itemCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An itemId can be used as an alternative way to get a reference to a component when no object reference is available.
 Instead of using an id with Ext.getCmp, use itemId with Ext.Container.getComponent which will retrieve itemId's or id's.
 Since itemId's are an index to the container's internal MixedCollection, the itemId is scoped locally to the container
 -- avoiding potential conflicts with Ext.ComponentMgr which requires a unique id. var c = new Ext.Panel({ //
     height:
 300,
     renderTo: document.body,
     layout: 'auto',
     items: [
         {
             itemId: 'p1',
            
 title: 'Panel 1',
             height: 150
         },
         {
             itemId: 'p2',
             title: 'Panel 2',
  
 height: 150
         }
     ]
 })
 p1 = c.getComponent('p1'); // not the same as Ext.getCmp()
 p2 =
 p1.ownerCt.getComponent('p2'); // reference via a sibling Also see id and ref. Note: to access the container of an item
 see ownerCt.]]></description><name>itemId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A Ext.KeyMap config object (in the format expected by Ext.KeyMap.addBinding used to assign custom key handling to this
 panel (defaults to null).]]></description><name>keys</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The separator to display after the text of each fieldLabel. This property may be configured at various levels. The order
 of precedence is: field / component level container level layout level (defaults to colon ':') To display no separator
 for this field's label specify empty string ''. Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 layoutConfig: {
         labelSeparator: '~'   // layout config has lowest priority (defaults to ':')
     },
    
 labelSeparator: '>>',     // config at container level
     items: [{
         xtype: 'textfield',
         fieldLabel:
 'Field 1',
         labelSeparator: '...' // field/component level config supersedes others
     },{
         xtype:
 'textfield',
         fieldLabel: 'Field 2' // labelSeparator will be '='
     }]
 });]]></description><name>labelSeparator</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS style specification string to apply directly to this field's label. Defaults to the container's labelStyle value
 if set (e.g., Ext.layout.FormLayout.labelStyle , or ''). Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         labelStyle: 'font-weight:bold;'
     }]
 });]]></description><name>labelStyle</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[*Important: In order for child items to be correctly sized and positioned, typically a layout manager must be specified
 through the layout configuration option. The sizing and positioning of child items is the responsibility of the
 Container's layout manager which creates and manages the type of layout you have in mind. For example:
 <pre><code>
 new Ext.Window({
 
 width:300, height: 300,
     layout: 'fit', // explicitly set layout manager: override the default (layout:'auto')
    
 items: [{
         title: 'Panel inside a Window'
     }]
 }).show();</pre></code>
 If the layout configuration is not explicitly
 specified for a general purpose container (e.g. Container or Panel) the default layout manager will be used which does
 nothing but render child components sequentially into the Container (no sizing or positioning will be performed in this
 situation). Some container classes implicitly specify a default layout (e.g. FormPanel specifies layout:'form'). Other
 specific purpose classes internally specify/manage their internal layout (e.g. GridPanel, TabPanel, TreePanel, Toolbar,
 Menu, etc.). layout may be specified as either as an Object or as a String: Specify as an Object Example usage: layout:
 {
     type: 'vbox',
     padding: '5',
     align: 'left'
 } type The layout type to be used for this container. If not
 specified, a default Ext.layout.ContainerLayout will be created and used. Valid layout type values are: absolute
 accordion anchor auto Default border card column fit form hbox menu table toolbar vbox Layout specific configuration
 properties Additional layout specific configuration properties may also be specified. For complete details regarding the
 valid config options for each layout type, see the layout class corresponding to the type specified. Specify as a String
 Example usage: layout: 'vbox',
 layoutConfig: {
     padding: '5',
     align: 'left'
 } layout The layout type to be used
 for this container (see list of valid layout type values above). layoutConfig Additional layout specific configuration
 properties. For complete details regarding the valid config options for each layout type, see the layout class
 corresponding to the layout specified.]]></description><name>layout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout or one of the two BoxLayout subclasses. An object containing margins to apply to this BoxComponent in the
 format: {
     top: (top margin),
     right: (right margin),
     bottom: (bottom margin),
     left: (left margin)
 } May
 also be a string containing space-separated, numeric margin values. The order of the sides associated with each value
 matches the way CSS processes margin values: If there is only one value, it applies to all sides. If there are two
 values, the top and bottom borders are set to the first value and the right and left are set to the second. If there are
 three values, the top is set to the first value, the left and right are set to the second, and the bottom is set to the
 third. If there are four values, they apply to the top, right, bottom, and left, respectively. Defaults to: {top:0,
 right:0, bottom:0, left:0}]]></description><name>margins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to mask the panel when it is disabled, false to not mask it (defaults to true). Either way, the panel will always
 tell its contained elements to disable themselves when it is disabled, but masking the panel can provide an additional
 visual cue that the panel is disabled.]]></description><name>maskDisabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum width of the tip in pixels (defaults to 300). The maximum supported value is 500.]]></description><name>maxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Minimum width in pixels of all buttons in this panel (defaults to 75)]]></description><name>minButtonWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum width of the tip in pixels (defaults to 40).]]></description><name>minWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically monitor window resize events to handle anything that is sensitive to the current size of the
 viewport. This value is typically managed by the chosen layout and should not need to be set manually.]]></description><name>monitorResize</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element when the mouse moves over the Element, and
 removed when the mouse moves out. (defaults to ''). This can be useful for adding customized 'active' or 'hover' styles
 to the component or any of its children using standard CSS rules.]]></description><name>overCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A shortcut for setting a padding style on the body element. The value can either be a number to be applied to all sides,
 or a normal css string describing padding. Defaults to undefined.]]></description><name>padding</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level x coordinate for this component if contained within a positioning container.]]></description><name>pageX</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level y coordinate for this component if contained within a positioning container.]]></description><name>pageY</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to false. When set to true, an extra css class 'x-panel-normal' will be added to the panel's element,
 effectively applying css styles suggested by the W3C (see http://www.w3.org/TR/CSS21/sample.html) to the Panel's body
 element (not the header, footer, etc.).]]></description><name>preventBodyReset</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered ptype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a Plugin is being specified not as a fully
 instantiated Component, but as a Component config object. The ptype will be looked up at render time up to determine
 what type of Plugin to create. If you create your own Plugins, you may register them using
 Ext.ComponentMgr.registerPlugin in order to be able to take advantage of lazy instantiation and rendering.]]></description><name>ptype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A path specification, relative to the Component's ownerCt specifying into which ancestor Container to place a named
 reference to this Component. The ancestor axis can be traversed by using '/' characters in the path. For example, to put
 a reference to a Toolbar Button into the Panel which owns the Toolbar: var myGrid = new Ext.grid.EditorGridPanel({
    
 title: 'My EditorGridPanel',
     store: myStore,
     colModel: myColModel,
     tbar: [{
         text: 'Save',
        
 handler: saveChanges,
         disabled: true,
         ref: '../saveButton'
     }],
     listeners: {
         afteredit:
 function() {
 //          The button reference is in the GridPanel
             myGrid.saveButton.enable();
         }
    
 }
 }); In the code above, if the ref had been 'saveButton' the reference would have been placed into the Toolbar. Each
 '/' in the ref moves up one level from the Component's ownerCt. Also see the added and removed events.]]></description><name>ref</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout layout manager (e.g. specifying layout:'border'). See Ext.layout.BorderLayout also.]]></description><name>region</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The event to listen to for resizing in layouts. Defaults to 'bodyresize'.]]></description><name>resizeEvent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True or "sides" for the default effect, "frame" for 4-way shadow, and "drop" for bottom-right shadow (defaults to
 "sides").]]></description><name>shadow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The number of pixels to offset the shadow if displayed (defaults to 4). Note that this option only applies when floating
 = true.]]></description><name>shadowOffset</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[false to disable the iframe shim in browsers which need one (defaults to true). Note that this option only applies when
 floating = true.]]></description><name>shim</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should trigger this component to save its state (defaults to none). stateEvents may
 be any type of event supported by this component, including browser or custom events (e.g., ['click',
 'customerchange']). See stateful for an explanation of saving and restoring Component state.]]></description><name>stateEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id for this component to use for state management purposes (defaults to the component id if one was set,
 otherwise null if the component is using a generated id). See stateful for an explanation of saving and restoring
 Component state.]]></description><name>stateId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A flag which causes the Component to attempt to restore the state of internal properties from a saved state on startup.
 The component must have either a stateId or id assigned for state to be managed. Auto-generated ids are not guaranteed
 to be stable across page loads and cannot be relied upon to save and restore the same state for a component. For state
 saving to work, the state manager's provider must have been set to an implementation of Ext.state.Provider which
 overrides the set and get methods to save and recall name/value pairs. A built-in implementation,
 Ext.state.CookieProvider is available. To set the state provider for the current page: Ext.state.Manager.setProvider(new
 Ext.state.CookieProvider({
     expires: new Date(new Date().getTime()+(1000*60*60*24*7)), //7 days from now
 })); A
 stateful Component attempts to save state when one of the events listed in the stateEvents configuration fires. To save
 state, a stateful Component first serializes its state by calling getState. By default, this function does nothing. The
 developer must provide an implementation which returns an object hash which represents the Component's restorable state.
 The value yielded by getState is passed to Ext.state.Manager.set which uses the configured Ext.state.Provider to save
 the object keyed by the Component's stateId, or, if that is not specified, its id. During construction, a stateful
 Component attempts to restore its state by calling Ext.state.Manager.get passing the stateId, or, if that is not
 specified, the id. The resulting object is passed to applyState. The default implementation of applyState simply copies
 properties into the object, but a developer may override this to support more behaviour. You can perform extra
 processing on state save and restore by attaching handlers to the beforestaterestore, staterestore, beforestatesave and
 statesave events.]]></description><name>stateful</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
     title: 'Some Title',
     renderTo: Ext.getBody(),
     width: 400, height:
 300,
     layout: 'form',
     items: [{
         xtype: 'textarea',
         style: {
             width: '95%',
            
 marginBottom: '10px'
         }
     },
         new Ext.Button({
             text: 'Send',
             minWidth: '100',
   
          style: {
                 marginBottom: '10px'
             }
         })
     ]
 });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is a child item of a TabPanel. A string to be used as innerHTML
 (html tags are accepted) to show in a tooltip when mousing over the associated tab selector element.
 Ext.QuickTips.init() must be called in order for the tips to render.]]></description><name>tabTip</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The title text to be used as innerHTML (html tags are accepted) to display in the panel header (defaults to ''). When a
 title is specified the header element will automatically be created and displayed unless header is explicitly set to
 false. If you do not want to specify a title at config time, but you may want one later, you must either specify a
 non-empty title (a blank space ' ' will do) or header:true so that the container element will get created.]]></description><name>title</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to allow expanding and collapsing the panel (when collapsible = true) by clicking anywhere in the header bar,
 false) to allow it only by clicking to tool button (defaults to false)). If this panel is a child item of a border
 layout also see the BorderLayout.Region floatable config option.]]></description><name>titleCollapse</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A Template used to create tools in the header Element. Defaults to: new Ext.Template('<div class="x-tool
 x-tool-{id}">&#160;</div>') This may may be overridden to provide a custom DOM structure for tools based upon a more
 complex XTemplate. The template's data is a single tool configuration object (Not the entire Array) as specified in
 tools. In the following example an <a> tag is used to provide a visual indication when hovering over the tool: var win =
 new Ext.Window({
     tools: [{
         id: 'download',
         href: '/MyPdfDoc.pdf'
     }],
     toolTemplate: new
 Ext.XTemplate(
         '<tpl if="id==\'download\'">',
             '<a class="x-tool x-tool-pdf" href="{href}"></a>',
    
 '</tpl>',
         '<tpl if="id!=\'download\'">',
             '<div class="x-tool x-tool-{id}">&#160;</div>',
        
 '</tpl>'
     ),
     width:500,
     height:300,
     closeAction:'hide'
 }); Note that the CSS class 'x-tool-pdf' should
 have an associated style rule which provides an appropriate background image, something like: a.x-tool-pdf
 {background-image: url(../shared/extjs/images/pdf.gif)!important;}]]></description><name>toolTemplate</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of tool button configs to be added to the header tool area. When rendered, each tool is stored as an Element
 referenced by a public property called tools.<tool-type> Each tool config may contain the following properties: id :
 String Required. The type of tool to create. By default, this assigns a CSS class of the form x-tool-<tool-type> to the
 resulting tool Element. Ext provides CSS rules, and an icon sprite containing images for the tool types listed below.
 The developer may implement custom tools by supplying alternate CSS rules and background images: toggle (Created by
 default when collapsible is true) close minimize maximize restore gear pin unpin right left up down refresh minus plus
 help search save print handler : Function Required. The function to call when clicked. Arguments passed are: event :
 Ext.EventObject The click event. toolEl : Ext.Element The tool Element. panel : Ext.Panel The host Panel tc : Object The
 tool configuration object stopEvent : Boolean Defaults to true. Specify as false to allow click event to propagate.
 scope : Object The scope in which to call the handler. qtip : String/Object A tip string, or a config argument to
 Ext.QuickTip.register hidden : Boolean True to initially render hidden. on : Object A listener config object specifiying
 event listeners in the format of an argument to addListener Note that, apart from the toggle tool which is provided when
 a panel is collapsible, these tools only provide the visual button. Any required functionality must be provided by
 adding handlers that implement the necessary behavior. Example usage: tools:[{
     id:'refresh',
     qtip: 'Refresh form
 Data',
     // hidden:true,
     handler: function(event, toolEl, panel){
         // refresh logic
     }
 },
 {
    
 id:'help',
     qtip: 'Get Help',
     handler: function(event, toolEl, panel){
         // whatever
     }
 }] For the
 custom id of 'help' define two relevant css classes with a link to a 15x15 image: .x-tool-help {background-image:
 url(images/help.png);}
 .x-tool-help-over {background-image: url(images/help_over.png);}
 // if using an image
 sprite:
 .x-tool-help {background-image: url(images/help.png) no-repeat 0 0;}
 .x-tool-help-over
 {background-position:-15px 0;}]]></description><name>tools</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Overrides the baseCls setting to baseCls = 'x-plain' which renders the panel unstyled except for required attributes for
 Ext layouts to function (e.g. overflow:hidden).]]></description><name>unstyled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Width in pixels of the tip (defaults to auto). Width will be ignored if it exceeds the bounds of minWidth or maxWidth.
 The maximum supported value is 500.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local x (left) coordinate for this component if contained within a positioning container.]]></description><name>x</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered xtype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a child item of a Container is being specified not
 as a fully instantiated Component, but as a Component config object. The xtype will be looked up at render time up to
 determine what type of child Component to create. The predefined xtypes are listed here. If you subclass Components to
 create your own Components, you may register them using Ext.ComponentMgr.registerType in order to be able to take
 advantage of lazy instantiation and rendering.]]></description><name>xtype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local y (top) coordinate for this component if contained within a positioning container.]]></description><name>y</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 A standard tooltip implementation for providing additional information when hovering over a target element.]]></description><name>toolTip</name><tag-class>org.brushingbits.jnap.ui.extjs3.ToolTip</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[A string component id or the numeric index of the component that should be initially activated within the container's
 layout on render. For example, activeItem: 'item-1' or activeItem: 0 (index 0 = the first item in the container's
 collection). activeItem only applies to layout styles that can display items one at a time (like
 Ext.layout.AccordionLayout, Ext.layout.CardLayout and Ext.layout.FitLayout). Related to
 Ext.layout.ContainerLayout.activeItem.]]></description><name>activeItem</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Whether the component can move the Dom node when rendering (defaults to true).]]></description><name>allowDomMove</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use an
 AnchorLayout (or subclass thereof). based layout manager, for example: Ext.form.FormPanel specifying layout: 'anchor' //
 or 'form', or 'absolute' See Ext.layout.AnchorLayout.anchor also.]]></description><name>anchor</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A numeric pixel value used to offset the default position of the anchor arrow (defaults to 0). When the anchor position
 is on the top or bottom of the tooltip, anchorOffset will be used as a horizontal offset. Likewise, when the anchor
 position is on the left or right side, anchorOffset will be used as a vertical offset.]]></description><name>anchorOffset</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to anchor the tooltip to the target element, false to anchor it relative to the mouse coordinates (defaults to
 true). When anchorToTarget is true, use defaultAlign to control tooltip alignment to the target element. When
 anchorToTarget is false, use anchorPosition instead to control alignment.]]></description><name>anchorToTarget</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to animate the transition when the panel is collapsed, false to skip the animation (defaults to true if the Ext.Fx
 class is available, otherwise false).]]></description><name>animCollapse</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The id of the node, a DOM node or an existing Element corresponding to a DIV that is already present in the document
 that specifies some panel-specific structural markup. When applyTo is used, constituent parts of the panel can be
 specified by CSS class name within the main element, and the panel will automatically create those components from that
 markup. Any required components not specified in the markup will be autogenerated if necessary. The following class
 names are supported (baseCls will be replaced by baseCls): baseCls + '-header' baseCls + '-header-text' baseCls +
 '-bwrap' baseCls + '-tbar' baseCls + '-body' baseCls + '-bbar' baseCls + '-footer' Using this config, a call to render()
 is not required. If applyTo is specified, any value passed for renderTo will be ignored and the target element's parent
 node will automatically be used as the panel's container.]]></description><name>applyTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If true the container will automatically destroy any contained component that is removed from it, else destruction must
 be handled manually (defaults to true).]]></description><name>autoDestroy</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A tag name or DomHelper spec used to create the Element which will encapsulate this Component. You do not normally need
 to specify this. For the base classes Ext.Component, Ext.BoxComponent, and Ext.Container, this defaults to 'div'. The
 more complex Ext classes use a more complex DOM structure created by their own onRender methods. This is intended to
 allow the developer to create application-specific utility Components encapsulated by different DOM elements. Example
 usage: <pre><code>{
     xtype: 'box',
     autoEl: {
         tag: 'img',
         src: 'http://www.example.com/example.jpg'
     }
 },
 {
     xtype: 'box',
     autoEl: {
         tag: 'blockquote',
         html: 'autoEl is cool!'
     }
 }, {
     xtype: 'container',
     autoEl: 'ul',
     cls: 'ux-unordered-list',
     items: {
         xtype: 'box',
         autoEl: 'li',
   
      html: 'First list item'
     }
 }</pre></code>]]></description><name>autoEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to use height:'auto', false to use fixed height (defaults to false). Note: Setting autoHeight: true means that the
 browser will manage the panel's height based on its contents, and that Ext will not manage it at all. If the panel is
 within a layout that manages dimensions (fit, border, etc.) then setting autoHeight: true can cause issues with
 scrolling and will not generally work as expected since the panel will take on the height of its contents rather than
 the height required by the Ext layout.]]></description><name>autoHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically hide the tooltip after the mouse exits the target element or after the dismissDelay has expired if
 set (defaults to true). If closable = true a close tool button will be rendered into the tooltip header.]]></description><name>autoHide</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A valid url spec according to the Updater Ext.Updater.update method. If autoLoad is not null, the panel will attempt to
 load its contents immediately upon render. The URL will become the default URL for this panel's body element, so it may
 be refreshed at any time.]]></description><name>autoLoad</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to use overflow:'auto' on the components layout element and show scroll bars automatically when necessary, false to
 clip any overflowing content (defaults to false).]]></description><name>autoScroll</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True if the component should check for hidden classes (e.g. 'x-hidden' or 'x-hide-display') and remove them on render
 (defaults to false).]]></description><name>autoShow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to use width:'auto', false to use fixed width (or allow it to be managed by its parent Container's layout manager.
 Defaults to false. Note: Although many components inherit this config option, not all will function as expected with a
 width of 'auto'. Setting autoWidth:true means that the browser will manage width based on the element's contents, and
 that Ext will not manage it at all. If the browser is managing the width, be aware that resizes performed by the browser
 in response to changes within the structure of the Component cannot be detected. Therefore changes to the width might
 result in elements needing to be synchronized with the new width. For example, where the target element is: <div
 id='grid-container' style='margin-left:25%;width:50%'></div> A Panel rendered into that target element must listen for
 browser window resize in order to relay its child items when the browser changes its width: var myPanel = new
 Ext.Panel({
     renderTo: 'grid-container',
     monitorResize: true, // relay on browser resize
     title: 'Panel',
    
 height: 400,
     autoWidth: true,
     layout: 'hbox',
     layoutConfig: {
         align: 'stretch'
     },
     defaults: {
         flex: 1
     },
     items: [{
         title: 'Box 1',
     }, {
         title: 'Box 2'
     }, {
         title:
 'Box 3'
     }],
 });]]></description><name>autoWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The base CSS class to apply to this panel's element (defaults to 'x-panel'). Another option available by default is to
 specify 'x-plain' which strips all styling except for required attributes for Ext layouts to function (e.g.
 overflow:hidden). See unstyled also.]]></description><name>baseCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to display an interior border on the body element of the panel, false to hide it (defaults to true). This only
 applies when border == true. If border == true and bodyBorder == false, the border will display as a 1px wide inset
 border, giving the entire body element an inset appearance.]]></description><name>bodyBorder</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A DomHelper element specification object may be specified for any Panel Element. By default, the Default element in the
 table below will be used for the html markup to create a child element with the commensurate Default class name (baseCls
 will be replaced by baseCls): 
 Panel      Default  Default             Custom      Additional       Additional
 Element  
 element  class               element     class            style
 ========   ==========================   =========  
 ==============   ===========
 header     div      baseCls+'-header'   headerCfg   headerCssClass   headerStyle
 bwrap     
 div      baseCls+'-bwrap'     bwrapCfg    bwrapCssClass    bwrapStyle
 + tbar     div      baseCls+'-tbar'       tbarCfg 
 tbarCssClass     tbarStyle
 + body     div      baseCls+'-body'       bodyCfg     bodyCssClass     bodyStyle
 + bbar    
 div      baseCls+'-bbar'       bbarCfg     bbarCssClass     bbarStyle
 + footer   div      baseCls+'-footer'   footerCfg 
 footerCssClass   footerStyle
  Configuring a Custom element may be used, for example, to force the body Element to use a
 different form of markup than is created by default. An example of this might be to create a child Panel containing a
 custom content, such as a header, or forcing centering of all Panel content by having the body be a <center> element:
 new Ext.Panel({
     title: 'Message Title',
     renderTo: Ext.getBody(),
     width: 200, height: 130,
     bodyCfg: {
    
 tag: 'center',
         cls: 'x-panel-body',  // Default class not applied if Custom element specified
         html:
 'Message'
     },
     footerCfg: {
         tag: 'h2',
         cls: 'x-panel-footer',        // same as the Default class
 
 html: 'footer html'
     },
     footerCssClass: 'custom-footer', // additional css class, see addClass
     footerStyle:  
 'background-color:red' // see bodyStyle
 }); The example above also explicitly creates a footer with custom markup and
 styling applied.]]></description><name>bodyCfg</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Additional css class selector to be applied to the body element in the format expected by Ext.Element.addClass (defaults
 to null). See bodyCfg.]]></description><name>bodyCssClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Custom CSS styles to be applied to the body element in the format expected by Ext.Element.applyStyles (defaults to
 null). See bodyCfg.]]></description><name>bodyStyle</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to display the borders of the panel's body element, false to hide them (defaults to true). By default, the border
 is a 2px wide inset border, but this can be further altered by setting bodyBorder to false.]]></description><name>border</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to ['add', 'remove'].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[When set to true (50 milliseconds) or a number of milliseconds, the layout assigned for this container will buffer the
 frequency it calculates and does a re-layout of components. This is useful for heavy containers or containers with a
 large quantity of sub-components for which frequent layout calls would be expensive. Defaults to 50.]]></description><name>bufferResize</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The alignment of any buttons added to this panel. Valid values are 'right', 'left' and 'center' (defaults to 'right').]]></description><name>buttonAlign</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A DomHelper element specification object specifying the element structure of this Panel's bwrap Element. See bodyCfg
 also.]]></description><name>bwrapCfg</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class used to to apply to the special clearing div rendered directly after each form field wrapper to provide
 field clearing (defaults to 'x-form-clear-left'). Note: this config is only used when this Component is rendered by a
 Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or specifying
 layout:'form') and either a fieldLabel is specified or isFormField=true is specified. See Ext.layout.FormLayout.fieldTpl
 also.]]></description><name>clearCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to render a close tool button into the tooltip header (defaults to false).]]></description><name>closable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element (defaults to ''). This can be useful for
 adding customized styles to the component or any of its children using standard CSS rules.]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to make sure the collapse/expand toggle button always renders first (to the left of) any other tools in the panel's
 title bar, false to render it last (defaults to true).]]></description><name>collapseFirst</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to render the panel collapsed, false to render it expanded (defaults to false).]]></description><name>collapsed</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS class to add to the panel's element after it has been collapsed (defaults to 'x-panel-collapsed').]]></description><name>collapsedCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to make the panel collapsible and have the expand/collapse toggle button automatically rendered into the header
 tool button area, false to keep the panel statically sized with no button (defaults to false).]]></description><name>collapsible</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's container. This can be useful for adding customized
 styles to the container or any of its children using standard CSS rules. See Ext.layout.ContainerLayout.extraCls also.
 Note: ctCls defaults to '' except for the following class which assigns a value by default: Box Layout :
 'x-box-layout-ct' To configure the above Class with an extra CSS class append to the default. For example, for BoxLayout
 (Hbox and Vbox): ctCls: 'x-box-layout-ct custom-class']]></description><name>ctCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Experimental. The default Ext.Element.alignTo anchor position value for this tip relative to its element of origin
 (defaults to "tl-bl?").]]></description><name>defaultAlign</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default xtype of child Components to create in this Container when a child item is specified as a raw configuration
 object, rather than as an instantiated Component. Defaults to 'panel', except Ext.menu.Menu which defaults to
 'menuitem', and Ext.Toolbar and Ext.ButtonGroup which default to 'button'.]]></description><name>defaultType</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[This option is a means of applying default settings to all added items whether added through the items config or via the
 add or insert methods. If an added item is a config object, and not an instantiated Component, then the default
 properties are unconditionally applied. If the added item is an instantiated Component, then the default properties are
 applied conditionally so as not to override existing properties in the item. If the defaults option is specified as a
 function, then the function will be called using this Container as the scope (this reference) and passing the added item
 as the first parameter. Any resulting object from that call is then applied to the item as default properties. For
 example, to automatically apply padding to the body of each of a set of contained Ext.Panel items, you could pass:
 defaults: {bodyStyle:'padding:15px'}. Usage: defaults: {               // defaults are applied to items, not the
 container
     autoScroll:true
 },
 items: [
     {
         xtype: 'panel',   // defaults do not have precedence over
       
 id: 'panel1',     // options in config objects, so the defaults
         autoScroll: false // will not be applied here,
 panel1 will be autoScroll:false
     },
     new Ext.Panel({       // defaults do have precedence over options
         id:
 'panel2',     // options in components, so the defaults
         autoScroll: false // will be applied here, panel2 will
 be autoScroll:true.
     })
 ]]]></description><name>defaults</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. A DomQuery selector which allows selection of individual elements within the target element to trigger showing
 and hiding the ToolTip as the mouse moves within the target. When specified, the child element of the target which
 caused a show event is placed into the triggerElement property before the ToolTip is shown. This may be useful when a
 Component has regular, repeating elements in it, each of which need a Tooltip which contains information specific to
 that element. For example: var myGrid = new Ext.grid.gridPanel(gridConfig);
 myGrid.on('render', function(grid) {
     var
 store = grid.getStore();  // Capture the Store.
     var view = grid.getView();    // Capture the GridView.
    
 myGrid.tip = new Ext.ToolTip({
         target: view.mainBody,    // The overall target element.
         delegate:
 '.x-grid3-row', // Each grid row causes its own seperate show and hide.
         trackMouse: true,         // Moving
 within the row should not hide the tip.
         renderTo: document.body,  // Render immediately so that tip.body can be
 
 //  referenced prior to the first show.
         listeners: {              // Change content dynamically depending on
 which element
                                   //  triggered the show.
             beforeshow: function
 updateTipBody(tip) {
                 var rowIndex = view.findRowIndex(tip.triggerElement);
                
 tip.body.dom.innerHTML = 'Over Record ID ' + store.getAt(rowIndex).id;
             }
         }
     });
 });]]></description><name>delegate</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this panel disabled (default is false). An important note when using the disabled config on panels is that IE
 will often fail to initialize the disabled mask element correectly if the panel's layout has not yet completed by the
 time the Panel is disabled during the render process. If you experience this issue, you may need to instead use the
 afterlayout event to initialize the disabled state: new Ext.Panel({
     ...
     listeners: {
         'afterlayout': {
   
 fn: function(p){
                 p.disable();
             },
             single: true // important, as many layouts can
 occur
         }
     }
 });]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class added to the component when it is disabled (defaults to 'x-item-disabled').]]></description><name>disabledClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Delay in milliseconds before the tooltip automatically hides (defaults to 5000). To disable automatic hiding, set
 dismissDelay = 0.]]></description><name>dismissDelay</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to enable dragging of this Panel (defaults to false). For custom drag/drop implementations, an Ext.Panel.DD config
 could also be passed in this config instead of true. Ext.Panel.DD is an internal, undocumented class which moves a proxy
 Element around in place of the Panel's element, but provides no other behaviour during dragging or on drop. It is a
 subclass of Ext.dd.DragSource, so behaviour may be added by implementing the interface methods of Ext.dd.DragDrop e.g.:
 new Ext.Panel({
     title: 'Drag me',
     x: 100,
     y: 100,
     renderTo: Ext.getBody(),
     floating: true,
    
 frame: true,
     width: 400,
     height: 200,
     draggable: {
 //      Config option of Ext.Panel.DD class.
 //      It's
 a floating Panel, so do not show a placeholder proxy in the original position.
         insertProxy: false,
 
 //     
 Called for each mousemove event while dragging the DD object.
         onDrag : function(e){
 //          Record the x,y
 position of the drag proxy so that we can
 //          position the Panel at end of drag.
             var pel =
 this.proxy.getEl();
             this.x = pel.getLeft(true);
             this.y = pel.getTop(true);
 
 //          Keep the
 Shadow aligned if there is one.
             var s = this.panel.getEl().shadow;
             if (s) {
                
 s.realign(this.x, this.y, pel.getWidth(), pel.getHeight());
             }
         },
 
 //      Called on the mouseup
 event.
         endDrag : function(e){
             this.panel.setPosition(this.x, this.y);
         }
     }
 }).show();]]></description><name>draggable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A comma-delimited list of panel elements to initialize when the panel is rendered. Normally, this list will be generated
 automatically based on the items added to the panel at config time, but sometimes it might be useful to make sure a
 structural element is rendered even if not specified at config time (for example, you may want to add a button or
 toolbar dynamically after the panel has been rendered). Adding those elements to this list will allocate the required
 placeholders in the panel when it is rendered. Valid values are header tbar (top bar) body bbar (bottom bar) footer
 Defaults to 'body'.]]></description><name>elements</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A Toolbar object, a Toolbar config, or an array of Buttons/Button configs, describing a Toolbar to be rendered into this
 Panel's footer element. After render, the fbar property will be an Toolbar instance. If buttons are specified, they will
 supersede the fbar configuration property. The Panel's buttonAlign configuration affects the layout of these items, for
 example: var w = new Ext.Window({
     height: 250,
     width: 500,
     bbar: new Ext.Toolbar({
         items: [{
        
 text: 'bbar Left'
         },'->',{
             text: 'bbar Right'
         }]
     }),
     buttonAlign: 'left', //
 anything but 'center' or 'right' and you can use '-', and '->'
                                   // to control the
 alignment of fbar items
     fbar: [{
         text: 'fbar Left'
     },'->',{
         text: 'fbar Right'
     }]
 }).show();
 Note: Although a Toolbar may contain Field components, these will not be updated by a load of an ancestor FormPanel. A
 Panel's toolbars are not part of the standard Container->Component hierarchy, and so are not scanned to collect form
 items. However, the values will be submitted because form submission parameters are collected from the DOM tree.]]></description><name>fbar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The label text to display next to this Component (defaults to ''). Note: this config is only used when this Component is
 rendered by a Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or
 specifying layout:'form'). Also see hideLabel and Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
    
 height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name'
    
 }]
 });]]></description><name>fieldLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use a
 BoxLayout. Each child Component with a flex property will be flexed either vertically (by a VBoxLayout) or horizontally
 (by an HBoxLayout) according to the item's relative flex value compared to the sum of all Components with flex value
 specified. Any child items that have either a flex = 0 or flex = undefined will not be 'flexed' (the initial size will
 not be changed).]]></description><name>flex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[This property is used to configure the underlying Ext.Layer. Acceptable values for this configuration property are:
 false : Default. Display the panel inline where it is rendered. true : Float the panel (absolute position it with
 automatic shimming and shadow). Setting floating to true will create an Ext.Layer for this panel and display the panel
 at negative offsets so that it is hidden. Since the panel will be absolute positioned, the position must be set
 explicitly after render (e.g., myPanel.setPosition(100,100);). Note: when floating a panel you should always assign a
 fixed width, otherwise it will be auto width and will expand to fill to the right edge of the viewport. object : The
 specified object will be used as the configuration object for the Ext.Layer that will be created.]]></description><name>floating</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to create the footer element explicitly, false to skip creating it. The footer will be created automatically if
 buttons or a fbar have been configured. See bodyCfg for an example.]]></description><name>footer</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A DomHelper element specification object specifying the element structure of this Panel's footer Element. See bodyCfg
 also.]]></description><name>footerCfg</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If true the container will force a layout initially even if hidden or collapsed. This option is useful for forcing forms
 to render in collapsed or hidden containers. (defaults to false).]]></description><name>forceLayout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[false by default to render with plain 1px square borders. true to render with 9 elements, complete with custom rounded
 corners (also see Ext.Element.boxWrap). The template generated for each condition is depicted below: // frame =
 false
 <div id="developer-specified-id-goes-here" class="x-panel">
 
     <div class="x-panel-header"><span
 class="x-panel-header-text">Title: (frame:false)</span></div>
 
     <div class="x-panel-bwrap">
         <div
 class="x-panel-body"><p>html value goes here</p></div>
     </div>
 </div>
 
 // frame = true (create 9 elements)
 <div
 id="developer-specified-id-goes-here" class="x-panel">
     <div class="x-panel-tl"><div class="x-panel-tr"><div
 class="x-panel-tc">
         <div class="x-panel-header"><span class="x-panel-header-text">Title:
 (frame:true)</span></div>
     </div></div></div>
 
     <div class="x-panel-bwrap">
         <div class="x-panel-ml"><div
 class="x-panel-mr"><div class="x-panel-mc">
             <div class="x-panel-body"><p>html value goes here</p></div>
     
 </div></div></div>
 
         <div class="x-panel-bl"><div class="x-panel-br"><div class="x-panel-bc"/>
        
 </div></div></div>
 </div>]]></description><name>frame</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to create the Panel's header element explicitly, false to skip creating it. If a title is set the header will be
 created automatically, otherwise it will not. If a title is set but header is explicitly set to false, the header will
 not be rendered.]]></description><name>header</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to display the panel title in the header, false to hide it (defaults to true).]]></description><name>headerAsText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A DomHelper element specification object specifying the element structure of this Panel's header Element. See bodyCfg
 also.]]></description><name>headerCfg</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component hidden (default is false). If true, the hide method will be called internally.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide the borders of each contained component, false to defer to the component's existing border settings
 (defaults to false).]]></description><name>hideBorders</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to hide the expand/collapse toggle button when collapsible == true, false to display it (defaults to false).]]></description><name>hideCollapseTool</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Delay in milliseconds after the mouse exits the target element but before the tooltip actually hides (defaults to 200).
 Set to 0 for the tooltip to hide immediately.]]></description><name>hideDelay</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to completely hide the label element (label and separator). Defaults to false. By default, even if you do not
 specify a fieldLabel the space will still be reserved so that the field will line up with other fields that do have
 labels. Setting this to true will cause the field to not reserve that space. Note: see the note for clearCls. Example
 use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield'
        
 hideLabel: true
     }]
 });]]></description><name>hideLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[How this component should be hidden. Supported values are 'visibility' (css visibility), 'offsets' (negative offset
 position) and 'display' (css display). Note: the default of 'display' is generally preferred since items are
 automatically laid out when they are first shown (no sizing is done while hidden).]]></description><name>hideMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide and show the component's container when hide/show is called on the component, false to hide and show the
 component itself (defaults to false). For example, this can be used as a shortcut for a hide button on a window by
 setting hide:true on the button when adding it to its parent container.]]></description><name>hideParent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class selector that specifies a background image to be used as the header icon (defaults to ''). An example of
 specifying a custom icon class would be something like: // specify the property in the config for the class:
      ...
   
 iconCls: 'my-icon'
 
 // css class that specifies background image to be used as the icon image:
 .my-icon {
 background-image: url(../images/my-icon.gif) 0 6px no-repeat !important; }]]></description><name>iconCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id of this component (defaults to an auto-assigned id). You should assign an id if you need to be able to
 access the component later and you do not have an object reference available (e.g., using Ext.getCmp). Note that this id
 will also be used as the element id for the containing HTML element that is rendered to the page for this component.
 This allows you to write id-based CSS rules to style the specific instance of this component uniquely, and also to
 select sub-elements using this component's id as the parent. Note: to avoid complications imposed by a unique id also
 see itemId and ref. Note: to access the container of an item see ownerCt.]]></description><name>id</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use the
 FormLayout layout manager (e.g. Ext.form.FormPanel or specifying layout:'form'). An additional CSS class to apply to the
 div wrapping the form item element of this field. If supplied, itemCls at the field level will override the default
 itemCls supplied at the container level. The value specified for itemCls will be added to the default class
 ('x-form-item'). Since it is applied to the item wrapper (see Ext.layout.FormLayout.fieldTpl), it allows you to write
 standard CSS rules that can apply to the field, the label (if specified), or any other element within the markup for the
 field. Note: see the note for fieldLabel. Example use: // Apply a style to the field's label:
 <style>
     .required
 .x-form-item-label {font-weight:bold;color:red;}
 </style>
 
 new Ext.FormPanel({
     height: 100,
     renderTo:
 Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         itemCls: 'required' //this
 label will be styled
     },{
         xtype: 'textfield',
         fieldLabel: 'Favorite Color'
     }]
 });]]></description><name>itemCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An itemId can be used as an alternative way to get a reference to a component when no object reference is available.
 Instead of using an id with Ext.getCmp, use itemId with Ext.Container.getComponent which will retrieve itemId's or id's.
 Since itemId's are an index to the container's internal MixedCollection, the itemId is scoped locally to the container
 -- avoiding potential conflicts with Ext.ComponentMgr which requires a unique id. var c = new Ext.Panel({ //
     height:
 300,
     renderTo: document.body,
     layout: 'auto',
     items: [
         {
             itemId: 'p1',
            
 title: 'Panel 1',
             height: 150
         },
         {
             itemId: 'p2',
             title: 'Panel 2',
  
 height: 150
         }
     ]
 })
 p1 = c.getComponent('p1'); // not the same as Ext.getCmp()
 p2 =
 p1.ownerCt.getComponent('p2'); // reference via a sibling Also see id and ref. Note: to access the container of an item
 see ownerCt.]]></description><name>itemId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A Ext.KeyMap config object (in the format expected by Ext.KeyMap.addBinding used to assign custom key handling to this
 panel (defaults to null).]]></description><name>keys</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The separator to display after the text of each fieldLabel. This property may be configured at various levels. The order
 of precedence is: field / component level container level layout level (defaults to colon ':') To display no separator
 for this field's label specify empty string ''. Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 layoutConfig: {
         labelSeparator: '~'   // layout config has lowest priority (defaults to ':')
     },
    
 labelSeparator: '>>',     // config at container level
     items: [{
         xtype: 'textfield',
         fieldLabel:
 'Field 1',
         labelSeparator: '...' // field/component level config supersedes others
     },{
         xtype:
 'textfield',
         fieldLabel: 'Field 2' // labelSeparator will be '='
     }]
 });]]></description><name>labelSeparator</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS style specification string to apply directly to this field's label. Defaults to the container's labelStyle value
 if set (e.g., Ext.layout.FormLayout.labelStyle , or ''). Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         labelStyle: 'font-weight:bold;'
     }]
 });]]></description><name>labelStyle</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[*Important: In order for child items to be correctly sized and positioned, typically a layout manager must be specified
 through the layout configuration option. The sizing and positioning of child items is the responsibility of the
 Container's layout manager which creates and manages the type of layout you have in mind. For example:
 <pre><code>
 new Ext.Window({
 
 width:300, height: 300,
     layout: 'fit', // explicitly set layout manager: override the default (layout:'auto')
    
 items: [{
         title: 'Panel inside a Window'
     }]
 }).show();</pre></code>
 If the layout configuration is not explicitly
 specified for a general purpose container (e.g. Container or Panel) the default layout manager will be used which does
 nothing but render child components sequentially into the Container (no sizing or positioning will be performed in this
 situation). Some container classes implicitly specify a default layout (e.g. FormPanel specifies layout:'form'). Other
 specific purpose classes internally specify/manage their internal layout (e.g. GridPanel, TabPanel, TreePanel, Toolbar,
 Menu, etc.). layout may be specified as either as an Object or as a String: Specify as an Object Example usage: layout:
 {
     type: 'vbox',
     padding: '5',
     align: 'left'
 } type The layout type to be used for this container. If not
 specified, a default Ext.layout.ContainerLayout will be created and used. Valid layout type values are: absolute
 accordion anchor auto Default border card column fit form hbox menu table toolbar vbox Layout specific configuration
 properties Additional layout specific configuration properties may also be specified. For complete details regarding the
 valid config options for each layout type, see the layout class corresponding to the type specified. Specify as a String
 Example usage: layout: 'vbox',
 layoutConfig: {
     padding: '5',
     align: 'left'
 } layout The layout type to be used
 for this container (see list of valid layout type values above). layoutConfig Additional layout specific configuration
 properties. For complete details regarding the valid config options for each layout type, see the layout class
 corresponding to the layout specified.]]></description><name>layout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout or one of the two BoxLayout subclasses. An object containing margins to apply to this BoxComponent in the
 format: {
     top: (top margin),
     right: (right margin),
     bottom: (bottom margin),
     left: (left margin)
 } May
 also be a string containing space-separated, numeric margin values. The order of the sides associated with each value
 matches the way CSS processes margin values: If there is only one value, it applies to all sides. If there are two
 values, the top and bottom borders are set to the first value and the right and left are set to the second. If there are
 three values, the top is set to the first value, the left and right are set to the second, and the bottom is set to the
 third. If there are four values, they apply to the top, right, bottom, and left, respectively. Defaults to: {top:0,
 right:0, bottom:0, left:0}]]></description><name>margins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to mask the panel when it is disabled, false to not mask it (defaults to true). Either way, the panel will always
 tell its contained elements to disable themselves when it is disabled, but masking the panel can provide an additional
 visual cue that the panel is disabled.]]></description><name>maskDisabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum width of the tip in pixels (defaults to 300). The maximum supported value is 500.]]></description><name>maxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Minimum width in pixels of all buttons in this panel (defaults to 75)]]></description><name>minButtonWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum width of the tip in pixels (defaults to 40).]]></description><name>minWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically monitor window resize events to handle anything that is sensitive to the current size of the
 viewport. This value is typically managed by the chosen layout and should not need to be set manually.]]></description><name>monitorResize</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An XY offset from the mouse position where the tooltip should be shown (defaults to [15,18]).]]></description><name>mouseOffset</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element when the mouse moves over the Element, and
 removed when the mouse moves out. (defaults to ''). This can be useful for adding customized 'active' or 'hover' styles
 to the component or any of its children using standard CSS rules.]]></description><name>overCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A shortcut for setting a padding style on the body element. The value can either be a number to be applied to all sides,
 or a normal css string describing padding. Defaults to undefined.]]></description><name>padding</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level x coordinate for this component if contained within a positioning container.]]></description><name>pageX</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level y coordinate for this component if contained within a positioning container.]]></description><name>pageY</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to false. When set to true, an extra css class 'x-panel-normal' will be added to the panel's element,
 effectively applying css styles suggested by the W3C (see http://www.w3.org/TR/CSS21/sample.html) to the Panel's body
 element (not the header, footer, etc.).]]></description><name>preventBodyReset</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered ptype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a Plugin is being specified not as a fully
 instantiated Component, but as a Component config object. The ptype will be looked up at render time up to determine
 what type of Plugin to create. If you create your own Plugins, you may register them using
 Ext.ComponentMgr.registerPlugin in order to be able to take advantage of lazy instantiation and rendering.]]></description><name>ptype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A path specification, relative to the Component's ownerCt specifying into which ancestor Container to place a named
 reference to this Component. The ancestor axis can be traversed by using '/' characters in the path. For example, to put
 a reference to a Toolbar Button into the Panel which owns the Toolbar: var myGrid = new Ext.grid.EditorGridPanel({
    
 title: 'My EditorGridPanel',
     store: myStore,
     colModel: myColModel,
     tbar: [{
         text: 'Save',
        
 handler: saveChanges,
         disabled: true,
         ref: '../saveButton'
     }],
     listeners: {
         afteredit:
 function() {
 //          The button reference is in the GridPanel
             myGrid.saveButton.enable();
         }
    
 }
 }); In the code above, if the ref had been 'saveButton' the reference would have been placed into the Toolbar. Each
 '/' in the ref moves up one level from the Component's ownerCt. Also see the added and removed events.]]></description><name>ref</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout layout manager (e.g. specifying layout:'border'). See Ext.layout.BorderLayout also.]]></description><name>region</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The event to listen to for resizing in layouts. Defaults to 'bodyresize'.]]></description><name>resizeEvent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True or "sides" for the default effect, "frame" for 4-way shadow, and "drop" for bottom-right shadow (defaults to
 "sides").]]></description><name>shadow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The number of pixels to offset the shadow if displayed (defaults to 4). Note that this option only applies when floating
 = true.]]></description><name>shadowOffset</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[false to disable the iframe shim in browsers which need one (defaults to true). Note that this option only applies when
 floating = true.]]></description><name>shim</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Delay in milliseconds before the tooltip displays after the mouse enters the target element (defaults to 500)]]></description><name>showDelay</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should trigger this component to save its state (defaults to none). stateEvents may
 be any type of event supported by this component, including browser or custom events (e.g., ['click',
 'customerchange']). See stateful for an explanation of saving and restoring Component state.]]></description><name>stateEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id for this component to use for state management purposes (defaults to the component id if one was set,
 otherwise null if the component is using a generated id). See stateful for an explanation of saving and restoring
 Component state.]]></description><name>stateId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A flag which causes the Component to attempt to restore the state of internal properties from a saved state on startup.
 The component must have either a stateId or id assigned for state to be managed. Auto-generated ids are not guaranteed
 to be stable across page loads and cannot be relied upon to save and restore the same state for a component. For state
 saving to work, the state manager's provider must have been set to an implementation of Ext.state.Provider which
 overrides the set and get methods to save and recall name/value pairs. A built-in implementation,
 Ext.state.CookieProvider is available. To set the state provider for the current page: Ext.state.Manager.setProvider(new
 Ext.state.CookieProvider({
     expires: new Date(new Date().getTime()+(1000*60*60*24*7)), //7 days from now
 })); A
 stateful Component attempts to save state when one of the events listed in the stateEvents configuration fires. To save
 state, a stateful Component first serializes its state by calling getState. By default, this function does nothing. The
 developer must provide an implementation which returns an object hash which represents the Component's restorable state.
 The value yielded by getState is passed to Ext.state.Manager.set which uses the configured Ext.state.Provider to save
 the object keyed by the Component's stateId, or, if that is not specified, its id. During construction, a stateful
 Component attempts to restore its state by calling Ext.state.Manager.get passing the stateId, or, if that is not
 specified, the id. The resulting object is passed to applyState. The default implementation of applyState simply copies
 properties into the object, but a developer may override this to support more behaviour. You can perform extra
 processing on state save and restore by attaching handlers to the beforestaterestore, staterestore, beforestatesave and
 statesave events.]]></description><name>stateful</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
     title: 'Some Title',
     renderTo: Ext.getBody(),
     width: 400, height:
 300,
     layout: 'form',
     items: [{
         xtype: 'textarea',
         style: {
             width: '95%',
            
 marginBottom: '10px'
         }
     },
         new Ext.Button({
             text: 'Send',
             minWidth: '100',
   
          style: {
                 marginBottom: '10px'
             }
         })
     ]
 });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is a child item of a TabPanel. A string to be used as innerHTML
 (html tags are accepted) to show in a tooltip when mousing over the associated tab selector element.
 Ext.QuickTips.init() must be called in order for the tips to render.]]></description><name>tabTip</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The target HTMLElement, Ext.Element or id to monitor for mouseover events to trigger showing this ToolTip.]]></description><name>target</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The title text to be used as innerHTML (html tags are accepted) to display in the panel header (defaults to ''). When a
 title is specified the header element will automatically be created and displayed unless header is explicitly set to
 false. If you do not want to specify a title at config time, but you may want one later, you must either specify a
 non-empty title (a blank space ' ' will do) or header:true so that the container element will get created.]]></description><name>title</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to allow expanding and collapsing the panel (when collapsible = true) by clicking anywhere in the header bar,
 false) to allow it only by clicking to tool button (defaults to false)). If this panel is a child item of a border
 layout also see the BorderLayout.Region floatable config option.]]></description><name>titleCollapse</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A Template used to create tools in the header Element. Defaults to: new Ext.Template('<div class="x-tool
 x-tool-{id}">&#160;</div>') This may may be overridden to provide a custom DOM structure for tools based upon a more
 complex XTemplate. The template's data is a single tool configuration object (Not the entire Array) as specified in
 tools. In the following example an <a> tag is used to provide a visual indication when hovering over the tool: var win =
 new Ext.Window({
     tools: [{
         id: 'download',
         href: '/MyPdfDoc.pdf'
     }],
     toolTemplate: new
 Ext.XTemplate(
         '<tpl if="id==\'download\'">',
             '<a class="x-tool x-tool-pdf" href="{href}"></a>',
    
 '</tpl>',
         '<tpl if="id!=\'download\'">',
             '<div class="x-tool x-tool-{id}">&#160;</div>',
        
 '</tpl>'
     ),
     width:500,
     height:300,
     closeAction:'hide'
 }); Note that the CSS class 'x-tool-pdf' should
 have an associated style rule which provides an appropriate background image, something like: a.x-tool-pdf
 {background-image: url(../shared/extjs/images/pdf.gif)!important;}]]></description><name>toolTemplate</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of tool button configs to be added to the header tool area. When rendered, each tool is stored as an Element
 referenced by a public property called tools.<tool-type> Each tool config may contain the following properties: id :
 String Required. The type of tool to create. By default, this assigns a CSS class of the form x-tool-<tool-type> to the
 resulting tool Element. Ext provides CSS rules, and an icon sprite containing images for the tool types listed below.
 The developer may implement custom tools by supplying alternate CSS rules and background images: toggle (Created by
 default when collapsible is true) close minimize maximize restore gear pin unpin right left up down refresh minus plus
 help search save print handler : Function Required. The function to call when clicked. Arguments passed are: event :
 Ext.EventObject The click event. toolEl : Ext.Element The tool Element. panel : Ext.Panel The host Panel tc : Object The
 tool configuration object stopEvent : Boolean Defaults to true. Specify as false to allow click event to propagate.
 scope : Object The scope in which to call the handler. qtip : String/Object A tip string, or a config argument to
 Ext.QuickTip.register hidden : Boolean True to initially render hidden. on : Object A listener config object specifiying
 event listeners in the format of an argument to addListener Note that, apart from the toggle tool which is provided when
 a panel is collapsible, these tools only provide the visual button. Any required functionality must be provided by
 adding handlers that implement the necessary behavior. Example usage: tools:[{
     id:'refresh',
     qtip: 'Refresh form
 Data',
     // hidden:true,
     handler: function(event, toolEl, panel){
         // refresh logic
     }
 },
 {
    
 id:'help',
     qtip: 'Get Help',
     handler: function(event, toolEl, panel){
         // whatever
     }
 }] For the
 custom id of 'help' define two relevant css classes with a link to a 15x15 image: .x-tool-help {background-image:
 url(images/help.png);}
 .x-tool-help-over {background-image: url(images/help_over.png);}
 // if using an image
 sprite:
 .x-tool-help {background-image: url(images/help.png) no-repeat 0 0;}
 .x-tool-help-over
 {background-position:-15px 0;}]]></description><name>tools</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to have the tooltip follow the mouse as it moves over the target element (defaults to false).]]></description><name>trackMouse</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Overrides the baseCls setting to baseCls = 'x-plain' which renders the panel unstyled except for required attributes for
 Ext layouts to function (e.g. overflow:hidden).]]></description><name>unstyled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Width in pixels of the tip (defaults to auto). Width will be ignored if it exceeds the bounds of minWidth or maxWidth.
 The maximum supported value is 500.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local x (left) coordinate for this component if contained within a positioning container.]]></description><name>x</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered xtype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a child item of a Container is being specified not
 as a fully instantiated Component, but as a Component config object. The xtype will be looked up at render time up to
 determine what type of child Component to create. The predefined xtypes are listed here. If you subclass Components to
 create your own Components, you may register them using Ext.ComponentMgr.registerType in order to be able to take
 advantage of lazy instantiation and rendering.]]></description><name>xtype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local y (top) coordinate for this component if contained within a positioning container.]]></description><name>y</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 <p>Basic Toolbar class. Although the <tt><a href="output/Ext.Container.html#Ext.Container-defaultType"
 ext:member="defaultType" ext:cls="Ext.Container">defaultType</a></tt> for Toolbar is <tt><a
 href="output/Ext.Button.html" ext:cls="Ext.Button">button</a></tt>, Toolbar elements (child items for the Toolbar
 container) may be virtually any type of Component. Toolbar elements can be created explicitly via their constructors, or
 implicitly via their xtypes, and can be <tt><a href="output/Ext.Toolbar.html#Ext.Toolbar-add" ext:member="add"
 ext:cls="Ext.Toolbar">add</a></tt>ed dynamically.</p> 
 <p>Some items have shortcut strings for creation:</p>
 
 <pre>
 <u>Shortcut</u>  <u>xtype</u>          <u>Class</u>                  <u>Description</u>
 '-&gt;'      'tbfill'    
 <a href="output/Ext.Toolbar.Fill.html" ext:cls="Ext.Toolbar.Fill">Ext.Toolbar.Fill</a>       begin using the
 right-justified button container
 '-'       'tbseparator'  <a href="output/Ext.Toolbar.Separator.html"
 ext:cls="Ext.Toolbar.Separator">Ext.Toolbar.Separator</a>  add a vertical separator bar between toolbar items
 ' '      
 'tbspacer'     <a href="output/Ext.Toolbar.Spacer.html" ext:cls="Ext.Toolbar.Spacer">Ext.Toolbar.Spacer</a>     add
 horiztonal space between elements
 </pre> Example usage of various elements: 
 <pre><code><b>var</b> tb = <b>new</b>
 Ext.Toolbar({
     renderTo: document.body,
     width: 600,
     height: 100,
     items: [
         {
             <i>//xtype: <em>'button'</em>, // <b>default</b> <b>for</b> Toolbars, same as <em>'tbbutton'</em></i>
             text: <em>'Button'</em>
         },
         {
             xtype: <em>'splitbutton'</em>, <i>// same as
 <em>'tbsplitbutton'</em></i>
             text: <em>'Split Button'</em>
         },
         <i>// begin using the
 right-justified button container</i>
         <em>'-&gt;'</em>, <i>// same as {xtype: <em>'tbfill'</em>}, //
 Ext.Toolbar.Fill</i>
         {
             xtype: <em>'textfield'</em>,
             name: <em>'field1'</em>,
            
 emptyText: <em>'enter search term'</em>
         },
         <i>// add a vertical separator bar between toolbar items</i>
 
 <em>'-'</em>, <i>// same as {xtype: <em>'tbseparator'</em>} to create Ext.Toolbar.Separator</i>
         <em>'text
 1'</em>, <i>// same as {xtype: <em>'tbtext'</em>, text: <em>'text1'</em>} to create Ext.Toolbar.TextItem</i>
        
 {xtype: <em>'tbspacer'</em>},<i>// same as <em>' '</em> to create Ext.Toolbar.Spacer</i>
         <em>'text 2'</em>,
     
 {xtype: <em>'tbspacer'</em>, width: 50}, <i>// add a 50px space</i>
         <em>'text 3'</em>
     ]
 });</code></pre>
 Example adding a ComboBox within a menu of a button: 
 <pre><code><i>// ComboBox creation</i>
 <b>var</b> combo =
 <b>new</b> Ext.form.ComboBox({
     store: <b>new</b> Ext.data.ArrayStore({
         autoDestroy: true,
         fields:
 [<em>'initials'</em>, <em>'fullname'</em>],
         data : [
             [<em>'FF'</em>, <em>'Fred Flintstone'</em>],
   
 [<em>'BR'</em>, <em>'Barney Rubble'</em>]
         ]
     }),
     displayField: <em>'fullname'</em>,
     typeAhead: true,
 
 mode: <em>'local'</em>,
     forceSelection: true,
     triggerAction: <em>'all'</em>,
     emptyText: <em>'Select a
 name...'</em>,
     selectOnFocus: true,
     width: 135,
     getListParent: <b>function</b>() {
         <b>return</b>
 this.el.up(<em>'.x-menu'</em>);
     },
     iconCls: <em>'no-icon'</em> <i>//use iconCls <b>if</b> placing within menu to
 shift to right side of menu</i>
 });
 
 <i>// put ComboBox <b>in</b> a Menu</i>
 <b>var</b> menu = <b>new</b>
 Ext.menu.Menu({
     id: <em>'mainMenu'</em>,
     items: [
         combo <i>// A Field <b>in</b> a Menu</i>
    
 ]
 });
 
 <i>// add a Button <b>with</b> the menu</i>
 tb.add({
         text:<em>'Button w/ Menu'</em>,
         menu: menu 
 <i>// assign menu by instance</i>
     });
 tb.doLayout();</code></pre>]]></description><name>toolbar</name><tag-class>org.brushingbits.jnap.ui.extjs3.Toolbar</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[A string component id or the numeric index of the component that should be initially activated within the container's
 layout on render. For example, activeItem: 'item-1' or activeItem: 0 (index 0 = the first item in the container's
 collection). activeItem only applies to layout styles that can display items one at a time (like
 Ext.layout.AccordionLayout, Ext.layout.CardLayout and Ext.layout.FitLayout). Related to
 Ext.layout.ContainerLayout.activeItem.]]></description><name>activeItem</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Whether the component can move the Dom node when rendering (defaults to true).]]></description><name>allowDomMove</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use an
 AnchorLayout (or subclass thereof). based layout manager, for example: Ext.form.FormPanel specifying layout: 'anchor' //
 or 'form', or 'absolute' See Ext.layout.AnchorLayout.anchor also.]]></description><name>anchor</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element corresponding to a DIV that is already present in
 the document that specifies some structural markup for this component. Description : When applyTo is used, constituent
 parts of the component can also be specified by id or CSS class name within the main element, and the component being
 created may attempt to create its subcomponents from that markup if applicable. Notes : When using this config, a call
 to render() is not required. If applyTo is specified, any value passed for renderTo will be ignored and the target
 element's parent node will automatically be used as the component's container.]]></description><name>applyTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If true the container will automatically destroy any contained component that is removed from it, else destruction must
 be handled manually (defaults to true).]]></description><name>autoDestroy</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A tag name or DomHelper spec used to create the Element which will encapsulate this Component. You do not normally need
 to specify this. For the base classes Ext.Component, Ext.BoxComponent, and Ext.Container, this defaults to 'div'. The
 more complex Ext classes use a more complex DOM structure created by their own onRender methods. This is intended to
 allow the developer to create application-specific utility Components encapsulated by different DOM elements. Example
 usage: <pre><code>{
     xtype: 'box',
     autoEl: {
         tag: 'img',
         src: 'http://www.example.com/example.jpg'
     }
 },
 {
     xtype: 'box',
     autoEl: {
         tag: 'blockquote',
         html: 'autoEl is cool!'
     }
 }, {
     xtype: 'container',
     autoEl: 'ul',
     cls: 'ux-unordered-list',
     items: {
         xtype: 'box',
         autoEl: 'li',
   
      html: 'First list item'
     }
 }</pre></code>]]></description><name>autoEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to use height:'auto', false to use fixed height (or allow it to be managed by its parent Container's layout
 manager. Defaults to false. Note: Although many components inherit this config option, not all will function as expected
 with a height of 'auto'. Setting autoHeight:true means that the browser will manage height based on the element's
 contents, and that Ext will not manage it at all. If the browser is managing the height, be aware that resizes performed
 by the browser in response to changes within the structure of the Component cannot be detected. Therefore changes to the
 height might result in elements needing to be synchronized with the new height. Example: var w = new Ext.Window({
    
 title: 'Window',
     width: 600,
     autoHeight: true,
     items: {
         title: 'Collapse Me',
         height: 400,
  
 collapsible: true,
         border: false,
         listeners: {
             beforecollapse: function() {
                w.el.shadow.hide();
             },
             beforeexpand: function() {
                w.el.shadow.hide();
             },
             collapse: function() {
                w.syncShadow();
             },
             expand: function() {
                w.syncShadow();
             }
         }
     }
 }).show();]]></description><name>autoHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to use overflow:'auto' on the components layout element and show scroll bars automatically when necessary, false to
 clip any overflowing content (defaults to false).]]></description><name>autoScroll</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True if the component should check for hidden classes (e.g. 'x-hidden' or 'x-hide-display') and remove them on render
 (defaults to false).]]></description><name>autoShow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to use width:'auto', false to use fixed width (or allow it to be managed by its parent Container's layout manager.
 Defaults to false. Note: Although many components inherit this config option, not all will function as expected with a
 width of 'auto'. Setting autoWidth:true means that the browser will manage width based on the element's contents, and
 that Ext will not manage it at all. If the browser is managing the width, be aware that resizes performed by the browser
 in response to changes within the structure of the Component cannot be detected. Therefore changes to the width might
 result in elements needing to be synchronized with the new width. For example, where the target element is: <div
 id='grid-container' style='margin-left:25%;width:50%'></div> A Panel rendered into that target element must listen for
 browser window resize in order to relay its child items when the browser changes its width: var myPanel = new
 Ext.Panel({
     renderTo: 'grid-container',
     monitorResize: true, // relay on browser resize
     title: 'Panel',
    
 height: 400,
     autoWidth: true,
     layout: 'hbox',
     layoutConfig: {
         align: 'stretch'
     },
     defaults: {
         flex: 1
     },
     items: [{
         title: 'Box 1',
     }, {
         title: 'Box 2'
     }, {
         title:
 'Box 3'
     }],
 });]]></description><name>autoWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to ['add', 'remove'].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[When set to true (50 milliseconds) or a number of milliseconds, the layout assigned for this container will buffer the
 frequency it calculates and does a re-layout of components. This is useful for heavy containers or containers with a
 large quantity of sub-components for which frequent layout calls would be expensive. Defaults to 50.]]></description><name>bufferResize</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default position at which to align child items. Defaults to "left" May be specified as "center" to cause items added
 before a Fill (A "->") item to be centered in the Toolbar. Items added after a Fill are still right-aligned. Specify as
 "right" to right align all child items.]]></description><name>buttonAlign</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class used to to apply to the special clearing div rendered directly after each form field wrapper to provide
 field clearing (defaults to 'x-form-clear-left'). Note: this config is only used when this Component is rendered by a
 Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or specifying
 layout:'form') and either a fieldLabel is specified or isFormField=true is specified. See Ext.layout.FormLayout.fieldTpl
 also.]]></description><name>clearCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element (defaults to ''). This can be useful for
 adding customized styles to the component or any of its children using standard CSS rules.]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's container. This can be useful for adding customized
 styles to the container or any of its children using standard CSS rules. See Ext.layout.ContainerLayout.extraCls also.
 Note: ctCls defaults to '' except for the following class which assigns a value by default: Box Layout :
 'x-box-layout-ct' To configure the above Class with an extra CSS class append to the default. For example, for BoxLayout
 (Hbox and Vbox): ctCls: 'x-box-layout-ct custom-class']]></description><name>ctCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default xtype of child Components to create in this Container when a child item is specified as a raw configuration
 object, rather than as an instantiated Component. Defaults to 'panel', except Ext.menu.Menu which defaults to
 'menuitem', and Ext.Toolbar and Ext.ButtonGroup which default to 'button'.]]></description><name>defaultType</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[This option is a means of applying default settings to all added items whether added through the items config or via the
 add or insert methods. If an added item is a config object, and not an instantiated Component, then the default
 properties are unconditionally applied. If the added item is an instantiated Component, then the default properties are
 applied conditionally so as not to override existing properties in the item. If the defaults option is specified as a
 function, then the function will be called using this Container as the scope (this reference) and passing the added item
 as the first parameter. Any resulting object from that call is then applied to the item as default properties. For
 example, to automatically apply padding to the body of each of a set of contained Ext.Panel items, you could pass:
 defaults: {bodyStyle:'padding:15px'}. Usage: defaults: {               // defaults are applied to items, not the
 container
     autoScroll:true
 },
 items: [
     {
         xtype: 'panel',   // defaults do not have precedence over
       
 id: 'panel1',     // options in config objects, so the defaults
         autoScroll: false // will not be applied here,
 panel1 will be autoScroll:false
     },
     new Ext.Panel({       // defaults do have precedence over options
         id:
 'panel2',     // options in components, so the defaults
         autoScroll: false // will be applied here, panel2 will
 be autoScroll:true.
     })
 ]]]></description><name>defaults</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component disabled (default is false).]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class added to the component when it is disabled (defaults to 'x-item-disabled').]]></description><name>disabledClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA['top' or 'bottom'.]]></description><name>dockPosition</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to false. Configure true to make the toolbar provide a button which activates a dropdown Menu to show items
 which overflow the Toolbar's width.]]></description><name>enableOverflow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The label text to display next to this Component (defaults to ''). Note: this config is only used when this Component is
 rendered by a Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or
 specifying layout:'form'). Also see hideLabel and Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
    
 height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name'
    
 }]
 });]]></description><name>fieldLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use a
 BoxLayout. Each child Component with a flex property will be flexed either vertically (by a VBoxLayout) or horizontally
 (by an HBoxLayout) according to the item's relative flex value compared to the sum of all Components with flex value
 specified. Any child items that have either a flex = 0 or flex = undefined will not be 'flexed' (the initial size will
 not be changed).]]></description><name>flex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If true the container will force a layout initially even if hidden or collapsed. This option is useful for forcing forms
 to render in collapsed or hidden containers. (defaults to false).]]></description><name>forceLayout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component hidden (default is false). If true, the hide method will be called internally.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide the borders of each contained component, false to defer to the component's existing border settings
 (defaults to false).]]></description><name>hideBorders</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to completely hide the label element (label and separator). Defaults to false. By default, even if you do not
 specify a fieldLabel the space will still be reserved so that the field will line up with other fields that do have
 labels. Setting this to true will cause the field to not reserve that space. Note: see the note for clearCls. Example
 use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield'
        
 hideLabel: true
     }]
 });]]></description><name>hideLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[How this component should be hidden. Supported values are 'visibility' (css visibility), 'offsets' (negative offset
 position) and 'display' (css display). Note: the default of 'display' is generally preferred since items are
 automatically laid out when they are first shown (no sizing is done while hidden).]]></description><name>hideMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide and show the component's container when hide/show is called on the component, false to hide and show the
 component itself (defaults to false). For example, this can be used as a shortcut for a hide button on a window by
 setting hide:true on the button when adding it to its parent container.]]></description><name>hideParent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id of this component (defaults to an auto-assigned id). You should assign an id if you need to be able to
 access the component later and you do not have an object reference available (e.g., using Ext.getCmp). Note that this id
 will also be used as the element id for the containing HTML element that is rendered to the page for this component.
 This allows you to write id-based CSS rules to style the specific instance of this component uniquely, and also to
 select sub-elements using this component's id as the parent. Note: to avoid complications imposed by a unique id also
 see itemId and ref. Note: to access the container of an item see ownerCt.]]></description><name>id</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use the
 FormLayout layout manager (e.g. Ext.form.FormPanel or specifying layout:'form'). An additional CSS class to apply to the
 div wrapping the form item element of this field. If supplied, itemCls at the field level will override the default
 itemCls supplied at the container level. The value specified for itemCls will be added to the default class
 ('x-form-item'). Since it is applied to the item wrapper (see Ext.layout.FormLayout.fieldTpl), it allows you to write
 standard CSS rules that can apply to the field, the label (if specified), or any other element within the markup for the
 field. Note: see the note for fieldLabel. Example use: // Apply a style to the field's label:
 <style>
     .required
 .x-form-item-label {font-weight:bold;color:red;}
 </style>
 
 new Ext.FormPanel({
     height: 100,
     renderTo:
 Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         itemCls: 'required' //this
 label will be styled
     },{
         xtype: 'textfield',
         fieldLabel: 'Favorite Color'
     }]
 });]]></description><name>itemCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An itemId can be used as an alternative way to get a reference to a component when no object reference is available.
 Instead of using an id with Ext.getCmp, use itemId with Ext.Container.getComponent which will retrieve itemId's or id's.
 Since itemId's are an index to the container's internal MixedCollection, the itemId is scoped locally to the container
 -- avoiding potential conflicts with Ext.ComponentMgr which requires a unique id. var c = new Ext.Panel({ //
     height:
 300,
     renderTo: document.body,
     layout: 'auto',
     items: [
         {
             itemId: 'p1',
            
 title: 'Panel 1',
             height: 150
         },
         {
             itemId: 'p2',
             title: 'Panel 2',
  
 height: 150
         }
     ]
 })
 p1 = c.getComponent('p1'); // not the same as Ext.getCmp()
 p2 =
 p1.ownerCt.getComponent('p2'); // reference via a sibling Also see id and ref. Note: to access the container of an item
 see ownerCt.]]></description><name>itemId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The separator to display after the text of each fieldLabel. This property may be configured at various levels. The order
 of precedence is: field / component level container level layout level (defaults to colon ':') To display no separator
 for this field's label specify empty string ''. Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 layoutConfig: {
         labelSeparator: '~'   // layout config has lowest priority (defaults to ':')
     },
    
 labelSeparator: '>>',     // config at container level
     items: [{
         xtype: 'textfield',
         fieldLabel:
 'Field 1',
         labelSeparator: '...' // field/component level config supersedes others
     },{
         xtype:
 'textfield',
         fieldLabel: 'Field 2' // labelSeparator will be '='
     }]
 });]]></description><name>labelSeparator</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS style specification string to apply directly to this field's label. Defaults to the container's labelStyle value
 if set (e.g., Ext.layout.FormLayout.labelStyle , or ''). Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         labelStyle: 'font-weight:bold;'
     }]
 });]]></description><name>labelStyle</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[*Important: In order for child items to be correctly sized and positioned, typically a layout manager must be specified
 through the layout configuration option. The sizing and positioning of child items is the responsibility of the
 Container's layout manager which creates and manages the type of layout you have in mind. For example:
 <pre><code>
 new Ext.Window({
 
 width:300, height: 300,
     layout: 'fit', // explicitly set layout manager: override the default (layout:'auto')
    
 items: [{
         title: 'Panel inside a Window'
     }]
 }).show();</pre></code>
 If the layout configuration is not explicitly
 specified for a general purpose container (e.g. Container or Panel) the default layout manager will be used which does
 nothing but render child components sequentially into the Container (no sizing or positioning will be performed in this
 situation). Some container classes implicitly specify a default layout (e.g. FormPanel specifies layout:'form'). Other
 specific purpose classes internally specify/manage their internal layout (e.g. GridPanel, TabPanel, TreePanel, Toolbar,
 Menu, etc.). layout may be specified as either as an Object or as a String: Specify as an Object Example usage: layout:
 {
     type: 'vbox',
     padding: '5',
     align: 'left'
 } type The layout type to be used for this container. If not
 specified, a default Ext.layout.ContainerLayout will be created and used. Valid layout type values are: absolute
 accordion anchor auto Default border card column fit form hbox menu table toolbar vbox Layout specific configuration
 properties Additional layout specific configuration properties may also be specified. For complete details regarding the
 valid config options for each layout type, see the layout class corresponding to the type specified. Specify as a String
 Example usage: layout: 'vbox',
 layoutConfig: {
     padding: '5',
     align: 'left'
 } layout The layout type to be used
 for this container (see list of valid layout type values above). layoutConfig Additional layout specific configuration
 properties. For complete details regarding the valid config options for each layout type, see the layout class
 corresponding to the layout specified.]]></description><name>layout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout or one of the two BoxLayout subclasses. An object containing margins to apply to this BoxComponent in the
 format: {
     top: (top margin),
     right: (right margin),
     bottom: (bottom margin),
     left: (left margin)
 } May
 also be a string containing space-separated, numeric margin values. The order of the sides associated with each value
 matches the way CSS processes margin values: If there is only one value, it applies to all sides. If there are two
 values, the top and bottom borders are set to the first value and the right and left are set to the second. If there are
 three values, the top is set to the first value, the left and right are set to the second, and the bottom is set to the
 third. If there are four values, they apply to the top, right, bottom, and left, respectively. Defaults to: {top:0,
 right:0, bottom:0, left:0}]]></description><name>margins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically monitor window resize events to handle anything that is sensitive to the current size of the
 viewport. This value is typically managed by the chosen layout and should not need to be set manually.]]></description><name>monitorResize</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element when the mouse moves over the Element, and
 removed when the mouse moves out. (defaults to ''). This can be useful for adding customized 'active' or 'hover' styles
 to the component or any of its children using standard CSS rules.]]></description><name>overCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level x coordinate for this component if contained within a positioning container.]]></description><name>pageX</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level y coordinate for this component if contained within a positioning container.]]></description><name>pageY</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered ptype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a Plugin is being specified not as a fully
 instantiated Component, but as a Component config object. The ptype will be looked up at render time up to determine
 what type of Plugin to create. If you create your own Plugins, you may register them using
 Ext.ComponentMgr.registerPlugin in order to be able to take advantage of lazy instantiation and rendering.]]></description><name>ptype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A path specification, relative to the Component's ownerCt specifying into which ancestor Container to place a named
 reference to this Component. The ancestor axis can be traversed by using '/' characters in the path. For example, to put
 a reference to a Toolbar Button into the Panel which owns the Toolbar: var myGrid = new Ext.grid.EditorGridPanel({
    
 title: 'My EditorGridPanel',
     store: myStore,
     colModel: myColModel,
     tbar: [{
         text: 'Save',
        
 handler: saveChanges,
         disabled: true,
         ref: '../saveButton'
     }],
     listeners: {
         afteredit:
 function() {
 //          The button reference is in the GridPanel
             myGrid.saveButton.enable();
         }
    
 }
 }); In the code above, if the ref had been 'saveButton' the reference would have been placed into the Toolbar. Each
 '/' in the ref moves up one level from the Component's ownerCt. Also see the added and removed events.]]></description><name>ref</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout layout manager (e.g. specifying layout:'border'). See Ext.layout.BorderLayout also.]]></description><name>region</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The event to listen to for resizing in layouts. Defaults to 'resize'.]]></description><name>resizeEvent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should trigger this component to save its state (defaults to none). stateEvents may
 be any type of event supported by this component, including browser or custom events (e.g., ['click',
 'customerchange']). See stateful for an explanation of saving and restoring Component state.]]></description><name>stateEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id for this component to use for state management purposes (defaults to the component id if one was set,
 otherwise null if the component is using a generated id). See stateful for an explanation of saving and restoring
 Component state.]]></description><name>stateId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A flag which causes the Component to attempt to restore the state of internal properties from a saved state on startup.
 The component must have either a stateId or id assigned for state to be managed. Auto-generated ids are not guaranteed
 to be stable across page loads and cannot be relied upon to save and restore the same state for a component. For state
 saving to work, the state manager's provider must have been set to an implementation of Ext.state.Provider which
 overrides the set and get methods to save and recall name/value pairs. A built-in implementation,
 Ext.state.CookieProvider is available. To set the state provider for the current page: Ext.state.Manager.setProvider(new
 Ext.state.CookieProvider({
     expires: new Date(new Date().getTime()+(1000*60*60*24*7)), //7 days from now
 })); A
 stateful Component attempts to save state when one of the events listed in the stateEvents configuration fires. To save
 state, a stateful Component first serializes its state by calling getState. By default, this function does nothing. The
 developer must provide an implementation which returns an object hash which represents the Component's restorable state.
 The value yielded by getState is passed to Ext.state.Manager.set which uses the configured Ext.state.Provider to save
 the object keyed by the Component's stateId, or, if that is not specified, its id. During construction, a stateful
 Component attempts to restore its state by calling Ext.state.Manager.get passing the stateId, or, if that is not
 specified, the id. The resulting object is passed to applyState. The default implementation of applyState simply copies
 properties into the object, but a developer may override this to support more behaviour. You can perform extra
 processing on state save and restore by attaching handlers to the beforestaterestore, staterestore, beforestatesave and
 statesave events.]]></description><name>stateful</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
     title: 'Some Title',
     renderTo: Ext.getBody(),
     width: 400, height:
 300,
     layout: 'form',
     items: [{
         xtype: 'textarea',
         style: {
             width: '95%',
            
 marginBottom: '10px'
         }
     },
         new Ext.Button({
             text: 'Send',
             minWidth: '100',
   
          style: {
                 marginBottom: '10px'
             }
         })
     ]
 });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is a child item of a TabPanel. A string to be used as innerHTML
 (html tags are accepted) to show in a tooltip when mousing over the associated tab selector element.
 Ext.QuickTips.init() must be called in order for the tips to render.]]></description><name>tabTip</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local x (left) coordinate for this component if contained within a positioning container.]]></description><name>x</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered xtype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a child item of a Container is being specified not
 as a fully instantiated Component, but as a Component config object. The xtype will be looked up at render time up to
 determine what type of child Component to create. The predefined xtypes are listed here. If you subclass Components to
 create your own Components, you may register them using Ext.ComponentMgr.registerType in order to be able to take
 advantage of lazy instantiation and rendering.]]></description><name>xtype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local y (top) coordinate for this component if contained within a positioning container.]]></description><name>y</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 The base class that other non-interacting Toolbar Item classes should extend in order to get some basic common toolbar
 item functionality.]]></description><name>toolbar.item</name><tag-class>org.brushingbits.jnap.ui.extjs3.toolbar.Item</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[Whether the component can move the Dom node when rendering (defaults to true).]]></description><name>allowDomMove</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use an
 AnchorLayout (or subclass thereof). based layout manager, for example: Ext.form.FormPanel specifying layout: 'anchor' //
 or 'form', or 'absolute' See Ext.layout.AnchorLayout.anchor also.]]></description><name>anchor</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element corresponding to a DIV that is already present in
 the document that specifies some structural markup for this component. Description : When applyTo is used, constituent
 parts of the component can also be specified by id or CSS class name within the main element, and the component being
 created may attempt to create its subcomponents from that markup if applicable. Notes : When using this config, a call
 to render() is not required. If applyTo is specified, any value passed for renderTo will be ignored and the target
 element's parent node will automatically be used as the component's container.]]></description><name>applyTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A tag name or DomHelper spec used to create the Element which will encapsulate this Component. You do not normally need
 to specify this. For the base classes Ext.Component, Ext.BoxComponent, and Ext.Container, this defaults to 'div'. The
 more complex Ext classes use a more complex DOM structure created by their own onRender methods. This is intended to
 allow the developer to create application-specific utility Components encapsulated by different DOM elements. Example
 usage: <pre><code>{
     xtype: 'box',
     autoEl: {
         tag: 'img',
         src: 'http://www.example.com/example.jpg'
     }
 },
 {
     xtype: 'box',
     autoEl: {
         tag: 'blockquote',
         html: 'autoEl is cool!'
     }
 }, {
     xtype: 'container',
     autoEl: 'ul',
     cls: 'ux-unordered-list',
     items: {
         xtype: 'box',
         autoEl: 'li',
   
      html: 'First list item'
     }
 }</pre></code>]]></description><name>autoEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to use height:'auto', false to use fixed height (or allow it to be managed by its parent Container's layout
 manager. Defaults to false. Note: Although many components inherit this config option, not all will function as expected
 with a height of 'auto'. Setting autoHeight:true means that the browser will manage height based on the element's
 contents, and that Ext will not manage it at all. If the browser is managing the height, be aware that resizes performed
 by the browser in response to changes within the structure of the Component cannot be detected. Therefore changes to the
 height might result in elements needing to be synchronized with the new height. Example: var w = new Ext.Window({
    
 title: 'Window',
     width: 600,
     autoHeight: true,
     items: {
         title: 'Collapse Me',
         height: 400,
  
 collapsible: true,
         border: false,
         listeners: {
             beforecollapse: function() {
                w.el.shadow.hide();
             },
             beforeexpand: function() {
                w.el.shadow.hide();
             },
             collapse: function() {
                w.syncShadow();
             },
             expand: function() {
                w.syncShadow();
             }
         }
     }
 }).show();]]></description><name>autoHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to use overflow:'auto' on the components layout element and show scroll bars automatically when necessary, false to
 clip any overflowing content (defaults to false).]]></description><name>autoScroll</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True if the component should check for hidden classes (e.g. 'x-hidden' or 'x-hide-display') and remove them on render
 (defaults to false).]]></description><name>autoShow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to use width:'auto', false to use fixed width (or allow it to be managed by its parent Container's layout manager.
 Defaults to false. Note: Although many components inherit this config option, not all will function as expected with a
 width of 'auto'. Setting autoWidth:true means that the browser will manage width based on the element's contents, and
 that Ext will not manage it at all. If the browser is managing the width, be aware that resizes performed by the browser
 in response to changes within the structure of the Component cannot be detected. Therefore changes to the width might
 result in elements needing to be synchronized with the new width. For example, where the target element is: <div
 id='grid-container' style='margin-left:25%;width:50%'></div> A Panel rendered into that target element must listen for
 browser window resize in order to relay its child items when the browser changes its width: var myPanel = new
 Ext.Panel({
     renderTo: 'grid-container',
     monitorResize: true, // relay on browser resize
     title: 'Panel',
    
 height: 400,
     autoWidth: true,
     layout: 'hbox',
     layoutConfig: {
         align: 'stretch'
     },
     defaults: {
         flex: 1
     },
     items: [{
         title: 'Box 1',
     }, {
         title: 'Box 2'
     }, {
         title:
 'Box 3'
     }],
 });]]></description><name>autoWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to [].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class used to to apply to the special clearing div rendered directly after each form field wrapper to provide
 field clearing (defaults to 'x-form-clear-left'). Note: this config is only used when this Component is rendered by a
 Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or specifying
 layout:'form') and either a fieldLabel is specified or isFormField=true is specified. See Ext.layout.FormLayout.fieldTpl
 also.]]></description><name>clearCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element (defaults to ''). This can be useful for
 adding customized styles to the component or any of its children using standard CSS rules.]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's container. This can be useful for adding customized
 styles to the container or any of its children using standard CSS rules. See Ext.layout.ContainerLayout.extraCls also.
 Note: ctCls defaults to '' except for the following class which assigns a value by default: Box Layout :
 'x-box-layout-ct' To configure the above Class with an extra CSS class append to the default. For example, for BoxLayout
 (Hbox and Vbox): ctCls: 'x-box-layout-ct custom-class']]></description><name>ctCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component disabled (default is false).]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class added to the component when it is disabled (defaults to 'x-item-disabled').]]></description><name>disabledClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The label text to display next to this Component (defaults to ''). Note: this config is only used when this Component is
 rendered by a Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or
 specifying layout:'form'). Also see hideLabel and Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
    
 height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name'
    
 }]
 });]]></description><name>fieldLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use a
 BoxLayout. Each child Component with a flex property will be flexed either vertically (by a VBoxLayout) or horizontally
 (by an HBoxLayout) according to the item's relative flex value compared to the sum of all Components with flex value
 specified. Any child items that have either a flex = 0 or flex = undefined will not be 'flexed' (the initial size will
 not be changed).]]></description><name>flex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component hidden (default is false). If true, the hide method will be called internally.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to completely hide the label element (label and separator). Defaults to false. By default, even if you do not
 specify a fieldLabel the space will still be reserved so that the field will line up with other fields that do have
 labels. Setting this to true will cause the field to not reserve that space. Note: see the note for clearCls. Example
 use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield'
        
 hideLabel: true
     }]
 });]]></description><name>hideLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[How this component should be hidden. Supported values are 'visibility' (css visibility), 'offsets' (negative offset
 position) and 'display' (css display). Note: the default of 'display' is generally preferred since items are
 automatically laid out when they are first shown (no sizing is done while hidden).]]></description><name>hideMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide and show the component's container when hide/show is called on the component, false to hide and show the
 component itself (defaults to false). For example, this can be used as a shortcut for a hide button on a window by
 setting hide:true on the button when adding it to its parent container.]]></description><name>hideParent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id of this component (defaults to an auto-assigned id). You should assign an id if you need to be able to
 access the component later and you do not have an object reference available (e.g., using Ext.getCmp). Note that this id
 will also be used as the element id for the containing HTML element that is rendered to the page for this component.
 This allows you to write id-based CSS rules to style the specific instance of this component uniquely, and also to
 select sub-elements using this component's id as the parent. Note: to avoid complications imposed by a unique id also
 see itemId and ref. Note: to access the container of an item see ownerCt.]]></description><name>id</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use the
 FormLayout layout manager (e.g. Ext.form.FormPanel or specifying layout:'form'). An additional CSS class to apply to the
 div wrapping the form item element of this field. If supplied, itemCls at the field level will override the default
 itemCls supplied at the container level. The value specified for itemCls will be added to the default class
 ('x-form-item'). Since it is applied to the item wrapper (see Ext.layout.FormLayout.fieldTpl), it allows you to write
 standard CSS rules that can apply to the field, the label (if specified), or any other element within the markup for the
 field. Note: see the note for fieldLabel. Example use: // Apply a style to the field's label:
 <style>
     .required
 .x-form-item-label {font-weight:bold;color:red;}
 </style>
 
 new Ext.FormPanel({
     height: 100,
     renderTo:
 Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         itemCls: 'required' //this
 label will be styled
     },{
         xtype: 'textfield',
         fieldLabel: 'Favorite Color'
     }]
 });]]></description><name>itemCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An itemId can be used as an alternative way to get a reference to a component when no object reference is available.
 Instead of using an id with Ext.getCmp, use itemId with Ext.Container.getComponent which will retrieve itemId's or id's.
 Since itemId's are an index to the container's internal MixedCollection, the itemId is scoped locally to the container
 -- avoiding potential conflicts with Ext.ComponentMgr which requires a unique id. var c = new Ext.Panel({ //
     height:
 300,
     renderTo: document.body,
     layout: 'auto',
     items: [
         {
             itemId: 'p1',
            
 title: 'Panel 1',
             height: 150
         },
         {
             itemId: 'p2',
             title: 'Panel 2',
  
 height: 150
         }
     ]
 })
 p1 = c.getComponent('p1'); // not the same as Ext.getCmp()
 p2 =
 p1.ownerCt.getComponent('p2'); // reference via a sibling Also see id and ref. Note: to access the container of an item
 see ownerCt.]]></description><name>itemId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The separator to display after the text of each fieldLabel. This property may be configured at various levels. The order
 of precedence is: field / component level container level layout level (defaults to colon ':') To display no separator
 for this field's label specify empty string ''. Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 layoutConfig: {
         labelSeparator: '~'   // layout config has lowest priority (defaults to ':')
     },
    
 labelSeparator: '>>',     // config at container level
     items: [{
         xtype: 'textfield',
         fieldLabel:
 'Field 1',
         labelSeparator: '...' // field/component level config supersedes others
     },{
         xtype:
 'textfield',
         fieldLabel: 'Field 2' // labelSeparator will be '='
     }]
 });]]></description><name>labelSeparator</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS style specification string to apply directly to this field's label. Defaults to the container's labelStyle value
 if set (e.g., Ext.layout.FormLayout.labelStyle , or ''). Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         labelStyle: 'font-weight:bold;'
     }]
 });]]></description><name>labelStyle</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout or one of the two BoxLayout subclasses. An object containing margins to apply to this BoxComponent in the
 format: {
     top: (top margin),
     right: (right margin),
     bottom: (bottom margin),
     left: (left margin)
 } May
 also be a string containing space-separated, numeric margin values. The order of the sides associated with each value
 matches the way CSS processes margin values: If there is only one value, it applies to all sides. If there are two
 values, the top and bottom borders are set to the first value and the right and left are set to the second. If there are
 three values, the top is set to the first value, the left and right are set to the second, and the bottom is set to the
 third. If there are four values, they apply to the top, right, bottom, and left, respectively. Defaults to: {top:0,
 right:0, bottom:0, left:0}]]></description><name>margins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element when the mouse moves over the Element, and
 removed when the mouse moves out. (defaults to ''). This can be useful for adding customized 'active' or 'hover' styles
 to the component or any of its children using standard CSS rules.]]></description><name>overCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Text to be used for the menu if the item is overflowed.]]></description><name>overflowText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level x coordinate for this component if contained within a positioning container.]]></description><name>pageX</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level y coordinate for this component if contained within a positioning container.]]></description><name>pageY</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered ptype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a Plugin is being specified not as a fully
 instantiated Component, but as a Component config object. The ptype will be looked up at render time up to determine
 what type of Plugin to create. If you create your own Plugins, you may register them using
 Ext.ComponentMgr.registerPlugin in order to be able to take advantage of lazy instantiation and rendering.]]></description><name>ptype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A path specification, relative to the Component's ownerCt specifying into which ancestor Container to place a named
 reference to this Component. The ancestor axis can be traversed by using '/' characters in the path. For example, to put
 a reference to a Toolbar Button into the Panel which owns the Toolbar: var myGrid = new Ext.grid.EditorGridPanel({
    
 title: 'My EditorGridPanel',
     store: myStore,
     colModel: myColModel,
     tbar: [{
         text: 'Save',
        
 handler: saveChanges,
         disabled: true,
         ref: '../saveButton'
     }],
     listeners: {
         afteredit:
 function() {
 //          The button reference is in the GridPanel
             myGrid.saveButton.enable();
         }
    
 }
 }); In the code above, if the ref had been 'saveButton' the reference would have been placed into the Toolbar. Each
 '/' in the ref moves up one level from the Component's ownerCt. Also see the added and removed events.]]></description><name>ref</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout layout manager (e.g. specifying layout:'border'). See Ext.layout.BorderLayout also.]]></description><name>region</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should trigger this component to save its state (defaults to none). stateEvents may
 be any type of event supported by this component, including browser or custom events (e.g., ['click',
 'customerchange']). See stateful for an explanation of saving and restoring Component state.]]></description><name>stateEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id for this component to use for state management purposes (defaults to the component id if one was set,
 otherwise null if the component is using a generated id). See stateful for an explanation of saving and restoring
 Component state.]]></description><name>stateId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A flag which causes the Component to attempt to restore the state of internal properties from a saved state on startup.
 The component must have either a stateId or id assigned for state to be managed. Auto-generated ids are not guaranteed
 to be stable across page loads and cannot be relied upon to save and restore the same state for a component. For state
 saving to work, the state manager's provider must have been set to an implementation of Ext.state.Provider which
 overrides the set and get methods to save and recall name/value pairs. A built-in implementation,
 Ext.state.CookieProvider is available. To set the state provider for the current page: Ext.state.Manager.setProvider(new
 Ext.state.CookieProvider({
     expires: new Date(new Date().getTime()+(1000*60*60*24*7)), //7 days from now
 })); A
 stateful Component attempts to save state when one of the events listed in the stateEvents configuration fires. To save
 state, a stateful Component first serializes its state by calling getState. By default, this function does nothing. The
 developer must provide an implementation which returns an object hash which represents the Component's restorable state.
 The value yielded by getState is passed to Ext.state.Manager.set which uses the configured Ext.state.Provider to save
 the object keyed by the Component's stateId, or, if that is not specified, its id. During construction, a stateful
 Component attempts to restore its state by calling Ext.state.Manager.get passing the stateId, or, if that is not
 specified, the id. The resulting object is passed to applyState. The default implementation of applyState simply copies
 properties into the object, but a developer may override this to support more behaviour. You can perform extra
 processing on state save and restore by attaching handlers to the beforestaterestore, staterestore, beforestatesave and
 statesave events.]]></description><name>stateful</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
     title: 'Some Title',
     renderTo: Ext.getBody(),
     width: 400, height:
 300,
     layout: 'form',
     items: [{
         xtype: 'textarea',
         style: {
             width: '95%',
            
 marginBottom: '10px'
         }
     },
         new Ext.Button({
             text: 'Send',
             minWidth: '100',
   
          style: {
                 marginBottom: '10px'
             }
         })
     ]
 });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is a child item of a TabPanel. A string to be used as innerHTML
 (html tags are accepted) to show in a tooltip when mousing over the associated tab selector element.
 Ext.QuickTips.init() must be called in order for the tips to render.]]></description><name>tabTip</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local x (left) coordinate for this component if contained within a positioning container.]]></description><name>x</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered xtype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a child item of a Container is being specified not
 as a fully instantiated Component, but as a Component config object. The xtype will be looked up at render time up to
 determine what type of child Component to create. The predefined xtypes are listed here. If you subclass Components to
 create your own Components, you may register them using Ext.ComponentMgr.registerType in order to be able to take
 advantage of lazy instantiation and rendering.]]></description><name>xtype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local y (top) coordinate for this component if contained within a positioning container.]]></description><name>y</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 <p>As the amount of records increases, the time required for the browser to render them increases. Paging is used to
 reduce the amount of data exchanged with the client. Note: if there are more records/rows than can be viewed in the
 available screen area, vertical scrollbars will be added.</p> 
 <p>Paging is typically handled on the server side (see
 exception below). The client sends parameters to the server side, which the server needs to interpret and then respond
 with the approprate data.</p> 
 <p><b>Ext.PagingToolbar</b> is a specialized toolbar that is bound to a <a
 href="output/Ext.data.Store.html" ext:cls="Ext.data.Store">Ext.data.Store</a> and provides automatic paging control.
 This Component <a href="output/Ext.data.Store.html#Ext.data.Store-load" ext:member="load"
 ext:cls="Ext.data.Store">load</a>s blocks of data into the <tt><a
 href="output/Ext.PagingToolbar.html#Ext.PagingToolbar-store" ext:member="store"
 ext:cls="Ext.PagingToolbar">store</a></tt> by passing <a href="output/Ext.data.Store.html#Ext.data.Store-paramNames"
 ext:member="paramNames" ext:cls="Ext.data.Store">paramNames</a> used for paging criteria.</p> 
 <p>PagingToolbar is
 typically used as one of the Grid's toolbars:</p> 
 <pre><code>Ext.QuickTips.init(); <i>// to display button quicktips</i>
 
 <b>var</b> myStore = <b>new</b> Ext.data.Store({
     reader: <b>new</b> Ext.data.JsonReader({
         <a
 href="output/Ext.data.JsonReader.html#Ext.data.JsonReader-totalProperty" ext:member="totalProperty"
 ext:cls="Ext.data.JsonReader">totalProperty</a>: <em>'results'</em>, 
         ...
     }),
     ...
 });
 
 <b>var</b>
 myPageSize = 25;  <i>// server script should only send back 25 items at a time</i>
 
 <b>var</b> grid = <b>new</b>
 Ext.grid.GridPanel({
     ...
     store: myStore,
     bbar: <b>new</b> Ext.PagingToolbar({
         <a
 href="output/Ext.PagingToolbar.html#Ext.PagingToolbar-store" ext:member="store" ext:cls="Ext.PagingToolbar">store</a>:
 myStore,       <i>// grid and PagingToolbar using same store</i>
         <a
 href="output/Ext.PagingToolbar.html#Ext.PagingToolbar-displayInfo" ext:member="displayInfo"
 ext:cls="Ext.PagingToolbar">displayInfo</a>: true,
         <a
 href="output/Ext.PagingToolbar.html#Ext.PagingToolbar-pageSize" ext:member="pageSize"
 ext:cls="Ext.PagingToolbar">pageSize</a>: myPageSize,
         <a
 href="output/Ext.PagingToolbar.html#Ext.PagingToolbar-prependButtons" ext:member="prependButtons"
 ext:cls="Ext.PagingToolbar">prependButtons</a>: true,
         items: [
             <em>'text 1'</em>
         ]
    
 })
 });</code></pre> 
 <p>To use paging, pass the paging requirements to the server when the store is first loaded.</p>
 
 <pre><code>store.load({
     params: {
         <i>// specify params <b>for</b> the first page load <b>if</b> using
 paging</i>
         start: 0,          
         limit: myPageSize,
         <i>// other params</i>
         foo:  
 <em>'bar'</em>
     }
 });</code></pre> 
 <p>If using <a href="output/Ext.data.Store.html#Ext.data.Store-autoLoad"
 ext:member="autoLoad" ext:cls="Ext.data.Store">store's autoLoad</a> configuration:</p> 
 <pre><code><b>var</b> myStore =
 <b>new</b> Ext.data.Store({
     <a href="output/Ext.data.Store.html#Ext.data.Store-autoLoad" ext:member="autoLoad"
 ext:cls="Ext.data.Store">autoLoad</a>: {params:{start: 0, limit: 25}},
     ...
 });</code></pre> 
 <p>The packet sent back
 from the server would have this form:</p> 
 <pre><code>{
     <em>&quot;success&quot;</em>: true,
    
 <em>&quot;results&quot;</em>: 2000, 
     <em>&quot;rows&quot;</em>: [ <i>// <b>*Note:</b> this must be an Array </i>
    
 { <em>&quot;id&quot;</em>:  1, <em>&quot;name&quot;</em>: <em>&quot;Bill&quot;</em>, <em>&quot;occupation&quot;</em>:
 <em>&quot;Gardener&quot;</em> },
         { <em>&quot;id&quot;</em>:  2, <em>&quot;name&quot;</em>: 
 <em>&quot;Ben&quot;</em>, <em>&quot;occupation&quot;</em>: <em>&quot;Horticulturalist&quot;</em> },
         ...
        
 { <em>&quot;id&quot;</em>: 25, <em>&quot;name&quot;</em>:  <em>&quot;Sue&quot;</em>, <em>&quot;occupation&quot;</em>:
 <em>&quot;Botanist&quot;</em> }
     ]
 }</code></pre> 
 <p><u>Paging with Local Data</u></p> 
 <p>Paging can also be
 accomplished with local data using extensions:</p> 
 <div class="mdetail-params">
  <ul> 
   <li><a
 href="http://extjs.com/forum/showthread.php?t=71532">Ext.ux.data.PagingStore</a></li> 
   <li>Paging Memory Proxy
 (examples/ux/PagingMemoryProxy.js)</li> 
  </ul>
 </div>]]></description><name>toolbar.paging</name><tag-class>org.brushingbits.jnap.ui.extjs3.PagingToolbar</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[A string component id or the numeric index of the component that should be initially activated within the container's
 layout on render. For example, activeItem: 'item-1' or activeItem: 0 (index 0 = the first item in the container's
 collection). activeItem only applies to layout styles that can display items one at a time (like
 Ext.layout.AccordionLayout, Ext.layout.CardLayout and Ext.layout.FitLayout). Related to
 Ext.layout.ContainerLayout.activeItem.]]></description><name>activeItem</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Customizable piece of the default paging text (defaults to 'of {0}'). Note that this string is formatted using {0} as a
 token that is replaced by the number of total pages. This token should be preserved when overriding this string if
 showing the total page count is desired.]]></description><name>afterPageText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Whether the component can move the Dom node when rendering (defaults to true).]]></description><name>allowDomMove</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use an
 AnchorLayout (or subclass thereof). based layout manager, for example: Ext.form.FormPanel specifying layout: 'anchor' //
 or 'form', or 'absolute' See Ext.layout.AnchorLayout.anchor also.]]></description><name>anchor</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element corresponding to a DIV that is already present in
 the document that specifies some structural markup for this component. Description : When applyTo is used, constituent
 parts of the component can also be specified by id or CSS class name within the main element, and the component being
 created may attempt to create its subcomponents from that markup if applicable. Notes : When using this config, a call
 to render() is not required. If applyTo is specified, any value passed for renderTo will be ignored and the target
 element's parent node will automatically be used as the component's container.]]></description><name>applyTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If true the container will automatically destroy any contained component that is removed from it, else destruction must
 be handled manually (defaults to true).]]></description><name>autoDestroy</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A tag name or DomHelper spec used to create the Element which will encapsulate this Component. You do not normally need
 to specify this. For the base classes Ext.Component, Ext.BoxComponent, and Ext.Container, this defaults to 'div'. The
 more complex Ext classes use a more complex DOM structure created by their own onRender methods. This is intended to
 allow the developer to create application-specific utility Components encapsulated by different DOM elements. Example
 usage: <pre><code>{
     xtype: 'box',
     autoEl: {
         tag: 'img',
         src: 'http://www.example.com/example.jpg'
     }
 },
 {
     xtype: 'box',
     autoEl: {
         tag: 'blockquote',
         html: 'autoEl is cool!'
     }
 }, {
     xtype: 'container',
     autoEl: 'ul',
     cls: 'ux-unordered-list',
     items: {
         xtype: 'box',
         autoEl: 'li',
   
      html: 'First list item'
     }
 }</pre></code>]]></description><name>autoEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to use height:'auto', false to use fixed height (or allow it to be managed by its parent Container's layout
 manager. Defaults to false. Note: Although many components inherit this config option, not all will function as expected
 with a height of 'auto'. Setting autoHeight:true means that the browser will manage height based on the element's
 contents, and that Ext will not manage it at all. If the browser is managing the height, be aware that resizes performed
 by the browser in response to changes within the structure of the Component cannot be detected. Therefore changes to the
 height might result in elements needing to be synchronized with the new height. Example: var w = new Ext.Window({
    
 title: 'Window',
     width: 600,
     autoHeight: true,
     items: {
         title: 'Collapse Me',
         height: 400,
  
 collapsible: true,
         border: false,
         listeners: {
             beforecollapse: function() {
                w.el.shadow.hide();
             },
             beforeexpand: function() {
                w.el.shadow.hide();
             },
             collapse: function() {
                w.syncShadow();
             },
             expand: function() {
                w.syncShadow();
             }
         }
     }
 }).show();]]></description><name>autoHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to use overflow:'auto' on the components layout element and show scroll bars automatically when necessary, false to
 clip any overflowing content (defaults to false).]]></description><name>autoScroll</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True if the component should check for hidden classes (e.g. 'x-hidden' or 'x-hide-display') and remove them on render
 (defaults to false).]]></description><name>autoShow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to use width:'auto', false to use fixed width (or allow it to be managed by its parent Container's layout manager.
 Defaults to false. Note: Although many components inherit this config option, not all will function as expected with a
 width of 'auto'. Setting autoWidth:true means that the browser will manage width based on the element's contents, and
 that Ext will not manage it at all. If the browser is managing the width, be aware that resizes performed by the browser
 in response to changes within the structure of the Component cannot be detected. Therefore changes to the width might
 result in elements needing to be synchronized with the new width. For example, where the target element is: <div
 id='grid-container' style='margin-left:25%;width:50%'></div> A Panel rendered into that target element must listen for
 browser window resize in order to relay its child items when the browser changes its width: var myPanel = new
 Ext.Panel({
     renderTo: 'grid-container',
     monitorResize: true, // relay on browser resize
     title: 'Panel',
    
 height: 400,
     autoWidth: true,
     layout: 'hbox',
     layoutConfig: {
         align: 'stretch'
     },
     defaults: {
         flex: 1
     },
     items: [{
         title: 'Box 1',
     }, {
         title: 'Box 2'
     }, {
         title:
 'Box 3'
     }],
 });]]></description><name>autoWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The text displayed before the input item (defaults to 'Page').]]></description><name>beforePageText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to ['add', 'remove'].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[When set to true (50 milliseconds) or a number of milliseconds, the layout assigned for this container will buffer the
 frequency it calculates and does a re-layout of components. This is useful for heavy containers or containers with a
 large quantity of sub-components for which frequent layout calls would be expensive. Defaults to 50.]]></description><name>bufferResize</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default position at which to align child items. Defaults to "left" May be specified as "center" to cause items added
 before a Fill (A "->") item to be centered in the Toolbar. Items added after a Fill are still right-aligned. Specify as
 "right" to right align all child items.]]></description><name>buttonAlign</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class used to to apply to the special clearing div rendered directly after each form field wrapper to provide
 field clearing (defaults to 'x-form-clear-left'). Note: this config is only used when this Component is rendered by a
 Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or specifying
 layout:'form') and either a fieldLabel is specified or isFormField=true is specified. See Ext.layout.FormLayout.fieldTpl
 also.]]></description><name>clearCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element (defaults to ''). This can be useful for
 adding customized styles to the component or any of its children using standard CSS rules.]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's container. This can be useful for adding customized
 styles to the container or any of its children using standard CSS rules. See Ext.layout.ContainerLayout.extraCls also.
 Note: ctCls defaults to '' except for the following class which assigns a value by default: Box Layout :
 'x-box-layout-ct' To configure the above Class with an extra CSS class append to the default. For example, for BoxLayout
 (Hbox and Vbox): ctCls: 'x-box-layout-ct custom-class']]></description><name>ctCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default xtype of child Components to create in this Container when a child item is specified as a raw configuration
 object, rather than as an instantiated Component. Defaults to 'panel', except Ext.menu.Menu which defaults to
 'menuitem', and Ext.Toolbar and Ext.ButtonGroup which default to 'button'.]]></description><name>defaultType</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[This option is a means of applying default settings to all added items whether added through the items config or via the
 add or insert methods. If an added item is a config object, and not an instantiated Component, then the default
 properties are unconditionally applied. If the added item is an instantiated Component, then the default properties are
 applied conditionally so as not to override existing properties in the item. If the defaults option is specified as a
 function, then the function will be called using this Container as the scope (this reference) and passing the added item
 as the first parameter. Any resulting object from that call is then applied to the item as default properties. For
 example, to automatically apply padding to the body of each of a set of contained Ext.Panel items, you could pass:
 defaults: {bodyStyle:'padding:15px'}. Usage: defaults: {               // defaults are applied to items, not the
 container
     autoScroll:true
 },
 items: [
     {
         xtype: 'panel',   // defaults do not have precedence over
       
 id: 'panel1',     // options in config objects, so the defaults
         autoScroll: false // will not be applied here,
 panel1 will be autoScroll:false
     },
     new Ext.Panel({       // defaults do have precedence over options
         id:
 'panel2',     // options in components, so the defaults
         autoScroll: false // will be applied here, panel2 will
 be autoScroll:true.
     })
 ]]]></description><name>defaults</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component disabled (default is false).]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class added to the component when it is disabled (defaults to 'x-item-disabled').]]></description><name>disabledClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to display the displayMsg (defaults to false)]]></description><name>displayInfo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The paging status message to display (defaults to 'Displaying {0} - {1} of {2}'). Note that this string is formatted
 using the braced numbers {0}-{2} as tokens that are replaced by the values for start, end and total respectively. These
 tokens should be preserved when overriding this string if showing those values is desired.]]></description><name>displayMsg</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA['top' or 'bottom'.]]></description><name>dockPosition</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The message to display when no records are found (defaults to 'No data to display')]]></description><name>emptyMsg</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to false. Configure true to make the toolbar provide a button which activates a dropdown Menu to show items
 which overflow the Toolbar's width.]]></description><name>enableOverflow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The label text to display next to this Component (defaults to ''). Note: this config is only used when this Component is
 rendered by a Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or
 specifying layout:'form'). Also see hideLabel and Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
    
 height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name'
    
 }]
 });]]></description><name>fieldLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The quicktip text displayed for the first page button (defaults to 'First Page'). Note: quick tips must be initialized
 for the quicktip to show.]]></description><name>firstText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use a
 BoxLayout. Each child Component with a flex property will be flexed either vertically (by a VBoxLayout) or horizontally
 (by an HBoxLayout) according to the item's relative flex value compared to the sum of all Components with flex value
 specified. Any child items that have either a flex = 0 or flex = undefined will not be 'flexed' (the initial size will
 not be changed).]]></description><name>flex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If true the container will force a layout initially even if hidden or collapsed. This option is useful for forcing forms
 to render in collapsed or hidden containers. (defaults to false).]]></description><name>forceLayout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component hidden (default is false). If true, the hide method will be called internally.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide the borders of each contained component, false to defer to the component's existing border settings
 (defaults to false).]]></description><name>hideBorders</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to completely hide the label element (label and separator). Defaults to false. By default, even if you do not
 specify a fieldLabel the space will still be reserved so that the field will line up with other fields that do have
 labels. Setting this to true will cause the field to not reserve that space. Note: see the note for clearCls. Example
 use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield'
        
 hideLabel: true
     }]
 });]]></description><name>hideLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[How this component should be hidden. Supported values are 'visibility' (css visibility), 'offsets' (negative offset
 position) and 'display' (css display). Note: the default of 'display' is generally preferred since items are
 automatically laid out when they are first shown (no sizing is done while hidden).]]></description><name>hideMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide and show the component's container when hide/show is called on the component, false to hide and show the
 component itself (defaults to false). For example, this can be used as a shortcut for a hide button on a window by
 setting hide:true on the button when adding it to its parent container.]]></description><name>hideParent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id of this component (defaults to an auto-assigned id). You should assign an id if you need to be able to
 access the component later and you do not have an object reference available (e.g., using Ext.getCmp). Note that this id
 will also be used as the element id for the containing HTML element that is rendered to the page for this component.
 This allows you to write id-based CSS rules to style the specific instance of this component uniquely, and also to
 select sub-elements using this component's id as the parent. Note: to avoid complications imposed by a unique id also
 see itemId and ref. Note: to access the container of an item see ownerCt.]]></description><name>id</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use the
 FormLayout layout manager (e.g. Ext.form.FormPanel or specifying layout:'form'). An additional CSS class to apply to the
 div wrapping the form item element of this field. If supplied, itemCls at the field level will override the default
 itemCls supplied at the container level. The value specified for itemCls will be added to the default class
 ('x-form-item'). Since it is applied to the item wrapper (see Ext.layout.FormLayout.fieldTpl), it allows you to write
 standard CSS rules that can apply to the field, the label (if specified), or any other element within the markup for the
 field. Note: see the note for fieldLabel. Example use: // Apply a style to the field's label:
 <style>
     .required
 .x-form-item-label {font-weight:bold;color:red;}
 </style>
 
 new Ext.FormPanel({
     height: 100,
     renderTo:
 Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         itemCls: 'required' //this
 label will be styled
     },{
         xtype: 'textfield',
         fieldLabel: 'Favorite Color'
     }]
 });]]></description><name>itemCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An itemId can be used as an alternative way to get a reference to a component when no object reference is available.
 Instead of using an id with Ext.getCmp, use itemId with Ext.Container.getComponent which will retrieve itemId's or id's.
 Since itemId's are an index to the container's internal MixedCollection, the itemId is scoped locally to the container
 -- avoiding potential conflicts with Ext.ComponentMgr which requires a unique id. var c = new Ext.Panel({ //
     height:
 300,
     renderTo: document.body,
     layout: 'auto',
     items: [
         {
             itemId: 'p1',
            
 title: 'Panel 1',
             height: 150
         },
         {
             itemId: 'p2',
             title: 'Panel 2',
  
 height: 150
         }
     ]
 })
 p1 = c.getComponent('p1'); // not the same as Ext.getCmp()
 p2 =
 p1.ownerCt.getComponent('p2'); // reference via a sibling Also see id and ref. Note: to access the container of an item
 see ownerCt.]]></description><name>itemId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The separator to display after the text of each fieldLabel. This property may be configured at various levels. The order
 of precedence is: field / component level container level layout level (defaults to colon ':') To display no separator
 for this field's label specify empty string ''. Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 layoutConfig: {
         labelSeparator: '~'   // layout config has lowest priority (defaults to ':')
     },
    
 labelSeparator: '>>',     // config at container level
     items: [{
         xtype: 'textfield',
         fieldLabel:
 'Field 1',
         labelSeparator: '...' // field/component level config supersedes others
     },{
         xtype:
 'textfield',
         fieldLabel: 'Field 2' // labelSeparator will be '='
     }]
 });]]></description><name>labelSeparator</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS style specification string to apply directly to this field's label. Defaults to the container's labelStyle value
 if set (e.g., Ext.layout.FormLayout.labelStyle , or ''). Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         labelStyle: 'font-weight:bold;'
     }]
 });]]></description><name>labelStyle</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The quicktip text displayed for the last page button (defaults to 'Last Page'). Note: quick tips must be initialized for
 the quicktip to show.]]></description><name>lastText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[*Important: In order for child items to be correctly sized and positioned, typically a layout manager must be specified
 through the layout configuration option. The sizing and positioning of child items is the responsibility of the
 Container's layout manager which creates and manages the type of layout you have in mind. For example:
 <pre><code>
 new Ext.Window({
 
 width:300, height: 300,
     layout: 'fit', // explicitly set layout manager: override the default (layout:'auto')
    
 items: [{
         title: 'Panel inside a Window'
     }]
 }).show();</pre></code>
 If the layout configuration is not explicitly
 specified for a general purpose container (e.g. Container or Panel) the default layout manager will be used which does
 nothing but render child components sequentially into the Container (no sizing or positioning will be performed in this
 situation). Some container classes implicitly specify a default layout (e.g. FormPanel specifies layout:'form'). Other
 specific purpose classes internally specify/manage their internal layout (e.g. GridPanel, TabPanel, TreePanel, Toolbar,
 Menu, etc.). layout may be specified as either as an Object or as a String: Specify as an Object Example usage: layout:
 {
     type: 'vbox',
     padding: '5',
     align: 'left'
 } type The layout type to be used for this container. If not
 specified, a default Ext.layout.ContainerLayout will be created and used. Valid layout type values are: absolute
 accordion anchor auto Default border card column fit form hbox menu table toolbar vbox Layout specific configuration
 properties Additional layout specific configuration properties may also be specified. For complete details regarding the
 valid config options for each layout type, see the layout class corresponding to the type specified. Specify as a String
 Example usage: layout: 'vbox',
 layoutConfig: {
     padding: '5',
     align: 'left'
 } layout The layout type to be used
 for this container (see list of valid layout type values above). layoutConfig Additional layout specific configuration
 properties. For complete details regarding the valid config options for each layout type, see the layout class
 corresponding to the layout specified.]]></description><name>layout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout or one of the two BoxLayout subclasses. An object containing margins to apply to this BoxComponent in the
 format: {
     top: (top margin),
     right: (right margin),
     bottom: (bottom margin),
     left: (left margin)
 } May
 also be a string containing space-separated, numeric margin values. The order of the sides associated with each value
 matches the way CSS processes margin values: If there is only one value, it applies to all sides. If there are two
 values, the top and bottom borders are set to the first value and the right and left are set to the second. If there are
 three values, the top is set to the first value, the left and right are set to the second, and the bottom is set to the
 third. If there are four values, they apply to the top, right, bottom, and left, respectively. Defaults to: {top:0,
 right:0, bottom:0, left:0}]]></description><name>margins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically monitor window resize events to handle anything that is sensitive to the current size of the
 viewport. This value is typically managed by the chosen layout and should not need to be set manually.]]></description><name>monitorResize</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The quicktip text displayed for the next page button (defaults to 'Next Page'). Note: quick tips must be initialized for
 the quicktip to show.]]></description><name>nextText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element when the mouse moves over the Element, and
 removed when the mouse moves out. (defaults to ''). This can be useful for adding customized 'active' or 'hover' styles
 to the component or any of its children using standard CSS rules.]]></description><name>overCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The number of records to display per page (defaults to 20)]]></description><name>pageSize</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level x coordinate for this component if contained within a positioning container.]]></description><name>pageX</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level y coordinate for this component if contained within a positioning container.]]></description><name>pageY</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to insert any configured items before the paging buttons. Defaults to false.]]></description><name>prependButtons</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The quicktip text displayed for the previous page button (defaults to 'Previous Page'). Note: quick tips must be
 initialized for the quicktip to show.]]></description><name>prevText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered ptype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a Plugin is being specified not as a fully
 instantiated Component, but as a Component config object. The ptype will be looked up at render time up to determine
 what type of Plugin to create. If you create your own Plugins, you may register them using
 Ext.ComponentMgr.registerPlugin in order to be able to take advantage of lazy instantiation and rendering.]]></description><name>ptype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A path specification, relative to the Component's ownerCt specifying into which ancestor Container to place a named
 reference to this Component. The ancestor axis can be traversed by using '/' characters in the path. For example, to put
 a reference to a Toolbar Button into the Panel which owns the Toolbar: var myGrid = new Ext.grid.EditorGridPanel({
    
 title: 'My EditorGridPanel',
     store: myStore,
     colModel: myColModel,
     tbar: [{
         text: 'Save',
        
 handler: saveChanges,
         disabled: true,
         ref: '../saveButton'
     }],
     listeners: {
         afteredit:
 function() {
 //          The button reference is in the GridPanel
             myGrid.saveButton.enable();
         }
    
 }
 }); In the code above, if the ref had been 'saveButton' the reference would have been placed into the Toolbar. Each
 '/' in the ref moves up one level from the Component's ownerCt. Also see the added and removed events.]]></description><name>ref</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The quicktip text displayed for the Refresh button (defaults to 'Refresh'). Note: quick tips must be initialized for the
 quicktip to show.]]></description><name>refreshText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout layout manager (e.g. specifying layout:'border'). See Ext.layout.BorderLayout also.]]></description><name>region</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The event to listen to for resizing in layouts. Defaults to 'resize'.]]></description><name>resizeEvent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should trigger this component to save its state (defaults to none). stateEvents may
 be any type of event supported by this component, including browser or custom events (e.g., ['click',
 'customerchange']). See stateful for an explanation of saving and restoring Component state.]]></description><name>stateEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id for this component to use for state management purposes (defaults to the component id if one was set,
 otherwise null if the component is using a generated id). See stateful for an explanation of saving and restoring
 Component state.]]></description><name>stateId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A flag which causes the Component to attempt to restore the state of internal properties from a saved state on startup.
 The component must have either a stateId or id assigned for state to be managed. Auto-generated ids are not guaranteed
 to be stable across page loads and cannot be relied upon to save and restore the same state for a component. For state
 saving to work, the state manager's provider must have been set to an implementation of Ext.state.Provider which
 overrides the set and get methods to save and recall name/value pairs. A built-in implementation,
 Ext.state.CookieProvider is available. To set the state provider for the current page: Ext.state.Manager.setProvider(new
 Ext.state.CookieProvider({
     expires: new Date(new Date().getTime()+(1000*60*60*24*7)), //7 days from now
 })); A
 stateful Component attempts to save state when one of the events listed in the stateEvents configuration fires. To save
 state, a stateful Component first serializes its state by calling getState. By default, this function does nothing. The
 developer must provide an implementation which returns an object hash which represents the Component's restorable state.
 The value yielded by getState is passed to Ext.state.Manager.set which uses the configured Ext.state.Provider to save
 the object keyed by the Component's stateId, or, if that is not specified, its id. During construction, a stateful
 Component attempts to restore its state by calling Ext.state.Manager.get passing the stateId, or, if that is not
 specified, the id. The resulting object is passed to applyState. The default implementation of applyState simply copies
 properties into the object, but a developer may override this to support more behaviour. You can perform extra
 processing on state save and restore by attaching handlers to the beforestaterestore, staterestore, beforestatesave and
 statesave events.]]></description><name>stateful</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
     title: 'Some Title',
     renderTo: Ext.getBody(),
     width: 400, height:
 300,
     layout: 'form',
     items: [{
         xtype: 'textarea',
         style: {
             width: '95%',
            
 marginBottom: '10px'
         }
     },
         new Ext.Button({
             text: 'Send',
             minWidth: '100',
   
          style: {
                 marginBottom: '10px'
             }
         })
     ]
 });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is a child item of a TabPanel. A string to be used as innerHTML
 (html tags are accepted) to show in a tooltip when mousing over the associated tab selector element.
 Ext.QuickTips.init() must be called in order for the tips to render.]]></description><name>tabTip</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local x (left) coordinate for this component if contained within a positioning container.]]></description><name>x</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered xtype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a child item of a Container is being specified not
 as a fully instantiated Component, but as a Component config object. The xtype will be looked up at render time up to
 determine what type of child Component to create. The predefined xtypes are listed here. If you subclass Components to
 create your own Components, you may register them using Ext.ComponentMgr.registerType in order to be able to take
 advantage of lazy instantiation and rendering.]]></description><name>xtype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local y (top) coordinate for this component if contained within a positioning container.]]></description><name>y</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 A simple element that adds extra horizontal space between items in a toolbar. By default a 2px wide space is added via
 css specification:
 <pre><code>.x-toolbar .xtb-spacer {
     width: 2px;
 }</code></pre> 
 <p>Example usage:</p>
 
 <pre><code><b>new</b> Ext.Panel({
     tbar : [
         <em>'Item 1'</em>,
         {xtype: <em>'tbspacer'</em>}, <i>// or <em>' '</em></i>
         <em>'Item 2'</em>,
         <i>// space width is also configurable via javascript</i>
         {xtype: <em>'tbspacer'</em>, width: 50}, <i>// add a 50px space</i>
         <em>'Item 3'</em>
     ]
 });</code></pre>]]></description><name>toolbar.spacer</name><tag-class>org.brushingbits.jnap.ui.extjs3.toolbar.Spacer</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[Whether the component can move the Dom node when rendering (defaults to true).]]></description><name>allowDomMove</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use an
 AnchorLayout (or subclass thereof). based layout manager, for example: Ext.form.FormPanel specifying layout: 'anchor' //
 or 'form', or 'absolute' See Ext.layout.AnchorLayout.anchor also.]]></description><name>anchor</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element corresponding to a DIV that is already present in
 the document that specifies some structural markup for this component. Description : When applyTo is used, constituent
 parts of the component can also be specified by id or CSS class name within the main element, and the component being
 created may attempt to create its subcomponents from that markup if applicable. Notes : When using this config, a call
 to render() is not required. If applyTo is specified, any value passed for renderTo will be ignored and the target
 element's parent node will automatically be used as the component's container.]]></description><name>applyTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A tag name or DomHelper spec used to create the Element which will encapsulate this Component. You do not normally need
 to specify this. For the base classes Ext.Component, Ext.BoxComponent, and Ext.Container, this defaults to 'div'. The
 more complex Ext classes use a more complex DOM structure created by their own onRender methods. This is intended to
 allow the developer to create application-specific utility Components encapsulated by different DOM elements. Example
 usage: <pre><code>{
     xtype: 'box',
     autoEl: {
         tag: 'img',
         src: 'http://www.example.com/example.jpg'
     }
 },
 {
     xtype: 'box',
     autoEl: {
         tag: 'blockquote',
         html: 'autoEl is cool!'
     }
 }, {
     xtype: 'container',
     autoEl: 'ul',
     cls: 'ux-unordered-list',
     items: {
         xtype: 'box',
         autoEl: 'li',
   
      html: 'First list item'
     }
 }</pre></code>]]></description><name>autoEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to use height:'auto', false to use fixed height (or allow it to be managed by its parent Container's layout
 manager. Defaults to false. Note: Although many components inherit this config option, not all will function as expected
 with a height of 'auto'. Setting autoHeight:true means that the browser will manage height based on the element's
 contents, and that Ext will not manage it at all. If the browser is managing the height, be aware that resizes performed
 by the browser in response to changes within the structure of the Component cannot be detected. Therefore changes to the
 height might result in elements needing to be synchronized with the new height. Example: var w = new Ext.Window({
    
 title: 'Window',
     width: 600,
     autoHeight: true,
     items: {
         title: 'Collapse Me',
         height: 400,
  
 collapsible: true,
         border: false,
         listeners: {
             beforecollapse: function() {
                w.el.shadow.hide();
             },
             beforeexpand: function() {
                w.el.shadow.hide();
             },
             collapse: function() {
                w.syncShadow();
             },
             expand: function() {
                w.syncShadow();
             }
         }
     }
 }).show();]]></description><name>autoHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to use overflow:'auto' on the components layout element and show scroll bars automatically when necessary, false to
 clip any overflowing content (defaults to false).]]></description><name>autoScroll</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True if the component should check for hidden classes (e.g. 'x-hidden' or 'x-hide-display') and remove them on render
 (defaults to false).]]></description><name>autoShow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to use width:'auto', false to use fixed width (or allow it to be managed by its parent Container's layout manager.
 Defaults to false. Note: Although many components inherit this config option, not all will function as expected with a
 width of 'auto'. Setting autoWidth:true means that the browser will manage width based on the element's contents, and
 that Ext will not manage it at all. If the browser is managing the width, be aware that resizes performed by the browser
 in response to changes within the structure of the Component cannot be detected. Therefore changes to the width might
 result in elements needing to be synchronized with the new width. For example, where the target element is: <div
 id='grid-container' style='margin-left:25%;width:50%'></div> A Panel rendered into that target element must listen for
 browser window resize in order to relay its child items when the browser changes its width: var myPanel = new
 Ext.Panel({
     renderTo: 'grid-container',
     monitorResize: true, // relay on browser resize
     title: 'Panel',
    
 height: 400,
     autoWidth: true,
     layout: 'hbox',
     layoutConfig: {
         align: 'stretch'
     },
     defaults: {
         flex: 1
     },
     items: [{
         title: 'Box 1',
     }, {
         title: 'Box 2'
     }, {
         title:
 'Box 3'
     }],
 });]]></description><name>autoWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to [].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class used to to apply to the special clearing div rendered directly after each form field wrapper to provide
 field clearing (defaults to 'x-form-clear-left'). Note: this config is only used when this Component is rendered by a
 Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or specifying
 layout:'form') and either a fieldLabel is specified or isFormField=true is specified. See Ext.layout.FormLayout.fieldTpl
 also.]]></description><name>clearCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element (defaults to ''). This can be useful for
 adding customized styles to the component or any of its children using standard CSS rules.]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's container. This can be useful for adding customized
 styles to the container or any of its children using standard CSS rules. See Ext.layout.ContainerLayout.extraCls also.
 Note: ctCls defaults to '' except for the following class which assigns a value by default: Box Layout :
 'x-box-layout-ct' To configure the above Class with an extra CSS class append to the default. For example, for BoxLayout
 (Hbox and Vbox): ctCls: 'x-box-layout-ct custom-class']]></description><name>ctCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component disabled (default is false).]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class added to the component when it is disabled (defaults to 'x-item-disabled').]]></description><name>disabledClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The label text to display next to this Component (defaults to ''). Note: this config is only used when this Component is
 rendered by a Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or
 specifying layout:'form'). Also see hideLabel and Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
    
 height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name'
    
 }]
 });]]></description><name>fieldLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use a
 BoxLayout. Each child Component with a flex property will be flexed either vertically (by a VBoxLayout) or horizontally
 (by an HBoxLayout) according to the item's relative flex value compared to the sum of all Components with flex value
 specified. Any child items that have either a flex = 0 or flex = undefined will not be 'flexed' (the initial size will
 not be changed).]]></description><name>flex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component hidden (default is false). If true, the hide method will be called internally.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to completely hide the label element (label and separator). Defaults to false. By default, even if you do not
 specify a fieldLabel the space will still be reserved so that the field will line up with other fields that do have
 labels. Setting this to true will cause the field to not reserve that space. Note: see the note for clearCls. Example
 use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield'
        
 hideLabel: true
     }]
 });]]></description><name>hideLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[How this component should be hidden. Supported values are 'visibility' (css visibility), 'offsets' (negative offset
 position) and 'display' (css display). Note: the default of 'display' is generally preferred since items are
 automatically laid out when they are first shown (no sizing is done while hidden).]]></description><name>hideMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide and show the component's container when hide/show is called on the component, false to hide and show the
 component itself (defaults to false). For example, this can be used as a shortcut for a hide button on a window by
 setting hide:true on the button when adding it to its parent container.]]></description><name>hideParent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id of this component (defaults to an auto-assigned id). You should assign an id if you need to be able to
 access the component later and you do not have an object reference available (e.g., using Ext.getCmp). Note that this id
 will also be used as the element id for the containing HTML element that is rendered to the page for this component.
 This allows you to write id-based CSS rules to style the specific instance of this component uniquely, and also to
 select sub-elements using this component's id as the parent. Note: to avoid complications imposed by a unique id also
 see itemId and ref. Note: to access the container of an item see ownerCt.]]></description><name>id</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use the
 FormLayout layout manager (e.g. Ext.form.FormPanel or specifying layout:'form'). An additional CSS class to apply to the
 div wrapping the form item element of this field. If supplied, itemCls at the field level will override the default
 itemCls supplied at the container level. The value specified for itemCls will be added to the default class
 ('x-form-item'). Since it is applied to the item wrapper (see Ext.layout.FormLayout.fieldTpl), it allows you to write
 standard CSS rules that can apply to the field, the label (if specified), or any other element within the markup for the
 field. Note: see the note for fieldLabel. Example use: // Apply a style to the field's label:
 <style>
     .required
 .x-form-item-label {font-weight:bold;color:red;}
 </style>
 
 new Ext.FormPanel({
     height: 100,
     renderTo:
 Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         itemCls: 'required' //this
 label will be styled
     },{
         xtype: 'textfield',
         fieldLabel: 'Favorite Color'
     }]
 });]]></description><name>itemCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An itemId can be used as an alternative way to get a reference to a component when no object reference is available.
 Instead of using an id with Ext.getCmp, use itemId with Ext.Container.getComponent which will retrieve itemId's or id's.
 Since itemId's are an index to the container's internal MixedCollection, the itemId is scoped locally to the container
 -- avoiding potential conflicts with Ext.ComponentMgr which requires a unique id. var c = new Ext.Panel({ //
     height:
 300,
     renderTo: document.body,
     layout: 'auto',
     items: [
         {
             itemId: 'p1',
            
 title: 'Panel 1',
             height: 150
         },
         {
             itemId: 'p2',
             title: 'Panel 2',
  
 height: 150
         }
     ]
 })
 p1 = c.getComponent('p1'); // not the same as Ext.getCmp()
 p2 =
 p1.ownerCt.getComponent('p2'); // reference via a sibling Also see id and ref. Note: to access the container of an item
 see ownerCt.]]></description><name>itemId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The separator to display after the text of each fieldLabel. This property may be configured at various levels. The order
 of precedence is: field / component level container level layout level (defaults to colon ':') To display no separator
 for this field's label specify empty string ''. Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 layoutConfig: {
         labelSeparator: '~'   // layout config has lowest priority (defaults to ':')
     },
    
 labelSeparator: '>>',     // config at container level
     items: [{
         xtype: 'textfield',
         fieldLabel:
 'Field 1',
         labelSeparator: '...' // field/component level config supersedes others
     },{
         xtype:
 'textfield',
         fieldLabel: 'Field 2' // labelSeparator will be '='
     }]
 });]]></description><name>labelSeparator</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS style specification string to apply directly to this field's label. Defaults to the container's labelStyle value
 if set (e.g., Ext.layout.FormLayout.labelStyle , or ''). Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         labelStyle: 'font-weight:bold;'
     }]
 });]]></description><name>labelStyle</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout or one of the two BoxLayout subclasses. An object containing margins to apply to this BoxComponent in the
 format: {
     top: (top margin),
     right: (right margin),
     bottom: (bottom margin),
     left: (left margin)
 } May
 also be a string containing space-separated, numeric margin values. The order of the sides associated with each value
 matches the way CSS processes margin values: If there is only one value, it applies to all sides. If there are two
 values, the top and bottom borders are set to the first value and the right and left are set to the second. If there are
 three values, the top is set to the first value, the left and right are set to the second, and the bottom is set to the
 third. If there are four values, they apply to the top, right, bottom, and left, respectively. Defaults to: {top:0,
 right:0, bottom:0, left:0}]]></description><name>margins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element when the mouse moves over the Element, and
 removed when the mouse moves out. (defaults to ''). This can be useful for adding customized 'active' or 'hover' styles
 to the component or any of its children using standard CSS rules.]]></description><name>overCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Text to be used for the menu if the item is overflowed.]]></description><name>overflowText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level x coordinate for this component if contained within a positioning container.]]></description><name>pageX</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level y coordinate for this component if contained within a positioning container.]]></description><name>pageY</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered ptype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a Plugin is being specified not as a fully
 instantiated Component, but as a Component config object. The ptype will be looked up at render time up to determine
 what type of Plugin to create. If you create your own Plugins, you may register them using
 Ext.ComponentMgr.registerPlugin in order to be able to take advantage of lazy instantiation and rendering.]]></description><name>ptype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A path specification, relative to the Component's ownerCt specifying into which ancestor Container to place a named
 reference to this Component. The ancestor axis can be traversed by using '/' characters in the path. For example, to put
 a reference to a Toolbar Button into the Panel which owns the Toolbar: var myGrid = new Ext.grid.EditorGridPanel({
    
 title: 'My EditorGridPanel',
     store: myStore,
     colModel: myColModel,
     tbar: [{
         text: 'Save',
        
 handler: saveChanges,
         disabled: true,
         ref: '../saveButton'
     }],
     listeners: {
         afteredit:
 function() {
 //          The button reference is in the GridPanel
             myGrid.saveButton.enable();
         }
    
 }
 }); In the code above, if the ref had been 'saveButton' the reference would have been placed into the Toolbar. Each
 '/' in the ref moves up one level from the Component's ownerCt. Also see the added and removed events.]]></description><name>ref</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout layout manager (e.g. specifying layout:'border'). See Ext.layout.BorderLayout also.]]></description><name>region</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should trigger this component to save its state (defaults to none). stateEvents may
 be any type of event supported by this component, including browser or custom events (e.g., ['click',
 'customerchange']). See stateful for an explanation of saving and restoring Component state.]]></description><name>stateEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id for this component to use for state management purposes (defaults to the component id if one was set,
 otherwise null if the component is using a generated id). See stateful for an explanation of saving and restoring
 Component state.]]></description><name>stateId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A flag which causes the Component to attempt to restore the state of internal properties from a saved state on startup.
 The component must have either a stateId or id assigned for state to be managed. Auto-generated ids are not guaranteed
 to be stable across page loads and cannot be relied upon to save and restore the same state for a component. For state
 saving to work, the state manager's provider must have been set to an implementation of Ext.state.Provider which
 overrides the set and get methods to save and recall name/value pairs. A built-in implementation,
 Ext.state.CookieProvider is available. To set the state provider for the current page: Ext.state.Manager.setProvider(new
 Ext.state.CookieProvider({
     expires: new Date(new Date().getTime()+(1000*60*60*24*7)), //7 days from now
 })); A
 stateful Component attempts to save state when one of the events listed in the stateEvents configuration fires. To save
 state, a stateful Component first serializes its state by calling getState. By default, this function does nothing. The
 developer must provide an implementation which returns an object hash which represents the Component's restorable state.
 The value yielded by getState is passed to Ext.state.Manager.set which uses the configured Ext.state.Provider to save
 the object keyed by the Component's stateId, or, if that is not specified, its id. During construction, a stateful
 Component attempts to restore its state by calling Ext.state.Manager.get passing the stateId, or, if that is not
 specified, the id. The resulting object is passed to applyState. The default implementation of applyState simply copies
 properties into the object, but a developer may override this to support more behaviour. You can perform extra
 processing on state save and restore by attaching handlers to the beforestaterestore, staterestore, beforestatesave and
 statesave events.]]></description><name>stateful</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
     title: 'Some Title',
     renderTo: Ext.getBody(),
     width: 400, height:
 300,
     layout: 'form',
     items: [{
         xtype: 'textarea',
         style: {
             width: '95%',
            
 marginBottom: '10px'
         }
     },
         new Ext.Button({
             text: 'Send',
             minWidth: '100',
   
          style: {
                 marginBottom: '10px'
             }
         })
     ]
 });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is a child item of a TabPanel. A string to be used as innerHTML
 (html tags are accepted) to show in a tooltip when mousing over the associated tab selector element.
 Ext.QuickTips.init() must be called in order for the tips to render.]]></description><name>tabTip</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of the spacer in pixels (defaults to 2px via css style .x-toolbar .xtb-spacer).]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local x (left) coordinate for this component if contained within a positioning container.]]></description><name>x</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered xtype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a child item of a Container is being specified not
 as a fully instantiated Component, but as a Component config object. The xtype will be looked up at render time up to
 determine what type of child Component to create. The predefined xtypes are listed here. If you subclass Components to
 create your own Components, you may register them using Ext.ComponentMgr.registerType in order to be able to take
 advantage of lazy instantiation and rendering.]]></description><name>xtype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local y (top) coordinate for this component if contained within a positioning container.]]></description><name>y</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 A simple class that renders text directly into a toolbar (with css class:
 <tt>'xtb-text'</tt>). Example usage:
 
 <pre><code><b>new</b> Ext.Panel({
     tbar : [
         {xtype: <em>'tbtext'</em>, text: <em>'Item 1'</em>} <i>// or
 simply <em>'Item 1'</em></i>
     ]
 });</code></pre>]]></description><name>toolbar.textItem</name><tag-class>org.brushingbits.jnap.ui.extjs3.toolbar.TextItem</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[Whether the component can move the Dom node when rendering (defaults to true).]]></description><name>allowDomMove</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use an
 AnchorLayout (or subclass thereof). based layout manager, for example: Ext.form.FormPanel specifying layout: 'anchor' //
 or 'form', or 'absolute' See Ext.layout.AnchorLayout.anchor also.]]></description><name>anchor</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element corresponding to a DIV that is already present in
 the document that specifies some structural markup for this component. Description : When applyTo is used, constituent
 parts of the component can also be specified by id or CSS class name within the main element, and the component being
 created may attempt to create its subcomponents from that markup if applicable. Notes : When using this config, a call
 to render() is not required. If applyTo is specified, any value passed for renderTo will be ignored and the target
 element's parent node will automatically be used as the component's container.]]></description><name>applyTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A tag name or DomHelper spec used to create the Element which will encapsulate this Component. You do not normally need
 to specify this. For the base classes Ext.Component, Ext.BoxComponent, and Ext.Container, this defaults to 'div'. The
 more complex Ext classes use a more complex DOM structure created by their own onRender methods. This is intended to
 allow the developer to create application-specific utility Components encapsulated by different DOM elements. Example
 usage: <pre><code>{
     xtype: 'box',
     autoEl: {
         tag: 'img',
         src: 'http://www.example.com/example.jpg'
     }
 },
 {
     xtype: 'box',
     autoEl: {
         tag: 'blockquote',
         html: 'autoEl is cool!'
     }
 }, {
     xtype: 'container',
     autoEl: 'ul',
     cls: 'ux-unordered-list',
     items: {
         xtype: 'box',
         autoEl: 'li',
   
      html: 'First list item'
     }
 }</pre></code>]]></description><name>autoEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to use height:'auto', false to use fixed height (or allow it to be managed by its parent Container's layout
 manager. Defaults to false. Note: Although many components inherit this config option, not all will function as expected
 with a height of 'auto'. Setting autoHeight:true means that the browser will manage height based on the element's
 contents, and that Ext will not manage it at all. If the browser is managing the height, be aware that resizes performed
 by the browser in response to changes within the structure of the Component cannot be detected. Therefore changes to the
 height might result in elements needing to be synchronized with the new height. Example: var w = new Ext.Window({
    
 title: 'Window',
     width: 600,
     autoHeight: true,
     items: {
         title: 'Collapse Me',
         height: 400,
  
 collapsible: true,
         border: false,
         listeners: {
             beforecollapse: function() {
                w.el.shadow.hide();
             },
             beforeexpand: function() {
                w.el.shadow.hide();
             },
             collapse: function() {
                w.syncShadow();
             },
             expand: function() {
                w.syncShadow();
             }
         }
     }
 }).show();]]></description><name>autoHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to use overflow:'auto' on the components layout element and show scroll bars automatically when necessary, false to
 clip any overflowing content (defaults to false).]]></description><name>autoScroll</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True if the component should check for hidden classes (e.g. 'x-hidden' or 'x-hide-display') and remove them on render
 (defaults to false).]]></description><name>autoShow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to use width:'auto', false to use fixed width (or allow it to be managed by its parent Container's layout manager.
 Defaults to false. Note: Although many components inherit this config option, not all will function as expected with a
 width of 'auto'. Setting autoWidth:true means that the browser will manage width based on the element's contents, and
 that Ext will not manage it at all. If the browser is managing the width, be aware that resizes performed by the browser
 in response to changes within the structure of the Component cannot be detected. Therefore changes to the width might
 result in elements needing to be synchronized with the new width. For example, where the target element is: <div
 id='grid-container' style='margin-left:25%;width:50%'></div> A Panel rendered into that target element must listen for
 browser window resize in order to relay its child items when the browser changes its width: var myPanel = new
 Ext.Panel({
     renderTo: 'grid-container',
     monitorResize: true, // relay on browser resize
     title: 'Panel',
    
 height: 400,
     autoWidth: true,
     layout: 'hbox',
     layoutConfig: {
         align: 'stretch'
     },
     defaults: {
         flex: 1
     },
     items: [{
         title: 'Box 1',
     }, {
         title: 'Box 2'
     }, {
         title:
 'Box 3'
     }],
 });]]></description><name>autoWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to [].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class used to to apply to the special clearing div rendered directly after each form field wrapper to provide
 field clearing (defaults to 'x-form-clear-left'). Note: this config is only used when this Component is rendered by a
 Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or specifying
 layout:'form') and either a fieldLabel is specified or isFormField=true is specified. See Ext.layout.FormLayout.fieldTpl
 also.]]></description><name>clearCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element (defaults to ''). This can be useful for
 adding customized styles to the component or any of its children using standard CSS rules.]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's container. This can be useful for adding customized
 styles to the container or any of its children using standard CSS rules. See Ext.layout.ContainerLayout.extraCls also.
 Note: ctCls defaults to '' except for the following class which assigns a value by default: Box Layout :
 'x-box-layout-ct' To configure the above Class with an extra CSS class append to the default. For example, for BoxLayout
 (Hbox and Vbox): ctCls: 'x-box-layout-ct custom-class']]></description><name>ctCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component disabled (default is false).]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class added to the component when it is disabled (defaults to 'x-item-disabled').]]></description><name>disabledClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The label text to display next to this Component (defaults to ''). Note: this config is only used when this Component is
 rendered by a Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or
 specifying layout:'form'). Also see hideLabel and Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
    
 height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name'
    
 }]
 });]]></description><name>fieldLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use a
 BoxLayout. Each child Component with a flex property will be flexed either vertically (by a VBoxLayout) or horizontally
 (by an HBoxLayout) according to the item's relative flex value compared to the sum of all Components with flex value
 specified. Any child items that have either a flex = 0 or flex = undefined will not be 'flexed' (the initial size will
 not be changed).]]></description><name>flex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component hidden (default is false). If true, the hide method will be called internally.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to completely hide the label element (label and separator). Defaults to false. By default, even if you do not
 specify a fieldLabel the space will still be reserved so that the field will line up with other fields that do have
 labels. Setting this to true will cause the field to not reserve that space. Note: see the note for clearCls. Example
 use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield'
        
 hideLabel: true
     }]
 });]]></description><name>hideLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[How this component should be hidden. Supported values are 'visibility' (css visibility), 'offsets' (negative offset
 position) and 'display' (css display). Note: the default of 'display' is generally preferred since items are
 automatically laid out when they are first shown (no sizing is done while hidden).]]></description><name>hideMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide and show the component's container when hide/show is called on the component, false to hide and show the
 component itself (defaults to false). For example, this can be used as a shortcut for a hide button on a window by
 setting hide:true on the button when adding it to its parent container.]]></description><name>hideParent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id of this component (defaults to an auto-assigned id). You should assign an id if you need to be able to
 access the component later and you do not have an object reference available (e.g., using Ext.getCmp). Note that this id
 will also be used as the element id for the containing HTML element that is rendered to the page for this component.
 This allows you to write id-based CSS rules to style the specific instance of this component uniquely, and also to
 select sub-elements using this component's id as the parent. Note: to avoid complications imposed by a unique id also
 see itemId and ref. Note: to access the container of an item see ownerCt.]]></description><name>id</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use the
 FormLayout layout manager (e.g. Ext.form.FormPanel or specifying layout:'form'). An additional CSS class to apply to the
 div wrapping the form item element of this field. If supplied, itemCls at the field level will override the default
 itemCls supplied at the container level. The value specified for itemCls will be added to the default class
 ('x-form-item'). Since it is applied to the item wrapper (see Ext.layout.FormLayout.fieldTpl), it allows you to write
 standard CSS rules that can apply to the field, the label (if specified), or any other element within the markup for the
 field. Note: see the note for fieldLabel. Example use: // Apply a style to the field's label:
 <style>
     .required
 .x-form-item-label {font-weight:bold;color:red;}
 </style>
 
 new Ext.FormPanel({
     height: 100,
     renderTo:
 Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         itemCls: 'required' //this
 label will be styled
     },{
         xtype: 'textfield',
         fieldLabel: 'Favorite Color'
     }]
 });]]></description><name>itemCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An itemId can be used as an alternative way to get a reference to a component when no object reference is available.
 Instead of using an id with Ext.getCmp, use itemId with Ext.Container.getComponent which will retrieve itemId's or id's.
 Since itemId's are an index to the container's internal MixedCollection, the itemId is scoped locally to the container
 -- avoiding potential conflicts with Ext.ComponentMgr which requires a unique id. var c = new Ext.Panel({ //
     height:
 300,
     renderTo: document.body,
     layout: 'auto',
     items: [
         {
             itemId: 'p1',
            
 title: 'Panel 1',
             height: 150
         },
         {
             itemId: 'p2',
             title: 'Panel 2',
  
 height: 150
         }
     ]
 })
 p1 = c.getComponent('p1'); // not the same as Ext.getCmp()
 p2 =
 p1.ownerCt.getComponent('p2'); // reference via a sibling Also see id and ref. Note: to access the container of an item
 see ownerCt.]]></description><name>itemId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The separator to display after the text of each fieldLabel. This property may be configured at various levels. The order
 of precedence is: field / component level container level layout level (defaults to colon ':') To display no separator
 for this field's label specify empty string ''. Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 layoutConfig: {
         labelSeparator: '~'   // layout config has lowest priority (defaults to ':')
     },
    
 labelSeparator: '>>',     // config at container level
     items: [{
         xtype: 'textfield',
         fieldLabel:
 'Field 1',
         labelSeparator: '...' // field/component level config supersedes others
     },{
         xtype:
 'textfield',
         fieldLabel: 'Field 2' // labelSeparator will be '='
     }]
 });]]></description><name>labelSeparator</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS style specification string to apply directly to this field's label. Defaults to the container's labelStyle value
 if set (e.g., Ext.layout.FormLayout.labelStyle , or ''). Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         labelStyle: 'font-weight:bold;'
     }]
 });]]></description><name>labelStyle</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout or one of the two BoxLayout subclasses. An object containing margins to apply to this BoxComponent in the
 format: {
     top: (top margin),
     right: (right margin),
     bottom: (bottom margin),
     left: (left margin)
 } May
 also be a string containing space-separated, numeric margin values. The order of the sides associated with each value
 matches the way CSS processes margin values: If there is only one value, it applies to all sides. If there are two
 values, the top and bottom borders are set to the first value and the right and left are set to the second. If there are
 three values, the top is set to the first value, the left and right are set to the second, and the bottom is set to the
 third. If there are four values, they apply to the top, right, bottom, and left, respectively. Defaults to: {top:0,
 right:0, bottom:0, left:0}]]></description><name>margins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element when the mouse moves over the Element, and
 removed when the mouse moves out. (defaults to ''). This can be useful for adding customized 'active' or 'hover' styles
 to the component or any of its children using standard CSS rules.]]></description><name>overCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Text to be used for the menu if the item is overflowed.]]></description><name>overflowText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level x coordinate for this component if contained within a positioning container.]]></description><name>pageX</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level y coordinate for this component if contained within a positioning container.]]></description><name>pageY</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered ptype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a Plugin is being specified not as a fully
 instantiated Component, but as a Component config object. The ptype will be looked up at render time up to determine
 what type of Plugin to create. If you create your own Plugins, you may register them using
 Ext.ComponentMgr.registerPlugin in order to be able to take advantage of lazy instantiation and rendering.]]></description><name>ptype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A path specification, relative to the Component's ownerCt specifying into which ancestor Container to place a named
 reference to this Component. The ancestor axis can be traversed by using '/' characters in the path. For example, to put
 a reference to a Toolbar Button into the Panel which owns the Toolbar: var myGrid = new Ext.grid.EditorGridPanel({
    
 title: 'My EditorGridPanel',
     store: myStore,
     colModel: myColModel,
     tbar: [{
         text: 'Save',
        
 handler: saveChanges,
         disabled: true,
         ref: '../saveButton'
     }],
     listeners: {
         afteredit:
 function() {
 //          The button reference is in the GridPanel
             myGrid.saveButton.enable();
         }
    
 }
 }); In the code above, if the ref had been 'saveButton' the reference would have been placed into the Toolbar. Each
 '/' in the ref moves up one level from the Component's ownerCt. Also see the added and removed events.]]></description><name>ref</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout layout manager (e.g. specifying layout:'border'). See Ext.layout.BorderLayout also.]]></description><name>region</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should trigger this component to save its state (defaults to none). stateEvents may
 be any type of event supported by this component, including browser or custom events (e.g., ['click',
 'customerchange']). See stateful for an explanation of saving and restoring Component state.]]></description><name>stateEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id for this component to use for state management purposes (defaults to the component id if one was set,
 otherwise null if the component is using a generated id). See stateful for an explanation of saving and restoring
 Component state.]]></description><name>stateId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A flag which causes the Component to attempt to restore the state of internal properties from a saved state on startup.
 The component must have either a stateId or id assigned for state to be managed. Auto-generated ids are not guaranteed
 to be stable across page loads and cannot be relied upon to save and restore the same state for a component. For state
 saving to work, the state manager's provider must have been set to an implementation of Ext.state.Provider which
 overrides the set and get methods to save and recall name/value pairs. A built-in implementation,
 Ext.state.CookieProvider is available. To set the state provider for the current page: Ext.state.Manager.setProvider(new
 Ext.state.CookieProvider({
     expires: new Date(new Date().getTime()+(1000*60*60*24*7)), //7 days from now
 })); A
 stateful Component attempts to save state when one of the events listed in the stateEvents configuration fires. To save
 state, a stateful Component first serializes its state by calling getState. By default, this function does nothing. The
 developer must provide an implementation which returns an object hash which represents the Component's restorable state.
 The value yielded by getState is passed to Ext.state.Manager.set which uses the configured Ext.state.Provider to save
 the object keyed by the Component's stateId, or, if that is not specified, its id. During construction, a stateful
 Component attempts to restore its state by calling Ext.state.Manager.get passing the stateId, or, if that is not
 specified, the id. The resulting object is passed to applyState. The default implementation of applyState simply copies
 properties into the object, but a developer may override this to support more behaviour. You can perform extra
 processing on state save and restore by attaching handlers to the beforestaterestore, staterestore, beforestatesave and
 statesave events.]]></description><name>stateful</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
     title: 'Some Title',
     renderTo: Ext.getBody(),
     width: 400, height:
 300,
     layout: 'form',
     items: [{
         xtype: 'textarea',
         style: {
             width: '95%',
            
 marginBottom: '10px'
         }
     },
         new Ext.Button({
             text: 'Send',
             minWidth: '100',
   
          style: {
                 marginBottom: '10px'
             }
         })
     ]
 });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is a child item of a TabPanel. A string to be used as innerHTML
 (html tags are accepted) to show in a tooltip when mousing over the associated tab selector element.
 Ext.QuickTips.init() must be called in order for the tips to render.]]></description><name>tabTip</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The text to be used as innerHTML (html tags are accepted)]]></description><name>text</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local x (left) coordinate for this component if contained within a positioning container.]]></description><name>x</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered xtype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a child item of a Container is being specified not
 as a fully instantiated Component, but as a Component config object. The xtype will be looked up at render time up to
 determine what type of child Component to create. The predefined xtypes are listed here. If you subclass Components to
 create your own Components, you may register them using Ext.ComponentMgr.registerType in order to be able to take
 advantage of lazy instantiation and rendering.]]></description><name>xtype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local y (top) coordinate for this component if contained within a positioning container.]]></description><name>y</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>]]></description><name>tree.asyncNode</name><tag-class>org.brushingbits.jnap.ui.extjs3.tree.AsyncTreeNode</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[False to not allow this node to have child nodes (defaults to true)]]></description><name>allowChildren</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[False to make this node undraggable if draggable = true (defaults to true)]]></description><name>allowDrag</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[False if this node cannot have child nodes dropped on it (defaults to true)]]></description><name>allowDrop</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to render a checked checkbox for this node, false to render an unchecked checkbox (defaults to undefined with no
 checkbox rendered)]]></description><name>checked</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A css class to be added to the node]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to start the node disabled]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to make this node draggable (defaults to false)]]></description><name>draggable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[False to not allow this node to be edited by an Ext.tree.TreeEditor (defaults to true)]]></description><name>editable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If set to true, the node will always show a plus/minus icon, even when empty]]></description><name>expandable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to start the node expanded]]></description><name>expanded</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to render hidden. (Defaults to false).]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[URL of the link used for the node (defaults to #)]]></description><name>href</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[target frame for the link]]></description><name>hrefTarget</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The path to an icon for the node. The preferred way to do this is to use the cls or iconCls attributes and add the icon
 via a CSS background image.]]></description><name>icon</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A css class to be added to the nodes icon element for applying css background images]]></description><name>iconCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The id for this node. If one is not specified, one is generated.]]></description><name>id</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[False to not allow this node to act as a drop target (defaults to true)]]></description><name>isTarget</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true if this node is a leaf and does not have children]]></description><name>leaf</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A TreeLoader to be used by this node (defaults to the loader defined on the tree)]]></description><name>loader</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An Ext QuickTip for the node]]></description><name>qtip</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An Ext QuickTip config for the node (used instead of qtip)]]></description><name>qtipCfg</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True for single click expand on this node]]></description><name>singleClickExpand</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The text for this node]]></description><name>text</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A UI class to use for this node (defaults to Ext.tree.TreeNodeUI)]]></description><name>uiProvider</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 Provides editor functionality for inline tree node editing. Any valid 
 <a href="output/Ext.form.Field.html"
 ext:cls="Ext.form.Field">Ext.form.Field</a> subclass can be used as the editor field.]]></description><name>tree.editor</name><tag-class>org.brushingbits.jnap.ui.extjs3.tree.TreeEditor</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[The position to align to (see Ext.Element.alignTo for more details, defaults to "l-l").]]></description><name>alignment</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to complete the editing process if in edit mode when the field is blurred. Defaults to true.]]></description><name>allowBlur</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Whether the component can move the Dom node when rendering (defaults to true).]]></description><name>allowDomMove</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element corresponding to a DIV that is already present in
 the document that specifies some structural markup for this component. Description : When applyTo is used, constituent
 parts of the component can also be specified by id or CSS class name within the main element, and the component being
 created may attempt to create its subcomponents from that markup if applicable. Notes : When using this config, a call
 to render() is not required. If applyTo is specified, any value passed for renderTo will be ignored and the target
 element's parent node will automatically be used as the component's container.]]></description><name>applyTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A tag name or DomHelper spec used to create the Element which will encapsulate this Component. You do not normally need
 to specify this. For the base classes Ext.Component, Ext.BoxComponent, and Ext.Container, this defaults to 'div'. The
 more complex Ext classes use a more complex DOM structure created by their own onRender methods. This is intended to
 allow the developer to create application-specific utility Components encapsulated by different DOM elements. Example
 usage: <pre><code>{
     xtype: 'box',
     autoEl: {
         tag: 'img',
         src: 'http://www.example.com/example.jpg'
     }
 },
 {
     xtype: 'box',
     autoEl: {
         tag: 'blockquote',
         html: 'autoEl is cool!'
     }
 }, {
     xtype: 'container',
     autoEl: 'ul',
     cls: 'ux-unordered-list',
     items: {
         xtype: 'box',
         autoEl: 'li',
   
      html: 'First list item'
     }
 }</pre></code>]]></description><name>autoEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True if the component should check for hidden classes (e.g. 'x-hidden' or 'x-hide-display') and remove them on render
 (defaults to false).]]></description><name>autoShow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True for the editor to automatically adopt the size of the underlying field, "width" to adopt the width only, or
 "height" to adopt the height only, "none" to always use the field dimensions. (defaults to false)]]></description><name>autoSize</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to [].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to cancel the edit when the escape key is pressed. Defaults to true.]]></description><name>cancelOnEsc</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class used to to apply to the special clearing div rendered directly after each form field wrapper to provide
 field clearing (defaults to 'x-form-clear-left'). Note: this config is only used when this Component is rendered by a
 Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or specifying
 layout:'form') and either a fieldLabel is specified or isFormField=true is specified. See Ext.layout.FormLayout.fieldTpl
 also.]]></description><name>clearCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class to apply to the editor (defaults to "x-small-editor x-tree-editor")]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to complete the edit when the enter key is pressed. Defaults to true.]]></description><name>completeOnEnter</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to constrain the editor to the viewport]]></description><name>constrain</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's container. This can be useful for adding customized
 styles to the container or any of its children using standard CSS rules. See Ext.layout.ContainerLayout.extraCls also.
 Note: ctCls defaults to '' except for the following class which assigns a value by default: Box Layout :
 'x-box-layout-ct' To configure the above Class with an extra CSS class append to the default. For example, for BoxLayout
 (Hbox and Vbox): ctCls: 'x-box-layout-ct custom-class']]></description><name>ctCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component disabled (default is false).]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class added to the component when it is disabled (defaults to 'x-item-disabled').]]></description><name>disabledClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The number of milliseconds between clicks to register a double-click that will trigger editing on the current node
 (defaults to 350). If two clicks occur on the same node within this time span, the editor for the node will display,
 otherwise it will be processed as a regular click.]]></description><name>editDelay</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Field object (or descendant) or config object for field]]></description><name>field</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The label text to display next to this Component (defaults to ''). Note: this config is only used when this Component is
 rendered by a Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or
 specifying layout:'form'). Also see hideLabel and Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
    
 height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name'
    
 }]
 });]]></description><name>fieldLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component hidden (default is false). If true, the hide method will be called internally.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide the bound element while the editor is displayed (defaults to false)]]></description><name>hideEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to completely hide the label element (label and separator). Defaults to false. By default, even if you do not
 specify a fieldLabel the space will still be reserved so that the field will line up with other fields that do have
 labels. Setting this to true will cause the field to not reserve that space. Note: see the note for clearCls. Example
 use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield'
        
 hideLabel: true
     }]
 });]]></description><name>hideLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[How this component should be hidden. Supported values are 'visibility' (css visibility), 'offsets' (negative offset
 position) and 'display' (css display). Note: the default of 'display' is generally preferred since items are
 automatically laid out when they are first shown (no sizing is done while hidden).]]></description><name>hideMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide and show the component's container when hide/show is called on the component, false to hide and show the
 component itself (defaults to false). For example, this can be used as a shortcut for a hide button on a window by
 setting hide:true on the button when adding it to its parent container.]]></description><name>hideParent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id of this component (defaults to an auto-assigned id). You should assign an id if you need to be able to
 access the component later and you do not have an object reference available (e.g., using Ext.getCmp). Note that this id
 will also be used as the element id for the containing HTML element that is rendered to the page for this component.
 This allows you to write id-based CSS rules to style the specific instance of this component uniquely, and also to
 select sub-elements using this component's id as the parent. Note: to avoid complications imposed by a unique id also
 see itemId and ref. Note: to access the container of an item see ownerCt.]]></description><name>id</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to skip the edit completion process (no save, no events fired) if the user completes an edit and the value has not
 changed (defaults to false). Applies only to string values - edits for other data types will never be ignored.]]></description><name>ignoreNoChange</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use the
 FormLayout layout manager (e.g. Ext.form.FormPanel or specifying layout:'form'). An additional CSS class to apply to the
 div wrapping the form item element of this field. If supplied, itemCls at the field level will override the default
 itemCls supplied at the container level. The value specified for itemCls will be added to the default class
 ('x-form-item'). Since it is applied to the item wrapper (see Ext.layout.FormLayout.fieldTpl), it allows you to write
 standard CSS rules that can apply to the field, the label (if specified), or any other element within the markup for the
 field. Note: see the note for fieldLabel. Example use: // Apply a style to the field's label:
 <style>
     .required
 .x-form-item-label {font-weight:bold;color:red;}
 </style>
 
 new Ext.FormPanel({
     height: 100,
     renderTo:
 Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         itemCls: 'required' //this
 label will be styled
     },{
         xtype: 'textfield',
         fieldLabel: 'Favorite Color'
     }]
 });]]></description><name>itemCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An itemId can be used as an alternative way to get a reference to a component when no object reference is available.
 Instead of using an id with Ext.getCmp, use itemId with Ext.Container.getComponent which will retrieve itemId's or id's.
 Since itemId's are an index to the container's internal MixedCollection, the itemId is scoped locally to the container
 -- avoiding potential conflicts with Ext.ComponentMgr which requires a unique id. var c = new Ext.Panel({ //
     height:
 300,
     renderTo: document.body,
     layout: 'auto',
     items: [
         {
             itemId: 'p1',
            
 title: 'Panel 1',
             height: 150
         },
         {
             itemId: 'p2',
             title: 'Panel 2',
  
 height: 150
         }
     ]
 })
 p1 = c.getComponent('p1'); // not the same as Ext.getCmp()
 p2 =
 p1.ownerCt.getComponent('p2'); // reference via a sibling Also see id and ref. Note: to access the container of an item
 see ownerCt.]]></description><name>itemId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The separator to display after the text of each fieldLabel. This property may be configured at various levels. The order
 of precedence is: field / component level container level layout level (defaults to colon ':') To display no separator
 for this field's label specify empty string ''. Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 layoutConfig: {
         labelSeparator: '~'   // layout config has lowest priority (defaults to ':')
     },
    
 labelSeparator: '>>',     // config at container level
     items: [{
         xtype: 'textfield',
         fieldLabel:
 'Field 1',
         labelSeparator: '...' // field/component level config supersedes others
     },{
         xtype:
 'textfield',
         fieldLabel: 'Field 2' // labelSeparator will be '='
     }]
 });]]></description><name>labelSeparator</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS style specification string to apply directly to this field's label. Defaults to the container's labelStyle value
 if set (e.g., Ext.layout.FormLayout.labelStyle , or ''). Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         labelStyle: 'font-weight:bold;'
     }]
 });]]></description><name>labelStyle</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum width in pixels of the editor field (defaults to 250). Note that if the maxWidth would exceed the containing
 tree element's size, it will be automatically limited for you to the container width, taking scroll and client offsets
 into account prior to each edit.]]></description><name>maxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The offsets to use when aligning (see Ext.Element.alignTo for more details. Defaults to [0, 0].]]></description><name>offsets</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element when the mouse moves over the Element, and
 removed when the mouse moves out. (defaults to ''). This can be useful for adding customized 'active' or 'hover' styles
 to the component or any of its children using standard CSS rules.]]></description><name>overCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered ptype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a Plugin is being specified not as a fully
 instantiated Component, but as a Component config object. The ptype will be looked up at render time up to determine
 what type of Plugin to create. If you create your own Plugins, you may register them using
 Ext.ComponentMgr.registerPlugin in order to be able to take advantage of lazy instantiation and rendering.]]></description><name>ptype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A path specification, relative to the Component's ownerCt specifying into which ancestor Container to place a named
 reference to this Component. The ancestor axis can be traversed by using '/' characters in the path. For example, to put
 a reference to a Toolbar Button into the Panel which owns the Toolbar: var myGrid = new Ext.grid.EditorGridPanel({
    
 title: 'My EditorGridPanel',
     store: myStore,
     colModel: myColModel,
     tbar: [{
         text: 'Save',
        
 handler: saveChanges,
         disabled: true,
         ref: '../saveButton'
     }],
     listeners: {
         afteredit:
 function() {
 //          The button reference is in the GridPanel
             myGrid.saveButton.enable();
         }
    
 }
 }); In the code above, if the ref had been 'saveButton' the reference would have been placed into the Toolbar. Each
 '/' in the ref moves up one level from the Component's ownerCt. Also see the added and removed events.]]></description><name>ref</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically revert the field value and cancel the edit when the user completes an edit and the field
 validation fails (defaults to true)]]></description><name>revertInvalid</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA["sides" for sides/bottom only, "frame" for 4-way shadow, and "drop" for bottom-right shadow (defaults to "frame")]]></description><name>shadow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to shim the editor if selects/iframes could be displayed beneath it (defaults to false)]]></description><name>shim</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should trigger this component to save its state (defaults to none). stateEvents may
 be any type of event supported by this component, including browser or custom events (e.g., ['click',
 'customerchange']). See stateful for an explanation of saving and restoring Component state.]]></description><name>stateEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id for this component to use for state management purposes (defaults to the component id if one was set,
 otherwise null if the component is using a generated id). See stateful for an explanation of saving and restoring
 Component state.]]></description><name>stateId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A flag which causes the Component to attempt to restore the state of internal properties from a saved state on startup.
 The component must have either a stateId or id assigned for state to be managed. Auto-generated ids are not guaranteed
 to be stable across page loads and cannot be relied upon to save and restore the same state for a component. For state
 saving to work, the state manager's provider must have been set to an implementation of Ext.state.Provider which
 overrides the set and get methods to save and recall name/value pairs. A built-in implementation,
 Ext.state.CookieProvider is available. To set the state provider for the current page: Ext.state.Manager.setProvider(new
 Ext.state.CookieProvider({
     expires: new Date(new Date().getTime()+(1000*60*60*24*7)), //7 days from now
 })); A
 stateful Component attempts to save state when one of the events listed in the stateEvents configuration fires. To save
 state, a stateful Component first serializes its state by calling getState. By default, this function does nothing. The
 developer must provide an implementation which returns an object hash which represents the Component's restorable state.
 The value yielded by getState is passed to Ext.state.Manager.set which uses the configured Ext.state.Provider to save
 the object keyed by the Component's stateId, or, if that is not specified, its id. During construction, a stateful
 Component attempts to restore its state by calling Ext.state.Manager.get passing the stateId, or, if that is not
 specified, the id. The resulting object is passed to applyState. The default implementation of applyState simply copies
 properties into the object, but a developer may override this to support more behaviour. You can perform extra
 processing on state save and restore by attaching handlers to the beforestaterestore, staterestore, beforestatesave and
 statesave events.]]></description><name>stateful</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
     title: 'Some Title',
     renderTo: Ext.getBody(),
     width: 400, height:
 300,
     layout: 'form',
     items: [{
         xtype: 'textarea',
         style: {
             width: '95%',
            
 marginBottom: '10px'
         }
     },
         new Ext.Button({
             text: 'Send',
             minWidth: '100',
   
          style: {
                 marginBottom: '10px'
             }
         })
     ]
 });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Handle the keydown/keypress events so they don't propagate (defaults to true)]]></description><name>swallowKeys</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to update the innerHTML of the bound element when the update completes (defaults to false)]]></description><name>updateEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The data value of the underlying field (defaults to "")]]></description><name>value</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered xtype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a child item of a Container is being specified not
 as a fully instantiated Component, but as a Component config object. The xtype will be looked up at render time up to
 determine what type of child Component to create. The predefined xtypes are listed here. If you subclass Components to
 create your own Components, you may register them using Ext.ComponentMgr.registerType in order to be able to take
 advantage of lazy instantiation and rendering.]]></description><name>xtype</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>]]></description><name>tree.node</name><tag-class>org.brushingbits.jnap.ui.extjs3.tree.TreeNode</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[False to not allow this node to have child nodes (defaults to true)]]></description><name>allowChildren</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[False to make this node undraggable if draggable = true (defaults to true)]]></description><name>allowDrag</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[False if this node cannot have child nodes dropped on it (defaults to true)]]></description><name>allowDrop</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to render a checked checkbox for this node, false to render an unchecked checkbox (defaults to undefined with no
 checkbox rendered)]]></description><name>checked</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A css class to be added to the node]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to start the node disabled]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to make this node draggable (defaults to false)]]></description><name>draggable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[False to not allow this node to be edited by an Ext.tree.TreeEditor (defaults to true)]]></description><name>editable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If set to true, the node will always show a plus/minus icon, even when empty]]></description><name>expandable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to start the node expanded]]></description><name>expanded</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to render hidden. (Defaults to false).]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[URL of the link used for the node (defaults to #)]]></description><name>href</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[target frame for the link]]></description><name>hrefTarget</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The path to an icon for the node. The preferred way to do this is to use the cls or iconCls attributes and add the icon
 via a CSS background image.]]></description><name>icon</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A css class to be added to the nodes icon element for applying css background images]]></description><name>iconCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The id for this node. If one is not specified, one is generated.]]></description><name>id</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[False to not allow this node to act as a drop target (defaults to true)]]></description><name>isTarget</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true if this node is a leaf and does not have children]]></description><name>leaf</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An Ext QuickTip for the node]]></description><name>qtip</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An Ext QuickTip config for the node (used instead of qtip)]]></description><name>qtipCfg</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True for single click expand on this node]]></description><name>singleClickExpand</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The text for this node]]></description><name>text</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A UI class to use for this node (defaults to Ext.tree.TreeNodeUI)]]></description><name>uiProvider</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 <p>The TreePanel provides tree-structured UI representation of tree-structured data.</p> 
 <p><a
 href="output/Ext.tree.TreeNode.html" ext:cls="Ext.tree.TreeNode">TreeNode</a>s added to the TreePanel may each contain
 metadata used by your application in their <a href="output/Ext.tree.TreeNode.html#Ext.tree.TreeNode-attributes"
 ext:member="attributes" ext:cls="Ext.tree.TreeNode">attributes</a> property.</p> 
 <p><b>A TreePanel must have a <a
 href="output/Ext.tree.TreePanel.html#Ext.tree.TreePanel-root" ext:member="root" ext:cls="Ext.tree.TreePanel">root</a>
 node before it is rendered.</b> This may either be specified using the <a
 href="output/Ext.tree.TreePanel.html#Ext.tree.TreePanel-root" ext:member="root" ext:cls="Ext.tree.TreePanel">root</a>
 config option, or using the <a href="output/Ext.tree.TreePanel.html#Ext.tree.TreePanel-setRootNode"
 ext:member="setRootNode" ext:cls="Ext.tree.TreePanel">setRootNode</a> method. </p>
 <p>An example of tree rendered to an
 existing div:</p>
 <pre><code><b>var</b> tree = <b>new</b> Ext.tree.TreePanel({
     renderTo: <em>'tree-div'</em>,
    
 useArrows: true,
     autoScroll: true,
     animate: true,
     enableDD: true,
     containerScroll: true,
     border:
 false,
     <i>// auto create TreeLoader</i>
     dataUrl: <em>'get-nodes.php'</em>,
 
     root: {
         nodeType:
 <em>'async'</em>,
         text: <em>'Ext JS'</em>,
         draggable: false,
         id: <em>'source'</em>
    
 }
 });
 
 tree.getRootNode().expand();</code></pre> 
 <p>The example above would work with a data packet similar to
 this:</p>
 <pre><code>[{
     <em>&quot;text&quot;</em>: <em>&quot;adapter&quot;</em>,
     <em>&quot;id&quot;</em>:
 <em>&quot;source\/adapter&quot;</em>,
     <em>&quot;cls&quot;</em>: <em>&quot;folder&quot;</em>
 }, {
    
 <em>&quot;text&quot;</em>: <em>&quot;dd&quot;</em>,
     <em>&quot;id&quot;</em>: <em>&quot;source\/dd&quot;</em>,
    
 <em>&quot;cls&quot;</em>: <em>&quot;folder&quot;</em>
 }, {
     <em>&quot;text&quot;</em>:
 <em>&quot;debug.js&quot;</em>,
     <em>&quot;id&quot;</em>: <em>&quot;source\/debug.js&quot;</em>,
    
 <em>&quot;leaf&quot;</em>: true,
     <em>&quot;cls&quot;</em>: <em>&quot;file&quot;</em>
 }]</code></pre> 
 <p>An example
 of tree within a Viewport:</p>
 <pre><code><b>new</b> Ext.Viewport({
     layout: <em>'border'</em>,
     items: [{
        
 region: <em>'west'</em>,
         collapsible: true,
         title: <em>'Navigation'</em>,
         xtype:
 <em>'treepanel'</em>,
         width: 200,
         autoScroll: true,
         split: true,
         loader: <b>new</b>
 Ext.tree.TreeLoader(),
         root: <b>new</b> Ext.tree.AsyncTreeNode({
             expanded: true,
            
 children: [{
                 text: <em>'Menu Option 1'</em>,
                 leaf: true
             }, {
                
 text: <em>'Menu Option 2'</em>,
                 leaf: true
             }, {
                 text: <em>'Menu Option
 3'</em>,
                 leaf: true
             }]
         }),
         rootVisible: false,
         listeners: {
         
 click: <b>function</b>(n) {
                 Ext.Msg.alert(<em>'Navigation Tree Click'</em>, <em>'You clicked:
 <em>&quot;'</em> + n.attributes.text + <em>'&quot;</em>'</em>);
             }
         }
     }, {
         region:
 <em>'center'</em>,
         xtype: <em>'tabpanel'</em>,
         <i>// remaining code not shown ...</i>
    
 }]
 });</code></pre>]]></description><name>tree.panel</name><tag-class>org.brushingbits.jnap.ui.extjs3.tree.TreePanel</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[A string component id or the numeric index of the component that should be initially activated within the container's
 layout on render. For example, activeItem: 'item-1' or activeItem: 0 (index 0 = the first item in the container's
 collection). activeItem only applies to layout styles that can display items one at a time (like
 Ext.layout.AccordionLayout, Ext.layout.CardLayout and Ext.layout.FitLayout). Related to
 Ext.layout.ContainerLayout.activeItem.]]></description><name>activeItem</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Whether the component can move the Dom node when rendering (defaults to true).]]></description><name>allowDomMove</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use an
 AnchorLayout (or subclass thereof). based layout manager, for example: Ext.form.FormPanel specifying layout: 'anchor' //
 or 'form', or 'absolute' See Ext.layout.AnchorLayout.anchor also.]]></description><name>anchor</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to animate the transition when the panel is collapsed, false to skip the animation (defaults to true if the Ext.Fx
 class is available, otherwise false).]]></description><name>animCollapse</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to enable animated expand/collapse (defaults to the value of Ext.enableFx)]]></description><name>animate</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The id of the node, a DOM node or an existing Element corresponding to a DIV that is already present in the document
 that specifies some panel-specific structural markup. When applyTo is used, constituent parts of the panel can be
 specified by CSS class name within the main element, and the panel will automatically create those components from that
 markup. Any required components not specified in the markup will be autogenerated if necessary. The following class
 names are supported (baseCls will be replaced by baseCls): baseCls + '-header' baseCls + '-header-text' baseCls +
 '-bwrap' baseCls + '-tbar' baseCls + '-body' baseCls + '-bbar' baseCls + '-footer' Using this config, a call to render()
 is not required. If applyTo is specified, any value passed for renderTo will be ignored and the target element's parent
 node will automatically be used as the panel's container.]]></description><name>applyTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If true the container will automatically destroy any contained component that is removed from it, else destruction must
 be handled manually (defaults to true).]]></description><name>autoDestroy</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A tag name or DomHelper spec used to create the Element which will encapsulate this Component. You do not normally need
 to specify this. For the base classes Ext.Component, Ext.BoxComponent, and Ext.Container, this defaults to 'div'. The
 more complex Ext classes use a more complex DOM structure created by their own onRender methods. This is intended to
 allow the developer to create application-specific utility Components encapsulated by different DOM elements. Example
 usage: <pre><code>{
     xtype: 'box',
     autoEl: {
         tag: 'img',
         src: 'http://www.example.com/example.jpg'
     }
 },
 {
     xtype: 'box',
     autoEl: {
         tag: 'blockquote',
         html: 'autoEl is cool!'
     }
 }, {
     xtype: 'container',
     autoEl: 'ul',
     cls: 'ux-unordered-list',
     items: {
         xtype: 'box',
         autoEl: 'li',
   
      html: 'First list item'
     }
 }</pre></code>]]></description><name>autoEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to use height:'auto', false to use fixed height (defaults to false). Note: Setting autoHeight: true means that the
 browser will manage the panel's height based on its contents, and that Ext will not manage it at all. If the panel is
 within a layout that manages dimensions (fit, border, etc.) then setting autoHeight: true can cause issues with
 scrolling and will not generally work as expected since the panel will take on the height of its contents rather than
 the height required by the Ext layout.]]></description><name>autoHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A valid url spec according to the Updater Ext.Updater.update method. If autoLoad is not null, the panel will attempt to
 load its contents immediately upon render. The URL will become the default URL for this panel's body element, so it may
 be refreshed at any time.]]></description><name>autoLoad</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to use overflow:'auto' on the components layout element and show scroll bars automatically when necessary, false to
 clip any overflowing content (defaults to false).]]></description><name>autoScroll</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True if the component should check for hidden classes (e.g. 'x-hidden' or 'x-hide-display') and remove them on render
 (defaults to false).]]></description><name>autoShow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to use width:'auto', false to use fixed width (or allow it to be managed by its parent Container's layout manager.
 Defaults to false. Note: Although many components inherit this config option, not all will function as expected with a
 width of 'auto'. Setting autoWidth:true means that the browser will manage width based on the element's contents, and
 that Ext will not manage it at all. If the browser is managing the width, be aware that resizes performed by the browser
 in response to changes within the structure of the Component cannot be detected. Therefore changes to the width might
 result in elements needing to be synchronized with the new width. For example, where the target element is: <div
 id='grid-container' style='margin-left:25%;width:50%'></div> A Panel rendered into that target element must listen for
 browser window resize in order to relay its child items when the browser changes its width: var myPanel = new
 Ext.Panel({
     renderTo: 'grid-container',
     monitorResize: true, // relay on browser resize
     title: 'Panel',
    
 height: 400,
     autoWidth: true,
     layout: 'hbox',
     layoutConfig: {
         align: 'stretch'
     },
     defaults: {
         flex: 1
     },
     items: [{
         title: 'Box 1',
     }, {
         title: 'Box 2'
     }, {
         title:
 'Box 3'
     }],
 });]]></description><name>autoWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The base CSS class to apply to this panel's element (defaults to 'x-panel'). Another option available by default is to
 specify 'x-plain' which strips all styling except for required attributes for Ext layouts to function (e.g.
 overflow:hidden). See unstyled also.]]></description><name>baseCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to display an interior border on the body element of the panel, false to hide it (defaults to true). This only
 applies when border == true. If border == true and bodyBorder == false, the border will display as a 1px wide inset
 border, giving the entire body element an inset appearance.]]></description><name>bodyBorder</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A DomHelper element specification object may be specified for any Panel Element. By default, the Default element in the
 table below will be used for the html markup to create a child element with the commensurate Default class name (baseCls
 will be replaced by baseCls): 
 Panel      Default  Default             Custom      Additional       Additional
 Element  
 element  class               element     class            style
 ========   ==========================   =========  
 ==============   ===========
 header     div      baseCls+'-header'   headerCfg   headerCssClass   headerStyle
 bwrap     
 div      baseCls+'-bwrap'     bwrapCfg    bwrapCssClass    bwrapStyle
 + tbar     div      baseCls+'-tbar'       tbarCfg 
 tbarCssClass     tbarStyle
 + body     div      baseCls+'-body'       bodyCfg     bodyCssClass     bodyStyle
 + bbar    
 div      baseCls+'-bbar'       bbarCfg     bbarCssClass     bbarStyle
 + footer   div      baseCls+'-footer'   footerCfg 
 footerCssClass   footerStyle
  Configuring a Custom element may be used, for example, to force the body Element to use a
 different form of markup than is created by default. An example of this might be to create a child Panel containing a
 custom content, such as a header, or forcing centering of all Panel content by having the body be a <center> element:
 new Ext.Panel({
     title: 'Message Title',
     renderTo: Ext.getBody(),
     width: 200, height: 130,
     bodyCfg: {
    
 tag: 'center',
         cls: 'x-panel-body',  // Default class not applied if Custom element specified
         html:
 'Message'
     },
     footerCfg: {
         tag: 'h2',
         cls: 'x-panel-footer',        // same as the Default class
 
 html: 'footer html'
     },
     footerCssClass: 'custom-footer', // additional css class, see addClass
     footerStyle:  
 'background-color:red' // see bodyStyle
 }); The example above also explicitly creates a footer with custom markup and
 styling applied.]]></description><name>bodyCfg</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Additional css class selector to be applied to the body element in the format expected by Ext.Element.addClass (defaults
 to null). See bodyCfg.]]></description><name>bodyCssClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Custom CSS styles to be applied to the body element in the format expected by Ext.Element.applyStyles (defaults to
 null). See bodyCfg.]]></description><name>bodyStyle</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to display the borders of the panel's body element, false to hide them (defaults to true). By default, the border
 is a 2px wide inset border, but this can be further altered by setting bodyBorder to false.]]></description><name>border</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to [].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[When set to true (50 milliseconds) or a number of milliseconds, the layout assigned for this container will buffer the
 frequency it calculates and does a re-layout of components. This is useful for heavy containers or containers with a
 large quantity of sub-components for which frequent layout calls would be expensive. Defaults to 50.]]></description><name>bufferResize</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The alignment of any buttons added to this panel. Valid values are 'right', 'left' and 'center' (defaults to 'right').]]></description><name>buttonAlign</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A DomHelper element specification object specifying the element structure of this Panel's bwrap Element. See bodyCfg
 also.]]></description><name>bwrapCfg</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class used to to apply to the special clearing div rendered directly after each form field wrapper to provide
 field clearing (defaults to 'x-form-clear-left'). Note: this config is only used when this Component is rendered by a
 Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or specifying
 layout:'form') and either a fieldLabel is specified or isFormField=true is specified. See Ext.layout.FormLayout.fieldTpl
 also.]]></description><name>clearCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Panels themselves do not directly support being closed, but some Panel subclasses do (like Ext.Window) or a Panel Class
 within an Ext.TabPanel. Specify true to enable closing in such situations. Defaults to false.]]></description><name>closable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element (defaults to ''). This can be useful for
 adding customized styles to the component or any of its children using standard CSS rules.]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to make sure the collapse/expand toggle button always renders first (to the left of) any other tools in the panel's
 title bar, false to render it last (defaults to true).]]></description><name>collapseFirst</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to render the panel collapsed, false to render it expanded (defaults to false).]]></description><name>collapsed</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS class to add to the panel's element after it has been collapsed (defaults to 'x-panel-collapsed').]]></description><name>collapsedCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to make the panel collapsible and have the expand/collapse toggle button automatically rendered into the header
 tool button area, false to keep the panel statically sized with no button (defaults to false).]]></description><name>collapsible</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to register this container with ScrollManager]]></description><name>containerScroll</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's container. This can be useful for adding customized
 styles to the container or any of its children using standard CSS rules. See Ext.layout.ContainerLayout.extraCls also.
 Note: ctCls defaults to '' except for the following class which assigns a value by default: Box Layout :
 'x-box-layout-ct' To configure the above Class with an extra CSS class append to the default. For example, for BoxLayout
 (Hbox and Vbox): ctCls: 'x-box-layout-ct custom-class']]></description><name>ctCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true if the tree should only allow append drops (use for trees which are sorted)]]></description><name>ddAppendOnly</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The DD group this TreePanel belongs to]]></description><name>ddGroup</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to enable body scrolling]]></description><name>ddScroll</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default xtype of child Components to create in this Container when a child item is specified as a raw configuration
 object, rather than as an instantiated Component. Defaults to 'panel', except Ext.menu.Menu which defaults to
 'menuitem', and Ext.Toolbar and Ext.ButtonGroup which default to 'button'.]]></description><name>defaultType</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[This option is a means of applying default settings to all added items whether added through the items config or via the
 add or insert methods. If an added item is a config object, and not an instantiated Component, then the default
 properties are unconditionally applied. If the added item is an instantiated Component, then the default properties are
 applied conditionally so as not to override existing properties in the item. If the defaults option is specified as a
 function, then the function will be called using this Container as the scope (this reference) and passing the added item
 as the first parameter. Any resulting object from that call is then applied to the item as default properties. For
 example, to automatically apply padding to the body of each of a set of contained Ext.Panel items, you could pass:
 defaults: {bodyStyle:'padding:15px'}. Usage: defaults: {               // defaults are applied to items, not the
 container
     autoScroll:true
 },
 items: [
     {
         xtype: 'panel',   // defaults do not have precedence over
       
 id: 'panel1',     // options in config objects, so the defaults
         autoScroll: false // will not be applied here,
 panel1 will be autoScroll:false
     },
     new Ext.Panel({       // defaults do have precedence over options
         id:
 'panel2',     // options in components, so the defaults
         autoScroll: false // will be applied here, panel2 will
 be autoScroll:true.
     })
 ]]]></description><name>defaults</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this panel disabled (default is false). An important note when using the disabled config on panels is that IE
 will often fail to initialize the disabled mask element correectly if the panel's layout has not yet completed by the
 time the Panel is disabled during the render process. If you experience this issue, you may need to instead use the
 afterlayout event to initialize the disabled state: new Ext.Panel({
     ...
     listeners: {
         'afterlayout': {
   
 fn: function(p){
                 p.disable();
             },
             single: true // important, as many layouts can
 occur
         }
     }
 });]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class added to the component when it is disabled (defaults to 'x-item-disabled').]]></description><name>disabledClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Custom config to pass to the Ext.tree.TreeDragZone instance]]></description><name>dragConfig</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to enable dragging of this Panel (defaults to false). For custom drag/drop implementations, an Ext.Panel.DD config
 could also be passed in this config instead of true. Ext.Panel.DD is an internal, undocumented class which moves a proxy
 Element around in place of the Panel's element, but provides no other behaviour during dragging or on drop. It is a
 subclass of Ext.dd.DragSource, so behaviour may be added by implementing the interface methods of Ext.dd.DragDrop e.g.:
 new Ext.Panel({
     title: 'Drag me',
     x: 100,
     y: 100,
     renderTo: Ext.getBody(),
     floating: true,
    
 frame: true,
     width: 400,
     height: 200,
     draggable: {
 //      Config option of Ext.Panel.DD class.
 //      It's
 a floating Panel, so do not show a placeholder proxy in the original position.
         insertProxy: false,
 
 //     
 Called for each mousemove event while dragging the DD object.
         onDrag : function(e){
 //          Record the x,y
 position of the drag proxy so that we can
 //          position the Panel at end of drag.
             var pel =
 this.proxy.getEl();
             this.x = pel.getLeft(true);
             this.y = pel.getTop(true);
 
 //          Keep the
 Shadow aligned if there is one.
             var s = this.panel.getEl().shadow;
             if (s) {
                
 s.realign(this.x, this.y, pel.getWidth(), pel.getHeight());
             }
         },
 
 //      Called on the mouseup
 event.
         endDrag : function(e){
             this.panel.setPosition(this.x, this.y);
         }
     }
 }).show();]]></description><name>draggable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Custom config to pass to the Ext.tree.TreeDropZone instance]]></description><name>dropConfig</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A comma-delimited list of panel elements to initialize when the panel is rendered. Normally, this list will be generated
 automatically based on the items added to the panel at config time, but sometimes it might be useful to make sure a
 structural element is rendered even if not specified at config time (for example, you may want to add a button or
 toolbar dynamically after the panel has been rendered). Adding those elements to this list will allocate the required
 placeholders in the panel when it is rendered. Valid values are header tbar (top bar) body bbar (bottom bar) footer
 Defaults to 'body'.]]></description><name>elements</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to enable drag and drop]]></description><name>enableDD</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to enable just drag]]></description><name>enableDrag</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to enable just drop]]></description><name>enableDrop</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A Toolbar object, a Toolbar config, or an array of Buttons/Button configs, describing a Toolbar to be rendered into this
 Panel's footer element. After render, the fbar property will be an Toolbar instance. If buttons are specified, they will
 supersede the fbar configuration property. The Panel's buttonAlign configuration affects the layout of these items, for
 example: var w = new Ext.Window({
     height: 250,
     width: 500,
     bbar: new Ext.Toolbar({
         items: [{
        
 text: 'bbar Left'
         },'->',{
             text: 'bbar Right'
         }]
     }),
     buttonAlign: 'left', //
 anything but 'center' or 'right' and you can use '-', and '->'
                                   // to control the
 alignment of fbar items
     fbar: [{
         text: 'fbar Left'
     },'->',{
         text: 'fbar Right'
     }]
 }).show();
 Note: Although a Toolbar may contain Field components, these will not be updated by a load of an ancestor FormPanel. A
 Panel's toolbars are not part of the standard Container->Component hierarchy, and so are not scanned to collect form
 items. However, the values will be submitted because form submission parameters are collected from the DOM tree.]]></description><name>fbar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The label text to display next to this Component (defaults to ''). Note: this config is only used when this Component is
 rendered by a Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or
 specifying layout:'form'). Also see hideLabel and Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
    
 height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name'
    
 }]
 });]]></description><name>fieldLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use a
 BoxLayout. Each child Component with a flex property will be flexed either vertically (by a VBoxLayout) or horizontally
 (by an HBoxLayout) according to the item's relative flex value compared to the sum of all Components with flex value
 specified. Any child items that have either a flex = 0 or flex = undefined will not be 'flexed' (the initial size will
 not be changed).]]></description><name>flex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[This property is used to configure the underlying Ext.Layer. Acceptable values for this configuration property are:
 false : Default. Display the panel inline where it is rendered. true : Float the panel (absolute position it with
 automatic shimming and shadow). Setting floating to true will create an Ext.Layer for this panel and display the panel
 at negative offsets so that it is hidden. Since the panel will be absolute positioned, the position must be set
 explicitly after render (e.g., myPanel.setPosition(100,100);). Note: when floating a panel you should always assign a
 fixed width, otherwise it will be auto width and will expand to fill to the right edge of the viewport. object : The
 specified object will be used as the configuration object for the Ext.Layer that will be created.]]></description><name>floating</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to create the footer element explicitly, false to skip creating it. The footer will be created automatically if
 buttons or a fbar have been configured. See bodyCfg for an example.]]></description><name>footer</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A DomHelper element specification object specifying the element structure of this Panel's footer Element. See bodyCfg
 also.]]></description><name>footerCfg</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If true the container will force a layout initially even if hidden or collapsed. This option is useful for forcing forms
 to render in collapsed or hidden containers. (defaults to false).]]></description><name>forceLayout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[false by default to render with plain 1px square borders. true to render with 9 elements, complete with custom rounded
 corners (also see Ext.Element.boxWrap). The template generated for each condition is depicted below: // frame =
 false
 <div id="developer-specified-id-goes-here" class="x-panel">
 
     <div class="x-panel-header"><span
 class="x-panel-header-text">Title: (frame:false)</span></div>
 
     <div class="x-panel-bwrap">
         <div
 class="x-panel-body"><p>html value goes here</p></div>
     </div>
 </div>
 
 // frame = true (create 9 elements)
 <div
 id="developer-specified-id-goes-here" class="x-panel">
     <div class="x-panel-tl"><div class="x-panel-tr"><div
 class="x-panel-tc">
         <div class="x-panel-header"><span class="x-panel-header-text">Title:
 (frame:true)</span></div>
     </div></div></div>
 
     <div class="x-panel-bwrap">
         <div class="x-panel-ml"><div
 class="x-panel-mr"><div class="x-panel-mc">
             <div class="x-panel-body"><p>html value goes here</p></div>
     
 </div></div></div>
 
         <div class="x-panel-bl"><div class="x-panel-br"><div class="x-panel-bc"/>
        
 </div></div></div>
 </div>]]></description><name>frame</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to create the Panel's header element explicitly, false to skip creating it. If a title is set the header will be
 created automatically, otherwise it will not. If a title is set but header is explicitly set to false, the header will
 not be rendered.]]></description><name>header</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to display the panel title in the header, false to hide it (defaults to true).]]></description><name>headerAsText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A DomHelper element specification object specifying the element structure of this Panel's header Element. See bodyCfg
 also.]]></description><name>headerCfg</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component hidden (default is false). If true, the hide method will be called internally.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide the borders of each contained component, false to defer to the component's existing border settings
 (defaults to false).]]></description><name>hideBorders</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to hide the expand/collapse toggle button when collapsible == true, false to display it (defaults to false).]]></description><name>hideCollapseTool</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to completely hide the label element (label and separator). Defaults to false. By default, even if you do not
 specify a fieldLabel the space will still be reserved so that the field will line up with other fields that do have
 labels. Setting this to true will cause the field to not reserve that space. Note: see the note for clearCls. Example
 use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield'
        
 hideLabel: true
     }]
 });]]></description><name>hideLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[How this component should be hidden. Supported values are 'visibility' (css visibility), 'offsets' (negative offset
 position) and 'display' (css display). Note: the default of 'display' is generally preferred since items are
 automatically laid out when they are first shown (no sizing is done while hidden).]]></description><name>hideMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide and show the component's container when hide/show is called on the component, false to hide and show the
 component itself (defaults to false). For example, this can be used as a shortcut for a hide button on a window by
 setting hide:true on the button when adding it to its parent container.]]></description><name>hideParent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The color of the node highlight (defaults to 'C3DAF9')]]></description><name>hlColor</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[false to disable node highlight on drop (defaults to the value of Ext.enableFx)]]></description><name>hlDrop</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class selector that specifies a background image to be used as the header icon (defaults to ''). An example of
 specifying a custom icon class would be something like: // specify the property in the config for the class:
      ...
   
 iconCls: 'my-icon'
 
 // css class that specifies background image to be used as the icon image:
 .my-icon {
 background-image: url(../images/my-icon.gif) 0 6px no-repeat !important; }]]></description><name>iconCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id of this component (defaults to an auto-assigned id). You should assign an id if you need to be able to
 access the component later and you do not have an object reference available (e.g., using Ext.getCmp). Note that this id
 will also be used as the element id for the containing HTML element that is rendered to the page for this component.
 This allows you to write id-based CSS rules to style the specific instance of this component uniquely, and also to
 select sub-elements using this component's id as the parent. Note: to avoid complications imposed by a unique id also
 see itemId and ref. Note: to access the container of an item see ownerCt.]]></description><name>id</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use the
 FormLayout layout manager (e.g. Ext.form.FormPanel or specifying layout:'form'). An additional CSS class to apply to the
 div wrapping the form item element of this field. If supplied, itemCls at the field level will override the default
 itemCls supplied at the container level. The value specified for itemCls will be added to the default class
 ('x-form-item'). Since it is applied to the item wrapper (see Ext.layout.FormLayout.fieldTpl), it allows you to write
 standard CSS rules that can apply to the field, the label (if specified), or any other element within the markup for the
 field. Note: see the note for fieldLabel. Example use: // Apply a style to the field's label:
 <style>
     .required
 .x-form-item-label {font-weight:bold;color:red;}
 </style>
 
 new Ext.FormPanel({
     height: 100,
     renderTo:
 Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         itemCls: 'required' //this
 label will be styled
     },{
         xtype: 'textfield',
         fieldLabel: 'Favorite Color'
     }]
 });]]></description><name>itemCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An itemId can be used as an alternative way to get a reference to a component when no object reference is available.
 Instead of using an id with Ext.getCmp, use itemId with Ext.Container.getComponent which will retrieve itemId's or id's.
 Since itemId's are an index to the container's internal MixedCollection, the itemId is scoped locally to the container
 -- avoiding potential conflicts with Ext.ComponentMgr which requires a unique id. var c = new Ext.Panel({ //
     height:
 300,
     renderTo: document.body,
     layout: 'auto',
     items: [
         {
             itemId: 'p1',
            
 title: 'Panel 1',
             height: 150
         },
         {
             itemId: 'p2',
             title: 'Panel 2',
  
 height: 150
         }
     ]
 })
 p1 = c.getComponent('p1'); // not the same as Ext.getCmp()
 p2 =
 p1.ownerCt.getComponent('p2'); // reference via a sibling Also see id and ref. Note: to access the container of an item
 see ownerCt.]]></description><name>itemId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A Ext.KeyMap config object (in the format expected by Ext.KeyMap.addBinding used to assign custom key handling to this
 panel (defaults to null).]]></description><name>keys</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The separator to display after the text of each fieldLabel. This property may be configured at various levels. The order
 of precedence is: field / component level container level layout level (defaults to colon ':') To display no separator
 for this field's label specify empty string ''. Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 layoutConfig: {
         labelSeparator: '~'   // layout config has lowest priority (defaults to ':')
     },
    
 labelSeparator: '>>',     // config at container level
     items: [{
         xtype: 'textfield',
         fieldLabel:
 'Field 1',
         labelSeparator: '...' // field/component level config supersedes others
     },{
         xtype:
 'textfield',
         fieldLabel: 'Field 2' // labelSeparator will be '='
     }]
 });]]></description><name>labelSeparator</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS style specification string to apply directly to this field's label. Defaults to the container's labelStyle value
 if set (e.g., Ext.layout.FormLayout.labelStyle , or ''). Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         labelStyle: 'font-weight:bold;'
     }]
 });]]></description><name>labelStyle</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[*Important: In order for child items to be correctly sized and positioned, typically a layout manager must be specified
 through the layout configuration option. The sizing and positioning of child items is the responsibility of the
 Container's layout manager which creates and manages the type of layout you have in mind. For example:
 <pre><code>
 new Ext.Window({
 
 width:300, height: 300,
     layout: 'fit', // explicitly set layout manager: override the default (layout:'auto')
    
 items: [{
         title: 'Panel inside a Window'
     }]
 }).show();</pre></code>
 If the layout configuration is not explicitly
 specified for a general purpose container (e.g. Container or Panel) the default layout manager will be used which does
 nothing but render child components sequentially into the Container (no sizing or positioning will be performed in this
 situation). Some container classes implicitly specify a default layout (e.g. FormPanel specifies layout:'form'). Other
 specific purpose classes internally specify/manage their internal layout (e.g. GridPanel, TabPanel, TreePanel, Toolbar,
 Menu, etc.). layout may be specified as either as an Object or as a String: Specify as an Object Example usage: layout:
 {
     type: 'vbox',
     padding: '5',
     align: 'left'
 } type The layout type to be used for this container. If not
 specified, a default Ext.layout.ContainerLayout will be created and used. Valid layout type values are: absolute
 accordion anchor auto Default border card column fit form hbox menu table toolbar vbox Layout specific configuration
 properties Additional layout specific configuration properties may also be specified. For complete details regarding the
 valid config options for each layout type, see the layout class corresponding to the type specified. Specify as a String
 Example usage: layout: 'vbox',
 layoutConfig: {
     padding: '5',
     align: 'left'
 } layout The layout type to be used
 for this container (see list of valid layout type values above). layoutConfig Additional layout specific configuration
 properties. For complete details regarding the valid config options for each layout type, see the layout class
 corresponding to the layout specified.]]></description><name>layout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[false to disable tree lines (defaults to true)]]></description><name>lines</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A Ext.tree.TreeLoader for use with this TreePanel]]></description><name>loader</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout or one of the two BoxLayout subclasses. An object containing margins to apply to this BoxComponent in the
 format: {
     top: (top margin),
     right: (right margin),
     bottom: (bottom margin),
     left: (left margin)
 } May
 also be a string containing space-separated, numeric margin values. The order of the sides associated with each value
 matches the way CSS processes margin values: If there is only one value, it applies to all sides. If there are two
 values, the top and bottom borders are set to the first value and the right and left are set to the second. If there are
 three values, the top is set to the first value, the left and right are set to the second, and the bottom is set to the
 third. If there are four values, they apply to the top, right, bottom, and left, respectively. Defaults to: {top:0,
 right:0, bottom:0, left:0}]]></description><name>margins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to mask the panel when it is disabled, false to not mask it (defaults to true). Either way, the panel will always
 tell its contained elements to disable themselves when it is disabled, but masking the panel can provide an additional
 visual cue that the panel is disabled.]]></description><name>maskDisabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Minimum width in pixels of all buttons in this panel (defaults to 75)]]></description><name>minButtonWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically monitor window resize events to handle anything that is sensitive to the current size of the
 viewport. This value is typically managed by the chosen layout and should not need to be set manually.]]></description><name>monitorResize</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element when the mouse moves over the Element, and
 removed when the mouse moves out. (defaults to ''). This can be useful for adding customized 'active' or 'hover' styles
 to the component or any of its children using standard CSS rules.]]></description><name>overCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A shortcut for setting a padding style on the body element. The value can either be a number to be applied to all sides,
 or a normal css string describing padding. Defaults to undefined.]]></description><name>padding</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level x coordinate for this component if contained within a positioning container.]]></description><name>pageX</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level y coordinate for this component if contained within a positioning container.]]></description><name>pageY</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The token used to separate sub-paths in path strings (defaults to '/')]]></description><name>pathSeparator</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to false. When set to true, an extra css class 'x-panel-normal' will be added to the panel's element,
 effectively applying css styles suggested by the W3C (see http://www.w3.org/TR/CSS21/sample.html) to the Panel's body
 element (not the header, footer, etc.).]]></description><name>preventBodyReset</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered ptype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a Plugin is being specified not as a fully
 instantiated Component, but as a Component config object. The ptype will be looked up at render time up to determine
 what type of Plugin to create. If you create your own Plugins, you may register them using
 Ext.ComponentMgr.registerPlugin in order to be able to take advantage of lazy instantiation and rendering.]]></description><name>ptype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A path specification, relative to the Component's ownerCt specifying into which ancestor Container to place a named
 reference to this Component. The ancestor axis can be traversed by using '/' characters in the path. For example, to put
 a reference to a Toolbar Button into the Panel which owns the Toolbar: var myGrid = new Ext.grid.EditorGridPanel({
    
 title: 'My EditorGridPanel',
     store: myStore,
     colModel: myColModel,
     tbar: [{
         text: 'Save',
        
 handler: saveChanges,
         disabled: true,
         ref: '../saveButton'
     }],
     listeners: {
         afteredit:
 function() {
 //          The button reference is in the GridPanel
             myGrid.saveButton.enable();
         }
    
 }
 }); In the code above, if the ref had been 'saveButton' the reference would have been placed into the Toolbar. Each
 '/' in the ref moves up one level from the Component's ownerCt. Also see the added and removed events.]]></description><name>ref</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout layout manager (e.g. specifying layout:'border'). See Ext.layout.BorderLayout also.]]></description><name>region</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The HTTP request method for loading data (defaults to the value of Ext.Ajax.method).]]></description><name>requestMethod</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The event to listen to for resizing in layouts. Defaults to 'bodyresize'.]]></description><name>resizeEvent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The root node for the tree.]]></description><name>root</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[false to hide the root node (defaults to true)]]></description><name>rootVisible</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A tree selection model to use with this TreePanel (defaults to an Ext.tree.DefaultSelectionModel)]]></description><name>selModel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true (or a valid Ext.Shadow Ext.Shadow.mode value) to display a shadow behind the panel, false to display no shadow
 (defaults to 'sides'). Note that this option only applies when floating = true.]]></description><name>shadow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The number of pixels to offset the shadow if displayed (defaults to 4). Note that this option only applies when floating
 = true.]]></description><name>shadowOffset</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[false to disable the iframe shim in browsers which need one (defaults to true). Note that this option only applies when
 floating = true.]]></description><name>shim</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true if only 1 node per branch may be expanded]]></description><name>singleExpand</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should trigger this component to save its state (defaults to none). stateEvents may
 be any type of event supported by this component, including browser or custom events (e.g., ['click',
 'customerchange']). See stateful for an explanation of saving and restoring Component state.]]></description><name>stateEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id for this component to use for state management purposes (defaults to the component id if one was set,
 otherwise null if the component is using a generated id). See stateful for an explanation of saving and restoring
 Component state.]]></description><name>stateId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A flag which causes the Component to attempt to restore the state of internal properties from a saved state on startup.
 The component must have either a stateId or id assigned for state to be managed. Auto-generated ids are not guaranteed
 to be stable across page loads and cannot be relied upon to save and restore the same state for a component. For state
 saving to work, the state manager's provider must have been set to an implementation of Ext.state.Provider which
 overrides the set and get methods to save and recall name/value pairs. A built-in implementation,
 Ext.state.CookieProvider is available. To set the state provider for the current page: Ext.state.Manager.setProvider(new
 Ext.state.CookieProvider({
     expires: new Date(new Date().getTime()+(1000*60*60*24*7)), //7 days from now
 })); A
 stateful Component attempts to save state when one of the events listed in the stateEvents configuration fires. To save
 state, a stateful Component first serializes its state by calling getState. By default, this function does nothing. The
 developer must provide an implementation which returns an object hash which represents the Component's restorable state.
 The value yielded by getState is passed to Ext.state.Manager.set which uses the configured Ext.state.Provider to save
 the object keyed by the Component's stateId, or, if that is not specified, its id. During construction, a stateful
 Component attempts to restore its state by calling Ext.state.Manager.get passing the stateId, or, if that is not
 specified, the id. The resulting object is passed to applyState. The default implementation of applyState simply copies
 properties into the object, but a developer may override this to support more behaviour. You can perform extra
 processing on state save and restore by attaching handlers to the beforestaterestore, staterestore, beforestatesave and
 statesave events.]]></description><name>stateful</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
     title: 'Some Title',
     renderTo: Ext.getBody(),
     width: 400, height:
 300,
     layout: 'form',
     items: [{
         xtype: 'textarea',
         style: {
             width: '95%',
            
 marginBottom: '10px'
         }
     },
         new Ext.Button({
             text: 'Send',
             minWidth: '100',
   
          style: {
                 marginBottom: '10px'
             }
         })
     ]
 });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is a child item of a TabPanel. A string to be used as innerHTML
 (html tags are accepted) to show in a tooltip when mousing over the associated tab selector element.
 Ext.QuickTips.init() must be called in order for the tips to render.]]></description><name>tabTip</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The title text to be used as innerHTML (html tags are accepted) to display in the panel header (defaults to ''). When a
 title is specified the header element will automatically be created and displayed unless header is explicitly set to
 false. If you do not want to specify a title at config time, but you may want one later, you must either specify a
 non-empty title (a blank space ' ' will do) or header:true so that the container element will get created.]]></description><name>title</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to allow expanding and collapsing the panel (when collapsible = true) by clicking anywhere in the header bar,
 false) to allow it only by clicking to tool button (defaults to false)). If this panel is a child item of a border
 layout also see the BorderLayout.Region floatable config option.]]></description><name>titleCollapse</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A Template used to create tools in the header Element. Defaults to: new Ext.Template('<div class="x-tool
 x-tool-{id}">&#160;</div>') This may may be overridden to provide a custom DOM structure for tools based upon a more
 complex XTemplate. The template's data is a single tool configuration object (Not the entire Array) as specified in
 tools. In the following example an <a> tag is used to provide a visual indication when hovering over the tool: var win =
 new Ext.Window({
     tools: [{
         id: 'download',
         href: '/MyPdfDoc.pdf'
     }],
     toolTemplate: new
 Ext.XTemplate(
         '<tpl if="id==\'download\'">',
             '<a class="x-tool x-tool-pdf" href="{href}"></a>',
    
 '</tpl>',
         '<tpl if="id!=\'download\'">',
             '<div class="x-tool x-tool-{id}">&#160;</div>',
        
 '</tpl>'
     ),
     width:500,
     height:300,
     closeAction:'hide'
 }); Note that the CSS class 'x-tool-pdf' should
 have an associated style rule which provides an appropriate background image, something like: a.x-tool-pdf
 {background-image: url(../shared/extjs/images/pdf.gif)!important;}]]></description><name>toolTemplate</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of tool button configs to be added to the header tool area. When rendered, each tool is stored as an Element
 referenced by a public property called tools.<tool-type> Each tool config may contain the following properties: id :
 String Required. The type of tool to create. By default, this assigns a CSS class of the form x-tool-<tool-type> to the
 resulting tool Element. Ext provides CSS rules, and an icon sprite containing images for the tool types listed below.
 The developer may implement custom tools by supplying alternate CSS rules and background images: toggle (Created by
 default when collapsible is true) close minimize maximize restore gear pin unpin right left up down refresh minus plus
 help search save print handler : Function Required. The function to call when clicked. Arguments passed are: event :
 Ext.EventObject The click event. toolEl : Ext.Element The tool Element. panel : Ext.Panel The host Panel tc : Object The
 tool configuration object stopEvent : Boolean Defaults to true. Specify as false to allow click event to propagate.
 scope : Object The scope in which to call the handler. qtip : String/Object A tip string, or a config argument to
 Ext.QuickTip.register hidden : Boolean True to initially render hidden. on : Object A listener config object specifiying
 event listeners in the format of an argument to addListener Note that, apart from the toggle tool which is provided when
 a panel is collapsible, these tools only provide the visual button. Any required functionality must be provided by
 adding handlers that implement the necessary behavior. Example usage: tools:[{
     id:'refresh',
     qtip: 'Refresh form
 Data',
     // hidden:true,
     handler: function(event, toolEl, panel){
         // refresh logic
     }
 },
 {
    
 id:'help',
     qtip: 'Get Help',
     handler: function(event, toolEl, panel){
         // whatever
     }
 }] For the
 custom id of 'help' define two relevant css classes with a link to a 15x15 image: .x-tool-help {background-image:
 url(images/help.png);}
 .x-tool-help-over {background-image: url(images/help_over.png);}
 // if using an image
 sprite:
 .x-tool-help {background-image: url(images/help.png) no-repeat 0 0;}
 .x-tool-help-over
 {background-position:-15px 0;}]]></description><name>tools</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[false to disable mouse over highlighting]]></description><name>trackMouseOver</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Overrides the baseCls setting to baseCls = 'x-plain' which renders the panel unstyled except for required attributes for
 Ext layouts to function (e.g. overflow:hidden).]]></description><name>unstyled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to use Vista-style arrows in the tree (defaults to false)]]></description><name>useArrows</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local x (left) coordinate for this component if contained within a positioning container.]]></description><name>x</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered xtype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a child item of a Container is being specified not
 as a fully instantiated Component, but as a Component config object. The xtype will be looked up at render time up to
 determine what type of child Component to create. The predefined xtypes are listed here. If you subclass Components to
 create your own Components, you may register them using Ext.ComponentMgr.registerType in order to be able to take
 advantage of lazy instantiation and rendering.]]></description><name>xtype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The local y (top) coordinate for this component if contained within a positioning container.]]></description><name>y</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 A TreeLoader provides for lazy loading of an 
 <a href="output/Ext.tree.TreeNode.html"
 ext:cls="Ext.tree.TreeNode">Ext.tree.TreeNode</a>'s child nodes from a specified URL. The response must be a JavaScript
 Array definition whose elements are node definition objects. e.g.: 
 <pre><code>[{
         id: 1,
         text: <em>'A
 leaf Node'</em>,
         leaf: true
     },{
         id: 2,
         text: <em>'A folder Node'</em>,
         children: [{
 
 id: 3,
             text: <em>'A child Node'</em>,
             leaf: true
         }]
    }]</code></pre> 
 <br />
 <br /> A
 server request is sent, and child nodes are loaded only when a node is expanded. The loading node's id is passed to the
 server under the parameter name &quot;node&quot; to enable the server to produce the correct child nodes. 
 <br />
 <br />
 To pass extra parameters, an event handler may be attached to the &quot;beforeload&quot; event, and the parameters
 specified in the TreeLoader's baseParams property: 
 <pre><code>myTreeLoader.on(<em>&quot;beforeload&quot;</em>,
 <b>function</b>(treeLoader, node) {
         this.baseParams.category = node.attributes.category;
     },
 this);</code></pre> This would pass an HTTP parameter called &quot;category&quot; to the server containing the value of
 the Node's &quot;category&quot; attribute.]]></description><name>tree.treeLoader</name><tag-class>org.brushingbits.jnap.ui.extjs3.tree.TreeLoader</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[An object containing attributes to be added to all nodes created by this loader. If the attributes sent by the server
 have an attribute in this object, they take priority.]]></description><name>baseAttrs</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object containing properties which specify HTTP parameters to be passed to each request for child nodes.]]></description><name>baseParams</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Default to true. Remove previously existing child nodes before loading.]]></description><name>clearOnLoad</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The URL from which to request a Json string which specifies an array of node definition objects representing the child
 nodes to be loaded.]]></description><name>dataUrl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Function to call when executing a request.]]></description><name>directFn</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The name of the parameter sent to the server which contains the identifier of the node. Defaults to 'node'.]]></description><name>nodeParameter</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to undefined. Only used when using directFn. Specifies the params in the order in which they must be passed to
 the server-side Direct method as either (1) an Array of String values, or (2) a String of params delimited by either
 whitespace, comma, or pipe. For example, any of the following would be acceptable: nodeParameter: 'node',
 paramOrder:
 ['param1','param2','param3']
 paramOrder: 'node param1 param2 param3'
 paramOrder: 'param1,node,param2,param3'
 paramOrder:
 'param1|param2|param|node']]></description><name>paramOrder</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Only used when using directFn. Send parameters as a collection of named arguments (defaults to false). Providing a
 paramOrder nullifies this configuration.]]></description><name>paramsAsHash</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If set to true, the loader recursively loads "children" attributes when doing the first load on nodes.]]></description><name>preloadChildren</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The HTTP request method for loading data (defaults to the value of Ext.Ajax.method).]]></description><name>requestMethod</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object containing properties which specify custom Ext.tree.TreeNodeUI implementations. If the optional uiProvider
 attribute of a returned child node is a string rather than a reference to a TreeNodeUI implementation, then that string
 value is used as a property name in the uiProviders object.]]></description><name>uiProviders</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Equivalent to dataUrl.]]></description><name>url</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original ExtJS 3 API docs:
 <a href="http://docs.sencha.com/extjs3/">http://docs.sencha.com/extjs3/</a>

 <p>A specialized panel intended for use as an application window. Windows are floated, <a
 href="output/Ext.Window.html#Ext.Window-resizable" ext:member="resizable" ext:cls="Ext.Window">resizable</a>, and <a
 href="output/Ext.Window.html#Ext.Window-draggable" ext:member="draggable" ext:cls="Ext.Window">draggable</a> by default.
 Windows can be <a href="output/Ext.Window.html#Ext.Window-maximizable" ext:member="maximizable"
 ext:cls="Ext.Window">maximized</a> to fill the viewport, restored to their prior size, and can be <a
 href="output/Ext.Window.html#Ext.Window-minimize" ext:member="minimize" ext:cls="Ext.Window">minimize</a>d.</p>
 
 <p>Windows can also be linked to a <a href="output/Ext.WindowGroup.html" ext:cls="Ext.WindowGroup">Ext.WindowGroup</a>
 or managed by the <a href="output/Ext.WindowMgr.html" ext:cls="Ext.WindowMgr">Ext.WindowMgr</a> to provide grouping,
 activation, to front, to back and other application-specific behavior.</p> 
 <p>By default, Windows will be rendered to
 document.body. To <a href="output/Ext.Window.html#Ext.Window-constrain" ext:member="constrain"
 ext:cls="Ext.Window">constrain</a> a Window to another element specify <a
 href="output/Ext.Component.html#Ext.Component-renderTo" ext:member="renderTo" ext:cls="Ext.Component">renderTo</a>.</p>
 
 <p><b>Note:</b> By default, the <code><a href="output/Ext.Window.html#Ext.Window-closable" ext:member="closable"
 ext:cls="Ext.Window">close</a></code> header tool <i>destroys</i> the Window resulting in destruction of any child
 Components. This makes the Window object, and all its descendants <b>unusable</b>. To enable re-use of a Window, use
 <b><code><a href="output/Ext.Window.html#Ext.Window-closeAction" ext:member="closeAction"
 ext:cls="Ext.Window">closeAction: <em>'hide'</em></a></code></b>.</p>]]></description><name>window</name><tag-class>org.brushingbits.jnap.ui.extjs3.Window</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[A string component id or the numeric index of the component that should be initially activated within the container's
 layout on render. For example, activeItem: 'item-1' or activeItem: 0 (index 0 = the first item in the container's
 collection). activeItem only applies to layout styles that can display items one at a time (like
 Ext.layout.AccordionLayout, Ext.layout.CardLayout and Ext.layout.FitLayout). Related to
 Ext.layout.ContainerLayout.activeItem.]]></description><name>activeItem</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Whether the component can move the Dom node when rendering (defaults to true).]]></description><name>allowDomMove</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use an
 AnchorLayout (or subclass thereof). based layout manager, for example: Ext.form.FormPanel specifying layout: 'anchor' //
 or 'form', or 'absolute' See Ext.layout.AnchorLayout.anchor also.]]></description><name>anchor</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to animate the transition when the panel is collapsed, false to skip the animation (defaults to true if the Ext.Fx
 class is available, otherwise false).]]></description><name>animCollapse</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Id or element from which the window should animate while opening (defaults to null with no animation).]]></description><name>animateTarget</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The id of the node, a DOM node or an existing Element corresponding to a DIV that is already present in the document
 that specifies some panel-specific structural markup. When applyTo is used, constituent parts of the panel can be
 specified by CSS class name within the main element, and the panel will automatically create those components from that
 markup. Any required components not specified in the markup will be autogenerated if necessary. The following class
 names are supported (baseCls will be replaced by baseCls): baseCls + '-header' baseCls + '-header-text' baseCls +
 '-bwrap' baseCls + '-tbar' baseCls + '-body' baseCls + '-bbar' baseCls + '-footer' Using this config, a call to render()
 is not required. If applyTo is specified, any value passed for renderTo will be ignored and the target element's parent
 node will automatically be used as the panel's container.]]></description><name>applyTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If true the container will automatically destroy any contained component that is removed from it, else destruction must
 be handled manually (defaults to true).]]></description><name>autoDestroy</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A tag name or DomHelper spec used to create the Element which will encapsulate this Component. You do not normally need
 to specify this. For the base classes Ext.Component, Ext.BoxComponent, and Ext.Container, this defaults to 'div'. The
 more complex Ext classes use a more complex DOM structure created by their own onRender methods. This is intended to
 allow the developer to create application-specific utility Components encapsulated by different DOM elements. Example
 usage: <pre><code>{
     xtype: 'box',
     autoEl: {
         tag: 'img',
         src: 'http://www.example.com/example.jpg'
     }
 },
 {
     xtype: 'box',
     autoEl: {
         tag: 'blockquote',
         html: 'autoEl is cool!'
     }
 }, {
     xtype: 'container',
     autoEl: 'ul',
     cls: 'ux-unordered-list',
     items: {
         xtype: 'box',
         autoEl: 'li',
   
      html: 'First list item'
     }
 }</pre></code>]]></description><name>autoEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to use height:'auto', false to use fixed height (defaults to false). Note: Setting autoHeight: true means that the
 browser will manage the panel's height based on its contents, and that Ext will not manage it at all. If the panel is
 within a layout that manages dimensions (fit, border, etc.) then setting autoHeight: true can cause issues with
 scrolling and will not generally work as expected since the panel will take on the height of its contents rather than
 the height required by the Ext layout.]]></description><name>autoHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A valid url spec according to the Updater Ext.Updater.update method. If autoLoad is not null, the panel will attempt to
 load its contents immediately upon render. The URL will become the default URL for this panel's body element, so it may
 be refreshed at any time.]]></description><name>autoLoad</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to use overflow:'auto' on the components layout element and show scroll bars automatically when necessary, false to
 clip any overflowing content (defaults to false).]]></description><name>autoScroll</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True if the component should check for hidden classes (e.g. 'x-hidden' or 'x-hide-display') and remove them on render
 (defaults to false).]]></description><name>autoShow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to use width:'auto', false to use fixed width (or allow it to be managed by its parent Container's layout manager.
 Defaults to false. Note: Although many components inherit this config option, not all will function as expected with a
 width of 'auto'. Setting autoWidth:true means that the browser will manage width based on the element's contents, and
 that Ext will not manage it at all. If the browser is managing the width, be aware that resizes performed by the browser
 in response to changes within the structure of the Component cannot be detected. Therefore changes to the width might
 result in elements needing to be synchronized with the new width. For example, where the target element is: <div
 id='grid-container' style='margin-left:25%;width:50%'></div> A Panel rendered into that target element must listen for
 browser window resize in order to relay its child items when the browser changes its width: var myPanel = new
 Ext.Panel({
     renderTo: 'grid-container',
     monitorResize: true, // relay on browser resize
     title: 'Panel',
    
 height: 400,
     autoWidth: true,
     layout: 'hbox',
     layoutConfig: {
         align: 'stretch'
     },
     defaults: {
         flex: 1
     },
     items: [{
         title: 'Box 1',
     }, {
         title: 'Box 2'
     }, {
         title:
 'Box 3'
     }],
 });]]></description><name>autoWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The base CSS class to apply to this panel's element (defaults to 'x-window').]]></description><name>baseCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to display an interior border on the body element of the panel, false to hide it (defaults to true). This only
 applies when border == true. If border == true and bodyBorder == false, the border will display as a 1px wide inset
 border, giving the entire body element an inset appearance.]]></description><name>bodyBorder</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A DomHelper element specification object may be specified for any Panel Element. By default, the Default element in the
 table below will be used for the html markup to create a child element with the commensurate Default class name (baseCls
 will be replaced by baseCls): 
 Panel      Default  Default             Custom      Additional       Additional
 Element  
 element  class               element     class            style
 ========   ==========================   =========  
 ==============   ===========
 header     div      baseCls+'-header'   headerCfg   headerCssClass   headerStyle
 bwrap     
 div      baseCls+'-bwrap'     bwrapCfg    bwrapCssClass    bwrapStyle
 + tbar     div      baseCls+'-tbar'       tbarCfg 
 tbarCssClass     tbarStyle
 + body     div      baseCls+'-body'       bodyCfg     bodyCssClass     bodyStyle
 + bbar    
 div      baseCls+'-bbar'       bbarCfg     bbarCssClass     bbarStyle
 + footer   div      baseCls+'-footer'   footerCfg 
 footerCssClass   footerStyle
  Configuring a Custom element may be used, for example, to force the body Element to use a
 different form of markup than is created by default. An example of this might be to create a child Panel containing a
 custom content, such as a header, or forcing centering of all Panel content by having the body be a <center> element:
 new Ext.Panel({
     title: 'Message Title',
     renderTo: Ext.getBody(),
     width: 200, height: 130,
     bodyCfg: {
    
 tag: 'center',
         cls: 'x-panel-body',  // Default class not applied if Custom element specified
         html:
 'Message'
     },
     footerCfg: {
         tag: 'h2',
         cls: 'x-panel-footer',        // same as the Default class
 
 html: 'footer html'
     },
     footerCssClass: 'custom-footer', // additional css class, see addClass
     footerStyle:  
 'background-color:red' // see bodyStyle
 }); The example above also explicitly creates a footer with custom markup and
 styling applied.]]></description><name>bodyCfg</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Additional css class selector to be applied to the body element in the format expected by Ext.Element.addClass (defaults
 to null). See bodyCfg.]]></description><name>bodyCssClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Custom CSS styles to be applied to the body element in the format expected by Ext.Element.applyStyles (defaults to
 null). See bodyCfg.]]></description><name>bodyStyle</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to display the borders of the panel's body element, false to hide them (defaults to true). By default, the border
 is a 2px wide inset border, but this can be further altered by setting bodyBorder to false.]]></description><name>border</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMaxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its height to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this BoxComponent will set its width to. Warning: This will override any size
 management applied by layout managers.]]></description><name>boxMinWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to ['add', 'remove'].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[When set to true (50 milliseconds) or a number of milliseconds, the layout assigned for this container will buffer the
 frequency it calculates and does a re-layout of components. This is useful for heavy containers or containers with a
 large quantity of sub-components for which frequent layout calls would be expensive. Defaults to 50.]]></description><name>bufferResize</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The alignment of any buttons added to this panel. Valid values are 'right', 'left' and 'center' (defaults to 'right').]]></description><name>buttonAlign</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A DomHelper element specification object specifying the element structure of this Panel's bwrap Element. See bodyCfg
 also.]]></description><name>bwrapCfg</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class used to to apply to the special clearing div rendered directly after each form field wrapper to provide
 field clearing (defaults to 'x-form-clear-left'). Note: this config is only used when this Component is rendered by a
 Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or specifying
 layout:'form') and either a fieldLabel is specified or isFormField=true is specified. See Ext.layout.FormLayout.fieldTpl
 also.]]></description><name>clearCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to display the 'close' tool button and allow the user to close the window, false to hide the button and disallow
 closing the window (defaults to true). By default, when close is requested by either clicking the close button in the
 header or pressing ESC when the Window has focus, the close method will be called. This will destroy the Window and its
 content meaning that it may not be reused. To make closing a Window hide the Window so that it may be reused, set
 closeAction to 'hide'.]]></description><name>closable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The action to take when the close header tool is clicked: 'close' : Default remove the window from the DOM and destroy
 it and all descendant Components. The window will not be available to be redisplayed via the show method. 'hide' : hide
 the window by setting visibility to hidden and applying negative offsets. The window will be available to be redisplayed
 via the show method. Note: This setting does not affect the close method which will always destroy the window. To
 programatically hide a window, call hide.]]></description><name>closeAction</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element (defaults to ''). This can be useful for
 adding customized styles to the component or any of its children using standard CSS rules.]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to make sure the collapse/expand toggle button always renders first (to the left of) any other tools in the panel's
 title bar, false to render it last (defaults to true).]]></description><name>collapseFirst</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to render the window collapsed, false to render it expanded (defaults to false). Note that if expandOnShow is true
 (the default) it will override the collapsed config and the window will always be expanded when shown.]]></description><name>collapsed</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS class to add to the panel's element after it has been collapsed (defaults to 'x-panel-collapsed').]]></description><name>collapsedCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to make the panel collapsible and have the expand/collapse toggle button automatically rendered into the header
 tool button area, false to keep the panel statically sized with no button (defaults to false).]]></description><name>collapsible</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to constrain the window within its containing element, false to allow it to fall outside of its containing element.
 By default the window will be rendered to document.body. To render and constrain the window within another element
 specify renderTo. (defaults to false). Optionally the header only can be constrained using constrainHeader.]]></description><name>constrain</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to constrain the window header within its containing element (allowing the window body to fall outside of its
 containing element) or false to allow the header to fall outside its containing element (defaults to false). Optionally
 the entire window can be constrained using constrain.]]></description><name>constrainHeader</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's container. This can be useful for adding customized
 styles to the container or any of its children using standard CSS rules. See Ext.layout.ContainerLayout.extraCls also.
 Note: ctCls defaults to '' except for the following class which assigns a value by default: Box Layout :
 'x-box-layout-ct' To configure the above Class with an extra CSS class append to the default. For example, for BoxLayout
 (Hbox and Vbox): ctCls: 'x-box-layout-ct custom-class']]></description><name>ctCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies a Component to receive focus when this Window is focussed. This may be one of: The index of a footer Button.
 The id of a Component. A Component.]]></description><name>defaultButton</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default xtype of child Components to create in this Container when a child item is specified as a raw configuration
 object, rather than as an instantiated Component. Defaults to 'panel', except Ext.menu.Menu which defaults to
 'menuitem', and Ext.Toolbar and Ext.ButtonGroup which default to 'button'.]]></description><name>defaultType</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[This option is a means of applying default settings to all added items whether added through the items config or via the
 add or insert methods. If an added item is a config object, and not an instantiated Component, then the default
 properties are unconditionally applied. If the added item is an instantiated Component, then the default properties are
 applied conditionally so as not to override existing properties in the item. If the defaults option is specified as a
 function, then the function will be called using this Container as the scope (this reference) and passing the added item
 as the first parameter. Any resulting object from that call is then applied to the item as default properties. For
 example, to automatically apply padding to the body of each of a set of contained Ext.Panel items, you could pass:
 defaults: {bodyStyle:'padding:15px'}. Usage: defaults: {               // defaults are applied to items, not the
 container
     autoScroll:true
 },
 items: [
     {
         xtype: 'panel',   // defaults do not have precedence over
       
 id: 'panel1',     // options in config objects, so the defaults
         autoScroll: false // will not be applied here,
 panel1 will be autoScroll:false
     },
     new Ext.Panel({       // defaults do have precedence over options
         id:
 'panel2',     // options in components, so the defaults
         autoScroll: false // will be applied here, panel2 will
 be autoScroll:true.
     })
 ]]]></description><name>defaults</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this panel disabled (default is false). An important note when using the disabled config on panels is that IE
 will often fail to initialize the disabled mask element correectly if the panel's layout has not yet completed by the
 time the Panel is disabled during the render process. If you experience this issue, you may need to instead use the
 afterlayout event to initialize the disabled state: new Ext.Panel({
     ...
     listeners: {
         'afterlayout': {
   
 fn: function(p){
                 p.disable();
             },
             single: true // important, as many layouts can
 occur
         }
     }
 });]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class added to the component when it is disabled (defaults to 'x-item-disabled').]]></description><name>disabledClass</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to allow the window to be dragged by the header bar, false to disable dragging (defaults to true). Note that by
 default the window will be centered in the viewport, so if dragging is disabled the window may need to be positioned
 programmatically after render (e.g., myWindow.setPosition(100, 100);).]]></description><name>draggable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A comma-delimited list of panel elements to initialize when the panel is rendered. Normally, this list will be generated
 automatically based on the items added to the panel at config time, but sometimes it might be useful to make sure a
 structural element is rendered even if not specified at config time (for example, you may want to add a button or
 toolbar dynamically after the panel has been rendered). Adding those elements to this list will allocate the required
 placeholders in the panel when it is rendered. Valid values are header tbar (top bar) body bbar (bottom bar) footer
 Defaults to 'body'.]]></description><name>elements</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to always expand the window when it is displayed, false to keep it in its current state (which may be collapsed)
 when displayed (defaults to true).]]></description><name>expandOnShow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A Toolbar object, a Toolbar config, or an array of Buttons/Button configs, describing a Toolbar to be rendered into this
 Panel's footer element. After render, the fbar property will be an Toolbar instance. If buttons are specified, they will
 supersede the fbar configuration property. The Panel's buttonAlign configuration affects the layout of these items, for
 example: var w = new Ext.Window({
     height: 250,
     width: 500,
     bbar: new Ext.Toolbar({
         items: [{
        
 text: 'bbar Left'
         },'->',{
             text: 'bbar Right'
         }]
     }),
     buttonAlign: 'left', //
 anything but 'center' or 'right' and you can use '-', and '->'
                                   // to control the
 alignment of fbar items
     fbar: [{
         text: 'fbar Left'
     },'->',{
         text: 'fbar Right'
     }]
 }).show();
 Note: Although a Toolbar may contain Field components, these will not be updated by a load of an ancestor FormPanel. A
 Panel's toolbars are not part of the standard Container->Component hierarchy, and so are not scanned to collect form
 items. However, the values will be submitted because form submission parameters are collected from the DOM tree.]]></description><name>fbar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The label text to display next to this Component (defaults to ''). Note: this config is only used when this Component is
 rendered by a Container which has been configured to use the FormLayout layout manager (e.g. Ext.form.FormPanel or
 specifying layout:'form'). Also see hideLabel and Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
    
 height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name'
    
 }]
 });]]></description><name>fieldLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use a
 BoxLayout. Each child Component with a flex property will be flexed either vertically (by a VBoxLayout) or horizontally
 (by an HBoxLayout) according to the item's relative flex value compared to the sum of all Components with flex value
 specified. Any child items that have either a flex = 0 or flex = undefined will not be 'flexed' (the initial size will
 not be changed).]]></description><name>flex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[This property is used to configure the underlying Ext.Layer. Acceptable values for this configuration property are:
 false : Default. Display the panel inline where it is rendered. true : Float the panel (absolute position it with
 automatic shimming and shadow). Setting floating to true will create an Ext.Layer for this panel and display the panel
 at negative offsets so that it is hidden. Since the panel will be absolute positioned, the position must be set
 explicitly after render (e.g., myPanel.setPosition(100,100);). Note: when floating a panel you should always assign a
 fixed width, otherwise it will be auto width and will expand to fill to the right edge of the viewport. object : The
 specified object will be used as the configuration object for the Ext.Layer that will be created.]]></description><name>floating</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to create the footer element explicitly, false to skip creating it. The footer will be created automatically if
 buttons or a fbar have been configured. See bodyCfg for an example.]]></description><name>footer</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A DomHelper element specification object specifying the element structure of this Panel's footer Element. See bodyCfg
 also.]]></description><name>footerCfg</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If true the container will force a layout initially even if hidden or collapsed. This option is useful for forcing forms
 to render in collapsed or hidden containers. (defaults to false).]]></description><name>forceLayout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[false by default to render with plain 1px square borders. true to render with 9 elements, complete with custom rounded
 corners (also see Ext.Element.boxWrap). The template generated for each condition is depicted below: // frame =
 false
 <div id="developer-specified-id-goes-here" class="x-panel">
 
     <div class="x-panel-header"><span
 class="x-panel-header-text">Title: (frame:false)</span></div>
 
     <div class="x-panel-bwrap">
         <div
 class="x-panel-body"><p>html value goes here</p></div>
     </div>
 </div>
 
 // frame = true (create 9 elements)
 <div
 id="developer-specified-id-goes-here" class="x-panel">
     <div class="x-panel-tl"><div class="x-panel-tr"><div
 class="x-panel-tc">
         <div class="x-panel-header"><span class="x-panel-header-text">Title:
 (frame:true)</span></div>
     </div></div></div>
 
     <div class="x-panel-bwrap">
         <div class="x-panel-ml"><div
 class="x-panel-mr"><div class="x-panel-mc">
             <div class="x-panel-body"><p>html value goes here</p></div>
     
 </div></div></div>
 
         <div class="x-panel-bl"><div class="x-panel-br"><div class="x-panel-bc"/>
        
 </div></div></div>
 </div>]]></description><name>frame</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to create the Panel's header element explicitly, false to skip creating it. If a title is set the header will be
 created automatically, otherwise it will not. If a title is set but header is explicitly set to false, the header will
 not be rendered.]]></description><name>header</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to display the panel title in the header, false to hide it (defaults to true).]]></description><name>headerAsText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A DomHelper element specification object specifying the element structure of this Panel's header Element. See bodyCfg
 also.]]></description><name>headerCfg</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Render this component hidden (default is true). If true, the hide method will be called internally.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The number of seconds that the window hide animation takes if enabled. Defaults to 0.25]]></description><name>hideAnimDuration</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide the borders of each contained component, false to defer to the component's existing border settings
 (defaults to false).]]></description><name>hideBorders</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to hide the expand/collapse toggle button when collapsible == true, false to display it (defaults to false).]]></description><name>hideCollapseTool</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to completely hide the label element (label and separator). Defaults to false. By default, even if you do not
 specify a fieldLabel the space will still be reserved so that the field will line up with other fields that do have
 labels. Setting this to true will cause the field to not reserve that space. Note: see the note for clearCls. Example
 use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
     items: [{
         xtype: 'textfield'
        
 hideLabel: true
     }]
 });]]></description><name>hideLabel</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[How this component should be hidden. Supported values are 'visibility' (css visibility), 'offsets' (negative offset
 position) and 'display' (css display). Note: the default of 'display' is generally preferred since items are
 automatically laid out when they are first shown (no sizing is done while hidden).]]></description><name>hideMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide and show the component's container when hide/show is called on the component, false to hide and show the
 component itself (defaults to false). For example, this can be used as a shortcut for a hide button on a window by
 setting hide:true on the button when adding it to its parent container.]]></description><name>hideParent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class selector that specifies a background image to be used as the header icon (defaults to ''). An example of
 specifying a custom icon class would be something like: // specify the property in the config for the class:
      ...
   
 iconCls: 'my-icon'
 
 // css class that specifies background image to be used as the icon image:
 .my-icon {
 background-image: url(../images/my-icon.gif) 0 6px no-repeat !important; }]]></description><name>iconCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id of this component (defaults to an auto-assigned id). You should assign an id if you need to be able to
 access the component later and you do not have an object reference available (e.g., using Ext.getCmp). Note that this id
 will also be used as the element id for the containing HTML element that is rendered to the page for this component.
 This allows you to write id-based CSS rules to style the specific instance of this component uniquely, and also to
 select sub-elements using this component's id as the parent. Note: to avoid complications imposed by a unique id also
 see itemId and ref. Note: to access the container of an item see ownerCt.]]></description><name>id</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to hide the window until show() is explicitly called (defaults to true).]]></description><name>initHidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this Component is rendered by a Container which has been configured to use the
 FormLayout layout manager (e.g. Ext.form.FormPanel or specifying layout:'form'). An additional CSS class to apply to the
 div wrapping the form item element of this field. If supplied, itemCls at the field level will override the default
 itemCls supplied at the container level. The value specified for itemCls will be added to the default class
 ('x-form-item'). Since it is applied to the item wrapper (see Ext.layout.FormLayout.fieldTpl), it allows you to write
 standard CSS rules that can apply to the field, the label (if specified), or any other element within the markup for the
 field. Note: see the note for fieldLabel. Example use: // Apply a style to the field's label:
 <style>
     .required
 .x-form-item-label {font-weight:bold;color:red;}
 </style>
 
 new Ext.FormPanel({
     height: 100,
     renderTo:
 Ext.getBody(),
     items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         itemCls: 'required' //this
 label will be styled
     },{
         xtype: 'textfield',
         fieldLabel: 'Favorite Color'
     }]
 });]]></description><name>itemCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An itemId can be used as an alternative way to get a reference to a component when no object reference is available.
 Instead of using an id with Ext.getCmp, use itemId with Ext.Container.getComponent which will retrieve itemId's or id's.
 Since itemId's are an index to the container's internal MixedCollection, the itemId is scoped locally to the container
 -- avoiding potential conflicts with Ext.ComponentMgr which requires a unique id. var c = new Ext.Panel({ //
     height:
 300,
     renderTo: document.body,
     layout: 'auto',
     items: [
         {
             itemId: 'p1',
            
 title: 'Panel 1',
             height: 150
         },
         {
             itemId: 'p2',
             title: 'Panel 2',
  
 height: 150
         }
     ]
 })
 p1 = c.getComponent('p1'); // not the same as Ext.getCmp()
 p2 =
 p1.ownerCt.getComponent('p2'); // reference via a sibling Also see id and ref. Note: to access the container of an item
 see ownerCt.]]></description><name>itemId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A Ext.KeyMap config object (in the format expected by Ext.KeyMap.addBinding used to assign custom key handling to this
 panel (defaults to null).]]></description><name>keys</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The separator to display after the text of each fieldLabel. This property may be configured at various levels. The order
 of precedence is: field / component level container level layout level (defaults to colon ':') To display no separator
 for this field's label specify empty string ''. Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 layoutConfig: {
         labelSeparator: '~'   // layout config has lowest priority (defaults to ':')
     },
    
 labelSeparator: '>>',     // config at container level
     items: [{
         xtype: 'textfield',
         fieldLabel:
 'Field 1',
         labelSeparator: '...' // field/component level config supersedes others
     },{
         xtype:
 'textfield',
         fieldLabel: 'Field 2' // labelSeparator will be '='
     }]
 });]]></description><name>labelSeparator</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS style specification string to apply directly to this field's label. Defaults to the container's labelStyle value
 if set (e.g., Ext.layout.FormLayout.labelStyle , or ''). Note: see the note for clearCls. Also see hideLabel and
 Ext.layout.FormLayout.fieldTpl. Example use: new Ext.FormPanel({
     height: 100,
     renderTo: Ext.getBody(),
    
 items: [{
         xtype: 'textfield',
         fieldLabel: 'Name',
         labelStyle: 'font-weight:bold;'
     }]
 });]]></description><name>labelStyle</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[*Important: In order for child items to be correctly sized and positioned, typically a layout manager must be specified
 through the layout configuration option. The sizing and positioning of child items is the responsibility of the
 Container's layout manager which creates and manages the type of layout you have in mind. For example:
 <pre><code>
 new Ext.Window({
 
 width:300, height: 300,
     layout: 'fit', // explicitly set layout manager: override the default (layout:'auto')
    
 items: [{
         title: 'Panel inside a Window'
     }]
 }).show();</pre></code>
 If the layout configuration is not explicitly
 specified for a general purpose container (e.g. Container or Panel) the default layout manager will be used which does
 nothing but render child components sequentially into the Container (no sizing or positioning will be performed in this
 situation). Some container classes implicitly specify a default layout (e.g. FormPanel specifies layout:'form'). Other
 specific purpose classes internally specify/manage their internal layout (e.g. GridPanel, TabPanel, TreePanel, Toolbar,
 Menu, etc.). layout may be specified as either as an Object or as a String: Specify as an Object Example usage: layout:
 {
     type: 'vbox',
     padding: '5',
     align: 'left'
 } type The layout type to be used for this container. If not
 specified, a default Ext.layout.ContainerLayout will be created and used. Valid layout type values are: absolute
 accordion anchor auto Default border card column fit form hbox menu table toolbar vbox Layout specific configuration
 properties Additional layout specific configuration properties may also be specified. For complete details regarding the
 valid config options for each layout type, see the layout class corresponding to the type specified. Specify as a String
 Example usage: layout: 'vbox',
 layoutConfig: {
     padding: '5',
     align: 'left'
 } layout The layout type to be used
 for this container (see list of valid layout type values above). layoutConfig Additional layout specific configuration
 properties. For complete details regarding the valid config options for each layout type, see the layout class
 corresponding to the layout specified.]]></description><name>layout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A reference to the WindowGroup that should manage this window (defaults to Ext.WindowMgr).]]></description><name>manager</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout or one of the two BoxLayout subclasses. An object containing margins to apply to this BoxComponent in the
 format: {
     top: (top margin),
     right: (right margin),
     bottom: (bottom margin),
     left: (left margin)
 } May
 also be a string containing space-separated, numeric margin values. The order of the sides associated with each value
 matches the way CSS processes margin values: If there is only one value, it applies to all sides. If there are two
 values, the top and bottom borders are set to the first value and the right and left are set to the second. If there are
 three values, the top is set to the first value, the left and right are set to the second, and the bottom is set to the
 third. If there are four values, they apply to the top, right, bottom, and left, respectively. Defaults to: {top:0,
 right:0, bottom:0, left:0}]]></description><name>margins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to mask the panel when it is disabled, false to not mask it (defaults to true). Either way, the panel will always
 tell its contained elements to disable themselves when it is disabled, but masking the panel can provide an additional
 visual cue that the panel is disabled.]]></description><name>maskDisabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to display the 'maximize' tool button and allow the user to maximize the window, false to hide the button and
 disallow maximizing the window (defaults to false). Note that when a window is maximized, the tool button will
 automatically change to a 'restore' button with the appropriate behavior already built-in that will restore the window
 to its previous size.]]></description><name>maximizable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to initially display the window in a maximized state. (Defaults to false).]]></description><name>maximized</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Minimum width in pixels of all buttons in this panel (defaults to 75)]]></description><name>minButtonWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum height in pixels allowed for this window (defaults to 100). Only applies when resizable = true.]]></description><name>minHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum width in pixels allowed for this window (defaults to 200). Only applies when resizable = true.]]></description><name>minWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to display the 'minimize' tool button and allow the user to minimize the window, false to hide the button and
 disallow minimizing the window (defaults to false). Note that this button provides no implementation -- the behavior of
 minimizing a window is implementation-specific, so the minimize event must be handled and a custom minimize behavior
 implemented for this option to be useful.]]></description><name>minimizable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to make the window modal and mask everything behind it when displayed, false to display it without restricting
 access to other UI elements (defaults to false).]]></description><name>modal</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically monitor window resize events to handle anything that is sensitive to the current size of the
 viewport. This value is typically managed by the chosen layout and should not need to be set manually.]]></description><name>monitorResize</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Allows override of the built-in processing for the escape key. Default action is to close the Window (performing
 whatever action is specified in closeAction. To prevent the Window closing when the escape key is pressed, specify this
 as Ext.emptyFn (See Ext.emptyFn).]]></description><name>onEsc</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element when the mouse moves over the Element, and
 removed when the mouse moves out. (defaults to ''). This can be useful for adding customized 'active' or 'hover' styles
 to the component or any of its children using standard CSS rules.]]></description><name>overCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A shortcut for setting a padding style on the body element. The value can either be a number to be applied to all sides,
 or a normal css string describing padding. Defaults to undefined.]]></description><name>padding</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level x coordinate for this component if contained within a positioning container.]]></description><name>pageX</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The page level y coordinate for this component if contained within a positioning container.]]></description><name>pageY</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to render the window body with a transparent background so that it will blend into the framing elements, false to
 add a lighter background color to visually highlight the body element and separate it more distinctly from the
 surrounding frame (defaults to false).]]></description><name>plain</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to false. When set to true, an extra css class 'x-panel-normal' will be added to the panel's element,
 effectively applying css styles suggested by the W3C (see http://www.w3.org/TR/CSS21/sample.html) to the Panel's body
 element (not the header, footer, etc.).]]></description><name>preventBodyReset</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered ptype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a Plugin is being specified not as a fully
 instantiated Component, but as a Component config object. The ptype will be looked up at render time up to determine
 what type of Plugin to create. If you create your own Plugins, you may register them using
 Ext.ComponentMgr.registerPlugin in order to be able to take advantage of lazy instantiation and rendering.]]></description><name>ptype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A path specification, relative to the Component's ownerCt specifying into which ancestor Container to place a named
 reference to this Component. The ancestor axis can be traversed by using '/' characters in the path. For example, to put
 a reference to a Toolbar Button into the Panel which owns the Toolbar: var myGrid = new Ext.grid.EditorGridPanel({
    
 title: 'My EditorGridPanel',
     store: myStore,
     colModel: myColModel,
     tbar: [{
         text: 'Save',
        
 handler: saveChanges,
         disabled: true,
         ref: '../saveButton'
     }],
     listeners: {
         afteredit:
 function() {
 //          The button reference is in the GridPanel
             myGrid.saveButton.enable();
         }
    
 }
 }); In the code above, if the ref had been 'saveButton' the reference would have been placed into the Toolbar. Each
 '/' in the ref moves up one level from the Component's ownerCt. Also see the added and removed events.]]></description><name>ref</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the
 BorderLayout layout manager (e.g. specifying layout:'border'). See Ext.layout.BorderLayout also.]]></description><name>region</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to allow user resizing at each edge and corner of the window, false to disable resizing (defaults to true).]]></description><name>resizable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The event to listen to for resizing in layouts. Defaults to 'bodyresize'.]]></description><name>resizeEvent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A valid Ext.Resizable handles config string (defaults to 'all'). Only applies when resizable = true.]]></description><name>resizeHandles</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true (or a valid Ext.Shadow Ext.Shadow.mode value) to display a shadow behind the panel, false to display no shadow
 (defaults to 'sides'). Note that this option only applies when floating = true.]]></description><name>shadow</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The number of pixels to offset the shadow if displayed (defaults to 4). Note that this option only applies when floating
 = true.]]></description><name>shadowOffset</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[false to disable the iframe shim in browsers which need one (defaults to true). Note that this option only applies when
 floating = true.]]></description><name>shim</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The number of seconds that the window show animation takes if enabled. Defaults to 0.25]]></description><name>showAnimDuration</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should trigger this component to save its state (defaults to none). stateEvents may
 be any type of event supported by this component, including browser or custom events (e.g., ['click',
 'customerchange']). See stateful for an explanation of saving and restoring Component state.]]></description><name>stateEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique id for this component to use for state management purposes (defaults to the component id if one was set,
 otherwise null if the component is using a generated id). See stateful for an explanation of saving and restoring
 Component state.]]></description><name>stateId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A flag which causes the Component to attempt to restore the state of internal properties from a saved state on startup.
 The component must have either a stateId or id assigned for state to be managed. Auto-generated ids are not guaranteed
 to be stable across page loads and cannot be relied upon to save and restore the same state for a component. For state
 saving to work, the state manager's provider must have been set to an implementation of Ext.state.Provider which
 overrides the set and get methods to save and recall name/value pairs. A built-in implementation,
 Ext.state.CookieProvider is available. To set the state provider for the current page: Ext.state.Manager.setProvider(new
 Ext.state.CookieProvider({
     expires: new Date(new Date().getTime()+(1000*60*60*24*7)), //7 days from now
 })); A
 stateful Component attempts to save state when one of the events listed in the stateEvents configuration fires. To save
 state, a stateful Component first serializes its state by calling getState. By default, this function does nothing. The
 developer must provide an implementation which returns an object hash which represents the Component's restorable state.
 The value yielded by getState is passed to Ext.state.Manager.set which uses the configured Ext.state.Provider to save
 the object keyed by the Component's stateId, or, if that is not specified, its id. During construction, a stateful
 Component attempts to restore its state by calling Ext.state.Manager.get passing the stateId, or, if that is not
 specified, the id. The resulting object is passed to applyState. The default implementation of applyState simply copies
 properties into the object, but a developer may override this to support more behaviour. You can perform extra
 processing on state save and restore by attaching handlers to the beforestaterestore, staterestore, beforestatesave and
 statesave events.]]></description><name>stateful</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
     title: 'Some Title',
     renderTo: Ext.getBody(),
     width: 400, height:
 300,
     layout: 'form',
     items: [{
         xtype: 'textarea',
         style: {
             width: '95%',
            
 marginBottom: '10px'
         }
     },
         new Ext.Button({
             text: 'Send',
             minWidth: '100',
   
          style: {
                 marginBottom: '10px'
             }
         })
     ]
 });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Note: this config is only used when this BoxComponent is a child item of a TabPanel. A string to be used as innerHTML
 (html tags are accepted) to show in a tooltip when mousing over the associated tab selector element.
 Ext.QuickTips.init() must be called in order for the tips to render.]]></description><name>tabTip</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The title text to be used as innerHTML (html tags are accepted) to display in the panel header (defaults to ''). When a
 title is specified the header element will automatically be created and displayed unless header is explicitly set to
 false. If you do not want to specify a title at config time, but you may want one later, you must either specify a
 non-empty title (a blank space ' ' will do) or header:true so that the container element will get created.]]></description><name>title</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to allow expanding and collapsing the panel (when collapsible = true) by clicking anywhere in the header bar,
 false) to allow it only by clicking to tool button (defaults to false)). If this panel is a child item of a border
 layout also see the BorderLayout.Region floatable config option.]]></description><name>titleCollapse</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A Template used to create tools in the header Element. Defaults to: new Ext.Template('<div class="x-tool
 x-tool-{id}">&#160;</div>') This may may be overridden to provide a custom DOM structure for tools based upon a more
 complex XTemplate. The template's data is a single tool configuration object (Not the entire Array) as specified in
 tools. In the following example an <a> tag is used to provide a visual indication when hovering over the tool: var win =
 new Ext.Window({
     tools: [{
         id: 'download',
         href: '/MyPdfDoc.pdf'
     }],
     toolTemplate: new
 Ext.XTemplate(
         '<tpl if="id==\'download\'">',
             '<a class="x-tool x-tool-pdf" href="{href}"></a>',
    
 '</tpl>',
         '<tpl if="id!=\'download\'">',
             '<div class="x-tool x-tool-{id}">&#160;</div>',
        
 '</tpl>'
     ),
     width:500,
     height:300,
     closeAction:'hide'
 }); Note that the CSS class 'x-tool-pdf' should
 have an associated style rule which provides an appropriate background image, something like: a.x-tool-pdf
 {background-image: url(../shared/extjs/images/pdf.gif)!important;}]]></description><name>toolTemplate</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of tool button configs to be added to the header tool area. When rendered, each tool is stored as an Element
 referenced by a public property called tools.<tool-type> Each tool config may contain the following properties: id :
 String Required. The type of tool to create. By default, this assigns a CSS class of the form x-tool-<tool-type> to the
 resulting tool Element. Ext provides CSS rules, and an icon sprite containing images for the tool types listed below.
 The developer may implement custom tools by supplying alternate CSS rules and background images: toggle (Created by
 default when collapsible is true) close minimize maximize restore gear pin unpin right left up down refresh minus plus
 help search save print handler : Function Required. The function to call when clicked. Arguments passed are: event :
 Ext.EventObject The click event. toolEl : Ext.Element The tool Element. panel : Ext.Panel The host Panel tc : Object The
 tool configuration object stopEvent : Boolean Defaults to true. Specify as false to allow click event to propagate.
 scope : Object The scope in which to call the handler. qtip : String/Object A tip string, or a config argument to
 Ext.QuickTip.register hidden : Boolean True to initially render hidden. on : Object A listener config object specifiying
 event listeners in the format of an argument to addListener Note that, apart from the toggle tool which is provided when
 a panel is collapsible, these tools only provide the visual button. Any required functionality must be provided by
 adding handlers that implement the necessary behavior. Example usage: tools:[{
     id:'refresh',
     qtip: 'Refresh form
 Data',
     // hidden:true,
     handler: function(event, toolEl, panel){
         // refresh logic
     }
 },
 {
    
 id:'help',
     qtip: 'Get Help',
     handler: function(event, toolEl, panel){
         // whatever
     }
 }] For the
 custom id of 'help' define two relevant css classes with a link to a 15x15 image: .x-tool-help {background-image:
 url(images/help.png);}
 .x-tool-help-over {background-image: url(images/help_over.png);}
 // if using an image
 sprite:
 .x-tool-help {background-image: url(images/help.png) no-repeat 0 0;}
 .x-tool-help-over
 {background-position:-15px 0;}]]></description><name>tools</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Overrides the baseCls setting to baseCls = 'x-plain' which renders the panel unstyled except for required attributes for
 Ext layouts to function (e.g. overflow:hidden).]]></description><name>unstyled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of this component in pixels (defaults to auto). Note to express this dimension as a percentage or offset see
 Ext.Component.anchor.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The X position of the left edge of the window on initial showing. Defaults to centering the Window within the width of
 the Window's container Ext.Element Element) (The Element that the Window is rendered to).]]></description><name>x</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The registered xtype to create. This config option is not used when passing a config object into a constructor. This
 config option is used only when lazy instantiation is being used, and a child item of a Container is being specified not
 as a fully instantiated Component, but as a Component config object. The xtype will be looked up at render time up to
 determine what type of child Component to create. The predefined xtypes are listed here. If you subclass Components to
 create your own Components, you may register them using Ext.ComponentMgr.registerType in order to be able to take
 advantage of lazy instantiation and rendering.]]></description><name>xtype</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Y position of the top edge of the window on initial showing. Defaults to centering the Window within the height of
 the Window's container Ext.Element Element) (The Element that the Window is rendered to).]]></description><name>y</name><rtexprvalue>true</rtexprvalue></attribute></tag></taglib>