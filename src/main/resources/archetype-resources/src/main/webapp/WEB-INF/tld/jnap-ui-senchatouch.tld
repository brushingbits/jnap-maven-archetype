<?xml version="1.0" encoding="UTF-8"?><taglib xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-jsptaglibrary_2_1.xsd" version="2.1"><display-name>jnap-ui SenchaTouch Tag Library</display-name><tlib-version>2.1</tlib-version><short-name>jnap-ui-senchatouch</short-name><uri>http://www.brushingbits.org/jnap/ui/tags-senchatouch</uri><tag><description><![CDATA[The documentation of this component was copied from the original SenchaTouch API docs:
 <a href="http://docs.sencha.com/touch/">http://docs.sencha.com/touch/</a>

 <p>Represents a Sencha Application. Most Applications consist of at least the application's name and a launch
 function:</p> 
 <pre><code><b>new</b> Ext.Application({
     name: <em>'MyApp'</em>,
 
     launch: <b>function</b>() {
     
 this.viewport = <b>new</b> Ext.Panel({
             fullscreen: true,
 
             id    : <em>'mainPanel'</em>,
         
 layout: <em>'card'</em>,
             items : [
                 {
                     html: <em>'Welcome to My
 App!'</em>
                 }
             ]
         });
     }
 });</code></pre> 
 <p>Instantiating a new application
 automatically creates a global variable using the configured <a href="output/Ext.Application.html#Ext.Application-name"
 ext:member="name" ext:cls="Ext.Application">name</a> property and sets up namespaces for views, stores, models and
 controllers within the app:</p> 
 <pre><code><i>//this code is run internally automatically when creating the app</i>
 <a
 href="output/Ext.ns.html" ext:cls="Ext.ns">Ext.ns</a>(<em>'MyApp'</em>, <em>'MyApp.views'</em>, <em>'MyApp.stores'</em>,
 <em>'MyApp.models'</em>, <em>'MyApp.controllers'</em>);</code></pre> 
 <p>The launch function usually creates the
 Application's Viewport and runs any actions the Application needs to perform when it boots up. The launch function is
 only expected to be run once.</p> 
 <p><u>Routes and history support</u></p> 
 <p>Sencha Applications provide in-app deep
 linking and history support, allowing your users both to use the back button inside your application and to refresh the
 page and come back to the same screen even after navigating. In-app history support relies on the Routing engine, which
 maps urls to controller/action pairs. Here's an example route definition:</p> 
 <pre><code><i>//Note the # <b>in</b> the
 url examples below</i>
 Ext.Router.draw(<b>function</b>(map) {
     <i>//maps the url http://mydomain.com/#dashboard to
 the home controller<em>'s index action</em></i><em>
     map.connect('</em>dashboard<em>', {controller: '</em>home<em>',
 action: '</em>index<em>'});
 
     <i>//fallback route - would match routes like http://mydomain.com/#users/list to the
 '</i></em><i>users<em>' controller'</em>s</i>
     <i>//<em>'list'</em> action</i>
    
 map.connect(<em>':controller/:action'</em>);
 });</code></pre> 
 <p>If you generated your Sencha app using the Sencha
 Command application generator script, you'll see this file is already present in your application's app/routes.js file.
 History-driven apps can specify the <a href="output/Ext.Application.html#Ext.Application-defaultUrl"
 ext:member="defaultUrl" ext:cls="Ext.Application">defaultUrl</a> configuration option, which will dispatch to that url
 if no url is currently set:</p> 
 <pre><code><b>new</b> Ext.Application({
     name: <em>'MyApp'</em>,
     defaultUrl:
 <em>'dashboard'</em>
 });</code></pre> 
 <p><u>Application profiles</u></p> 
 <p>Applications support multiple app profiles
 and reconfigure itself accordingly. Here we set up an Application with 3 profiles - one if the device is a phone, one
 for tablets in landscape orientation and one for tablets in portrait orientation:</p> 
 <pre><code><b>new</b>
 Ext.Application({
     name: <em>'MyApp'</em>,
 
     profiles: {
         phone: <b>function</b>() {
            
 <b>return</b> Ext.is.Phone;
         },
         tabletPortrait: <b>function</b>() {
             <b>return</b>
 Ext.is.Tablet &amp;&amp; Ext.orientation == <em>'portrait'</em>;
         },
         tabletLandscape: <b>function</b>()
 {
             <b>return</b> Ext.is.Tablet &amp;&amp; Ext.orientation == <em>'landscape'</em>;
         }
    
 }
 });</code></pre> 
 <p>When the Application checks its list of profiles, the first function that returns true becomes
 the current profile. The Application will normally automatically detect when a profile change has occurred (e.g. if a
 tablet is rotated from portrait to landscape mode) and fire the <a
 href="output/Ext.Application.html#Ext.Application-profilechange" ext:member="profilechange"
 ext:cls="Ext.Application">profilechange</a> event. It will also by default inform all <a
 href="output/Ext.Component.html" ext:cls="Ext.Component">Components</a> on the page that the current profile has changed
 by calling their <a href="output/Ext.Component.html#Ext.Component-setProfile" ext:member="setProfile"
 ext:cls="Ext.Component">setProfile</a> functions. The setProfile function is left as an empty function for you to
 implement if your component needs to react to different device/application profiles.</p> 
 <p>The current profile can be
 found using <a href="output/Ext.Application.html#Ext.Application-getProfile" ext:member="getProfile"
 ext:cls="Ext.Application">getProfile</a>. If the Application does not correctly detect device profile changes, calling
 the <a href="output/Ext.Application.html#Ext.Application-determineProfile" ext:member="determineProfile"
 ext:cls="Ext.Application">determineProfile</a> function will force it to re-check.</p>]]></description><name>application</name><tag-class>org.brushingbits.jnap.ui.senchatouch.Application</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[Will automatically set up the application to work in full screen mode by calling Ext.Viewport.init if true (defaults to
 true)]]></description><name>autoInitViewport</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If true, automatically calls Ext.Component.setProfile on all components whenever a application/device profile change is
 detected (defaults to true)]]></description><name>autoUpdateComponentProfiles</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[When the app is first loaded, this url will be redirected to. Defaults to undefined]]></description><name>defaultUrl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A config object containing one or more event handlers to be added to this object during initialization. This should be a
 valid listeners config object as specified in the addListener example for attaching multiple handlers at once. DOM
 events from ExtJs Components While some ExtJs Component classes export selected DOM events (e.g. "click", "mouseover"
 etc), this is usually only done when extra value can be added. For example the DataView's click event passing the node
 clicked on. To access DOM events directly from a child element of a Component, we need to specify the element option to
 identify the Component property to add a DOM listener to: new Ext.Panel({
     width: 400,
     height: 200,
    
 dockedItems: [{
         xtype: 'toolbar'
     }],
     listeners: {
         click: {
             element: 'el', //bind to
 the underlying el property on the panel
             fn: function(){ console.log('click el'); }
         },
        
 dblclick: {
             element: 'body', //bind to the underlying body property on the panel
             fn: function(){
 console.log('dblclick body'); }
         }
     }
 });]]></description><name>listeners</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The number of milliseconds the load mask takes to fade out. Defaults to 1000]]></description><name>loadMaskFadeDuration</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The number of milliseconds until the load mask is removed after starting the fadeout. Defaults to 1050.]]></description><name>loadMaskRemoveDuration</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The name of the Application. This should be the same as the single global variable that the application uses, and should
 not contain spaces]]></description><name>name</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A set of named profile specifications that this application supports. See the intro docs for an example]]></description><name>profiles</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The scope to execute the launch function in. Defaults to the Application instance.]]></description><name>scope</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If true, determines the current application profile on launch and calls updateComponentProfiles. Defaults to true]]></description><name>setProfilesOnLaunch</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically set up Ext.History support (defaults to true)]]></description><name>useHistory</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically remove an application loading mask when the DOM is ready. If set to true, this expects a div
 called "loading-mask" to be present in the body. Pass the id of some other DOM node if using a custom loading mask
 element. Defaults to false.]]></description><name>useLoadMask</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original SenchaTouch API docs:
 <a href="http://docs.sencha.com/touch/">http://docs.sencha.com/touch/</a>

 <p>Provides a simple container for HTML5 Audio.</p> 
 <p><i>Recommended types: Uncompressed WAV and AIF audio, MP3 audio,
 and AAC-LC or HE-AAC audio</i></p> 
 <h2>Useful Properties</h2> 
 <ul class="list"> 
  <li><a
 href="output/Ext.Audio.html#Ext.Audio-url" ext:member="url" ext:cls="Ext.Audio">url</a></li> 
  <li><a
 href="output/Ext.Audio.html#Ext.Audio-autoPause" ext:member="autoPause" ext:cls="Ext.Audio">autoPause</a></li> 
  <li><a
 href="output/Ext.Audio.html#Ext.Audio-autoResume" ext:member="autoResume" ext:cls="Ext.Audio">autoResume</a></li> 
 </ul>
 
 <h2>Useful Methods</h2> 
 <ul class="list"> 
  <li><a href="output/Ext.Audio.html#Ext.Audio-pause" ext:member="pause"
 ext:cls="Ext.Audio">pause</a></li> 
  <li><a href="output/Ext.Audio.html#Ext.Audio-play" ext:member="play"
 ext:cls="Ext.Audio">play</a></li> 
  <li><a href="output/Ext.Audio.html#Ext.Audio-toggle" ext:member="toggle"
 ext:cls="Ext.Audio">toggle</a></li> 
 </ul> 
 <h2>Screenshot:</h2> 
 <p><img src="doc_resources/Ext.Audio/screenshot.png"
 /></p> 
 <h2>Example code:</h2> 
 <pre><code><b>var</b> pnl = <b>new</b> Ext.Panel({
     fullscreen: true,
     items: [
   
 {
             xtype: <em>'audio'</em>,
             url  : <em>&quot;who-goingmobile.mp3&quot;</em>
         }
    
 ]
 });</code></pre>]]></description><name>audio</name><tag-class>org.brushingbits.jnap.ui.senchatouch.Audio</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[A string component id or the numeric index of the component that should be initially activated within the container's
 layout on render. For example, activeItem: 'item-1' or activeItem: 0 (index 0 = the first item in the container's
 collection). activeItem only applies to layout styles that can display items one at a time (like Ext.layout.CardLayout
 and Ext.layout.FitLayout). Related to Ext.layout.ContainerLayout.activeItem.]]></description><name>activeItem</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If true the container will automatically destroy any contained component that is removed from it, else destruction must
 be handled manually (defaults to true).]]></description><name>autoDestroy</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Will automatically pause the media when the container is deactivated. (Defaults to true)]]></description><name>autoPause</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Will automatically start playing the media when the container is activated. (Defaults to false)]]></description><name>autoResume</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The base CSS class to apply to this components's element. This will also be prepended to elements within this component
 like Panel's body will get a class x-panel-body. This means that if you create a subclass of Panel, and you want it to
 get all the Panels styling for the element and the body, you leave the baseCls x-panel and use componentCls to add
 specific styling for this component.]]></description><name>baseCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the border for this component. The border can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>border</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to ['add', 'remove'].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Animation to be used during transitions of cards. Note this only works when this container has a CardLayout. Any valid
 value from Ext.anims can be used ('fade', 'slide', 'flip', 'cube', 'pop', 'wipe'). Defaults to null.]]></description><name>cardSwitchAnimation</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element (defaults to ''). This can be useful for
 adding customized styles to the component or any of its children using standard CSS rules.]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS Class to be added to a components root level element to give distinction to it via styling.]]></description><name>componentCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The sizing and positioning of the component Elements is the responsibility of the Component's layout manager which
 creates and manages the type of layout specific to the component. If the layout configuration is not explicitly
 specified for a general purpose compopnent the default layout manager will be used.]]></description><name>componentLayout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default xtype of child Components to create in this Container when a child item is specified as a raw configuration
 object, rather than as an instantiated Component. Defaults to 'panel'.]]></description><name>defaultType</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[This option is a means of applying default settings to all added items whether added through the items config or via the
 add or insert methods. If an added item is a config object, and not an instantiated Component, then the default
 properties are unconditionally applied. If the added item is an instantiated Component, then the default properties are
 applied conditionally so as not to override existing properties in the item. If the defaults option is specified as a
 function, then the function will be called using this Container as the scope (this reference) and passing the added item
 as the first parameter. Any resulting object from that call is then applied to the item as default properties. For
 example, to automatically apply padding to the body of each of a set of contained Ext.Panel items, you could pass:
 defaults: {bodyStyle:'padding:15px'}. Usage: defaults: {               // defaults are applied to items, not the
 container
     autoScroll:true
 },
 items: [
     {
         xtype: 'panel',   // defaults do not have precedence over
       
 id: 'panel1',     // options in config objects, so the defaults
         autoScroll: false // will not be applied here,
 panel1 will be autoScroll:false
     },
     new Ext.Panel({       // defaults do have precedence over options
         id:
 'panel2',     // options in components, so the defaults
         autoScroll: false // will be applied here, panel2 will
 be autoScroll:true.
     })
 ]]]></description><name>defaults</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to false.]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class to add when the Component is disabled. Defaults to 'x-item-disabled'.]]></description><name>disabledCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Allows the component to be dragged via the touch event.]]></description><name>draggable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Set this to false to turn off the native media controls (Defaults to true).]]></description><name>enableControls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Create the Component as a floating and use absolute positioning. Defaults to false.]]></description><name>floating</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of this component in pixels.]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to false.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[** IMPORTANT: be sure to specify a layout if needed ! ** A single item, or an array of child Components to be added to
 this container, for example: // specifying a single item
 items: {...},
 layout: 'fit',    // specify a layout!
 
 //
 specifying multiple items
 items: [{...}, {...}],
 layout: 'hbox', // specify a layout! Each item may be: any type of
 object based on Ext.Component a fully instanciated object or an object literal that: has a specified xtype the
 Ext.Component.xtype specified is associated with the Component desired and should be chosen from one of the available
 xtypes as listed in Ext.Component. If an xtype is not explicitly specified, the defaultType for that Container is used.
 will be "lazily instanciated", avoiding the overhead of constructing a fully instanciated Component object Notes: Ext
 uses lazy rendering. Child Components will only be rendered should it become necessary. Items are automatically laid out
 when they are first shown (no sizing is done while hidden), or in response to a doLayout call. Do not specify contentEl/
 html with items.]]></description><name>items</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[*Important: In order for child items to be correctly sized and positioned, typically a layout manager must be specified
 through the layout configuration option. The sizing and positioning of child items is the responsibility of the
 Container's layout manager which creates and manages the type of layout you have in mind. For example: If the layout
 configuration is not explicitly specified for a general purpose container (e.g. Container or Panel) the default layout
 manager will be used which does nothing but render child components sequentially into the Container (no sizing or
 positioning will be performed in this situation). layout may be specified as either as an Object or as a String: Specify
 as an Object Example usage: layout: {
     type: 'vbox',
     align: 'left'
 } type The layout type to be used for this
 container. If not specified, a default Ext.layout.ContainerLayout will be created and used. Valid layout type values
 are:
 auto - Default card fit hbox vbox Layout specific configuration properties Additional layout specific
 configuration properties may also be specified. For complete details regarding the valid config options for each layout
 type, see the layout class corresponding to the type specified. Specify as a String Example usage: layout: {
     type:
 'vbox',
     padding: '5',
     align: 'left'
 } layout The layout type to be used for this container (see list of valid
 layout type values above). Additional layout specific configuration properties. For complete details regarding the valid
 config options for each layout type, see the layout class corresponding to the layout specified.]]></description><name>layout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A config object containing one or more event handlers to be added to this object during initialization. This should be a
 valid listeners config object as specified in the addListener example for attaching multiple handlers at once. DOM
 events from ExtJs Components While some ExtJs Component classes export selected DOM events (e.g. "click", "mouseover"
 etc), this is usually only done when extra value can be added. For example the DataView's click event passing the node
 clicked on. To access DOM events directly from a child element of a Component, we need to specify the element option to
 identify the Component property to add a DOM listener to: new Ext.Panel({
     width: 400,
     height: 200,
    
 dockedItems: [{
         xtype: 'toolbar'
     }],
     listeners: {
         click: {
             element: 'el', //bind to
 the underlying el property on the panel
             fn: function(){ console.log('click el'); }
         },
        
 dblclick: {
             element: 'body', //bind to the underlying body property on the panel
             fn: function(){
 console.log('dblclick body'); }
         }
     }
 });]]></description><name>listeners</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the margin for this component. The margin can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>margin</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this Component will set its height to. Warning: This will override any size management
 applied by layout managers.]]></description><name>maxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this Component will set its width to. Warning: This will override any size management
 applied by layout managers.]]></description><name>maxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this Component will set its height to. Warning: This will override any size management
 applied by layout managers.]]></description><name>minHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this Component will set its width to. Warning: This will override any size management
 applied by layout managers.]]></description><name>minWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the padding for this component. The padding can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>padding</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Will begin preloading the media immediately. (Defaults to true)]]></description><name>preload</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object containing properties specifying DomQuery selectors which identify child elements created by the render
 process. After the Component's internal structure is rendered according to the renderTpl, this object is iterated
 through, and the found Elements are added as properties to the Component using the renderSelector property name. For
 example, a Component which rendered an image, and description into its element might use the following properties coded
 into its prototype: renderTpl: '"{imageUrl}" class="x-image-component-img">
 "x-image-component-desc">{description}',
 
 renderSelectors: {
     image: 'img.x-image-component-img',
     descEl:
 'div.x-image-component-desc'
 } After rendering, the Component would have a property image referencing its child img
 Element, and a property descEl referencing the div Element which contains the description.]]></description><name>renderSelectors</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An XTemplate used to create the internal structure inside this Component's encapsulating Element. You do not normally
 need to specify this. For the base classes Ext.Component and Ext.Container, this defaults to null which means that they
 will be initially rendered with no internal structure; they render their Element empty. The more specialized ExtJS and
 Touch classes which use a more complex DOM structure, provide their own template definitions. This is intended to allow
 the developer to create application-specific utility Components with customized internal structure. Upon rendering, any
 created child elements may be automatically imported into object properties using the renderSelectors option.]]></description><name>renderTpl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
             title: 'Some Title',
             renderTo: Ext.getBody(),
          
 width: 400, height: 300,
             layout: 'form',
             items: [{
                 xtype: 'textareafield',
      
 style: {
                     width: '95%',
                     marginBottom: '10px'
                 }
             },
    
 new Ext.Button({
                 text: 'Send',
                 minWidth: '100',
                 style: {
                
     marginBottom: '10px'
                 }
             })
             ]
         });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The class that is added to the content target when you set styleHtmlContent to true. Defaults to 'x-html']]></description><name>styleHtmlCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically style the html inside the content target of this component (body for panels). Defaults to false.]]></description><name>styleHtmlContent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An Ext.Template, Ext.XTemplate or an array of strings to form an Ext.XTemplate. Used in conjunction with the data and
 tplWriteMode configurations.]]></description><name>tpl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A set of predefined ui styles for individual components. Most components support 'light' and 'dark'. Extra string added
 to the baseCls with an extra '-'. 
 <pre><code>
 new Ext.Panel({
     title: 'Some Title',
     baseCls: 'x-component'
     ui: 'green'
 });</pre></code>
 The ui configuration in this example would add 'x-component-green' as an additional class.]]></description><name>ui</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Location of the audio to play.]]></description><name>url</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of this component in pixels.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original SenchaTouch API docs:
 <a href="http://docs.sencha.com/touch/">http://docs.sencha.com/touch/</a>

 <p>A simple class to display different styles of buttons.</p> 
 <h2>Useful Properties</h2> 
 <ul class="list"> 
  <li><a
 href="output/Ext.Button.html#Ext.Button-ui" ext:member="ui" ext:cls="Ext.Button">ui</a> (defines the style of the
 button)</li> 
 </ul> 
 <h2>Useful Methods</h2> 
 <ul class="list"> 
  <li><a
 href="output/Ext.Button.html#Ext.Button-handler" ext:member="handler" ext:cls="Ext.Button">handler</a> (method to be
 called when the button is tapped)</li> 
 </ul> 
 <h2>Screenshot:</h2> 
 <p><img
 src="doc_resources/Ext.Button/screenshot.png" /></p> 
 <h2>Example code:</h2> 
 <pre><code><i>// an array of buttons
 (using xtypes) to be included <b>in</b> the panel below</i>
 <b>var</b> buttons = [
     {
         text:
 <em>'Normal'</em>
     },
     {
         ui  : <em>'round'</em>,
         text: <em>'Round'</em>
     },
     {
         ui  :
 <em>'small'</em>,
         text: <em>'Small'</em>
     }
 ];
 
 <b>var</b> panel = <b>new</b> Ext.Panel({
     layout: {
      
 type : <em>'vbox'</em>,
         pack : <em>'center'</em>,
         align: <em>'stretch'</em>
     },
     defaults: {
      
 layout: {
             type: <em>'hbox'</em>
         },
         flex: 1,
         defaults: {
             xtype:
 <em>'button'</em>,
             cls  : <em>'demobtn'</em>,
             flex : 1
         }
     },
     items: [
         {
  
 items: buttons <i>// buttons array defined above</i>
         },
         {
             items: [
                
 <b>new</b> Ext.Button({
                     ui  : <em>'decline'</em>,
                     text: <em>'Drastic'</em>
      
 }),
                 {
                     ui  : <em>'decline-round'</em>,
                     text: <em>'Round'</em>
    
 },
                 {
                     ui  : <em>'decline-small'</em>,
                     text: <em>'Small'</em>
     
 }
             ]
         },
         {
             items: [
                 {
                     ui  :
 <em>'confirm'</em>,
                     text: <em>'Confirm'</em>
                 },
                 {
                   
 ui  : <em>'confirm-round'</em>,
                     text: <em>'Round'</em>
                 },
                 {
         
 ui  : <em>'confirm-small'</em>,
                     text: <em>'Small'</em>
                 }
             ]
         }
    
 ]
 });</code></pre>]]></description><name>button</name><tag-class>org.brushingbits.jnap.ui.senchatouch.Button</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[If provided, a handler function is automatically created that fires the given event in the configured scope.]]></description><name>autoEvent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class for badge Defaults to 'x-badge']]></description><name>badgeCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The text to be used for a small badge on the button. Defaults to '']]></description><name>badgeText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Base CSS class Defaults to 'x-button']]></description><name>baseCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the border for this component. The border can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>border</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Center the Component. Defaults to false.]]></description><name>centered</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS class string to apply to the button's main element.]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS Class to be added to a components root level element to give distinction to it via styling.]]></description><name>componentCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The sizing and positioning of the component Elements is the responsibility of the Component's layout manager which
 creates and manages the type of layout specific to the component. If the layout configuration is not explicitly
 specified for a general purpose compopnent the default layout manager will be used.]]></description><name>componentLayout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to start disabled (defaults to false)]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class to add when the Component is disabled. Defaults to 'x-item-disabled'.]]></description><name>disabledCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Allows the component to be dragged via the touch event.]]></description><name>draggable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Create the Component as a floating and use absolute positioning. Defaults to false.]]></description><name>floating</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The class that is being added to this component when its floating. (defaults to x-floating)]]></description><name>floatingCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Force the component to take up 100% width and height available. Defaults to false. Setting this configuration
 immediately sets the monitorOrientation config to true. Setting this to true will render the component instantly.]]></description><name>fullscreen</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A function called when the button is clicked (can be used instead of click event). The handler is passed the following
 parameters: b : Button This Button. e : EventObject The click event.]]></description><name>handler</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of this component in pixels.]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to start hidden (defaults to false)]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically bind a tap listener to the mask that hides the window. Defaults to true. Note: if you set this
 property to false you have to programmaticaly hide the overlay.]]></description><name>hideOnMaskTap</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The path to an image to display in the button (the image will be set as the background-image CSS property of the button
 by default, so if you want a mixed icon/text button, set cls:'x-btn-text-icon')]]></description><name>icon</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The alignment of the buttons icon if one has been defined. Valid options are 'top', 'right', 'bottom', 'left' (defaults
 to 'left').]]></description><name>iconAlign</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A css class which sets a background image to be used as the icon for this button]]></description><name>iconCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Whether or not to mask the icon with the iconMaskCls configuration. Defaults to false.]]></description><name>iconMask</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class to be added to the iconEl when the iconMask config is set to true. Defaults to 'x-icon-mask']]></description><name>iconMaskCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Set this to true to automatically relayout this component on orientation change. This property is set to true by default
 if a component is floating unless you specifically set this to false. Also note that you dont have to set this property
 to true if this component is a child of a fullscreen container, since fullscreen components are also laid out
 automatically on orientation change. Defaults to null]]></description><name>layoutOnOrientationChange</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A config object containing one or more event handlers to be added to this object during initialization. This should be a
 valid listeners config object as specified in the addListener example for attaching multiple handlers at once. DOM
 events from ExtJs Components While some ExtJs Component classes export selected DOM events (e.g. "click", "mouseover"
 etc), this is usually only done when extra value can be added. For example the DataView's click event passing the node
 clicked on. To access DOM events directly from a child element of a Component, we need to specify the element option to
 identify the Component property to add a DOM listener to: new Ext.Panel({
     width: 400,
     height: 200,
    
 dockedItems: [{
         xtype: 'toolbar'
     }],
     listeners: {
         click: {
             element: 'el', //bind to
 the underlying el property on the panel
             fn: function(){ console.log('click el'); }
         },
        
 dblclick: {
             element: 'body', //bind to the underlying body property on the panel
             fn: function(){
 console.log('dblclick body'); }
         }
     }
 });]]></description><name>listeners</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the margin for this component. The margin can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>margin</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this Component will set its height to. Warning: This will override any size management
 applied by layout managers.]]></description><name>maxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this Component will set its width to. Warning: This will override any size management
 applied by layout managers.]]></description><name>maxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this Component will set its height to. Warning: This will override any size management
 applied by layout managers.]]></description><name>minHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this Component will set its width to. Warning: This will override any size management
 applied by layout managers.]]></description><name>minWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to make the Component modal and mask everything behind it when displayed, false to display it without restricting
 access to other UI elements (defaults to false).]]></description><name>modal</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Monitor Orientation change]]></description><name>monitorOrientation</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the padding for this component. The padding can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>padding</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class when the button is in pressed state Defaults to 'x-button-pressed']]></description><name>pressedCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The amount of delay between the tapstart and the moment we add the pressedCls. Settings this to true defaults to 100ms]]></description><name>pressedDelay</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object containing properties specifying DomQuery selectors which identify child elements created by the render
 process. After the Component's internal structure is rendered according to the renderTpl, this object is iterated
 through, and the found Elements are added as properties to the Component using the renderSelector property name. For
 example, a Component which rendered an image, and description into its element might use the following properties coded
 into its prototype: renderTpl: '"{imageUrl}" class="x-image-component-img">
 "x-image-component-desc">{description}',
 
 renderSelectors: {
     image: 'img.x-image-component-img',
     descEl:
 'div.x-image-component-desc'
 } After rendering, the Component would have a property image referencing its child img
 Element, and a property descEl referencing the div Element which contains the description.]]></description><name>renderSelectors</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An XTemplate used to create the internal structure inside this Component's encapsulating Element. You do not normally
 need to specify this. For the base classes Ext.Component and Ext.Container, this defaults to null which means that they
 will be initially rendered with no internal structure; they render their Element empty. The more specialized ExtJS and
 Touch classes which use a more complex DOM structure, provide their own template definitions. This is intended to allow
 the developer to create application-specific utility Components with customized internal structure. Upon rendering, any
 created child elements may be automatically imported into object properties using the renderSelectors option.]]></description><name>renderTpl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The scope (this reference) in which the handler and toggleHandler is executed. Defaults to this Button.]]></description><name>scope</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Configure the component to be scrollable. Acceptable values are: 'horizontal', 'vertical', 'both' to enabling scrolling
 for that direction. A Scroller configuration. false to explicitly disable scrolling. Enabling scrolling immediately sets
 the monitorOrientation config to true (for Panel)]]></description><name>scroll</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The type of animation you want to use when this component is shown. If you set this this hide animation will
 automatically be the opposite.]]></description><name>showAnimation</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to stop the event that fires when you click outside the floating component. Defalts to true.]]></description><name>stopMaskTapEvent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
             title: 'Some Title',
             renderTo: Ext.getBody(),
          
 width: 400, height: 300,
             layout: 'form',
             items: [{
                 xtype: 'textareafield',
      
 style: {
                     width: '95%',
                     marginBottom: '10px'
                 }
             },
    
 new Ext.Button({
                 text: 'Send',
                 minWidth: '100',
                 style: {
                
     marginBottom: '10px'
                 }
             })
             ]
         });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The class that is added to the content target when you set styleHtmlContent to true. Defaults to 'x-html']]></description><name>styleHtmlCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically style the html inside the content target of this component (body for panels). Defaults to false.]]></description><name>styleHtmlContent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The button text to be used as innerHTML (html tags are accepted)]]></description><name>text</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An Ext.Template, Ext.XTemplate or an array of strings to form an Ext.XTemplate. Used in conjunction with the data and
 tplWriteMode configurations.]]></description><name>tpl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Determines the UI look and feel of the button. Valid options are 'normal', 'back', 'round', 'action', 'forward'.
 Defaults to 'normal'.]]></description><name>ui</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of this component in pixels.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original SenchaTouch API docs:
 <a href="http://docs.sencha.com/touch/">http://docs.sencha.com/touch/</a>

 <p>A customized Panel which provides the ability to slide back and forth between different child items.</p> 
 <h2>Useful
 Properties</h2> 
 <ul class="list"> 
  <li><a href="output/Ext.Carousel.html#Ext.Carousel-ui" ext:member="ui"
 ext:cls="Ext.Carousel">ui</a> (defines the style of the carousel)</li> 
  <li><a
 href="output/Ext.Carousel.html#Ext.Carousel-direction" ext:member="direction" ext:cls="Ext.Carousel">direction</a>
 (defines the direction of the carousel)</li> 
  <li><a href="output/Ext.Carousel.html#Ext.Carousel-indicator"
 ext:member="indicator" ext:cls="Ext.Carousel">indicator</a> (defines if the indicator show be shown)</li> 
 </ul>
 
 <h2>Useful Methods</h2> 
 <ul class="list"> 
  <li><a href="output/Ext.Carousel.html#Ext.Carousel-next" ext:member="next"
 ext:cls="Ext.Carousel">next</a> (moves to the next card)</li> 
  <li><a href="output/Ext.Carousel.html#Ext.Carousel-prev"
 ext:member="prev" ext:cls="Ext.Carousel">prev</a> (moves to the previous card)</li> 
  <li><a
 href="output/Ext.Carousel.html#Ext.Carousel-setActiveItem" ext:member="setActiveItem"
 ext:cls="Ext.Carousel">setActiveItem</a> (moves to the passed card)</li> 
 </ul> 
 <h2>Screenshot:</h2> 
 <p><img
 src="doc_resources/Ext.Carousel/screenshot.png" /></p> 
 <h2>Example code:</h2> 
 <pre><code><b>var</b> carousel =
 <b>new</b> Ext.Carousel({
     items: [
         {
             html: <em>'&lt;p&gt;Navigate the carousel on this page by
 swiping left/right.&lt;/p&gt;'</em>,
             cls : <em>'card card1'</em>
         },
         {
             html:
 <em>'&lt;p&gt;Clicking on either side of the indicators below&lt;/p&gt;'</em>,
             cls : <em>'card card2'</em>
  
 },
         {
             html: <em>'Card #3'</em>,
             cls : <em>'card card3'</em>
         }
    
 ]
 });
 
 <b>var</b> panel = <b>new</b> Ext.Panel({
     cls: <em>'cards'</em>,
     layout: {
         type :
 <em>'vbox'</em>,
         align: <em>'stretch'</em>
     },
     defaults: {
         flex: 1
     },
     items: [
        
 carousel,
         {
             xtype    : <em>'carousel'</em>,
             ui       : <em>'light'</em>,
            
 direction: <em>'vertical'</em>,
             
             items: [
             {
                     html:
 <em>'&lt;p&gt;Carousels can be vertical and given a ui of <em>&quot;light&quot;</em> or
 <em>&quot;dark&quot;</em>.&lt;/p&gt;'</em>,
                     cls : <em>'card card1'</em>
                 },
          
 {
                     html: <em>'Card #2'</em>,
                     cls : <em>'card card2'</em>
                 },
      
 {
                     html: <em>'Card #3'</em>,
                     cls : <em>'card card3'</em>
                 }
       
      ]
         }
     ]
 });</code></pre>]]></description><name>carousel</name><tag-class>org.brushingbits.jnap.ui.senchatouch.Carousel</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[A string component id or the numeric index of the component that should be initially activated within the container's
 layout on render. For example, activeItem: 'item-1' or activeItem: 0 (index 0 = the first item in the container's
 collection). activeItem only applies to layout styles that can display items one at a time (like Ext.layout.CardLayout
 and Ext.layout.FitLayout). Related to Ext.layout.ContainerLayout.activeItem.]]></description><name>activeItem</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If true the container will automatically destroy any contained component that is removed from it, else destruction must
 be handled manually (defaults to true).]]></description><name>autoDestroy</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The base CSS class to apply to the Carousel's element (defaults to 'x-carousel').]]></description><name>baseCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A shortcut for setting a border style on the body element. The value can either be a number to be applied to all sides,
 or a normal css string describing borders. Defaults to undefined.]]></description><name>bodyBorder</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A shortcut for setting a margin style on the body element. The value can either be a number to be applied to all sides,
 or a normal css string describing margins. Defaults to undefined.]]></description><name>bodyMargin</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A shortcut for setting a padding style on the body element. The value can either be a number to be applied to all sides,
 or a normal css string describing padding. Defaults to undefined.]]></description><name>bodyPadding</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the border for this component. The border can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>border</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to ['add', 'remove'].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element (defaults to ''). This can be useful for
 adding customized styles to the component or any of its children using standard CSS rules.]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS Class to be added to a components root level element to give distinction to it via styling.]]></description><name>componentCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The sizing and positioning of the component Elements is the responsibility of the Component's layout manager which
 creates and manages the type of layout specific to the component. If the layout configuration is not explicitly
 specified for a general purpose compopnent the default layout manager will be used.]]></description><name>componentLayout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default xtype of child Components to create in this Container when a child item is specified as a raw configuration
 object, rather than as an instantiated Component. Defaults to 'panel'.]]></description><name>defaultType</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[This option is a means of applying default settings to all added items whether added through the items config or via the
 add or insert methods. If an added item is a config object, and not an instantiated Component, then the default
 properties are unconditionally applied. If the added item is an instantiated Component, then the default properties are
 applied conditionally so as not to override existing properties in the item. If the defaults option is specified as a
 function, then the function will be called using this Container as the scope (this reference) and passing the added item
 as the first parameter. Any resulting object from that call is then applied to the item as default properties. For
 example, to automatically apply padding to the body of each of a set of contained Ext.Panel items, you could pass:
 defaults: {bodyStyle:'padding:15px'}. Usage: defaults: {               // defaults are applied to items, not the
 container
     autoScroll:true
 },
 items: [
     {
         xtype: 'panel',   // defaults do not have precedence over
       
 id: 'panel1',     // options in config objects, so the defaults
         autoScroll: false // will not be applied here,
 panel1 will be autoScroll:false
     },
     new Ext.Panel({       // defaults do have precedence over options
         id:
 'panel2',     // options in components, so the defaults
         autoScroll: false // will be applied here, panel2 will
 be autoScroll:true.
     })
 ]]]></description><name>defaults</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The direction of the Carousel. Default is 'horizontal'. 'vertical' also available.]]></description><name>direction</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to false.]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class to add when the Component is disabled. Defaults to 'x-item-disabled'.]]></description><name>disabledCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A component or series of components to be added as docked items to this panel. The docked items can be docked to either
 the top, right, left or bottom of a panel. This is typically used for things like toolbars or tab bars: var panel = new
 Ext.Panel({
     fullscreen: true,
     dockedItems: [{
         xtype: 'toolbar',
         dock: 'top',
         items: [{
  
           text: 'Docked to the bottom'
         }]
     }]
 });]]></description><name>dockedItems</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Allows the component to be dragged via the touch event.]]></description><name>draggable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Create the Component as a floating and use absolute positioning. Defaults to false.]]></description><name>floating</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of this component in pixels.]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to false.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Provides an indicator while toggling between child items to let the user know where they are in the card stack.]]></description><name>indicator</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[** IMPORTANT: be sure to specify a layout if needed ! ** A single item, or an array of child Components to be added to
 this container, for example: // specifying a single item
 items: {...},
 layout: 'fit',    // specify a layout!
 
 //
 specifying multiple items
 items: [{...}, {...}],
 layout: 'hbox', // specify a layout! Each item may be: any type of
 object based on Ext.Component a fully instanciated object or an object literal that: has a specified xtype the
 Ext.Component.xtype specified is associated with the Component desired and should be chosen from one of the available
 xtypes as listed in Ext.Component. If an xtype is not explicitly specified, the defaultType for that Container is used.
 will be "lazily instanciated", avoiding the overhead of constructing a fully instanciated Component object Notes: Ext
 uses lazy rendering. Child Components will only be rendered should it become necessary. Items are automatically laid out
 when they are first shown (no sizing is done while hidden), or in response to a doLayout call. Do not specify contentEl/
 html with items.]]></description><name>items</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[*Important: In order for child items to be correctly sized and positioned, typically a layout manager must be specified
 through the layout configuration option. The sizing and positioning of child items is the responsibility of the
 Container's layout manager which creates and manages the type of layout you have in mind. For example: If the layout
 configuration is not explicitly specified for a general purpose container (e.g. Container or Panel) the default layout
 manager will be used which does nothing but render child components sequentially into the Container (no sizing or
 positioning will be performed in this situation). layout may be specified as either as an Object or as a String: Specify
 as an Object Example usage: layout: {
     type: 'vbox',
     align: 'left'
 } type The layout type to be used for this
 container. If not specified, a default Ext.layout.ContainerLayout will be created and used. Valid layout type values
 are:
 auto - Default card fit hbox vbox Layout specific configuration properties Additional layout specific
 configuration properties may also be specified. For complete details regarding the valid config options for each layout
 type, see the layout class corresponding to the type specified. Specify as a String Example usage: layout: {
     type:
 'vbox',
     padding: '5',
     align: 'left'
 } layout The layout type to be used for this container (see list of valid
 layout type values above). Additional layout specific configuration properties. For complete details regarding the valid
 config options for each layout type, see the layout class corresponding to the layout specified.]]></description><name>layout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A config object containing one or more event handlers to be added to this object during initialization. This should be a
 valid listeners config object as specified in the addListener example for attaching multiple handlers at once. DOM
 events from ExtJs Components While some ExtJs Component classes export selected DOM events (e.g. "click", "mouseover"
 etc), this is usually only done when extra value can be added. For example the DataView's click event passing the node
 clicked on. To access DOM events directly from a child element of a Component, we need to specify the element option to
 identify the Component property to add a DOM listener to: new Ext.Panel({
     width: 400,
     height: 200,
    
 dockedItems: [{
         xtype: 'toolbar'
     }],
     listeners: {
         click: {
             element: 'el', //bind to
 the underlying el property on the panel
             fn: function(){ console.log('click el'); }
         },
        
 dblclick: {
             element: 'body', //bind to the underlying body property on the panel
             fn: function(){
 console.log('dblclick body'); }
         }
     }
 });]]></description><name>listeners</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the margin for this component. The margin can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>margin</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this Component will set its height to. Warning: This will override any size management
 applied by layout managers.]]></description><name>maxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this Component will set its width to. Warning: This will override any size management
 applied by layout managers.]]></description><name>maxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this Component will set its height to. Warning: This will override any size management
 applied by layout managers.]]></description><name>minHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this Component will set its width to. Warning: This will override any size management
 applied by layout managers.]]></description><name>minWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the padding for this component. The padding can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>padding</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object containing properties specifying DomQuery selectors which identify child elements created by the render
 process. After the Component's internal structure is rendered according to the renderTpl, this object is iterated
 through, and the found Elements are added as properties to the Component using the renderSelector property name. For
 example, a Component which rendered an image, and description into its element might use the following properties coded
 into its prototype: renderTpl: '"{imageUrl}" class="x-image-component-img">
 "x-image-component-desc">{description}',
 
 renderSelectors: {
     image: 'img.x-image-component-img',
     descEl:
 'div.x-image-component-desc'
 } After rendering, the Component would have a property image referencing its child img
 Element, and a property descEl referencing the div Element which contains the description.]]></description><name>renderSelectors</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An XTemplate used to create the internal structure inside this Component's encapsulating Element. You do not normally
 need to specify this. For the base classes Ext.Component and Ext.Container, this defaults to null which means that they
 will be initially rendered with no internal structure; they render their Element empty. The more specialized ExtJS and
 Touch classes which use a more complex DOM structure, provide their own template definitions. This is intended to allow
 the developer to create application-specific utility Components with customized internal structure. Upon rendering, any
 created child elements may be automatically imported into object properties using the renderSelectors option.]]></description><name>renderTpl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
             title: 'Some Title',
             renderTo: Ext.getBody(),
          
 width: 400, height: 300,
             layout: 'form',
             items: [{
                 xtype: 'textareafield',
      
 style: {
                     width: '95%',
                     marginBottom: '10px'
                 }
             },
    
 new Ext.Button({
                 text: 'Send',
                 minWidth: '100',
                 style: {
                
     marginBottom: '10px'
                 }
             })
             ]
         });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The class that is added to the content target when you set styleHtmlContent to true. Defaults to 'x-html']]></description><name>styleHtmlCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically style the html inside the content target of this component (body for panels). Defaults to false.]]></description><name>styleHtmlContent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An Ext.Template, Ext.XTemplate or an array of strings to form an Ext.XTemplate. Used in conjunction with the data and
 tplWriteMode configurations.]]></description><name>tpl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Style options for Carousel. Default is 'dark'. 'light' is also available.]]></description><name>ui</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of this component in pixels.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original SenchaTouch API docs:
 <a href="http://docs.sencha.com/touch/">http://docs.sencha.com/touch/</a>

 <p>Base class for any <a href="output/Ext.BoxComponent.html" ext:cls="Ext.BoxComponent">Ext.BoxComponent</a> that may
 contain other Components. Containers handle the basic behavior of containing items, namely adding, inserting and
 removing items.</p> 
 <p><u><b>Layout</b></u></p> 
 <p>Container classes delegate the rendering of child Components to a
 layout manager class which must be configured into the Container using the <code><b><a
 href="output/Ext.Container.html#Ext.Container-layout" ext:member="layout" ext:cls="Ext.Container">layout</a></b></code>
 configuration property.</p> 
 <p>When either specifying child <code><a
 href="output/Ext.Container.html#Ext.Container-items" ext:member="items" ext:cls="Ext.Container">items</a></code> of a
 Container, or dynamically <a href="output/Ext.Container.html#Ext.Container-add" ext:member="add"
 ext:cls="Ext.Container">adding</a> Components to a Container, remember to consider how you wish the Container to arrange
 those child elements, and whether those child elements need to be sized using one of Ext's built-in <b><code><a
 href="output/Ext.Container.html#Ext.Container-layout" ext:member="layout" ext:cls="Ext.Container">layout</a></code></b>
 schemes. By default, Containers use the <a href="output/Ext.layout.AutoContainerLayout.html"
 ext:cls="Ext.layout.AutoContainerLayout">AutoContainerLayout</a> scheme which only renders child components, appending
 them one after the other inside the Container, and <b>does not apply any sizing</b> at all.</p> 
 <p>A common mistake is
 when a developer neglects to specify a <b><code><a href="output/Ext.Container.html#Ext.Container-layout"
 ext:member="layout" ext:cls="Ext.Container">layout</a></code></b>. If a Container is left to use the default <a
 href="output/Ext.layout.AutoContainerLayout.html" ext:cls="Ext.layout.AutoContainerLayout">AutoContainerLayout</a>
 scheme, none of its child components will be resized, or changed in any way when the Container is resized.</p>]]></description><name>container</name><tag-class>org.brushingbits.jnap.ui.senchatouch.Container</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[A string component id or the numeric index of the component that should be initially activated within the container's
 layout on render. For example, activeItem: 'item-1' or activeItem: 0 (index 0 = the first item in the container's
 collection). activeItem only applies to layout styles that can display items one at a time (like Ext.layout.CardLayout
 and Ext.layout.FitLayout). Related to Ext.layout.ContainerLayout.activeItem.]]></description><name>activeItem</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If true the container will automatically destroy any contained component that is removed from it, else destruction must
 be handled manually (defaults to true).]]></description><name>autoDestroy</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The base CSS class to apply to this components's element. This will also be prepended to elements within this component
 like Panel's body will get a class x-panel-body. This means that if you create a subclass of Panel, and you want it to
 get all the Panels styling for the element and the body, you leave the baseCls x-panel and use componentCls to add
 specific styling for this component.]]></description><name>baseCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the border for this component. The border can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>border</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to ['add', 'remove'].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Animation to be used during transitions of cards. Note this only works when this container has a CardLayout. Any valid
 value from Ext.anims can be used ('fade', 'slide', 'flip', 'cube', 'pop', 'wipe'). Defaults to null.]]></description><name>cardSwitchAnimation</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element (defaults to ''). This can be useful for
 adding customized styles to the component or any of its children using standard CSS rules.]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS Class to be added to a components root level element to give distinction to it via styling.]]></description><name>componentCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The sizing and positioning of the component Elements is the responsibility of the Component's layout manager which
 creates and manages the type of layout specific to the component. If the layout configuration is not explicitly
 specified for a general purpose compopnent the default layout manager will be used.]]></description><name>componentLayout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default xtype of child Components to create in this Container when a child item is specified as a raw configuration
 object, rather than as an instantiated Component. Defaults to 'panel'.]]></description><name>defaultType</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[This option is a means of applying default settings to all added items whether added through the items config or via the
 add or insert methods. If an added item is a config object, and not an instantiated Component, then the default
 properties are unconditionally applied. If the added item is an instantiated Component, then the default properties are
 applied conditionally so as not to override existing properties in the item. If the defaults option is specified as a
 function, then the function will be called using this Container as the scope (this reference) and passing the added item
 as the first parameter. Any resulting object from that call is then applied to the item as default properties. For
 example, to automatically apply padding to the body of each of a set of contained Ext.Panel items, you could pass:
 defaults: {bodyStyle:'padding:15px'}. Usage: defaults: {               // defaults are applied to items, not the
 container
     autoScroll:true
 },
 items: [
     {
         xtype: 'panel',   // defaults do not have precedence over
       
 id: 'panel1',     // options in config objects, so the defaults
         autoScroll: false // will not be applied here,
 panel1 will be autoScroll:false
     },
     new Ext.Panel({       // defaults do have precedence over options
         id:
 'panel2',     // options in components, so the defaults
         autoScroll: false // will be applied here, panel2 will
 be autoScroll:true.
     })
 ]]]></description><name>defaults</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to false.]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class to add when the Component is disabled. Defaults to 'x-item-disabled'.]]></description><name>disabledCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Allows the component to be dragged via the touch event.]]></description><name>draggable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Create the Component as a floating and use absolute positioning. Defaults to false.]]></description><name>floating</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of this component in pixels.]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to false.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[** IMPORTANT: be sure to specify a layout if needed ! ** A single item, or an array of child Components to be added to
 this container, for example: // specifying a single item
 items: {...},
 layout: 'fit',    // specify a layout!
 
 //
 specifying multiple items
 items: [{...}, {...}],
 layout: 'hbox', // specify a layout! Each item may be: any type of
 object based on Ext.Component a fully instanciated object or an object literal that: has a specified xtype the
 Ext.Component.xtype specified is associated with the Component desired and should be chosen from one of the available
 xtypes as listed in Ext.Component. If an xtype is not explicitly specified, the defaultType for that Container is used.
 will be "lazily instanciated", avoiding the overhead of constructing a fully instanciated Component object Notes: Ext
 uses lazy rendering. Child Components will only be rendered should it become necessary. Items are automatically laid out
 when they are first shown (no sizing is done while hidden), or in response to a doLayout call. Do not specify contentEl/
 html with items.]]></description><name>items</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[*Important: In order for child items to be correctly sized and positioned, typically a layout manager must be specified
 through the layout configuration option. The sizing and positioning of child items is the responsibility of the
 Container's layout manager which creates and manages the type of layout you have in mind. For example: If the layout
 configuration is not explicitly specified for a general purpose container (e.g. Container or Panel) the default layout
 manager will be used which does nothing but render child components sequentially into the Container (no sizing or
 positioning will be performed in this situation). layout may be specified as either as an Object or as a String: Specify
 as an Object Example usage: layout: {
     type: 'vbox',
     align: 'left'
 } type The layout type to be used for this
 container. If not specified, a default Ext.layout.ContainerLayout will be created and used. Valid layout type values
 are:
 auto - Default card fit hbox vbox Layout specific configuration properties Additional layout specific
 configuration properties may also be specified. For complete details regarding the valid config options for each layout
 type, see the layout class corresponding to the type specified. Specify as a String Example usage: layout: {
     type:
 'vbox',
     padding: '5',
     align: 'left'
 } layout The layout type to be used for this container (see list of valid
 layout type values above). Additional layout specific configuration properties. For complete details regarding the valid
 config options for each layout type, see the layout class corresponding to the layout specified.]]></description><name>layout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A config object containing one or more event handlers to be added to this object during initialization. This should be a
 valid listeners config object as specified in the addListener example for attaching multiple handlers at once. DOM
 events from ExtJs Components While some ExtJs Component classes export selected DOM events (e.g. "click", "mouseover"
 etc), this is usually only done when extra value can be added. For example the DataView's click event passing the node
 clicked on. To access DOM events directly from a child element of a Component, we need to specify the element option to
 identify the Component property to add a DOM listener to: new Ext.Panel({
     width: 400,
     height: 200,
    
 dockedItems: [{
         xtype: 'toolbar'
     }],
     listeners: {
         click: {
             element: 'el', //bind to
 the underlying el property on the panel
             fn: function(){ console.log('click el'); }
         },
        
 dblclick: {
             element: 'body', //bind to the underlying body property on the panel
             fn: function(){
 console.log('dblclick body'); }
         }
     }
 });]]></description><name>listeners</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the margin for this component. The margin can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>margin</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this Component will set its height to. Warning: This will override any size management
 applied by layout managers.]]></description><name>maxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this Component will set its width to. Warning: This will override any size management
 applied by layout managers.]]></description><name>maxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this Component will set its height to. Warning: This will override any size management
 applied by layout managers.]]></description><name>minHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this Component will set its width to. Warning: This will override any size management
 applied by layout managers.]]></description><name>minWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the padding for this component. The padding can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>padding</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object containing properties specifying DomQuery selectors which identify child elements created by the render
 process. After the Component's internal structure is rendered according to the renderTpl, this object is iterated
 through, and the found Elements are added as properties to the Component using the renderSelector property name. For
 example, a Component which rendered an image, and description into its element might use the following properties coded
 into its prototype: renderTpl: '"{imageUrl}" class="x-image-component-img">
 "x-image-component-desc">{description}',
 
 renderSelectors: {
     image: 'img.x-image-component-img',
     descEl:
 'div.x-image-component-desc'
 } After rendering, the Component would have a property image referencing its child img
 Element, and a property descEl referencing the div Element which contains the description.]]></description><name>renderSelectors</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An XTemplate used to create the internal structure inside this Component's encapsulating Element. You do not normally
 need to specify this. For the base classes Ext.Component and Ext.Container, this defaults to null which means that they
 will be initially rendered with no internal structure; they render their Element empty. The more specialized ExtJS and
 Touch classes which use a more complex DOM structure, provide their own template definitions. This is intended to allow
 the developer to create application-specific utility Components with customized internal structure. Upon rendering, any
 created child elements may be automatically imported into object properties using the renderSelectors option.]]></description><name>renderTpl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
             title: 'Some Title',
             renderTo: Ext.getBody(),
          
 width: 400, height: 300,
             layout: 'form',
             items: [{
                 xtype: 'textareafield',
      
 style: {
                     width: '95%',
                     marginBottom: '10px'
                 }
             },
    
 new Ext.Button({
                 text: 'Send',
                 minWidth: '100',
                 style: {
                
     marginBottom: '10px'
                 }
             })
             ]
         });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The class that is added to the content target when you set styleHtmlContent to true. Defaults to 'x-html']]></description><name>styleHtmlCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically style the html inside the content target of this component (body for panels). Defaults to false.]]></description><name>styleHtmlContent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An Ext.Template, Ext.XTemplate or an array of strings to form an Ext.XTemplate. Used in conjunction with the data and
 tplWriteMode configurations.]]></description><name>tpl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A set of predefined ui styles for individual components. Most components support 'light' and 'dark'. Extra string added
 to the baseCls with an extra '-'. 
 <pre><code>
 new Ext.Panel({
     title: 'Some Title',
     baseCls: 'x-component'
     ui: 'green'
 });</pre></code>
 The ui configuration in this example would add 'x-component-green' as an additional class.]]></description><name>ui</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of this component in pixels.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original SenchaTouch API docs:
 <a href="http://docs.sencha.com/touch/">http://docs.sencha.com/touch/</a>

 <p>AbstractStore is a superclass of <a href="output/Ext.data.Store.html" ext:cls="Ext.data.Store">Ext.data.Store</a> and
 <a href="output/Ext.data.TreeStore.html" ext:cls="Ext.data.TreeStore">Ext.data.TreeStore</a>. It's never used directly,
 but offers a set of methods used by both of those subclasses.</p> 
 <p>We've left it here in the docs for reference
 purposes, but unless you need to make a whole new type of Store, what you're probably looking for is <a
 href="output/Ext.data.Store.html" ext:cls="Ext.data.Store">Ext.data.Store</a>. If you're still interested, here's a
 brief description of what AbstractStore is and is not.</p> 
 <p>AbstractStore provides the basic configuration for
 anything that can be considered a Store. It expects to be given a <a href="output/Ext.data.Model.html"
 ext:cls="Ext.data.Model">Model</a> that represents the type of data in the Store. It also expects to be given a <a
 href="output/Ext.data.Proxy.html" ext:cls="Ext.data.Proxy">Proxy</a> that handles the loading of data into the
 Store.</p> 
 <p>AbstractStore provides a few helpful methods such as <a
 href="output/Ext.data.AbstractStore.html#Ext.data.AbstractStore-load" ext:member="load"
 ext:cls="Ext.data.AbstractStore">load</a> and <a href="output/Ext.data.AbstractStore.html#Ext.data.AbstractStore-sync"
 ext:member="sync" ext:cls="Ext.data.AbstractStore">sync</a>, which load and save data respectively, passing the requests
 through the configured <a href="output/Ext.data.AbstractStore.html#Ext.data.AbstractStore-proxy" ext:member="proxy"
 ext:cls="Ext.data.AbstractStore">proxy</a>. Both built-in Store subclasses add extra behavior to each of these
 functions. Note also that each AbstractStore subclass has its own way of storing data - in <a
 href="output/Ext.data.Store.html" ext:cls="Ext.data.Store">Ext.data.Store</a> the data is saved as a flat <a
 href="output/Ext.data.MixedCollection.html" ext:cls="Ext.data.MixedCollection">MixedCollection</a>, whereas in <a
 href="output/Ext.data.TreeStore.html" ext:cls="Ext.data.TreeStore">TreeStore</a> we use a <a
 href="output/Ext.data.Tree.html" ext:cls="Ext.data.Tree">Ext.data.Tree</a> to maintain the data's hierarchy.</p>
 
 <p>Finally, AbstractStore provides an API for sorting and filtering data via its <a
 href="output/Ext.data.AbstractStore.html#Ext.data.AbstractStore-sorters" ext:member="sorters"
 ext:cls="Ext.data.AbstractStore">sorters</a> and <a
 href="output/Ext.data.AbstractStore.html#Ext.data.AbstractStore-filters" ext:member="filters"
 ext:cls="Ext.data.AbstractStore">filters</a> <a href="output/Ext.data.MixedCollection.html"
 ext:cls="Ext.data.MixedCollection">MixedCollections</a>. Although this functionality is provided by AbstractStore,
 there's a good description of how to use it in the introduction of <a href="output/Ext.data.Store.html"
 ext:cls="Ext.data.Store">Ext.data.Store</a>.</p>]]></description><name>data.abstractStore</name><tag-class>org.brushingbits.jnap.ui.senchatouch.data.AbstractStore</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[If data is not specified, and if autoLoad is true or an Object, this store's load method is automatically called after
 creation. If the value of autoLoad is an Object, this Object will be passed to the store's load method. Defaults to
 false.]]></description><name>autoLoad</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically sync the Store with its Proxy after every edit to one of its Records. Defaults to false.]]></description><name>autoSave</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A config object containing one or more event handlers to be added to this object during initialization. This should be a
 valid listeners config object as specified in the addListener example for attaching multiple handlers at once. DOM
 events from ExtJs Components While some ExtJs Component classes export selected DOM events (e.g. "click", "mouseover"
 etc), this is usually only done when extra value can be added. For example the DataView's click event passing the node
 clicked on. To access DOM events directly from a child element of a Component, we need to specify the element option to
 identify the Component property to add a DOM listener to: new Ext.Panel({
     width: 400,
     height: 200,
    
 dockedItems: [{
         xtype: 'toolbar'
     }],
     listeners: {
         click: {
             element: 'el', //bind to
 the underlying el property on the panel
             fn: function(){ console.log('click el'); }
         },
        
 dblclick: {
             element: 'body', //bind to the underlying body property on the panel
             fn: function(){
 console.log('dblclick body'); }
         }
     }
 });]]></description><name>listeners</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Proxy to use for this Store. This can be either a string, a config object or a Proxy instance - see setProxy for
 details.]]></description><name>proxy</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional unique identifier for this store. If present, this Store will be registered with the Ext.StoreMgr, making it
 easy to reuse elsewhere. Defaults to undefined.]]></description><name>storeId</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original SenchaTouch API docs:
 <a href="http://docs.sencha.com/touch/">http://docs.sencha.com/touch/</a>

 <p>AjaxProxy is one of the most widely-used ways of getting data into your application. It uses AJAX requests to load
 data from the server, usually to be placed into a <a href="output/Ext.data.Store.html"
 ext:cls="Ext.data.Store">Store</a>. Let's take a look at a typical setup. Here we're going to set up a Store that has an
 AjaxProxy. To prepare, we'll also set up a <a href="output/Ext.data.Model.html" ext:cls="Ext.data.Model">Model</a>:</p>
 
 <pre><code>Ext.regModel(<em>'User'</em>, {
     fields: [<em>'id'</em>, <em>'name'</em>, <em>'email'</em>]
 });
 
 <i>//The
 Store contains the AjaxProxy as an inline configuration</i>
 <b>var</b> store = <b>new</b> Ext.data.Store({
     model:
 <em>'User'</em>,
     proxy: {
         type: <em>'ajax'</em>,
         url : <em>'users.json'</em>
    
 }
 });
 
 store.load();</code></pre> 
 <p>Our example is going to load user data into a Store, so we start off by defining a
 <a href="output/Ext.data.Model.html" ext:cls="Ext.data.Model">Model</a> with the fields that we expect the server to
 return. Next we set up the Store itself, along with a <a href="output/Ext.data.AjaxProxy.html#Ext.data.AjaxProxy-proxy"
 ext:member="proxy" ext:cls="Ext.data.AjaxProxy">proxy</a> configuration. This configuration was automatically turned
 into an Ext.data.AjaxProxy instance, with the url we specified being passed into AjaxProxy's constructor. It's as if
 we'd done this:</p> 
 <pre><code><b>new</b> Ext.data.AjaxProxy({
     url: <em>'users.json'</em>,
     model:
 <em>'User'</em>,
     reader: <em>'json'</em>
 });</code></pre> 
 <p>A couple of extra configurations appeared here - <a
 href="output/Ext.data.AjaxProxy.html#Ext.data.AjaxProxy-model" ext:member="model" ext:cls="Ext.data.AjaxProxy">model</a>
 and <a href="output/Ext.data.AjaxProxy.html#Ext.data.AjaxProxy-reader" ext:member="reader"
 ext:cls="Ext.data.AjaxProxy">reader</a>. These are set by default when we create the proxy via the Store - the Store
 already knows about the Model, and Proxy's default <a href="output/Ext.data.Reader.html"
 ext:cls="Ext.data.Reader">Reader</a> is <a href="output/Ext.data.JsonReader.html"
 ext:cls="Ext.data.JsonReader">JsonReader</a>.</p> 
 <p>Now when we call store.load(), the AjaxProxy springs into action,
 making a request to the url we configured ('users.json' in this case). As we're performing a read, it sends a GET
 request to that url (see <a href="output/Ext.data.AjaxProxy.html#Ext.data.AjaxProxy-actionMethods"
 ext:member="actionMethods" ext:cls="Ext.data.AjaxProxy">actionMethods</a> to customize this - by default any kind of
 read will be sent as a GET request and any kind of write will be sent as a POST request).</p> 
 <p><u>Limitations</u></p>
 
 <p>AjaxProxy cannot be used to retrieve data from other domains. If your application is running on http://domainA.com
 it cannot load data from http://domainB.com because browsers have a built-in security policy that prohibits domains
 talking to each other via AJAX.</p> 
 <p>If you need to read data from another domain and can't set up a proxy server
 (some software that runs on your own domain's web server and transparently forwards requests to http://domainB.com,
 making it look like they actually came from http://domainA.com), you can use <a
 href="output/Ext.data.ScriptTagProxy.html" ext:cls="Ext.data.ScriptTagProxy">Ext.data.ScriptTagProxy</a> and a technique
 known as JSON-P (JSON with Padding), which can help you get around the problem so long as the server on
 http://domainB.com is set up to support JSON-P responses. See <a href="output/Ext.data.ScriptTagProxy.html"
 ext:cls="Ext.data.ScriptTagProxy">ScriptTagProxy</a>'s introduction docs for more details.</p> 
 <p><u>Readers and
 Writers</u></p> 
 <p>AjaxProxy can be configured to use any type of <a href="output/Ext.data.Reader.html"
 ext:cls="Ext.data.Reader">Reader</a> to decode the server's response. If no Reader is supplied, AjaxProxy will default
 to using a <a href="output/Ext.data.JsonReader.html" ext:cls="Ext.data.JsonReader">JsonReader</a>. Reader configuration
 can be passed in as a simple object, which the Proxy automatically turns into a <a href="output/Ext.data.Reader.html"
 ext:cls="Ext.data.Reader">Reader</a> instance:</p> 
 <pre><code><b>var</b> proxy = <b>new</b> Ext.data.AjaxProxy({
    
 model: <em>'User'</em>,
     reader: {
         type: <em>'xml'</em>,
         root: <em>'users'</em>
    
 }
 });
 
 proxy.getReader(); <i>//returns an <a href="output/Ext.data.XmlReader.html"
 ext:cls="Ext.data.XmlReader">XmlReader</a> instance based on the config we supplied</i></code></pre> 
 <p><u>Url
 generation</u></p> 
 <p>AjaxProxy automatically inserts any sorting, filtering, paging and grouping options into the url
 it generates for each request. These are controlled with the following configuration options:</p> 
 <ul
 style="list-style-type: disc; padding-left: 20px;"> 
  <li><a
 href="output/Ext.data.AjaxProxy.html#Ext.data.AjaxProxy-pageParam" ext:member="pageParam"
 ext:cls="Ext.data.AjaxProxy">pageParam</a> - controls how the page number is sent to the server (see also <a
 href="output/Ext.data.AjaxProxy.html#Ext.data.AjaxProxy-startParam" ext:member="startParam"
 ext:cls="Ext.data.AjaxProxy">startParam</a> and <a href="output/Ext.data.AjaxProxy.html#Ext.data.AjaxProxy-limitParam"
 ext:member="limitParam" ext:cls="Ext.data.AjaxProxy">limitParam</a>)</li> 
  <li><a
 href="output/Ext.data.AjaxProxy.html#Ext.data.AjaxProxy-sortParam" ext:member="sortParam"
 ext:cls="Ext.data.AjaxProxy">sortParam</a> - controls how sort information is sent to the server</li> 
  <li><a
 href="output/Ext.data.AjaxProxy.html#Ext.data.AjaxProxy-groupParam" ext:member="groupParam"
 ext:cls="Ext.data.AjaxProxy">groupParam</a> - controls how grouping information is sent to the server</li> 
  <li><a
 href="output/Ext.data.AjaxProxy.html#Ext.data.AjaxProxy-filterParam" ext:member="filterParam"
 ext:cls="Ext.data.AjaxProxy">filterParam</a> - controls how filter information is sent to the server</li> 
 </ul>
 
 <p>Each request sent by AjaxProxy is described by an <a href="output/Ext.data.Operation.html"
 ext:cls="Ext.data.Operation">Operation</a>. To see how we can customize the generated urls, let's say we're loading the
 Proxy with the following Operation:</p> 
 <pre><code><b>var</b> operation = <b>new</b> Ext.data.Operation({
     action:
 <em>'read'</em>,
     page  : 2
 });</code></pre> 
 <p>Now we'll issue the request for this Operation by calling <a
 href="output/Ext.data.AjaxProxy.html#Ext.data.AjaxProxy-read" ext:member="read"
 ext:cls="Ext.data.AjaxProxy">read</a>:</p> 
 <pre><code><b>var</b> proxy = <b>new</b> Ext.data.AjaxProxy({
     url:
 <em>'/users'</em>
 });
 
 proxy.read(operation); <i>//GET /users?page=2</i></code></pre> 
 <p>Easy enough - the Proxy just
 copied the page property from the Operation. We can customize how this page data is sent to the server:</p>
 
 <pre><code><b>var</b> proxy = <b>new</b> Ext.data.AjaxProxy({
     url: <em>'/users'</em>,
     pagePage:
 <em>'pageNumber'</em>
 });
 
 proxy.read(operation); <i>//GET /users?pageNumber=2</i></code></pre> 
 <p>Alternatively, our
 Operation could have been configured to send start and limit parameters instead of page:</p> 
 <pre><code><b>var</b>
 operation = <b>new</b> Ext.data.Operation({
     action: <em>'read'</em>,
     start : 50,
     limit : 25
 });
 
 <b>var</b>
 proxy = <b>new</b> Ext.data.AjaxProxy({
     url: <em>'/users'</em>
 });
 
 proxy.read(operation); <i>//GET
 /users?start=50&amp;limit=25</i></code></pre> 
 <p>Again we can customize this url:</p> 
 <pre><code><b>var</b> proxy =
 <b>new</b> Ext.data.AjaxProxy({
     url: <em>'/users'</em>,
     startParam: <em>'startIndex'</em>,
     limitParam:
 <em>'limitIndex'</em>
 });
 
 proxy.read(operation); <i>//GET /users?startIndex=50&amp;limitIndex=25</i></code></pre>
 
 <p>AjaxProxy will also send sort and filter information to the server. Let's take a look at how this looks with a more
 expressive Operation object:</p> 
 <pre><code><b>var</b> operation = <b>new</b> Ext.data.Operation({
     action:
 <em>'read'</em>,
     sorters: [
         <b>new</b> Ext.util.Sorter({
             property : <em>'name'</em>,
            
 direction: <em>'ASC'</em>
         }),
         <b>new</b> Ext.util.Sorter({
             property : <em>'age'</em>,
       
 direction: <em>'DESC'</em>
         })
     ],
     filters: [
         <b>new</b> Ext.util.Filter({
             property:
 <em>'eyeColor'</em>,
             value   : <em>'brown'</em>
         })
     ]
 });</code></pre> 
 <p>This is the type of
 object that is generated internally when loading a <a href="output/Ext.data.Store.html"
 ext:cls="Ext.data.Store">Store</a> with sorters and filters defined. By default the AjaxProxy will JSON encode the
 sorters and filters, resulting in something like this (note that the url is escaped before sending the request, but is
 left unescaped here for clarity):</p> 
 <pre><code><b>var</b> proxy = <b>new</b> Ext.data.AjaxProxy({
     url:
 <em>'/users'</em>
 });
 
 proxy.read(operation); <i>//GET
 /users?sort=[{<em>&quot;property&quot;</em>:<em>&quot;name&quot;</em>,<em>&quot;direction&quot;</em>:<em>&quot;ASC&quot;</em>},{<em>&quot;property&quot;</em>:<em>&quot;age&quot;</em>,<em>&quot;direction&quot;</em>:<em>&quot;DESC&quot;</em>}]&amp;filter=[{<em>&quot;property&quot;</em>:<em>&quot;eyeColor&quot;</em>,<em>&quot;value&quot;</em>:<em>&quot;brown&quot;</em>}]</i></code></pre>
 
 <p>We can again customize how this is created by supplying a few configuration options. Let's say our server is set up
 to receive sorting information is a format like &quot;sortBy=name#ASC,age#DESC&quot;. We can configure AjaxProxy to
 provide that format like this:</p> 
 <pre><code><b>var</b> proxy = <b>new</b> Ext.data.AjaxProxy({
      url:
 <em>'/users'</em>,
      sortParam: <em>'sortBy'</em>,
      filterParam: <em>'filterBy'</em>,
 
      <i>//our custom
 implementation of sorter encoding - turns our sorters into <em>&quot;name#ASC,age#DESC&quot;</em></i>
     
 encodeSorters: <b>function</b>(sorters) {
          <b>var</b> length   = sorters.length,
              sortStrs = [],
    
 sorter, i;
 
          <b>for</b> (i = 0; i &lt; length; i++) {
              sorter = sorters[i];
 
             
 sortStrs[i] = sorter.property + <em>'#'</em> + sorter.direction
          }
 
          <b>return</b>
 sortStrs.join(<em>&quot;,&quot;</em>);
      }
  });
 
  proxy.read(operation); <i>//GET
 /users?sortBy=name#ASC,age#DESC&amp;filterBy=[{<em>&quot;property&quot;</em>:<em>&quot;eyeColor&quot;</em>,<em>&quot;value&quot;</em>:<em>&quot;brown&quot;</em>}]</i></code></pre>
 
 <p>We can also provide a custom <a href="output/Ext.data.AjaxProxy.html#Ext.data.AjaxProxy-encodeFilters"
 ext:member="encodeFilters" ext:cls="Ext.data.AjaxProxy">encodeFilters</a> function to encode our filters.</p>]]></description><name>data.ajaxProxy</name><tag-class>org.brushingbits.jnap.ui.senchatouch.data.AjaxProxy</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[Comma-separated ordering 'create', 'update' and 'destroy' actions when batching. Override this to set a different order
 for the batched CRUD actions to be executed in. Defaults to 'create,update,destroy']]></description><name>batchOrder</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The name of the cache param added to the url when using noCache (defaults to "_dc")]]></description><name>cacheString</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Extra parameters that will be included on every request. Individual requests with params of the same name will override
 these params when they are in conflict.]]></description><name>extraParams</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The name of the 'filter' parameter to send in a request. Defaults to 'filter'. Set this to undefined if you don't want
 to send a filter parameter]]></description><name>filterParam</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The name of the 'group' parameter to send in a request. Defaults to 'group'. Set this to undefined if you don't want to
 send a group parameter]]></description><name>groupParam</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Any headers to add to the Ajax request. Defaults to undefined.]]></description><name>headers</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The name of the 'limit' parameter to send in a request. Defaults to 'limit'. Set this to undefined if you don't want to
 send a limit parameter]]></description><name>limitParam</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A config object containing one or more event handlers to be added to this object during initialization. This should be a
 valid listeners config object as specified in the addListener example for attaching multiple handlers at once. DOM
 events from ExtJs Components While some ExtJs Component classes export selected DOM events (e.g. "click", "mouseover"
 etc), this is usually only done when extra value can be added. For example the DataView's click event passing the node
 clicked on. To access DOM events directly from a child element of a Component, we need to specify the element option to
 identify the Component property to add a DOM listener to: new Ext.Panel({
     width: 400,
     height: 200,
    
 dockedItems: [{
         xtype: 'toolbar'
     }],
     listeners: {
         click: {
             element: 'el', //bind to
 the underlying el property on the panel
             fn: function(){ console.log('click el'); }
         },
        
 dblclick: {
             element: 'body', //bind to the underlying body property on the panel
             fn: function(){
 console.log('dblclick body'); }
         }
     }
 });]]></description><name>listeners</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The name of the Model to tie to this Proxy. Can be either the string name of the Model, or a reference to the Model
 constructor. Required.]]></description><name>model</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to true. Disable caching by adding a unique parameter name to the request.]]></description><name>noCache</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The name of the 'page' parameter to send in a request. Defaults to 'page'. Set this to undefined if you don't want to
 send a page parameter]]></description><name>pageParam</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.data.Reader to use to decode the server's response. This can either be a Reader instance, a config object or
 just a valid Reader type name (e.g. 'json', 'xml').]]></description><name>reader</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The name of the 'sort' parameter to send in a request. Defaults to 'sort'. Set this to undefined if you don't want to
 send a sort parameter]]></description><name>sortParam</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The name of the 'start' parameter to send in a request. Defaults to 'start'. Set this to undefined if you don't want to
 send a start parameter]]></description><name>startParam</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The number of milliseconds to wait for a response. Defaults to 30 seconds.]]></description><name>timeout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The URL from which to request the data object.]]></description><name>url</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.data.Writer to use to encode any request sent to the server. This can either be a Writer instance, a config
 object or just a valid Writer type name (e.g. 'json', 'xml').]]></description><name>writer</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original SenchaTouch API docs:
 <a href="http://docs.sencha.com/touch/">http://docs.sencha.com/touch/</a>

 <p>Fields are used to define what a Model is. They aren't instantiated directly - instead, <a
 href="output/Ext.html#Ext-regModel" ext:member="regModel" ext:cls="Ext">Ext.regModel</a> creates a Field instance for
 each field configured in a <a href="output/Ext.data.Model.html" ext:cls="Ext.data.Model">Model</a>. For example, we
 might set up a model like this:</p> 
 <pre><code>Ext.regModel(<em>'User'</em>, {
     fields: [
         <em>'name'</em>,
 <em>'email'</em>,
         {name: <em>'age'</em>, type: <em>'int'</em>},
         {name: <em>'gender'</em>, type:
 <em>'string'</em>, defaultValue: <em>'Unknown'</em>}
     ]
 });</code></pre> 
 <p>Four fields will have been created for
 the User Model - name, email, age and gender. Note that we specified a couple of different formats here; if we only pass
 in the string name of the field (as with name and email), the field is set up with the 'auto' type. It's as if we'd done
 this instead:</p> 
 <pre><code>Ext.regModel(<em>'User'</em>, {
     fields: [
         {name: <em>'name'</em>, type:
 <em>'auto'</em>},
         {name: <em>'email'</em>, type: <em>'auto'</em>},
         {name: <em>'age'</em>, type:
 <em>'int'</em>},
         {name: <em>'gender'</em>, type: <em>'string'</em>, defaultValue: <em>'Unknown'</em>}
    
 ]
 });</code></pre> 
 <p><u>Types and conversion</u></p> 
 <p>The <a href="output/Ext.data.Field.html#Ext.data.Field-type"
 ext:member="type" ext:cls="Ext.data.Field">type</a> is important - it's used to automatically convert data passed to the
 field into the correct format. In our example above, the name and email fields used the 'auto' type and will just accept
 anything that is passed into them. The 'age' field had an 'int' type however, so if we passed 25.4 this would be rounded
 to 25.</p> 
 <p>Sometimes a simple type isn't enough, or we want to perform some processing when we load a Field's data.
 We can do this using a <a href="output/Ext.data.Field.html#Ext.data.Field-convert" ext:member="convert"
 ext:cls="Ext.data.Field">convert</a> function. Here, we're going to create a new field based on another:</p>
 
 <code></code>
 <pre><code>
 Ext.regModel(<em>'User'</em>, {
     fields: [
         <em>'name'</em>, <em>'email'</em>,
     
 {name: <em>'age'</em>, type: <em>'int'</em>},
         {name: <em>'gender'</em>, type: <em>'string'</em>, defaultValue:
 <em>'Unknown'</em>},
 
         {
             name: <em>'firstName'</em>,
             convert: <b>function</b>(value,
 record) {
                 <b>var</b> fullName  = record.get(<em>'name'</em>),
                     splits    =
 fullName.split(<em>&quot; &quot;</em>),
                     firstName = splits[0];
 
                 <b>return</b>
 firstName;
             }
         }
     ]
 });</code></pre> 
 <p>Now when we create a new User, the firstName is populated
 automatically based on the name:</p> 
 <code></code>
 <pre><code>
 <b>var</b> ed = Ext.ModelMgr.create({name: <em>'Ed
 Spencer'</em>}, <em>'User'</em>);
 
 console.log(ed.get(<em>'firstName'</em>)); <i>//logs <em>'Ed'</em>, based on our
 convert <b>function</b></i></code></pre> 
 <p>In fact, if we log out all of the data inside ed, we'll see this:</p>
 
 <code></code>
 <pre><code>
 console.log(ed.data);
 
 <i>//outputs this:</i>
 {
     age: 0,
     email:
 <em>&quot;&quot;</em>,
     firstName: <em>&quot;Ed&quot;</em>,
     gender: <em>&quot;Unknown&quot;</em>,
     name:
 <em>&quot;Ed Spencer&quot;</em>
 }</code></pre> 
 <p>The age field has been given a default of zero because we made it an
 int type. As an auto field, email has defaulted to an empty string. When we registered the User model we set gender's <a
 href="output/Ext.data.Field.html#Ext.data.Field-defaultValue" ext:member="defaultValue"
 ext:cls="Ext.data.Field">defaultValue</a> to 'Unknown' so we see that now. Let's correct that and satisfy ourselves that
 the types work as we expect:</p> 
 <code></code>
 <pre><code>
 ed.set(<em>'gender'</em>,
 <em>'Male'</em>);
 ed.get(<em>'gender'</em>); <i>//returns <em>'Male'</em></i>
 
 ed.set(<em>'age'</em>,
 25.4);
 ed.get(<em>'age'</em>); <i>//returns 25 - we wanted an int, not a float, so no decimal places
 allowed</i></code></pre>]]></description><name>data.field</name><tag-class>org.brushingbits.jnap.ui.senchatouch.data.Field</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[A function which converts the value provided by the Reader into an object that will be stored in the Model. It is passed
 the following parameters: v : Mixed The data value as read by the Reader, if undefined will use the configured
 defaultValue. rec : Ext.data.Model The data object containing the Model as read so far by the Reader. Note that the
 Model may not be fully populated at this point as the fields are read in the order that they are defined in your fields
 array. // example of convert function
 function fullName(v, record){
     return record.name.last + ', ' +
 record.name.first;
 }
 
 function location(v, record){
     return !record.city ? '' : (record.city + ', ' +
 record.state);
 }
 
 var Dude = Ext.regModel({
     fields: [
         {name: 'fullname',  convert: fullName},
         {name:
 'firstname', mapping: 'name.first'},
         {name: 'lastname',  mapping: 'name.last'},
         {name: 'city',
 defaultValue: 'homeless'},
         'state',
         {name: 'location',  convert: location}
     ]
 });
 
 // create the data
 store
 var store = new Ext.data.Store({
     reader: {
         type: 'json',
         model: 'Dude',
         idProperty:
 'key',
         root: 'daRoot',
         totalProperty: 'total'
     }
 });
 
 var myData = [
     { key: 1,
       name: {
 first: 'Fat',    last:  'Albert' }
       // notice no city, state provided in data object
     },
     { key: 2,
      
 name: { first: 'Barney', last:  'Rubble' },
       city: 'Bedrock', state: 'Stoneridge'
     },
     { key: 3,
       name:
 { first: 'Cliff',  last:  'Claven' },
       city: 'Boston',  state: 'MA'
     }
 ];]]></description><name>convert</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[(Optional) Used when converting received data into a Date when the type is specified as "date". A format string for the
 Date.parseDate function, or "timestamp" if the value provided by the Reader is a UNIX timestamp, or "time" if the value
 provided by the Reader is a javascript millisecond timestamp. See Date]]></description><name>dateFormat</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default value used when a Model is being created by a Reader when the item referenced by the mapping does not exist
 in the data object (i.e. undefined). (defaults to "")]]></description><name>defaultValue</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[(Optional) A path expression for use by the Ext.data.DataReader implementation that is creating the Model to extract the
 Field value from the data object. If the path expression is the same as the field name, the mapping may be omitted. The
 form of the mapping expression depends on the Reader being used. Ext.data.JsonReader The mapping is a string containing
 the javascript expression to reference the data from an element of the data item's root Array. Defaults to the field
 name. Ext.data.XmlReader The mapping is an Ext.DomQuery path to the data item relative to the DOM element that
 represents the record. Defaults to the field name. Ext.data.ArrayReader The mapping is a number indicating the Array
 index of the field's value. Defaults to the field specification's Array position. If a more complex value extraction
 strategy is required, then configure the Field with a convert function. This is passed the whole row object, and may
 interrogate it in whatever way is necessary in order to return the desired data.]]></description><name>mapping</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The name by which the field is referenced within the Model. This is referenced by, for example, the dataIndex property
 in column definition objects passed to Ext.grid.ColumnModel. Note: In the simplest case, if no properties other than
 name are required, a field definition may consist of just a String for the field name.]]></description><name>name</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Initial direction to sort ("ASC" or "DESC"). Defaults to "ASC".]]></description><name>sortDir</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A function which converts a Field's value to a comparable value in order to ensure correct sort ordering. Predefined
 functions are provided in Ext.data.SortTypes. A custom sort example: // current sort     after sort we want
 //
 +-+------+          +-+------+
 // |1|First |          |1|First |
 // |2|Last  |          |3|Second|
 // |3|Second|        
 |2|Last  |
 // +-+------+          +-+------+
 
 sortType: function(value) {
    switch (value.toLowerCase()) // native
 toLowerCase():
    {
       case 'first': return 1;
       case 'second': return 2;
       default: return 3;
    }
 }]]></description><name>sortType</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The data type for automatic conversion from received data to the stored value if convert has not been specified. This
 may be specified as a string value. Possible values are auto (Default, implies no conversion) string int float boolean
 date This may also be specified by referencing a member of the Ext.data.Types class. Developers may create their own
 application-specific data types by defining new members of the Ext.data.Types class.]]></description><name>type</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[(Optional) Use when converting received data into a Number type (either int or float). If the value cannot be parsed,
 null will be used if useNull is true, otherwise the value will be 0. Defaults to false]]></description><name>useNull</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original SenchaTouch API docs:
 <a href="http://docs.sencha.com/touch/">http://docs.sencha.com/touch/</a>

 <p>The JSON Reader is used by a Proxy to read a server response that is sent back in JSON format. This usually happens
 as a result of loading a Store - for example we might create something like this:</p>
 
 <pre><code>Ext.regModel(<em>'User'</em>, {
     fields: [<em>'id'</em>, <em>'name'</em>,
 <em>'email'</em>]
 });
 
 <b>var</b> store = <b>new</b> Ext.data.Store({
     model: <em>'User'</em>,
     proxy: {
        
 type: <em>'ajax'</em>,
         url : <em>'users.json'</em>,
         reader: {
             type: <em>'json'</em>
        
 }
     }
 });</code></pre> 
 <p>The example above creates a 'User' model. Models are explained in the <a
 href="output/Ext.data.Model.html" ext:cls="Ext.data.Model">Model</a> docs if you're not already familiar with them.</p>
 
 <p>We created the simplest type of JSON Reader possible by simply telling our <a href="output/Ext.data.Store.html"
 ext:cls="Ext.data.Store">Store</a>'s <a href="output/Ext.data.Proxy.html" ext:cls="Ext.data.Proxy">Proxy</a> that we
 want a JSON Reader. The Store automatically passes the configured model to the Store, so it is as if we passed this
 instead: </p>
 <pre><code>reader: {
     type : <em>'json'</em>,
     model: <em>'User'</em>
 }</code></pre> 
 <p>The reader
 we set up is ready to read data from our server - at the moment it will accept a response like this:</p> 
 <pre><code>[
  
 {
         <em>&quot;id&quot;</em>: 1,
         <em>&quot;name&quot;</em>: <em>&quot;Ed Spencer&quot;</em>,
        
 <em>&quot;email&quot;</em>: <em>&quot;ed@sencha.com&quot;</em>
     },
     {
         <em>&quot;id&quot;</em>: 2,
        
 <em>&quot;name&quot;</em>: <em>&quot;Abe Elias&quot;</em>,
         <em>&quot;email&quot;</em>:
 <em>&quot;abe@sencha.com&quot;</em>
     }
 ]</code></pre> 
 <p><u>Reading other JSON formats</u></p> 
 <p>If you already
 have your JSON format defined and it doesn't look quite like what we have above, you can usually pass JsonReader a
 couple of configuration options to make it parse your format. For example, we can use the <a
 href="output/Ext.data.JsonReader.html#Ext.data.JsonReader-root" ext:member="root" ext:cls="Ext.data.JsonReader">root</a>
 configuration to parse data that comes back like this:</p> 
 <pre><code>{
     <em>&quot;users&quot;</em>: [
        {
     
 <em>&quot;id&quot;</em>: 1,
            <em>&quot;name&quot;</em>: <em>&quot;Ed Spencer&quot;</em>,
           
 <em>&quot;email&quot;</em>: <em>&quot;ed@sencha.com&quot;</em>
        },
        {
            <em>&quot;id&quot;</em>:
 2,
            <em>&quot;name&quot;</em>: <em>&quot;Abe Elias&quot;</em>,
            <em>&quot;email&quot;</em>:
 <em>&quot;abe@sencha.com&quot;</em>
        }
     ]
 }</code></pre> 
 <p>To parse this we just pass in a <a
 href="output/Ext.data.JsonReader.html#Ext.data.JsonReader-root" ext:member="root" ext:cls="Ext.data.JsonReader">root</a>
 configuration that matches the 'users' above:</p> 
 <pre><code>reader: {
     type: <em>'json'</em>,
     root:
 <em>'users'</em>
 }</code></pre> 
 <p>Sometimes the JSON structure is even more complicated. Document databases like
 CouchDB often provide metadata around each record inside a nested structure like this:</p> 
 <pre><code>{
    
 <em>&quot;total&quot;</em>: 122,
     <em>&quot;offset&quot;</em>: 0,
     <em>&quot;users&quot;</em>: [
         {
        
 <em>&quot;id&quot;</em>: <em>&quot;ed-spencer-1&quot;</em>,
             <em>&quot;value&quot;</em>: 1,
            
 <em>&quot;user&quot;</em>: {
                 <em>&quot;id&quot;</em>: 1,
                 <em>&quot;name&quot;</em>:
 <em>&quot;Ed Spencer&quot;</em>,
                 <em>&quot;email&quot;</em>: <em>&quot;ed@sencha.com&quot;</em>
         
 }
         }
     ]
 }</code></pre> 
 <p>In the case above the record data is nested an additional level inside the
 &quot;users&quot; array as each &quot;user&quot; item has additional metadata surrounding it ('id' and 'value' in this
 case). To parse data out of each &quot;user&quot; item in the JSON above we need to specify the <a
 href="output/Ext.data.JsonReader.html#Ext.data.JsonReader-record" ext:member="record"
 ext:cls="Ext.data.JsonReader">record</a> configuration like this:</p> 
 <pre><code>reader: {
     type  :
 <em>'json'</em>,
     root  : <em>'users'</em>,
     record: <em>'user'</em>
 }</code></pre> 
 <p><u>Response
 metadata</u></p> 
 <p>The server can return additional data in its response, such as the <a
 href="output/Ext.data.JsonReader.html#Ext.data.JsonReader-totalProperty" ext:member="totalProperty"
 ext:cls="Ext.data.JsonReader">total number of records</a> and the <a
 href="output/Ext.data.JsonReader.html#Ext.data.JsonReader-successProperty" ext:member="successProperty"
 ext:cls="Ext.data.JsonReader">success status of the response</a>. These are typically included in the JSON response like
 this:</p> 
 <pre><code>{
     <em>&quot;total&quot;</em>: 100,
     <em>&quot;success&quot;</em>: true,
    
 <em>&quot;users&quot;</em>: [
         {
             <em>&quot;id&quot;</em>: 1,
             <em>&quot;name&quot;</em>:
 <em>&quot;Ed Spencer&quot;</em>,
             <em>&quot;email&quot;</em>: <em>&quot;ed@sencha.com&quot;</em>
         }
   
 ]
 }</code></pre> 
 <p>If these properties are present in the JSON response they can be parsed out by the JsonReader and
 used by the Store that loaded it. We can set up the names of these properties by specifying a final pair of
 configuration options:</p> 
 <pre><code>reader: {
     type : <em>'json'</em>,
     root : <em>'users'</em>,
    
 totalProperty  : <em>'total'</em>,
     successProperty: <em>'success'</em>
 }</code></pre> 
 <p>These final options are
 not necessary to make the Reader work, but can be useful when the server needs to report an error or if it needs to
 indicate that there is a lot of data available of which only a subset is currently being returned.</p>]]></description><name>data.jsonReader</name><tag-class>org.brushingbits.jnap.ui.senchatouch.data.JsonReader</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[Name of the property within a row object that contains a record identifier value. Defaults to id]]></description><name>idProperty</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically parse models nested within other models in a response object. See the Ext.data.Reader intro docs
 for full explanation. Defaults to true.]]></description><name>implicitIncludes</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The optional location within the JSON response that the record data itself can be found at. See the JsonReader intro
 docs for more details. This is not often needed and defaults to undefined.]]></description><name>record</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Required. The name of the property which contains the Array of row objects. Defaults to undefined. An exception will be
 thrown if the root property is undefined. The data packet value for this property should be an empty array to clear the
 data or show no data.]]></description><name>root</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Name of the property from which to retrieve the success attribute. Defaults to success. See Ext.data.DataProxy.exception
 for additional information.]]></description><name>successProperty</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Name of the property from which to retrieve the total number of records in the dataset. This is only needed if the whole
 dataset is not passed in one go, but is being paged from the remote server. Defaults to total.]]></description><name>totalProperty</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original SenchaTouch API docs:
 <a href="http://docs.sencha.com/touch/">http://docs.sencha.com/touch/</a>

 <p>Writer that outputs model data in JSON format</p>]]></description><name>data.jsonWriter</name><tag-class>org.brushingbits.jnap.ui.senchatouch.data.JsonWriter</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[True to use Ext.encode() on the data before sending. Defaults to false.]]></description><name>encode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Name of the property within a row object that contains a record identifier value. Defaults to id]]></description><name>idProperty</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically parse models nested within other models in a response object. See the Ext.data.Reader intro docs
 for full explanation. Defaults to true.]]></description><name>implicitIncludes</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The key under which the records in this Writer will be placed. Defaults to 'records'. Example generated request:
 {'records': [{name: 'my record'}, {name: 'another record'}]}]]></description><name>root</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Name of the property from which to retrieve the success attribute. Defaults to success. See Ext.data.DataProxy.exception
 for additional information.]]></description><name>successProperty</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Name of the property from which to retrieve the total number of records in the dataset. This is only needed if the whole
 dataset is not passed in one go, but is being paged from the remote server. Defaults to total.]]></description><name>totalProperty</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original SenchaTouch API docs:
 <a href="http://docs.sencha.com/touch/">http://docs.sencha.com/touch/</a>

 <p>In-memory proxy. This proxy simply uses a local variable for data storage/retrieval, so its contents are lost on
 every page refresh.</p> 
 <p>Usually this Proxy isn't used directly, serving instead as a helper to a <a
 href="output/Ext.data.Store.html" ext:cls="Ext.data.Store">Store</a> where a reader is required to load data. For
 example, say we have a Store for a User model and have some inline data we want to load, but this data isn't in quite
 the right format: we can use a MemoryProxy with a JsonReader to read it into our Store:</p> 
 <pre><code><i>//this is the
 model we will be using <b>in</b> the store</i>
 Ext.regModel(<em>'User'</em>, {
     fields: [
         {name:
 <em>'id'</em>,    type: <em>'int'</em>},
         {name: <em>'name'</em>,  type: <em>'string'</em>},
         {name:
 <em>'phone'</em>, type: <em>'string'</em>, mapping: <em>'phoneNumber'</em>}
     ]
 });
 
 <i>//this data does not line up
 to our model fields - the phone field is called phoneNumber</i>
 <b>var</b> data = {
     users: [
         {
            
 id: 1,
             name: <em>'Ed Spencer'</em>,
             phoneNumber: <em>'555 1234'</em>
         },
         {
       
 id: 2,
             name: <em>'Abe Elias'</em>,
             phoneNumber: <em>'666 1234'</em>
         }
    
 ]
 };
 
 <i>//note how we set the <em>'root'</em> <b>in</b> the reader to match the data structure above</i>
 <b>var</b>
 store = <b>new</b> Ext.data.Store({
     autoLoad: true,
     model: <em>'User'</em>,
     data : data,
     proxy: {
       
 type: <em>'memory'</em>,
         reader: {
             type: <em>'json'</em>,
             root: <em>'users'</em>
        
 }
     }
 });</code></pre>]]></description><name>data.memoryProxy</name><tag-class>org.brushingbits.jnap.ui.senchatouch.data.MemoryProxy</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[Comma-separated ordering 'create', 'update' and 'destroy' actions when batching. Override this to set a different order
 for the batched CRUD actions to be executed in. Defaults to 'create,update,destroy']]></description><name>batchOrder</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional array of Records to load into the Proxy]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A config object containing one or more event handlers to be added to this object during initialization. This should be a
 valid listeners config object as specified in the addListener example for attaching multiple handlers at once. DOM
 events from ExtJs Components While some ExtJs Component classes export selected DOM events (e.g. "click", "mouseover"
 etc), this is usually only done when extra value can be added. For example the DataView's click event passing the node
 clicked on. To access DOM events directly from a child element of a Component, we need to specify the element option to
 identify the Component property to add a DOM listener to: new Ext.Panel({
     width: 400,
     height: 200,
    
 dockedItems: [{
         xtype: 'toolbar'
     }],
     listeners: {
         click: {
             element: 'el', //bind to
 the underlying el property on the panel
             fn: function(){ console.log('click el'); }
         },
        
 dblclick: {
             element: 'body', //bind to the underlying body property on the panel
             fn: function(){
 console.log('dblclick body'); }
         }
     }
 });]]></description><name>listeners</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The name of the Model to tie to this Proxy. Can be either the string name of the Model, or a reference to the Model
 constructor. Required.]]></description><name>model</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original SenchaTouch API docs:
 <a href="http://docs.sencha.com/touch/">http://docs.sencha.com/touch/</a>

 <p>A Model represents some object that your application manages. For example, one might define a Model for Users,
 Products, Cars, or any other real-world object that we want to model in the system. Models are registered via the <a
 href="output/Ext.ModelMgr.html" ext:cls="Ext.ModelMgr">model manager</a>, and are used by <a
 href="output/Ext.data.Store.html" ext:cls="Ext.data.Store">stores</a>, which are in turn used by many of the data-bound
 components in Ext.</p> 
 <p>Models are defined as a set of fields and any arbitrary methods and properties relevant to
 the model. For example:</p> 
 <pre><code>Ext.regModel(<em>'User'</em>, {
     fields: [
         {name: <em>'name'</em>, 
 type: <em>'string'</em>},
         {name: <em>'age'</em>,   type: <em>'int'</em>},
         {name: <em>'phone'</em>, type:
 <em>'string'</em>},
         {name: <em>'alive'</em>, type: <em>'boolean'</em>, defaultValue: true}
     ],
 
    
 changeName: <b>function</b>() {
         <b>var</b> oldName = this.get(<em>'name'</em>),
             newName = oldName +
 <em>&quot; The Barbarian&quot;</em>;
 
         this.set(<em>'name'</em>, newName);
     }
 });</code></pre> 
 <p>The fields
 array is turned into a <a href="output/Ext.util.MixedCollection.html"
 ext:cls="Ext.util.MixedCollection">MixedCollection</a> automatically by the <a href="output/Ext.ModelMgr.html"
 ext:cls="Ext.ModelMgr">ModelMgr</a>, and all other functions and properties are copied to the new Model's prototype.</p>
 
 <p>Now we can create instances of our User model and call any model logic we defined:</p> 
 <pre><code><b>var</b> user =
 Ext.ModelMgr.create({
     name : <em>'Conan'</em>,
     age  : 24,
     phone: <em>'555-555-5555'</em>
 },
 <em>'User'</em>);
 
 user.changeName();
 user.get(<em>'name'</em>); <i>//returns <em>&quot;Conan The
 Barbarian&quot;</em></i></code></pre> 
 <p><u>Validations</u></p> 
 <p>Models have built-in support for validations, which
 are executed against the validator functions in <a href="output/Ext.data.validations.html"
 ext:cls="Ext.data.validations">Ext.data.validations</a> (<a href="output/Ext.data.validations.html"
 ext:cls="Ext.data.validations">see all validation functions</a>). Validations are easy to add to models:</p>
 
 <pre><code>Ext.regModel(<em>'User'</em>, {
     fields: [
         {name: <em>'name'</em>,     type: <em>'string'</em>},
 
 {name: <em>'age'</em>,      type: <em>'int'</em>},
         {name: <em>'phone'</em>,    type: <em>'string'</em>},
        
 {name: <em>'gender'</em>,   type: <em>'string'</em>},
         {name: <em>'username'</em>, type: <em>'string'</em>},
     
 {name: <em>'alive'</em>,    type: <em>'boolean'</em>, defaultValue: true}
     ],
 
     validations: [
         {type:
 <em>'presence'</em>,  field: <em>'age'</em>},
         {type: <em>'length'</em>,    field: <em>'name'</em>,     min: 2},
 
 {type: <em>'inclusion'</em>, field: <em>'gender'</em>,   list: [<em>'Male'</em>, <em>'Female'</em>]},
         {type:
 <em>'exclusion'</em>, field: <em>'username'</em>, list: [<em>'Admin'</em>, <em>'Operator'</em>]},
         {type:
 <em>'format'</em>,    field: <em>'username'</em>, matcher: /([a-z]+)[0-9]{2,3}/}
     ]
 });</code></pre> 
 <p>The
 validations can be run by simply calling the <a href="output/Ext.data.Model.html#Ext.data.Model-validate"
 ext:member="validate" ext:cls="Ext.data.Model">validate</a> function, which returns a <a
 href="output/Ext.data.Errors.html" ext:cls="Ext.data.Errors">Ext.data.Errors</a> object:</p> 
 <pre><code><b>var</b>
 instance = Ext.ModelMgr.create({
     name: <em>'Ed'</em>,
     gender: <em>'Male'</em>,
     username:
 <em>'edspencer'</em>
 }, <em>'User'</em>);
 
 <b>var</b> errors = instance.validate();</code></pre>
 
 <p><u>Associations</u></p> 
 <p>Models can have associations with other Models via <a
 href="output/Ext.data.BelongsToAssociation.html" ext:cls="Ext.data.BelongsToAssociation">belongsTo</a> and <a
 href="output/Ext.data.HasManyAssociation.html" ext:cls="Ext.data.HasManyAssociation">hasMany</a> associations. For
 example, let's say we're writing a blog administration application which deals with Users, Posts and Comments. We can
 express the relationships between these models like this:</p> 
 <pre><code>Ext.regModel(<em>'Post'</em>, {
     fields:
 [<em>'id'</em>, <em>'user_id'</em>],
 
     belongsTo: <em>'User'</em>,
     hasMany  : {model: <em>'Comment'</em>, name:
 <em>'comments'</em>}
 });
 
 Ext.regModel(<em>'Comment'</em>, {
     fields: [<em>'id'</em>, <em>'user_id'</em>,
 <em>'post_id'</em>],
 
     belongsTo: <em>'Post'</em>
 });
 
 Ext.regModel(<em>'User'</em>, {
     fields: [<em>'id'</em>],
 
 
 hasMany: [
         <em>'Post'</em>,
         {model: <em>'Comment'</em>, name: <em>'comments'</em>}
    
 ]
 });</code></pre> 
 <p>See the docs for <a href="output/Ext.data.BelongsToAssociation.html"
 ext:cls="Ext.data.BelongsToAssociation">Ext.data.BelongsToAssociation</a> and <a
 href="output/Ext.data.HasManyAssociation.html" ext:cls="Ext.data.HasManyAssociation">Ext.data.HasManyAssociation</a> for
 details on the usage and configuration of associations. Note that associations can also be specified like this:</p>
 
 <pre><code>Ext.regModel(<em>'User'</em>, {
     fields: [<em>'id'</em>],
 
     associations: [
         {type:
 <em>'hasMany'</em>, model: <em>'Post'</em>,    name: <em>'posts'</em>},
         {type: <em>'hasMany'</em>, model:
 <em>'Comment'</em>, name: <em>'comments'</em>}
     ]
 });</code></pre> 
 <p><u>Using a Proxy</u></p> 
 <p>Models are great
 for representing types of data and relationships, but sooner or later we're going to want to load or save that data
 somewhere. All loading and saving of data is handled via a <a href="output/Ext.data.Proxy.html"
 ext:cls="Ext.data.Proxy">Proxy</a>, which can be set directly on the Model:</p>
 
 <pre><code>Ext.regModel(<em>'User'</em>, {
     fields: [<em>'id'</em>, <em>'name'</em>, <em>'email'</em>],
 
     proxy:
 {
         type: <em>'rest'</em>,
         url : <em>'/users'</em>
     }
 });</code></pre> 
 <p>Here we've set up a <a
 href="output/Ext.data.RestProxy.html" ext:cls="Ext.data.RestProxy">Rest Proxy</a>, which knows how to load and save data
 to and from a RESTful backend. Let's see how this works:</p> 
 <pre><code><b>var</b> user = Ext.ModelMgr.create({name:
 <em>'Ed Spencer'</em>, email: <em>'ed@sencha.com'</em>}, <em>'User'</em>);
 
 user.save(); <i>//POST
 /users</i></code></pre> 
 <p>Calling <a href="output/Ext.data.Model.html#Ext.data.Model-save" ext:member="save"
 ext:cls="Ext.data.Model">save</a> on the new Model instance tells the configured RestProxy that we wish to persist this
 Model's data onto our server. RestProxy figures out that this Model hasn't been saved before because it doesn't have an
 id, and performs the appropriate action - in this case issuing a POST request to the url we configured (/users). We
 configure any Proxy on any Model and always follow this API - see <a href="output/Ext.data.Proxy.html"
 ext:cls="Ext.data.Proxy">Ext.data.Proxy</a> for a full list.</p> 
 <p>Loading data via the Proxy is equally easy:</p>
 
 <pre><code><i>//get a reference to the User model class</i>
 <b>var</b> User =
 Ext.ModelMgr.getModel(<em>'User'</em>);
 
 <i>//Uses the configured RestProxy to make a GET request to
 /users/123</i>
 User.load(123, {
     success: <b>function</b>(user) {
         console.log(user.getId()); <i>//logs
 123</i>
     }
 });</code></pre> 
 <p>Models can also be updated and destroyed easily:</p> 
 <pre><code><i>//the user Model
 we loaded <b>in</b> the last snippet:</i>
 user.set(<em>'name'</em>, <em>'Edward Spencer'</em>);
 
 <i>//tells the Proxy to
 save the Model. In this <b>case</b> it will perform a PUT request to /users/123 as this Model already has an
 id</i>
 user.save({
     success: <b>function</b>() {
         console.log(<em>'The User was updated'</em>);
    
 }
 });
 
 <i>//tells the Proxy to destroy the Model. Performs a DELETE request to /users/123</i>
 user.destroy({
    
 success: <b>function</b>() {
         console.log(<em>'The User was destroyed!'</em>);
     }
 });</code></pre>
 
 <p><u>Usage in Stores</u></p> 
 <p>It is very common to want to load a set of Model instances to be displayed and
 manipulated in the UI. We do this by creating a <a href="output/Ext.data.Store.html"
 ext:cls="Ext.data.Store">Store</a>:</p> 
 <pre><code><b>var</b> store = <b>new</b> Ext.data.Store({
     model:
 <em>'User'</em>
 });
 
 <i>//uses the Proxy we set up on Model to load the Store data</i>
 store.load();</code></pre> 
 <p>A
 Store is just a collection of Model instances - usually loaded from a server somewhere. Store can also maintain a set of
 added, updated and removed Model instances to be synchronized with the server via the Proxy. See the <a
 href="output/Ext.data.Store.html" ext:cls="Ext.data.Store">Store docs</a> for more information on Stores.</p>]]></description><name>data.model</name><tag-class>org.brushingbits.jnap.ui.senchatouch.data.Model</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[The name of the field treated as this Model's unique id (defaults to 'id').]]></description><name>idProperty</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A config object containing one or more event handlers to be added to this object during initialization. This should be a
 valid listeners config object as specified in the addListener example for attaching multiple handlers at once. DOM
 events from ExtJs Components While some ExtJs Component classes export selected DOM events (e.g. "click", "mouseover"
 etc), this is usually only done when extra value can be added. For example the DataView's click event passing the node
 clicked on. To access DOM events directly from a child element of a Component, we need to specify the element option to
 identify the Component property to add a DOM listener to: new Ext.Panel({
     width: 400,
     height: 200,
    
 dockedItems: [{
         xtype: 'toolbar'
     }],
     listeners: {
         click: {
             element: 'el', //bind to
 the underlying el property on the panel
             fn: function(){ console.log('click el'); }
         },
        
 dblclick: {
             element: 'body', //bind to the underlying body property on the panel
             fn: function(){
 console.log('dblclick body'); }
         }
     }
 });]]></description><name>listeners</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The property on this Persistable object that its data is saved to. Defaults to 'data' (e.g. all persistable data resides
 in this.data.)]]></description><name>persistanceProperty</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original SenchaTouch API docs:
 <a href="http://docs.sencha.com/touch/">http://docs.sencha.com/touch/</a>]]></description><name>data.node</name><tag-class>org.brushingbits.jnap.ui.senchatouch.data.Node</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[The id for this node. If one is not specified, one is generated.]]></description><name>id</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true if this node is a leaf and does not have children]]></description><name>leaf</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A config object containing one or more event handlers to be added to this object during initialization. This should be a
 valid listeners config object as specified in the addListener example for attaching multiple handlers at once. DOM
 events from ExtJs Components While some ExtJs Component classes export selected DOM events (e.g. "click", "mouseover"
 etc), this is usually only done when extra value can be added. For example the DataView's click event passing the node
 clicked on. To access DOM events directly from a child element of a Component, we need to specify the element option to
 identify the Component property to add a DOM listener to: new Ext.Panel({
     width: 400,
     height: 200,
    
 dockedItems: [{
         xtype: 'toolbar'
     }],
     listeners: {
         click: {
             element: 'el', //bind to
 the underlying el property on the panel
             fn: function(){ console.log('click el'); }
         },
        
 dblclick: {
             element: 'body', //bind to the underlying body property on the panel
             fn: function(){
 console.log('dblclick body'); }
         }
     }
 });]]></description><name>listeners</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original SenchaTouch API docs:
 <a href="http://docs.sencha.com/touch/">http://docs.sencha.com/touch/</a>

 <p>Proxies are used by <a href="output/Ext.data.Store.html" ext:cls="Ext.data.Store">Stores</a> to handle the loading
 and saving of <a href="output/Ext.data.Model.html" ext:cls="Ext.data.Model">Model</a> data. Usually developers will not
 need to create or interact with proxies directly.</p> 
 <p><u>Types of Proxy</u></p> 
 <p>There are two main types of
 Proxy - <a href="output/Ext.data.ClientProxy.html" ext:cls="Ext.data.ClientProxy">Client</a> and <a
 href="output/Ext.data.ServerProxy.html" ext:cls="Ext.data.ServerProxy">Server</a>. The Client proxies save their data
 locally and include the following subclasses:</p> 
 <ul style="list-style-type: disc; padding-left: 25px"> 
  <li><a
 href="output/Ext.data.LocalStorageProxy.html" ext:cls="Ext.data.LocalStorageProxy">LocalStorageProxy</a> - saves its
 data to localStorage if the browser supports it</li> 
  <li><a href="output/Ext.data.SessionStorageProxy.html"
 ext:cls="Ext.data.SessionStorageProxy">SessionStorageProxy</a> - saves its data to sessionStorage if the browsers
 supports it</li> 
  <li><a href="output/Ext.data.MemoryProxy.html" ext:cls="Ext.data.MemoryProxy">MemoryProxy</a> - holds
 data in memory only, any data is lost when the page is refreshed</li> 
 </ul> 
 <p>The Server proxies save their data by
 sending requests to some remote server. These proxies include:</p> 
 <ul style="list-style-type: disc; padding-left:
 25px"> 
  <li><a href="output/Ext.data.AjaxProxy.html" ext:cls="Ext.data.AjaxProxy">AjaxProxy</a> - sends requests to a
 server on the same domain</li> 
  <li><a href="output/Ext.data.ScriptTagProxy.html"
 ext:cls="Ext.data.ScriptTagProxy">ScriptTagProxy</a> - uses JSON-P to send requests to a server on a different
 domain</li> 
 </ul> 
 <p>Proxies operate on the principle that all operations performed are either Create, Read, Update or
 Delete. These four operations are mapped to the methods <a href="output/Ext.data.Proxy.html#Ext.data.Proxy-create"
 ext:member="create" ext:cls="Ext.data.Proxy">create</a>, <a href="output/Ext.data.Proxy.html#Ext.data.Proxy-read"
 ext:member="read" ext:cls="Ext.data.Proxy">read</a>, <a href="output/Ext.data.Proxy.html#Ext.data.Proxy-update"
 ext:member="update" ext:cls="Ext.data.Proxy">update</a> and <a href="output/Ext.data.Proxy.html#Ext.data.Proxy-destroy"
 ext:member="destroy" ext:cls="Ext.data.Proxy">destroy</a> respectively. Each Proxy subclass implements these
 functions.</p> 
 <p>The CRUD methods each expect an <a href="output/Ext.data.Operation.html"
 ext:cls="Ext.data.Operation">Operation</a> object as the sole argument. The Operation encapsulates information about the
 action the Store wishes to perform, the <a href="output/Ext.data.Model.html" ext:cls="Ext.data.Model">model</a>
 instances that are to be modified, etc. See the <a href="output/Ext.data.Operation.html"
 ext:cls="Ext.data.Operation">Operation</a> documentation for more details. Each CRUD method also accepts a callback
 function to be called asynchronously on completion.</p> 
 <p>Proxies also support batching of Operations via a <a
 href="output/Ext.data.Batch.html" ext:cls="Ext.data.Batch">batch</a> object, invoked by the <a
 href="output/Ext.data.Proxy.html#Ext.data.Proxy-batch" ext:member="batch" ext:cls="Ext.data.Proxy">batch</a> method.</p>]]></description><name>data.proxy</name><tag-class>org.brushingbits.jnap.ui.senchatouch.data.Proxy</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[Comma-separated ordering 'create', 'update' and 'destroy' actions when batching. Override this to set a different order
 for the batched CRUD actions to be executed in. Defaults to 'create,update,destroy']]></description><name>batchOrder</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A config object containing one or more event handlers to be added to this object during initialization. This should be a
 valid listeners config object as specified in the addListener example for attaching multiple handlers at once. DOM
 events from ExtJs Components While some ExtJs Component classes export selected DOM events (e.g. "click", "mouseover"
 etc), this is usually only done when extra value can be added. For example the DataView's click event passing the node
 clicked on. To access DOM events directly from a child element of a Component, we need to specify the element option to
 identify the Component property to add a DOM listener to: new Ext.Panel({
     width: 400,
     height: 200,
    
 dockedItems: [{
         xtype: 'toolbar'
     }],
     listeners: {
         click: {
             element: 'el', //bind to
 the underlying el property on the panel
             fn: function(){ console.log('click el'); }
         },
        
 dblclick: {
             element: 'body', //bind to the underlying body property on the panel
             fn: function(){
 console.log('dblclick body'); }
         }
     }
 });]]></description><name>listeners</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The name of the Model to tie to this Proxy. Can be either the string name of the Model, or a reference to the Model
 constructor. Required.]]></description><name>model</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original SenchaTouch API docs:
 <a href="http://docs.sencha.com/touch/">http://docs.sencha.com/touch/</a>

 <p>RestProxy is a specialization of the <a href="output/Ext.data.AjaxProxy.html"
 ext:cls="Ext.data.AjaxProxy">AjaxProxy</a> which simply maps the four actions (create, read, update and destroy) to
 RESTful HTTP verbs. For example, let's set up a <a href="output/Ext.data.Model.html" ext:cls="Ext.data.Model">Model</a>
 with an inline RestProxy</p> 
 <pre><code>Ext.regModel(<em>'User'</em>, {
     fields: [<em>'id'</em>, <em>'name'</em>,
 <em>'email'</em>],
 
     proxy: {
         type: <em>'rest'</em>,
         url : <em>'/users'</em>
     }
 });</code></pre>
 
 <p>Now we can create a new User instance and save it via the RestProxy. Doing this will cause the Proxy to send a POST
 request to '/users': </p>
 <pre><code><b>var</b> user = Ext.ModelMgr.create({name: <em>'Ed Spencer'</em>, email:
 <em>'ed@sencha.com'</em>}, <em>'User'</em>);
 
 user.save(); <i>//POST /users</i></code></pre> 
 <p>Let's expand this a
 little and provide a callback for the <a href="output/Ext.data.Model.html#Ext.data.Model-save" ext:member="save"
 ext:cls="Ext.data.Model">Ext.data.Model.save</a> call to update the Model once it has been created. We'll assume the
 creation went successfully and that the server gave this user an ID of 123:</p> 
 <pre><code>user.save({
     success:
 <b>function</b>(user) {
         user.set(<em>'name'</em>, <em>'Khan Noonien Singh'</em>);
 
         user.save(); <i>//PUT
 /users/123</i>
     }
 });</code></pre> 
 <p>Now that we're no longer creating a new Model instance, the request method is
 changed to an HTTP PUT, targeting the relevant url for that user. Now let's delete this user, which will use the DELETE
 method:</p> 
 <pre><code>user.destroy(); <i>//DELETE /users/123</i></code></pre> 
 <p>Finally, when we perform a load of a
 Model or Store, RestProxy will use the GET method:</p> 
 <pre><code><i>//1. Load via Store</i>
 
 <i>//the Store
 automatically picks up the Proxy from the User model</i>
 <b>var</b> store = <b>new</b> Ext.data.Store({
     model:
 <em>'User'</em>
 });
 
 store.load(); <i>//GET /users</i>
 
 <i>//2. Load directly from the Model</i>
 
 <i>//GET
 /users/123</i>
 Ext.ModelMgr.getModel(<em>'User'</em>).load(123, {
     success: <b>function</b>(user) {
        
 console.log(user.getId()); <i>//outputs 123</i>
     }
 });</code></pre> 
 <p><u>Url generation</u></p> 
 <p>RestProxy is
 able to automatically generate the urls above based on two configuration options - <a
 href="output/Ext.data.RestProxy.html#Ext.data.RestProxy-appendId" ext:member="appendId"
 ext:cls="Ext.data.RestProxy">appendId</a> and <a href="output/Ext.data.RestProxy.html#Ext.data.RestProxy-format"
 ext:member="format" ext:cls="Ext.data.RestProxy">format</a>. If appendId is true (it is by default) then RestProxy will
 automatically append the ID of the Model instance in question to the configured url, resulting in the '/users/123' that
 we saw above.</p> 
 <p>If the request is not for a specific Model instance (e.g. loading a Store), the url is not
 appended with an id. RestProxy will automatically insert a '/' before the ID if one is not already present.</p>
 
 <pre><code><b>new</b> Ext.data.RestProxy({
     url: <em>'/users'</em>,
     appendId: true
 <i>//<b>default</b></i>
 });
 
 <i>// Collection url: /users</i>
 <i>// Instance url  : /users/123</i></code></pre>
 
 <p>RestProxy can also optionally append a format string to the end of any generated url:</p> 
 <pre><code><b>new</b>
 Ext.data.RestProxy({
     url: <em>'/users'</em>,
     format: <em>'json'</em>
 });
 
 <i>// Collection url:
 /users.json</i>
 <i>// Instance url  : /users/123.json</i></code></pre> 
 <p>If further customization is needed, simply
 implement the <a href="output/Ext.data.RestProxy.html#Ext.data.RestProxy-buildUrl" ext:member="buildUrl"
 ext:cls="Ext.data.RestProxy">buildUrl</a> method and add your custom generated url onto the <a
 href="output/Ext.data.Request.html" ext:cls="Ext.data.Request">Request</a> object that is passed to buildUrl. See <a
 href="source/RestProxy.html#method-Ext.data.RestProxy-buildUrl">RestProxy's implementation</a> for an example of how to
 achieve this.</p> 
 <p>Note that RestProxy inherits from <a href="output/Ext.data.AjaxProxy.html"
 ext:cls="Ext.data.AjaxProxy">AjaxProxy</a>, which already injects all of the sorter, filter, group and paging options
 into the generated url. See the <a href="output/Ext.data.AjaxProxy.html" ext:cls="Ext.data.AjaxProxy">AjaxProxy docs</a>
 for more details.</p>]]></description><name>data.restProxy</name><tag-class>org.brushingbits.jnap.ui.senchatouch.data.RestProxy</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[True to automatically append the ID of a Model instance when performing a request based on that single instance. See
 RestProxy intro docs for more details. Defaults to true.]]></description><name>appendId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Comma-separated ordering 'create', 'update' and 'destroy' actions when batching. Override this to set a different order
 for the batched CRUD actions to be executed in. Defaults to 'create,update,destroy']]></description><name>batchOrder</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The name of the cache param added to the url when using noCache (defaults to "_dc")]]></description><name>cacheString</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Extra parameters that will be included on every request. Individual requests with params of the same name will override
 these params when they are in conflict.]]></description><name>extraParams</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The name of the 'filter' parameter to send in a request. Defaults to 'filter'. Set this to undefined if you don't want
 to send a filter parameter]]></description><name>filterParam</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional data format to send to the server when making any request (e.g. 'json'). See the RestProxy intro docs for full
 details. Defaults to undefined.]]></description><name>format</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The name of the 'group' parameter to send in a request. Defaults to 'group'. Set this to undefined if you don't want to
 send a group parameter]]></description><name>groupParam</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Any headers to add to the Ajax request. Defaults to undefined.]]></description><name>headers</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The name of the 'limit' parameter to send in a request. Defaults to 'limit'. Set this to undefined if you don't want to
 send a limit parameter]]></description><name>limitParam</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A config object containing one or more event handlers to be added to this object during initialization. This should be a
 valid listeners config object as specified in the addListener example for attaching multiple handlers at once. DOM
 events from ExtJs Components While some ExtJs Component classes export selected DOM events (e.g. "click", "mouseover"
 etc), this is usually only done when extra value can be added. For example the DataView's click event passing the node
 clicked on. To access DOM events directly from a child element of a Component, we need to specify the element option to
 identify the Component property to add a DOM listener to: new Ext.Panel({
     width: 400,
     height: 200,
    
 dockedItems: [{
         xtype: 'toolbar'
     }],
     listeners: {
         click: {
             element: 'el', //bind to
 the underlying el property on the panel
             fn: function(){ console.log('click el'); }
         },
        
 dblclick: {
             element: 'body', //bind to the underlying body property on the panel
             fn: function(){
 console.log('dblclick body'); }
         }
     }
 });]]></description><name>listeners</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The name of the Model to tie to this Proxy. Can be either the string name of the Model, or a reference to the Model
 constructor. Required.]]></description><name>model</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to true. Disable caching by adding a unique parameter name to the request.]]></description><name>noCache</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The name of the 'page' parameter to send in a request. Defaults to 'page'. Set this to undefined if you don't want to
 send a page parameter]]></description><name>pageParam</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.data.Reader to use to decode the server's response. This can either be a Reader instance, a config object or
 just a valid Reader type name (e.g. 'json', 'xml').]]></description><name>reader</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The name of the 'sort' parameter to send in a request. Defaults to 'sort'. Set this to undefined if you don't want to
 send a sort parameter]]></description><name>sortParam</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The name of the 'start' parameter to send in a request. Defaults to 'start'. Set this to undefined if you don't want to
 send a start parameter]]></description><name>startParam</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The number of milliseconds to wait for a response. Defaults to 30 seconds.]]></description><name>timeout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The URL from which to request the data object.]]></description><name>url</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.data.Writer to use to encode any request sent to the server. This can either be a Writer instance, a config
 object or just a valid Writer type name (e.g. 'json', 'xml').]]></description><name>writer</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original SenchaTouch API docs:
 <a href="http://docs.sencha.com/touch/">http://docs.sencha.com/touch/</a>

 <p>ScriptTagProxy is useful when you need to load data from a domain other than the one your application is running on.
 If your application is running on http://domainA.com it cannot use <a href="output/Ext.data.AjaxProxy.html"
 ext:cls="Ext.data.AjaxProxy">Ajax</a> to load its data from http://domainB.com because cross-domain ajax requests are
 prohibited by the browser.</p> 
 <p>We can get around this using a ScriptTagProxy. ScriptTagProxy injects a
 &lt;script&gt; tag into the DOM whenever an AJAX request would usually be made. Let's say we want to load data from
 http://domainB.com/users - the script tag that would be injected might look like this:</p> 
 <pre><code>&lt;script
 src=<em>&quot;http:<i>//domainB.com/users?callback=someCallback&quot;</i></em><i>&gt;&lt;/script&gt;</i></code></pre>
 
 <p>When we inject the tag above, the browser makes a request to that url and includes the response as if it was any
 other type of JavaScript include. By passing a callback in the url above, we're telling domainB's server that we want to
 be notified when the result comes in and that it should call our callback function with the data it sends back. So long
 as the server formats the response to look like this, everything will work:</p> 
 <pre><code>someCallback({
     users: [
 
 {
             id: 1,
             name: <em>&quot;Ed Spencer&quot;</em>,
             email:
 <em>&quot;ed@sencha.com&quot;</em>
         }
     ]
 });</code></pre> 
 <p>As soon as the script finishes loading, the
 'someCallback' function that we passed in the url is called with the JSON object that the server returned.</p>
 
 <p>ScriptTagProxy takes care of all of this automatically. It formats the url you pass, adding the callback parameter
 automatically. It even creates a temporary callback function, waits for it to be called and then puts the data into the
 Proxy making it look just like you loaded it through a normal <a href="output/Ext.data.AjaxProxy.html"
 ext:cls="Ext.data.AjaxProxy">AjaxProxy</a>. Here's how we might set that up:</p>
 
 <pre><code>Ext.regModel(<em>'User'</em>, {
     fields: [<em>'id'</em>, <em>'name'</em>,
 <em>'email'</em>]
 });
 
 <b>var</b> store = <b>new</b> Ext.data.Store({
     model: <em>'User'</em>,
     proxy: {
        
 type: <em>'scripttag'</em>,
         url : <em>'http:<i>//domainB.com/users'</i></em>
    
 }
 });
 
 store.load();</code></pre> 
 <p>That's all we need to do - ScriptTagProxy takes care of the rest. In this case the
 Proxy will have injected a script tag like this: </p>
 <pre><code>&lt;script
 src=<em>&quot;http:<i>//domainB.com/users?callback=stcCallback001&quot;</i></em><i>
 id=<em>&quot;stcScript001&quot;</em>&gt;&lt;/script&gt;</i></code></pre> 
 <p><u>Customization</u></p> 
 <p>Most parts of
 this script tag can be customized using the <a
 href="output/Ext.data.ScriptTagProxy.html#Ext.data.ScriptTagProxy-callbackParam" ext:member="callbackParam"
 ext:cls="Ext.data.ScriptTagProxy">callbackParam</a>, <a
 href="output/Ext.data.ScriptTagProxy.html#Ext.data.ScriptTagProxy-callbackPrefix" ext:member="callbackPrefix"
 ext:cls="Ext.data.ScriptTagProxy">callbackPrefix</a> and <a
 href="output/Ext.data.ScriptTagProxy.html#Ext.data.ScriptTagProxy-scriptIdPrefix" ext:member="scriptIdPrefix"
 ext:cls="Ext.data.ScriptTagProxy">scriptIdPrefix</a> configurations. For example: </p>
 <pre><code><b>var</b> store =
 <b>new</b> Ext.data.Store({
     model: <em>'User'</em>,
     proxy: {
         type: <em>'scripttag'</em>,
         url :
 <em>'http:<i>//domainB.com/users'</i></em><i>,</i>
         callbackParam: <em>'theCallbackFunction'</em>,
        
 callbackPrefix: <em>'ABC'</em>,
         scriptIdPrefix: <em>'injectedScript'</em>
     }
 });
 
 store.load();</code></pre>
 
 <p>Would inject a script tag like this:</p> 
 <pre><code>&lt;script
 src=<em>&quot;http:<i>//domainB.com/users?theCallbackFunction=ABC001&quot;</i></em><i>
 id=<em>&quot;injectedScript001&quot;</em>&gt;&lt;/script&gt;</i></code></pre> 
 <p><u>Implementing on the server
 side</u></p> 
 <p>The remote server side needs to be configured to return data in this format. Here are suggestions for
 how you might achieve this using Java, PHP and ASP.net:</p> 
 <p>Java:</p> 
 <pre><code>boolean scriptTag = false;
 String
 cb = request.getParameter(<em>&quot;callback&quot;</em>);
 <b>if</b> (cb != null) {
     scriptTag = true;
    
 response.setContentType(<em>&quot;text/javascript&quot;</em>);
 } <b>else</b> {
    
 response.setContentType(<em>&quot;application/x-json&quot;</em>);
 }
 Writer out = response.getWriter();
 <b>if</b>
 (scriptTag) {
     out.write(cb + <em>&quot;(&quot;</em>);
 }
 out.print(dataBlock.toJsonString());
 <b>if</b> (scriptTag)
 {
     out.write(<em>&quot;);&quot;</em>);
 }</code></pre> 
 <p>PHP:</p> 
 <pre><code>$callback =
 $_REQUEST[<em>'callback'</em>];
 
 <i>// Create the output object.</i>
 $output = array(<em>'a'</em> =&gt;
 <em>'Apple'</em>, <em>'b'</em> =&gt; <em>'Banana'</em>);
 
 <i>//start output</i>
 <b>if</b> ($callback) {
    
 header(<em>'Content-Type: text/javascript'</em>);
     echo $callback . <em>'('</em> . json_encode($output) .
 <em>');'</em>;
 } <b>else</b> {
     header(<em>'Content-Type: application/x-json'</em>);
     echo
 json_encode($output);
 }</code></pre> 
 <p>ASP.net:</p> 
 <pre><code>String jsonString = <em>&quot;{success:
 true}&quot;</em>;
 String cb = Request.Params.Get(<em>&quot;callback&quot;</em>);
 String responseString =
 <em>&quot;&quot;</em>;
 <b>if</b> (!String.IsNullOrEmpty(cb)) {
     responseString = cb + <em>&quot;(&quot;</em> +
 jsonString + <em>&quot;)&quot;</em>;
 } <b>else</b> {
     responseString =
 jsonString;
 }
 Response.Write(responseString);</code></pre>]]></description><name>data.scriptTagProxy</name><tag-class>org.brushingbits.jnap.ui.senchatouch.data.ScriptTagProxy</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[True to automatically append the request's params to the generated url. Defaults to true]]></description><name>autoAppendParams</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Comma-separated ordering 'create', 'update' and 'destroy' actions when batching. Override this to set a different order
 for the batched CRUD actions to be executed in. Defaults to 'create,update,destroy']]></description><name>batchOrder</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The name of the cache param added to the url when using noCache (defaults to "_dc")]]></description><name>cacheString</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The name of the parameter to pass to the server which tells the server the name of the callback function set up by the
 load call to process the returned data object. Defaults to "callback". The server-side processing must read this
 parameter value, and generate javascript output which calls this named function passing the data object as its only
 parameter.]]></description><name>callbackParam</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The prefix string that is used to create a unique callback function name in the global scope. This can optionally be
 modified to give control over how the callback string passed to the remote server is generated. Defaults to
 'stcCallback']]></description><name>callbackPrefix</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Extra parameters that will be included on every request. Individual requests with params of the same name will override
 these params when they are in conflict.]]></description><name>extraParams</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The name of the 'filter' parameter to send in a request. Defaults to 'filter'. Set this to undefined if you don't want
 to send a filter parameter]]></description><name>filterParam</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The name of the 'group' parameter to send in a request. Defaults to 'group'. Set this to undefined if you don't want to
 send a group parameter]]></description><name>groupParam</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The name of the 'limit' parameter to send in a request. Defaults to 'limit'. Set this to undefined if you don't want to
 send a limit parameter]]></description><name>limitParam</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A config object containing one or more event handlers to be added to this object during initialization. This should be a
 valid listeners config object as specified in the addListener example for attaching multiple handlers at once. DOM
 events from ExtJs Components While some ExtJs Component classes export selected DOM events (e.g. "click", "mouseover"
 etc), this is usually only done when extra value can be added. For example the DataView's click event passing the node
 clicked on. To access DOM events directly from a child element of a Component, we need to specify the element option to
 identify the Component property to add a DOM listener to: new Ext.Panel({
     width: 400,
     height: 200,
    
 dockedItems: [{
         xtype: 'toolbar'
     }],
     listeners: {
         click: {
             element: 'el', //bind to
 the underlying el property on the panel
             fn: function(){ console.log('click el'); }
         },
        
 dblclick: {
             element: 'body', //bind to the underlying body property on the panel
             fn: function(){
 console.log('dblclick body'); }
         }
     }
 });]]></description><name>listeners</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The name of the Model to tie to this Proxy. Can be either the string name of the Model, or a reference to the Model
 constructor. Required.]]></description><name>model</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to true. Disable caching by adding a unique parameter name to the request.]]></description><name>noCache</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The name of the 'page' parameter to send in a request. Defaults to 'page'. Set this to undefined if you don't want to
 send a page parameter]]></description><name>pageParam</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.data.Reader to use to decode the server's response. This can either be a Reader instance, a config object or
 just a valid Reader type name (e.g. 'json', 'xml').]]></description><name>reader</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The param name to use when passing records to the server (e.g. 'records=someEncodedRecordString'). Defaults to 'records']]></description><name>recordParam</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The prefix string that is used to create a unique ID for the injected script tag element (defaults to 'stcScript')]]></description><name>scriptIdPrefix</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The name of the 'sort' parameter to send in a request. Defaults to 'sort'. Set this to undefined if you don't want to
 send a sort parameter]]></description><name>sortParam</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The name of the 'start' parameter to send in a request. Defaults to 'start'. Set this to undefined if you don't want to
 send a start parameter]]></description><name>startParam</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The number of milliseconds to wait for a response. Defaults to 30 seconds.]]></description><name>timeout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The URL from which to request the data object.]]></description><name>url</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.data.Writer to use to encode any request sent to the server. This can either be a Writer instance, a config
 object or just a valid Writer type name (e.g. 'json', 'xml').]]></description><name>writer</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original SenchaTouch API docs:
 <a href="http://docs.sencha.com/touch/">http://docs.sencha.com/touch/</a>

 <p>ServerProxy is a superclass of <a href="output/Ext.data.ScriptTagProxy.html"
 ext:cls="Ext.data.ScriptTagProxy">ScriptTagProxy</a> and <a href="output/Ext.data.AjaxProxy.html"
 ext:cls="Ext.data.AjaxProxy">AjaxProxy</a>, and would not usually be used directly.</p> 
 <p>ServerProxy should ideally
 be named HttpProxy as it is a superclass for all HTTP proxies - for Ext JS 4.x it has been called ServerProxy to enable
 any 3.x applications that reference the HttpProxy to continue to work (HttpProxy is now an alias of AjaxProxy).</p>]]></description><name>data.serverProxy</name><tag-class>org.brushingbits.jnap.ui.senchatouch.data.ServerProxy</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[Comma-separated ordering 'create', 'update' and 'destroy' actions when batching. Override this to set a different order
 for the batched CRUD actions to be executed in. Defaults to 'create,update,destroy']]></description><name>batchOrder</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The name of the cache param added to the url when using noCache (defaults to "_dc")]]></description><name>cacheString</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Extra parameters that will be included on every request. Individual requests with params of the same name will override
 these params when they are in conflict.]]></description><name>extraParams</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The name of the 'filter' parameter to send in a request. Defaults to 'filter'. Set this to undefined if you don't want
 to send a filter parameter]]></description><name>filterParam</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The name of the 'group' parameter to send in a request. Defaults to 'group'. Set this to undefined if you don't want to
 send a group parameter]]></description><name>groupParam</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The name of the 'limit' parameter to send in a request. Defaults to 'limit'. Set this to undefined if you don't want to
 send a limit parameter]]></description><name>limitParam</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A config object containing one or more event handlers to be added to this object during initialization. This should be a
 valid listeners config object as specified in the addListener example for attaching multiple handlers at once. DOM
 events from ExtJs Components While some ExtJs Component classes export selected DOM events (e.g. "click", "mouseover"
 etc), this is usually only done when extra value can be added. For example the DataView's click event passing the node
 clicked on. To access DOM events directly from a child element of a Component, we need to specify the element option to
 identify the Component property to add a DOM listener to: new Ext.Panel({
     width: 400,
     height: 200,
    
 dockedItems: [{
         xtype: 'toolbar'
     }],
     listeners: {
         click: {
             element: 'el', //bind to
 the underlying el property on the panel
             fn: function(){ console.log('click el'); }
         },
        
 dblclick: {
             element: 'body', //bind to the underlying body property on the panel
             fn: function(){
 console.log('dblclick body'); }
         }
     }
 });]]></description><name>listeners</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The name of the Model to tie to this Proxy. Can be either the string name of the Model, or a reference to the Model
 constructor. Required.]]></description><name>model</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to true. Disable caching by adding a unique parameter name to the request.]]></description><name>noCache</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The name of the 'page' parameter to send in a request. Defaults to 'page'. Set this to undefined if you don't want to
 send a page parameter]]></description><name>pageParam</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.data.Reader to use to decode the server's response. This can either be a Reader instance, a config object or
 just a valid Reader type name (e.g. 'json', 'xml').]]></description><name>reader</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The name of the 'sort' parameter to send in a request. Defaults to 'sort'. Set this to undefined if you don't want to
 send a sort parameter]]></description><name>sortParam</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The name of the 'start' parameter to send in a request. Defaults to 'start'. Set this to undefined if you don't want to
 send a start parameter]]></description><name>startParam</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The number of milliseconds to wait for a response. Defaults to 30 seconds.]]></description><name>timeout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The URL from which to request the data object.]]></description><name>url</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.data.Writer to use to encode any request sent to the server. This can either be a Writer instance, a config
 object or just a valid Writer type name (e.g. 'json', 'xml').]]></description><name>writer</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original SenchaTouch API docs:
 <a href="http://docs.sencha.com/touch/">http://docs.sencha.com/touch/</a>

 <p>The Store class encapsulates a client side cache of <a href="output/Ext.data.Model.html"
 ext:cls="Ext.data.Model">Model</a> objects. Stores load data via a <a href="output/Ext.data.Proxy.html"
 ext:cls="Ext.data.Proxy">Proxy</a>, and also provide functions for <a
 href="output/Ext.data.Store.html#Ext.data.Store-sort" ext:member="sort" ext:cls="Ext.data.Store">sorting</a>, <a
 href="output/Ext.data.Store.html#Ext.data.Store-filter" ext:member="filter" ext:cls="Ext.data.Store">filtering</a> and
 querying the <a href="output/Ext.data.Model.html" ext:cls="Ext.data.Model">model</a> instances contained within it.</p>
 
 <p>Creating a Store is easy - we just tell it the Model and the Proxy to use to load and save its data:</p>
 
 <pre><code><i>// Set up a <a href="output/Ext.data.Model.html" ext:cls="Ext.data.Model">model</a> to use <b>in</b> our
 Store</i>
 Ext.regModel(<em>'User'</em>, {
     fields: [
         {name: <em>'firstName'</em>, type: <em>'string'</em>},
  
 {name: <em>'lastName'</em>,  type: <em>'string'</em>},
         {name: <em>'age'</em>,       type: <em>'int'</em>},
      
 {name: <em>'eyeColor'</em>,  type: <em>'string'</em>}
     ]
 });
 
 <b>var</b> myStore = <b>new</b> Ext.data.Store({
    
 model: <em>'User'</em>,
     proxy: {
         type: <em>'ajax'</em>,
         url : <em>'/users.json'</em>,
        
 reader: {
             type: <em>'json'</em>,
             root: <em>'users'</em>
         }
     },
     autoLoad:
 true
 });</code></pre> 
 <p>In the example above we configured an AJAX proxy to load data from the url '/users.json'. We
 told our Proxy to use a <a href="output/Ext.data.JsonReader.html" ext:cls="Ext.data.JsonReader">JsonReader</a> to parse
 the response from the server into Model object - <a href="output/Ext.data.JsonReader.html"
 ext:cls="Ext.data.JsonReader">see the docs on JsonReader</a> for details.</p> 
 <p><u>Inline data</u></p> 
 <p>Stores can
 also load data inline. Internally, Store converts each of the objects we pass in as <a
 href="output/Ext.data.Store.html#Ext.data.Store-data" ext:member="data" ext:cls="Ext.data.Store">data</a> into Model
 instances:</p> 
 <pre><code><b>new</b> Ext.data.Store({
     model: <em>'User'</em>,
     data : [
         {firstName:
 <em>'Ed'</em>,    lastName: <em>'Spencer'</em>},
         {firstName: <em>'Tommy'</em>, lastName: <em>'Maintz'</em>},
    
 {firstName: <em>'Aaron'</em>, lastName: <em>'Conran'</em>},
         {firstName: <em>'Jamie'</em>, lastName:
 <em>'Avins'</em>}
     ]
 });</code></pre> 
 <p>Loading inline data using the method above is great if the data is in the
 correct format already (e.g. it doesn't need to be processed by a <a href="output/Ext.data.Reader.html"
 ext:cls="Ext.data.Reader">reader</a>). If your inline data requires processing to decode the data structure, use a <a
 href="output/Ext.data.MemoryProxy.html" ext:cls="Ext.data.MemoryProxy">MemoryProxy</a> instead (see the <a
 href="output/Ext.data.MemoryProxy.html" ext:cls="Ext.data.MemoryProxy">MemoryProxy</a> docs for an example).</p>
 
 <p>Additional data can also be loaded locally using <a href="output/Ext.data.Store.html#Ext.data.Store-add"
 ext:member="add" ext:cls="Ext.data.Store">add</a>.</p> 
 <p><u>Loading Nested Data</u></p> 
 <p>Applications often need to
 load sets of associated data - for example a CRM system might load a User and her Orders. Instead of issuing an AJAX
 request for the User and a series of additional AJAX requests for each Order, we can load a nested dataset and allow the
 Reader to automatically populate the associated models. Below is a brief example, see the <a
 href="output/Ext.data.Reader.html" ext:cls="Ext.data.Reader">Ext.data.Reader</a> intro docs for a full explanation:</p>
 
 <pre><code><b>var</b> store = <b>new</b> Ext.data.Store({
     autoLoad: true,
     model: <em>&quot;User&quot;</em>,
    
 proxy: {
         type: <em>'ajax'</em>,
         url : <em>'users.json'</em>,
         reader: {
             type:
 <em>'json'</em>,
             root: <em>'users'</em>
         }
     }
 });</code></pre> 
 <p>Which would consume a response
 like this:</p> 
 <pre><code>{
     <em>&quot;users&quot;</em>: [
         {
             <em>&quot;id&quot;</em>: 1,
        
 <em>&quot;name&quot;</em>: <em>&quot;Ed&quot;</em>,
             <em>&quot;orders&quot;</em>: [
                 {
        
 <em>&quot;id&quot;</em>: 10,
                     <em>&quot;total&quot;</em>: 10.76,
                    
 <em>&quot;status&quot;</em>: <em>&quot;invoiced&quot;</em>
                 },
                 {
                    
 <em>&quot;id&quot;</em>: 11,
                     <em>&quot;total&quot;</em>: 13.45,
                    
 <em>&quot;status&quot;</em>: <em>&quot;shipped&quot;</em>
                 }
             ]
         }
     ]
 }</code></pre>
 
 <p>See the <a href="output/Ext.data.Reader.html" ext:cls="Ext.data.Reader">Ext.data.Reader</a> intro docs for a full
 explanation.</p> 
 <p><u>Filtering and Sorting</u></p> 
 <p>Stores can be sorted and filtered - in both cases either
 remotely or locally. The <a href="output/Ext.data.Store.html#Ext.data.Store-sorters" ext:member="sorters"
 ext:cls="Ext.data.Store">sorters</a> and <a href="output/Ext.data.Store.html#Ext.data.Store-filters"
 ext:member="filters" ext:cls="Ext.data.Store">filters</a> are held inside <a href="output/Ext.util.MixedCollection.html"
 ext:cls="Ext.util.MixedCollection">MixedCollection</a> instances to make them easy to manage. Usually it is sufficient
 to either just specify sorters and filters in the Store configuration or call <a
 href="output/Ext.data.Store.html#Ext.data.Store-sort" ext:member="sort" ext:cls="Ext.data.Store">sort</a> or <a
 href="output/Ext.data.Store.html#Ext.data.Store-filter" ext:member="filter" ext:cls="Ext.data.Store">filter</a>:
 </p>
 <pre><code><b>var</b> store = <b>new</b> Ext.data.Store({
     model: <em>'User'</em>,
     sorters: [
         {
     
 property : <em>'age'</em>,
             direction: <em>'DESC'</em>
         },
         {
             property :
 <em>'firstName'</em>,
             direction: <em>'ASC'</em>
         }
     ],
     
     filters: [
         {
            
 property: <em>'firstName'</em>,
             value   : /Ed/
         }
     ]
 });</code></pre> 
 <p>The new Store will keep
 the configured sorters and filters in the MixedCollection instances mentioned above. By default, sorting and filtering
 are both performed locally by the Store - see <a href="output/Ext.data.Store.html#Ext.data.Store-remoteSort"
 ext:member="remoteSort" ext:cls="Ext.data.Store">remoteSort</a> and <a
 href="output/Ext.data.Store.html#Ext.data.Store-remoteFilter" ext:member="remoteFilter"
 ext:cls="Ext.data.Store">remoteFilter</a> to allow the server to perform these operations instead.</p> 
 <p>Filtering and
 sorting after the Store has been instantiated is also easy. Calling <a
 href="output/Ext.data.Store.html#Ext.data.Store-filter" ext:member="filter" ext:cls="Ext.data.Store">filter</a> adds
 another filter to the Store and automatically filters the dataset (calling <a
 href="output/Ext.data.Store.html#Ext.data.Store-filter" ext:member="filter" ext:cls="Ext.data.Store">filter</a> with no
 arguments simply re-applies all existing filters). Note that by default <a
 href="output/Ext.data.Store.html#Ext.data.Store-sortOnFilter" ext:member="sortOnFilter"
 ext:cls="Ext.data.Store">sortOnFilter</a> is set to true, which means that your sorters are automatically reapplied if
 using local sorting.</p> 
 <pre><code>store.filter(<em>'eyeColor'</em>, <em>'Brown'</em>);</code></pre> 
 <p>Change the
 sorting at any time by calling <a href="output/Ext.data.Store.html#Ext.data.Store-sort" ext:member="sort"
 ext:cls="Ext.data.Store">sort</a>:</p> 
 <pre><code>store.sort(<em>'height'</em>, <em>'ASC'</em>);</code></pre> 
 <p>Note
 that all existing sorters will be removed in favor of the new sorter data (if <a
 href="output/Ext.data.Store.html#Ext.data.Store-sort" ext:member="sort" ext:cls="Ext.data.Store">sort</a> is called with
 no arguments, the existing sorters are just reapplied instead of being removed). To keep existing sorters and add new
 ones, just add them to the MixedCollection:</p> 
 <pre><code>store.sorters.add(<b>new</b> Ext.util.Sorter({
     property
 : <em>'shoeSize'</em>,
     direction: <em>'ASC'</em>
 }));
 
 store.sort();</code></pre> 
 <p><u>Registering with
 StoreMgr</u></p> 
 <p>Any Store that is instantiated with a <a href="output/Ext.data.Store.html#Ext.data.Store-storeId"
 ext:member="storeId" ext:cls="Ext.data.Store">storeId</a> will automatically be registed with the <a
 href="output/Ext.StoreMgr.html" ext:cls="Ext.StoreMgr">StoreMgr</a>. This makes it easy to reuse the same store in
 multiple views:</p> 
 <pre><code><i>//this store can be used several times</i>
 <b>new</b> Ext.data.Store({
     model:
 <em>'User'</em>,
     storeId: <em>'usersStore'</em>
 });
 
 <b>new</b> Ext.List({
     store: <em>'usersStore'</em>,
 
    
 <i>//other config goes here</i>
 });
 
 <b>new</b> Ext.DataView({
     store: <em>'usersStore'</em>,
 
     <i>//other config
 goes here</i>
 });</code></pre> 
 <p><u>Further Reading</u></p> 
 <p>Stores are backed up by an ecosystem of classes that
 enables their operation. To gain a full understanding of these pieces and how they fit together, see:</p> 
 <ul
 style="list-style-type: disc; padding-left: 25px"> 
  <li><a href="output/Ext.data.Proxy.html"
 ext:cls="Ext.data.Proxy">Proxy</a> - overview of what Proxies are and how they are used</li> 
  <li><a
 href="output/Ext.data.Model.html" ext:cls="Ext.data.Model">Model</a> - the core class in the data package</li> 
  <li><a
 href="output/Ext.data.Reader.html" ext:cls="Ext.data.Reader">Reader</a> - used by any subclass of <a
 href="output/Ext.data.ServerProxy.html" ext:cls="Ext.data.ServerProxy">ServerProxy</a> to read a response</li> 
 </ul>]]></description><name>data.store</name><tag-class>org.brushingbits.jnap.ui.senchatouch.data.Store</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[If data is not specified, and if autoLoad is true or an Object, this store's load method is automatically called after
 creation. If the value of autoLoad is an Object, this Object will be passed to the store's load method. Defaults to
 false.]]></description><name>autoLoad</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically sync the Store with its Proxy after every edit to one of its Records. Defaults to false.]]></description><name>autoSave</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to empty the store when loading another page via loadPage, nextPage or previousPage (defaults to true). Setting to
 false keeps existing records, allowing large data sets to be loaded one page at a time but rendered all together.]]></description><name>clearOnPageLoad</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional array of Model instances or data objects to load locally. See "Inline data" above for details.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A config object containing one or more event handlers to be added to this object during initialization. This should be a
 valid listeners config object as specified in the addListener example for attaching multiple handlers at once. DOM
 events from ExtJs Components While some ExtJs Component classes export selected DOM events (e.g. "click", "mouseover"
 etc), this is usually only done when extra value can be added. For example the DataView's click event passing the node
 clicked on. To access DOM events directly from a child element of a Component, we need to specify the element option to
 identify the Component property to add a DOM listener to: new Ext.Panel({
     width: 400,
     height: 200,
    
 dockedItems: [{
         xtype: 'toolbar'
     }],
     listeners: {
         click: {
             element: 'el', //bind to
 the underlying el property on the panel
             fn: function(){ console.log('click el'); }
         },
        
 dblclick: {
             element: 'body', //bind to the underlying body property on the panel
             fn: function(){
 console.log('dblclick body'); }
         }
     }
 });]]></description><name>listeners</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Proxy to use for this Store. This can be either a string, a config object or a Proxy instance - see setProxy for
 details.]]></description><name>proxy</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to defer any filtering operation to the server. If false, filtering is done locally on the client. Defaults to
 false.]]></description><name>remoteFilter</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to defer any sorting operation to the server. If false, sorting is done locally on the client. Defaults to false.]]></description><name>remoteSort</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[For local filtering only, causes sort to be called whenever filter is called, causing the sorters to be reapplied after
 filtering. Defaults to true]]></description><name>sortOnFilter</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional unique identifier for this store. If present, this Store will be registered with the Ext.StoreMgr, making it
 easy to reuse elsewhere. Defaults to undefined.]]></description><name>storeId</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original SenchaTouch API docs:
 <a href="http://docs.sencha.com/touch/">http://docs.sencha.com/touch/</a>

 Represents a tree data structure and bubbles all the events for its nodes. The nodes in the tree have most standard DOM
 functionality.]]></description><name>data.tree</name><tag-class>org.brushingbits.jnap.ui.senchatouch.data.Tree</tag-class><body-content>scriptless</body-content><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A config object containing one or more event handlers to be added to this object during initialization. This should be a
 valid listeners config object as specified in the addListener example for attaching multiple handlers at once. DOM
 events from ExtJs Components While some ExtJs Component classes export selected DOM events (e.g. "click", "mouseover"
 etc), this is usually only done when extra value can be added. For example the DataView's click event passing the node
 clicked on. To access DOM events directly from a child element of a Component, we need to specify the element option to
 identify the Component property to add a DOM listener to: new Ext.Panel({
     width: 400,
     height: 200,
    
 dockedItems: [{
         xtype: 'toolbar'
     }],
     listeners: {
         click: {
             element: 'el', //bind to
 the underlying el property on the panel
             fn: function(){ console.log('click el'); }
         },
        
 dblclick: {
             element: 'body', //bind to the underlying body property on the panel
             fn: function(){
 console.log('dblclick body'); }
         }
     }
 });]]></description><name>listeners</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The token used to separate paths in node ids (defaults to '/').]]></description><name>pathSeparator</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original SenchaTouch API docs:
 <a href="http://docs.sencha.com/touch/">http://docs.sencha.com/touch/</a>

 <p>A store class that allows the representation of hierarchical data.</p>]]></description><name>data.treeStore</name><tag-class>org.brushingbits.jnap.ui.senchatouch.data.TreeStore</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[If data is not specified, and if autoLoad is true or an Object, this store's load method is automatically called after
 creation. If the value of autoLoad is an Object, this Object will be passed to the store's load method. Defaults to
 false.]]></description><name>autoLoad</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically sync the Store with its Proxy after every edit to one of its Records. Defaults to false.]]></description><name>autoSave</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Default to true. Remove previously existing child nodes before loading.]]></description><name>clearOnLoad</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default root id. Defaults to 'root']]></description><name>defaultRootId</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A config object containing one or more event handlers to be added to this object during initialization. This should be a
 valid listeners config object as specified in the addListener example for attaching multiple handlers at once. DOM
 events from ExtJs Components While some ExtJs Component classes export selected DOM events (e.g. "click", "mouseover"
 etc), this is usually only done when extra value can be added. For example the DataView's click event passing the node
 clicked on. To access DOM events directly from a child element of a Component, we need to specify the element option to
 identify the Component property to add a DOM listener to: new Ext.Panel({
     width: 400,
     height: 200,
    
 dockedItems: [{
         xtype: 'toolbar'
     }],
     listeners: {
         click: {
             element: 'el', //bind to
 the underlying el property on the panel
             fn: function(){ console.log('click el'); }
         },
        
 dblclick: {
             element: 'body', //bind to the underlying body property on the panel
             fn: function(){
 console.log('dblclick body'); }
         }
     }
 });]]></description><name>listeners</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The name of the parameter sent to the server which contains the identifier of the node. Defaults to 'node'.]]></description><name>nodeParam</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Proxy to use for this Store. This can be either a string, a config object or a Proxy instance - see setProxy for
 details.]]></description><name>proxy</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional unique identifier for this store. If present, this Store will be registered with the Ext.StoreMgr, making it
 easy to reuse elsewhere. Defaults to undefined.]]></description><name>storeId</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original SenchaTouch API docs:
 <a href="http://docs.sencha.com/touch/">http://docs.sencha.com/touch/</a>

 <p>WebStorageProxy is simply a superclass for the <a href="output/Ext.data.LocalStorageProxy.html"
 ext:cls="Ext.data.LocalStorageProxy">localStorage</a> and <a href="output/Ext.data.SessionStorageProxy.html"
 ext:cls="Ext.data.SessionStorageProxy">sessionStorage</a> proxies. It uses the new HTML5 key/value client-side storage
 objects to save <a href="output/Ext.data.Model.html" ext:cls="Ext.data.Model">model instances</a> for offline use.</p>]]></description><name>data.webStorageProxy</name><tag-class>org.brushingbits.jnap.ui.senchatouch.data.WebStorageProxy</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[Comma-separated ordering 'create', 'update' and 'destroy' actions when batching. Override this to set a different order
 for the batched CRUD actions to be executed in. Defaults to 'create,update,destroy']]></description><name>batchOrder</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The unique ID used as the key in which all record data are stored in the local storage object]]></description><name>id</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A config object containing one or more event handlers to be added to this object during initialization. This should be a
 valid listeners config object as specified in the addListener example for attaching multiple handlers at once. DOM
 events from ExtJs Components While some ExtJs Component classes export selected DOM events (e.g. "click", "mouseover"
 etc), this is usually only done when extra value can be added. For example the DataView's click event passing the node
 clicked on. To access DOM events directly from a child element of a Component, we need to specify the element option to
 identify the Component property to add a DOM listener to: new Ext.Panel({
     width: 400,
     height: 200,
    
 dockedItems: [{
         xtype: 'toolbar'
     }],
     listeners: {
         click: {
             element: 'el', //bind to
 the underlying el property on the panel
             fn: function(){ console.log('click el'); }
         },
        
 dblclick: {
             element: 'body', //bind to the underlying body property on the panel
             fn: function(){
 console.log('dblclick body'); }
         }
     }
 });]]></description><name>listeners</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The name of the Model to tie to this Proxy. Can be either the string name of the Model, or a reference to the Model
 constructor. Required.]]></description><name>model</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original SenchaTouch API docs:
 <a href="http://docs.sencha.com/touch/">http://docs.sencha.com/touch/</a>

 <p>The XML Reader is used by a Proxy to read a server response that is sent back in XML format. This usually happens as
 a result of loading a Store - for example we might create something like this:</p>
 
 <pre><code>Ext.regModel(<em>'User'</em>, {
     fields: [<em>'id'</em>, <em>'name'</em>,
 <em>'email'</em>]
 });
 
 <b>var</b> store = <b>new</b> Ext.data.Store({
     model: <em>'User'</em>,
     proxy: {
        
 type: <em>'ajax'</em>,
         url : <em>'users.xml'</em>,
         reader: {
             type: <em>'xml'</em>,
          
 record: <em>'user'</em>
         }
     }
 });</code></pre> 
 <p>The example above creates a 'User' model. Models are
 explained in the <a href="output/Ext.data.Model.html" ext:cls="Ext.data.Model">Model</a> docs if you're not already
 familiar with them.</p> 
 <p>We created the simplest type of XML Reader possible by simply telling our <a
 href="output/Ext.data.Store.html" ext:cls="Ext.data.Store">Store</a>'s <a href="output/Ext.data.Proxy.html"
 ext:cls="Ext.data.Proxy">Proxy</a> that we want a XML Reader. The Store automatically passes the configured model to the
 Store, so it is as if we passed this instead: </p>
 <pre><code>reader: {
     type : <em>'xml'</em>,
     model:
 <em>'User'</em>,
     record: <em>'user'</em>
 }</code></pre> 
 <p>The reader we set up is ready to read data from our
 server - at the moment it will accept a response like this:</p> 
 <pre><code>&lt;?xml version=<em>&quot;1.0&quot;</em>
 encoding=<em>&quot;UTF-8&quot;</em>?&gt;
 &lt;user&gt;
     &lt;id&gt;1&lt;/id&gt;
     &lt;name&gt;Ed
 Spencer&lt;/name&gt;
     &lt;email&gt;ed@sencha.com&lt;/email&gt;
 &lt;/user&gt;
 &lt;user&gt;
     &lt;id&gt;2&lt;/id&gt;
 
 &lt;name&gt;Abe Elias&lt;/name&gt;
     &lt;email&gt;abe@sencha.com&lt;/email&gt;
 &lt;/user&gt;</code></pre> 
 <p>The XML
 Reader uses the configured <a href="output/Ext.data.XmlReader.html#Ext.data.XmlReader-record" ext:member="record"
 ext:cls="Ext.data.XmlReader">record</a> option to pull out the data for each record - in this case we set record to
 'user', so each &lt;user&gt; above will be converted into a User model.</p> 
 <p><u>Reading other XML formats</u></p>
 
 <p>If you already have your XML format defined and it doesn't look quite like what we have above, you can usually pass
 XmlReader a couple of configuration options to make it parse your format. For example, we can use the <a
 href="output/Ext.data.XmlReader.html#Ext.data.XmlReader-root" ext:member="root" ext:cls="Ext.data.XmlReader">root</a>
 configuration to parse data that comes back like this:</p> 
 <pre><code>&lt;?xml version=<em>&quot;1.0&quot;</em>
 encoding=<em>&quot;UTF-8&quot;</em>?&gt;
 &lt;users&gt;
     &lt;user&gt;
         &lt;id&gt;1&lt;/id&gt;
        
 &lt;name&gt;Ed Spencer&lt;/name&gt;
         &lt;email&gt;ed@sencha.com&lt;/email&gt;
     &lt;/user&gt;
     &lt;user&gt;
 
 &lt;id&gt;2&lt;/id&gt;
         &lt;name&gt;Abe Elias&lt;/name&gt;
         &lt;email&gt;abe@sencha.com&lt;/email&gt;
    
 &lt;/user&gt;
 &lt;/users&gt;</code></pre> 
 <p>To parse this we just pass in a <a
 href="output/Ext.data.XmlReader.html#Ext.data.XmlReader-root" ext:member="root" ext:cls="Ext.data.XmlReader">root</a>
 configuration that matches the 'users' above:</p> 
 <pre><code>reader: {
     type  : <em>'xml'</em>,
     root  :
 <em>'users'</em>,
     record: <em>'user'</em>
 }</code></pre> 
 <p>Note that XmlReader doesn't care whether your <a
 href="output/Ext.data.XmlReader.html#Ext.data.XmlReader-root" ext:member="root" ext:cls="Ext.data.XmlReader">root</a>
 and <a href="output/Ext.data.XmlReader.html#Ext.data.XmlReader-record" ext:member="record"
 ext:cls="Ext.data.XmlReader">record</a> elements are nested deep inside a larger structure, so a response like this will
 still work: </p>
 <pre><code>&lt;?xml version=<em>&quot;1.0&quot;</em>
 encoding=<em>&quot;UTF-8&quot;</em>?&gt;
 &lt;deeply&gt;
     &lt;nested&gt;
         &lt;xml&gt;
            
 &lt;users&gt;
                 &lt;user&gt;
                     &lt;id&gt;1&lt;/id&gt;
                     &lt;name&gt;Ed
 Spencer&lt;/name&gt;
                     &lt;email&gt;ed@sencha.com&lt;/email&gt;
                 &lt;/user&gt;
         
 &lt;user&gt;
                     &lt;id&gt;2&lt;/id&gt;
                     &lt;name&gt;Abe Elias&lt;/name&gt;
          
 &lt;email&gt;abe@sencha.com&lt;/email&gt;
                 &lt;/user&gt;
             &lt;/users&gt;
         &lt;/xml&gt;
 
 &lt;/nested&gt;
 &lt;/deeply&gt;</code></pre> 
 <p><u>Response metadata</u></p> 
 <p>The server can return additional data
 in its response, such as the <a href="output/Ext.data.XmlReader.html#Ext.data.XmlReader-totalProperty"
 ext:member="totalProperty" ext:cls="Ext.data.XmlReader">total number of records</a> and the <a
 href="output/Ext.data.XmlReader.html#Ext.data.XmlReader-successProperty" ext:member="successProperty"
 ext:cls="Ext.data.XmlReader">success status of the response</a>. These are typically included in the XML response like
 this:</p> 
 <pre><code>&lt;?xml version=<em>&quot;1.0&quot;</em>
 encoding=<em>&quot;UTF-8&quot;</em>?&gt;
 &lt;total&gt;100&lt;/total&gt;
 &lt;success&gt;true&lt;/success&gt;
 &lt;users&gt;
 
 &lt;user&gt;
         &lt;id&gt;1&lt;/id&gt;
         &lt;name&gt;Ed Spencer&lt;/name&gt;
        
 &lt;email&gt;ed@sencha.com&lt;/email&gt;
     &lt;/user&gt;
     &lt;user&gt;
         &lt;id&gt;2&lt;/id&gt;
        
 &lt;name&gt;Abe Elias&lt;/name&gt;
         &lt;email&gt;abe@sencha.com&lt;/email&gt;
    
 &lt;/user&gt;
 &lt;/users&gt;</code></pre> 
 <p>If these properties are present in the XML response they can be parsed out
 by the XmlReader and used by the Store that loaded it. We can set up the names of these properties by specifying a final
 pair of configuration options:</p> 
 <pre><code>reader: {
     type: <em>'xml'</em>,
     root: <em>'users'</em>,
    
 totalProperty  : <em>'total'</em>,
     successProperty: <em>'success'</em>
 }</code></pre> 
 <p>These final options are
 not necessary to make the Reader work, but can be useful when the server needs to report an error or if it needs to
 indicate that there is a lot of data available of which only a subset is currently being returned.</p> 
 <p><u>Response
 format</u></p> 
 <p><b>Note:</b> in order for the browser to parse a returned XML document, the Content-Type header in
 the HTTP response must be set to &quot;text/xml&quot; or &quot;application/xml&quot;. This is very important - the
 XmlReader will not work correctly otherwise.</p>]]></description><name>data.xmlReader</name><tag-class>org.brushingbits.jnap.ui.senchatouch.data.XmlReader</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[Name of the property within a row object that contains a record identifier value. Defaults to id]]></description><name>idProperty</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically parse models nested within other models in a response object. See the Ext.data.Reader intro docs
 for full explanation. Defaults to true.]]></description><name>implicitIncludes</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The DomQuery path to the repeated element which contains record information. This is an alias for the root config
 option.]]></description><name>record</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Required. The name of the property which contains the Array of row objects. Defaults to undefined. An exception will be
 thrown if the root property is undefined. The data packet value for this property should be an empty array to clear the
 data or show no data.]]></description><name>root</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Name of the property from which to retrieve the success attribute. Defaults to success. See Ext.data.DataProxy.exception
 for additional information.]]></description><name>successProperty</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Name of the property from which to retrieve the total number of records in the dataset. This is only needed if the whole
 dataset is not passed in one go, but is being paged from the remote server. Defaults to total.]]></description><name>totalProperty</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original SenchaTouch API docs:
 <a href="http://docs.sencha.com/touch/">http://docs.sencha.com/touch/</a>

 <p>Writer that outputs model data in XML format</p>]]></description><name>data.xmlWriter</name><tag-class>org.brushingbits.jnap.ui.senchatouch.data.XmlWriter</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[The name of the root element of the document. Defaults to 'xmlData'.]]></description><name>documentRoot</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A header to use in the XML document (such as setting the encoding or version). Defaults to ''.]]></description><name>header</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Name of the property within a row object that contains a record identifier value. Defaults to id]]></description><name>idProperty</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically parse models nested within other models in a response object. See the Ext.data.Reader intro docs
 for full explanation. Defaults to true.]]></description><name>implicitIncludes</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The name of the node to use for each record. Defaults to 'record'.]]></description><name>record</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Required. The name of the property which contains the Array of row objects. Defaults to undefined. An exception will be
 thrown if the root property is undefined. The data packet value for this property should be an empty array to clear the
 data or show no data.]]></description><name>root</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Name of the property from which to retrieve the success attribute. Defaults to success. See Ext.data.DataProxy.exception
 for additional information.]]></description><name>successProperty</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Name of the property from which to retrieve the total number of records in the dataset. This is only needed if the whole
 dataset is not passed in one go, but is being paged from the remote server. Defaults to total.]]></description><name>totalProperty</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original SenchaTouch API docs:
 <a href="http://docs.sencha.com/touch/">http://docs.sencha.com/touch/</a>

 A mechanism for displaying data using custom layout templates and formatting. DataView uses an 
 <a
 href="output/Ext.XTemplate.html" ext:cls="Ext.XTemplate">Ext.XTemplate</a> as its internal templating mechanism, and is
 bound to an 
 <a href="output/Ext.data.Store.html" ext:cls="Ext.data.Store">Ext.data.Store</a> so that as the data in the
 store changes the view is automatically updated to reflect the changes. The view also provides built-in behavior for
 many common events that can occur for its contained items including itemtap, itemdoubletap, itemswipe, containertap,
 etc. as well as a built-in selection model. 
 <b>In order to use these features, an <a
 href="output/Ext.DataView.html#Ext.DataView-itemSelector" ext:member="itemSelector"
 ext:cls="Ext.DataView">itemSelector</a> config must be provided for the DataView to determine what nodes it will be
 working with.</b> 
 <p>The example below binds a DataView to a <a href="output/Ext.data.Store.html"
 ext:cls="Ext.data.Store">Ext.data.Store</a> and renders it into an <a href="output/Ext.Panel.html"
 ext:cls="Ext.Panel">Ext.Panel</a>.</p> 
 <pre><code><b>var</b> store = <b>new</b> Ext.data.JsonStore({
     url:
 <em>'get-images.php'</em>,
     root: <em>'images'</em>,
     fields: [
         <em>'name'</em>, <em>'url'</em>,
        
 {name:<em>'size'</em>, type: <em>'float'</em>},
         {name:<em>'lastmod'</em>, type:<em>'date'</em>,
 dateFormat:<em>'timestamp'</em>}
     ]
 });
 store.load();
 
 <b>var</b> tpl = <b>new</b> Ext.XTemplate(
     <em>'&lt;tpl
 <b>for</b>=<em>&quot;.&quot;</em>&gt;'</em>,
         <em>'&lt;div class=<em>&quot;thumb-wrap&quot;</em>
 id=<em>&quot;{name}&quot;</em>&gt;'</em>,
         <em>'&lt;div class=<em>&quot;thumb&quot;</em>&gt;&lt;img
 src=<em>&quot;{url}&quot;</em> title=<em>&quot;{name}&quot;</em>&gt;&lt;/div&gt;'</em>,
         <em>'&lt;span
 class=<em>&quot;x-editable&quot;</em>&gt;{shortName}&lt;/span&gt;&lt;/div&gt;'</em>,
     <em>'&lt;/tpl&gt;'</em>,
    
 <em>'&lt;div class=<em>&quot;x-clear&quot;</em>&gt;&lt;/div&gt;'</em>
 );
 
 <b>var</b> panel = <b>new</b> Ext.Panel({
    
 id:<em>'images-view'</em>,
     frame:true,
     width:535,
     autoHeight:true,
     collapsible:true,
    
 layout:<em>'fit'</em>,
     title:<em>'Simple DataView'</em>,
 
     items: <b>new</b> Ext.DataView({
         store:
 store,
         tpl: tpl,
         autoHeight:true,
         multiSelect: true,
         overClass:<em>'x-view-over'</em>,
  
 itemSelector:<em>'div.thumb-wrap'</em>,
         emptyText: <em>'No images to display'</em>
    
 })
 });
 panel.render(Ext.getBody());</code></pre>]]></description><name>dataView</name><tag-class>org.brushingbits.jnap.ui.senchatouch.DataView</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[Only respected if singleSelect is true. If this is set to false, a selected item will not be deselected when tapped on,
 ensuring that once an item has been selected at least one item will always be selected. Defaults to allowed (true).]]></description><name>allowDeselect</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The base CSS class to apply to this components's element. This will also be prepended to elements within this component
 like Panel's body will get a class x-panel-body. This means that if you create a subclass of Panel, and you want it to
 get all the Panels styling for the element and the body, you leave the baseCls x-panel and use componentCls to add
 specific styling for this component.]]></description><name>baseCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Set this to true to ignore datachanged events on the bound store. This is useful if you wish to provide custom
 transition animations via a plugin (defaults to false)]]></description><name>blockRefresh</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the border for this component. The border can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>border</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Center the Component. Defaults to false.]]></description><name>centered</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element (defaults to ''). This can be useful for
 adding customized styles to the component or any of its children using standard CSS rules.]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS Class to be added to a components root level element to give distinction to it via styling.]]></description><name>componentCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The sizing and positioning of the component Elements is the responsibility of the Component's layout manager which
 creates and manages the type of layout specific to the component. If the layout configuration is not explicitly
 specified for a general purpose compopnent the default layout manager will be used.]]></description><name>componentLayout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to defer emptyText being applied until the store's first load]]></description><name>deferEmptyText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to disable selection within the DataView. Defaults to false. This configuration will lock the selection model that
 the DataView uses.]]></description><name>disableSelection</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to false.]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class to add when the Component is disabled. Defaults to 'x-item-disabled'.]]></description><name>disabledCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Allows the component to be dragged via the touch event.]]></description><name>draggable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The text to display in the view when there is no data to display (defaults to '').]]></description><name>emptyText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Create the Component as a floating and use absolute positioning. Defaults to false.]]></description><name>floating</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The class that is being added to this component when its floating. (defaults to x-floating)]]></description><name>floatingCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Force the component to take up 100% width and height available. Defaults to false. Setting this configuration
 immediately sets the monitorOrientation config to true. Setting this to true will render the component instantly.]]></description><name>fullscreen</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of this component in pixels.]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to false.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically bind a tap listener to the mask that hides the window. Defaults to true. Note: if you set this
 property to false you have to programmaticaly hide the overlay.]]></description><name>hideOnMaskTap</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>itemSelector</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Set this to true to automatically relayout this component on orientation change. This property is set to true by default
 if a component is floating unless you specifically set this to false. Also note that you dont have to set this property
 to true if this component is a child of a fullscreen container, since fullscreen components are also laid out
 automatically on orientation change. Defaults to null]]></description><name>layoutOnOrientationChange</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A config object containing one or more event handlers to be added to this object during initialization. This should be a
 valid listeners config object as specified in the addListener example for attaching multiple handlers at once. DOM
 events from ExtJs Components While some ExtJs Component classes export selected DOM events (e.g. "click", "mouseover"
 etc), this is usually only done when extra value can be added. For example the DataView's click event passing the node
 clicked on. To access DOM events directly from a child element of a Component, we need to specify the element option to
 identify the Component property to add a DOM listener to: new Ext.Panel({
     width: 400,
     height: 200,
    
 dockedItems: [{
         xtype: 'toolbar'
     }],
     listeners: {
         click: {
             element: 'el', //bind to
 the underlying el property on the panel
             fn: function(){ console.log('click el'); }
         },
        
 dblclick: {
             element: 'body', //bind to the underlying body property on the panel
             fn: function(){
 console.log('dblclick body'); }
         }
     }
 });]]></description><name>listeners</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A string to display during data load operations (defaults to undefined). If specified, this text will be displayed in a
 loading div and the view's contents will be cleared while loading, otherwise the view's contents will continue to
 display normally until the new data is loaded and the contents are replaced.]]></description><name>loadingText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the margin for this component. The margin can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>margin</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this Component will set its height to. Warning: This will override any size management
 applied by layout managers.]]></description><name>maxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this Component will set its width to. Warning: This will override any size management
 applied by layout managers.]]></description><name>maxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this Component will set its height to. Warning: This will override any size management
 applied by layout managers.]]></description><name>minHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this Component will set its width to. Warning: This will override any size management
 applied by layout managers.]]></description><name>minWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to make the Component modal and mask everything behind it when displayed, false to display it without restricting
 access to other UI elements (defaults to false).]]></description><name>modal</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Monitor Orientation change]]></description><name>monitorOrientation</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to allow selection of more than one item at a time, false to allow selection of only a single item at a time or no
 selection at all, depending on the value of singleSelect (defaults to false).]]></description><name>multiSelect</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS class to apply to each item in the view on mouseover (defaults to undefined).]]></description><name>overItemCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the padding for this component. The padding can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>padding</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS class to apply to an item on the view while it is being pressed (defaults to 'x-item-pressed').]]></description><name>pressedCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The amount of delay between the tapstart and the moment we add the pressedCls. Settings this to true defaults to 100ms]]></description><name>pressedDelay</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object containing properties specifying DomQuery selectors which identify child elements created by the render
 process. After the Component's internal structure is rendered according to the renderTpl, this object is iterated
 through, and the found Elements are added as properties to the Component using the renderSelector property name. For
 example, a Component which rendered an image, and description into its element might use the following properties coded
 into its prototype: renderTpl: '"{imageUrl}" class="x-image-component-img">
 "x-image-component-desc">{description}',
 
 renderSelectors: {
     image: 'img.x-image-component-img',
     descEl:
 'div.x-image-component-desc'
 } After rendering, the Component would have a property image referencing its child img
 Element, and a property descEl referencing the div Element which contains the description.]]></description><name>renderSelectors</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An XTemplate used to create the internal structure inside this Component's encapsulating Element. You do not normally
 need to specify this. For the base classes Ext.Component and Ext.Container, this defaults to null which means that they
 will be initially rendered with no internal structure; they render their Element empty. The more specialized ExtJS and
 Touch classes which use a more complex DOM structure, provide their own template definitions. This is intended to allow
 the developer to create application-specific utility Components with customized internal structure. Upon rendering, any
 created child elements may be automatically imported into object properties using the renderSelectors option.]]></description><name>renderTpl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Configure the component to be scrollable. Acceptable values are: 'horizontal', 'vertical', 'both' to enabling scrolling
 for that direction. A Scroller configuration. false to explicitly disable scrolling. Enabling scrolling immediately sets
 the monitorOrientation config to true (for Panel)]]></description><name>scroll</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS class to apply to each selected item in the view (defaults to 'x-view-selected').]]></description><name>selectedItemCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The type of animation you want to use when this component is shown. If you set this this hide animation will
 automatically be the opposite.]]></description><name>showAnimation</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to enable multiselection by clicking on multiple items without requiring the user to hold Shift or Ctrl, false to
 force the user to hold Ctrl or Shift to select more than on item (defaults to false).]]></description><name>simpleSelect</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to allow selection of exactly one item at a time, false to allow no selection at all (defaults to false). Note that
 if multiSelect = true, this value will be ignored.]]></description><name>singleSelect</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to stop the event that fires when you click outside the floating component. Defalts to true.]]></description><name>stopMaskTapEvent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>store</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
             title: 'Some Title',
             renderTo: Ext.getBody(),
          
 width: 400, height: 300,
             layout: 'form',
             items: [{
                 xtype: 'textareafield',
      
 style: {
                     width: '95%',
                     marginBottom: '10px'
                 }
             },
    
 new Ext.Button({
                 text: 'Send',
                 minWidth: '100',
                 style: {
                
     marginBottom: '10px'
                 }
             })
             ]
         });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The class that is added to the content target when you set styleHtmlContent to true. Defaults to 'x-html']]></description><name>styleHtmlCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically style the html inside the content target of this component (body for panels). Defaults to false.]]></description><name>styleHtmlContent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>tpl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to enable mouseenter and mouseleave events]]></description><name>trackOver</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to 'singletap'. Other valid options are 'tap']]></description><name>triggerEvent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A set of predefined ui styles for individual components. Most components support 'light' and 'dark'. Extra string added
 to the baseCls with an extra '-'. 
 <pre><code>
 new Ext.Panel({
     title: 'Some Title',
     baseCls: 'x-component'
     ui: 'green'
 });</pre></code>
 The ui configuration in this example would add 'x-component-green' as an additional class.]]></description><name>ui</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of this component in pixels.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original SenchaTouch API docs:
 <a href="http://docs.sencha.com/touch/">http://docs.sencha.com/touch/</a>

 <p>A date picker component which shows a DatePicker on the screen. This class extends from <a
 href="output/Ext.Picker.html" ext:cls="Ext.Picker">Ext.Picker</a> and <a href="output/Ext.Sheet.html"
 ext:cls="Ext.Sheet">Ext.Sheet</a> so it is a popup.</p> 
 <p>This component has no required properties.</p> 
 <h2>Useful
 Properties</h2> 
 <ul class="list"> 
  <li><a href="output/Ext.DatePicker.html#Ext.DatePicker-yearFrom"
 ext:member="yearFrom" ext:cls="Ext.DatePicker">yearFrom</a></li> 
  <li><a
 href="output/Ext.DatePicker.html#Ext.DatePicker-yearTo" ext:member="yearTo" ext:cls="Ext.DatePicker">yearTo</a></li>
 
 </ul> 
 <h2>Screenshot:</h2> 
 <p><img src="doc_resources/Ext.DatePicker/screenshot.png" /></p> 
 <h2>Example code:</h2>
 
 <pre><code><b>var</b> datePicker = <b>new</b> Ext.DatePicker();
 datePicker.show();</code></pre> 
 <p>you may want to
 adjust the <a href="output/Ext.DatePicker.html#Ext.DatePicker-yearFrom" ext:member="yearFrom"
 ext:cls="Ext.DatePicker">yearFrom</a> and <a href="output/Ext.DatePicker.html#Ext.DatePicker-yearTo" ext:member="yearTo"
 ext:cls="Ext.DatePicker">yearTo</a> properties: </p>
 <pre><code><b>var</b> datePicker = <b>new</b> Ext.DatePicker({
    
 yearFrom: 2000,
     yearTo  : 2015
 });
 datePicker.show();</code></pre>]]></description><name>datePicker</name><tag-class>org.brushingbits.jnap.ui.senchatouch.DatePicker</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[CSS class to be applied to individual list items when they have been chosen.]]></description><name>activeCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A string component id or the numeric index of the component that should be initially activated within the container's
 layout on render. For example, activeItem: 'item-1' or activeItem: 0 (index 0 = the first item in the container's
 collection). activeItem only applies to layout styles that can display items one at a time (like Ext.layout.CardLayout
 and Ext.layout.FitLayout). Related to Ext.layout.ContainerLayout.activeItem.]]></description><name>activeItem</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If true the container will automatically destroy any contained component that is removed from it, else destruction must
 be handled manually (defaults to true).]]></description><name>autoDestroy</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The base CSS class to apply to this panel's element (defaults to 'x-panel').]]></description><name>baseCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A shortcut for setting a border style on the body element. The value can either be a number to be applied to all sides,
 or a normal css string describing borders. Defaults to undefined.]]></description><name>bodyBorder</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A shortcut for setting a margin style on the body element. The value can either be a number to be applied to all sides,
 or a normal css string describing margins. Defaults to undefined.]]></description><name>bodyMargin</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A shortcut for setting a padding style on the body element. The value can either be a number to be applied to all sides,
 or a normal css string describing padding. Defaults to undefined.]]></description><name>bodyPadding</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the border for this component. The border can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>border</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to ['add', 'remove'].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element (defaults to ''). This can be useful for
 adding customized styles to the component or any of its children using standard CSS rules.]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The main component class]]></description><name>componentCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The sizing and positioning of the component Elements is the responsibility of the Component's layout manager which
 creates and manages the type of layout specific to the component. If the layout configuration is not explicitly
 specified for a general purpose compopnent the default layout manager will be used.]]></description><name>componentLayout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The label to show for the day column. Defaults to 'Day'.]]></description><name>dayText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default xtype of child Components to create in this Container when a child item is specified as a raw configuration
 object, rather than as an instantiated Component. Defaults to 'panel'.]]></description><name>defaultType</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[This option is a means of applying default settings to all added items whether added through the items config or via the
 add or insert methods. If an added item is a config object, and not an instantiated Component, then the default
 properties are unconditionally applied. If the added item is an instantiated Component, then the default properties are
 applied conditionally so as not to override existing properties in the item. If the defaults option is specified as a
 function, then the function will be called using this Container as the scope (this reference) and passing the added item
 as the first parameter. Any resulting object from that call is then applied to the item as default properties. For
 example, to automatically apply padding to the body of each of a set of contained Ext.Panel items, you could pass:
 defaults: {bodyStyle:'padding:15px'}. Usage: defaults: {               // defaults are applied to items, not the
 container
     autoScroll:true
 },
 items: [
     {
         xtype: 'panel',   // defaults do not have precedence over
       
 id: 'panel1',     // options in config objects, so the defaults
         autoScroll: false // will not be applied here,
 panel1 will be autoScroll:false
     },
     new Ext.Panel({       // defaults do have precedence over options
         id:
 'panel2',     // options in components, so the defaults
         autoScroll: false // will be applied here, panel2 will
 be autoScroll:true.
     })
 ]]]></description><name>defaults</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to false.]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class to add when the Component is disabled. Defaults to 'x-item-disabled'.]]></description><name>disabledCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A component or series of components to be added as docked items to this panel. The docked items can be docked to either
 the top, right, left or bottom of a panel. This is typically used for things like toolbars or tab bars: var panel = new
 Ext.Panel({
     fullscreen: true,
     dockedItems: [{
         xtype: 'toolbar',
         dock: 'top',
         items: [{
  
           text: 'Docked to the bottom'
         }]
     }]
 });]]></description><name>dockedItems</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Can be either: A {String} text to be used on the Done button An {Object} as config for Ext.Button false or null to hide
 it Defaults to 'Done'.]]></description><name>doneButton</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Allows the component to be dragged via the touch event.]]></description><name>draggable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The viewport side from which to anchor the sheet when made visible (top, bottom, left, right) Defaults to 'bottom']]></description><name>enter</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[the named Ext.anim effect or animation configuration object used for transitions when the component is shown. Defaults
 to 'slide']]></description><name>enterAnimation</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The viewport side used as the exit point when hidden (top, bottom, left, right) Applies to sliding animation effects
 only. Defaults to 'bottom']]></description><name>exit</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[the named Ext.anim effect or animation configuration object used for transitions when the component is hidden. Defaults
 to 'slide']]></description><name>exitAnimation</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Create the Component as a floating and use absolute positioning. Defaults to false.]]></description><name>floating</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of the picker. Defaults to 220]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to false.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically bind a tap listener to the mask that hides the window. Defaults to false. Note: if you don't set
 this property to false you have to programmaticaly hide the overlay.]]></description><name>hideOnMaskTap</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[** IMPORTANT: be sure to specify a layout if needed ! ** A single item, or an array of child Components to be added to
 this container, for example: // specifying a single item
 items: {...},
 layout: 'fit',    // specify a layout!
 
 //
 specifying multiple items
 items: [{...}, {...}],
 layout: 'hbox', // specify a layout! Each item may be: any type of
 object based on Ext.Component a fully instanciated object or an object literal that: has a specified xtype the
 Ext.Component.xtype specified is associated with the Component desired and should be chosen from one of the available
 xtypes as listed in Ext.Component. If an xtype is not explicitly specified, the defaultType for that Container is used.
 will be "lazily instanciated", avoiding the overhead of constructing a fully instanciated Component object Notes: Ext
 uses lazy rendering. Child Components will only be rendered should it become necessary. Items are automatically laid out
 when they are first shown (no sizing is done while hidden), or in response to a doLayout call. Do not specify contentEl/
 html with items.]]></description><name>items</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[*Important: In order for child items to be correctly sized and positioned, typically a layout manager must be specified
 through the layout configuration option. The sizing and positioning of child items is the responsibility of the
 Container's layout manager which creates and manages the type of layout you have in mind. For example: If the layout
 configuration is not explicitly specified for a general purpose container (e.g. Container or Panel) the default layout
 manager will be used which does nothing but render child components sequentially into the Container (no sizing or
 positioning will be performed in this situation). layout may be specified as either as an Object or as a String: Specify
 as an Object Example usage: layout: {
     type: 'vbox',
     align: 'left'
 } type The layout type to be used for this
 container. If not specified, a default Ext.layout.ContainerLayout will be created and used. Valid layout type values
 are:
 auto - Default card fit hbox vbox Layout specific configuration properties Additional layout specific
 configuration properties may also be specified. For complete details regarding the valid config options for each layout
 type, see the layout class corresponding to the type specified. Specify as a String Example usage: layout: {
     type:
 'vbox',
     padding: '5',
     align: 'left'
 } layout The layout type to be used for this container (see list of valid
 layout type values above). Additional layout specific configuration properties. For complete details regarding the valid
 config options for each layout type, see the layout class corresponding to the layout specified.]]></description><name>layout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A config object containing one or more event handlers to be added to this object during initialization. This should be a
 valid listeners config object as specified in the addListener example for attaching multiple handlers at once. DOM
 events from ExtJs Components While some ExtJs Component classes export selected DOM events (e.g. "click", "mouseover"
 etc), this is usually only done when extra value can be added. For example the DataView's click event passing the node
 clicked on. To access DOM events directly from a child element of a Component, we need to specify the element option to
 identify the Component property to add a DOM listener to: new Ext.Panel({
     width: 400,
     height: 200,
    
 dockedItems: [{
         xtype: 'toolbar'
     }],
     listeners: {
         click: {
             element: 'el', //bind to
 the underlying el property on the panel
             fn: function(){ console.log('click el'); }
         },
        
 dblclick: {
             element: 'body', //bind to the underlying body property on the panel
             fn: function(){
 console.log('dblclick body'); }
         }
     }
 });]]></description><name>listeners</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the margin for this component. The margin can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>margin</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this Component will set its height to. Warning: This will override any size management
 applied by layout managers.]]></description><name>maxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this Component will set its width to. Warning: This will override any size management
 applied by layout managers.]]></description><name>maxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this Component will set its height to. Warning: This will override any size management
 applied by layout managers.]]></description><name>minHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this Component will set its width to. Warning: This will override any size management
 applied by layout managers.]]></description><name>minWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The label to show for the month column. Defaults to 'Month'.]]></description><name>monthText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the padding for this component. The padding can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>padding</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object containing properties specifying DomQuery selectors which identify child elements created by the render
 process. After the Component's internal structure is rendered according to the renderTpl, this object is iterated
 through, and the found Elements are added as properties to the Component using the renderSelector property name. For
 example, a Component which rendered an image, and description into its element might use the following properties coded
 into its prototype: renderTpl: '"{imageUrl}" class="x-image-component-img">
 "x-image-component-desc">{description}',
 
 renderSelectors: {
     image: 'img.x-image-component-img',
     descEl:
 'div.x-image-component-desc'
 } After rendering, the Component would have a property image referencing its child img
 Element, and a property descEl referencing the div Element which contains the description.]]></description><name>renderSelectors</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An XTemplate used to create the internal structure inside this Component's encapsulating Element. You do not normally
 need to specify this. For the base classes Ext.Component and Ext.Container, this defaults to null which means that they
 will be initially rendered with no internal structure; they render their Element empty. The more specialized ExtJS and
 Touch classes which use a more complex DOM structure, provide their own template definitions. This is intended to allow
 the developer to create application-specific utility Components with customized internal structure. Upon rendering, any
 created child elements may be automatically imported into object properties using the renderSelectors option.]]></description><name>renderTpl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of strings that specifies the order of the slots. Defaults to ['month', 'day', 'year'].]]></description><name>slotOrder</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of slot configurations. name - {String} - Name of the slot align - {String} - Alignment of the slot. left,
 right, or center items - {Array} - An array of text/value pairs in the format {text: 'myKey', value: 'myValue'} title -
 {String} - Title of the slot. This is used in conjunction with useTitles: true.]]></description><name>slots</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If true, the width of anchored Sheets are adjusted to fill the entire top/bottom axis width, or false to center the
 Sheet along the same axis based upon the sheets current/calculated width. This option is ignored when {link #centered}
 is true or x/y coordinates are specified for the Sheet.]]></description><name>stretchX</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If true, the height of anchored Sheets are adjusted to fill the entire right/left axis height, or false to center the
 Sheet along the same axis based upon the sheets current/calculated height. This option is ignored when {link #centered}
 is true or x/y coordinates are specified for the Sheet.]]></description><name>stretchY</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
             title: 'Some Title',
             renderTo: Ext.getBody(),
          
 width: 400, height: 300,
             layout: 'form',
             items: [{
                 xtype: 'textareafield',
      
 style: {
                     width: '95%',
                     marginBottom: '10px'
                 }
             },
    
 new Ext.Button({
                 text: 'Send',
                 minWidth: '100',
                 style: {
                
     marginBottom: '10px'
                 }
             })
             ]
         });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The class that is added to the content target when you set styleHtmlContent to true. Defaults to 'x-html']]></description><name>styleHtmlCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically style the html inside the content target of this component (body for panels). Defaults to false.]]></description><name>styleHtmlContent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An Ext.Template, Ext.XTemplate or an array of strings to form an Ext.XTemplate. Used in conjunction with the data and
 tplWriteMode configurations.]]></description><name>tpl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A set of predefined ui styles for individual components. Most components support 'light' and 'dark'. Extra string added
 to the baseCls with an extra '-'. 
 <pre><code>
 new Ext.Panel({
     title: 'Some Title',
     baseCls: 'x-component'
     ui: 'green'
 });</pre></code>
 The ui configuration in this example would add 'x-component-green' as an additional class.]]></description><name>ui</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Generate a title header for each individual slot and use the title configuration of the slot. Defaults to false.]]></description><name>useTitles</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Default value for the field and the internal Ext.DatePicker component. Accepts an object of 'year', 'month' and 'day'
 values, all of which should be numbers, or a Date. Examples: {year: 1989, day: 1, month: 5} = 1st May 1989. new Date() =
 current date]]></description><name>value</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of this component in pixels.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The start year for the date picker. Defaults to 1980]]></description><name>yearFrom</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The label to show for the year column. Defaults to 'Year'.]]></description><name>yearText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The last year for the date picker. Defaults to the current year.]]></description><name>yearTo</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original SenchaTouch API docs:
 <a href="http://docs.sencha.com/touch/">http://docs.sencha.com/touch/</a>

 Simple Checkbox class. Can be used as a direct replacement for traditional checkbox fields.]]></description><name>form.checkbox</name><tag-class>org.brushingbits.jnap.ui.senchatouch.form.Checkbox</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[A string component id or the numeric index of the component that should be initially activated within the container's
 layout on render. For example, activeItem: 'item-1' or activeItem: 0 (index 0 = the first item in the container's
 collection). activeItem only applies to layout styles that can display items one at a time (like Ext.layout.CardLayout
 and Ext.layout.FitLayout). Related to Ext.layout.ContainerLayout.activeItem.]]></description><name>activeItem</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically create the field input element on render. This is true by default, but should be set to false for
 any Ext.Field subclasses that don't need an HTML input (e.g. Ext.Slider and similar)]]></description><name>autoCreateField</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If true the container will automatically destroy any contained component that is removed from it, else destruction must
 be handled manually (defaults to true).]]></description><name>autoDestroy</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The base CSS class to apply to this components's element. This will also be prepended to elements within this component
 like Panel's body will get a class x-panel-body. This means that if you create a subclass of Panel, and you want it to
 get all the Panels styling for the element and the body, you leave the baseCls x-panel and use componentCls to add
 specific styling for this component.]]></description><name>baseCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the border for this component. The border can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>border</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to ['add', 'remove'].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Animation to be used during transitions of cards. Note this only works when this container has a CardLayout. Any valid
 value from Ext.anims can be used ('fade', 'slide', 'flip', 'cube', 'pop', 'wipe'). Defaults to null.]]></description><name>cardSwitchAnimation</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true if the checkbox should render initially checked (defaults to false)]]></description><name>checked</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom CSS class to apply to the field's underlying element (defaults to '').]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS Class to be added to a components root level element to give distinction to it via styling.]]></description><name>componentCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The sizing and positioning of the component Elements is the responsibility of the Component's layout manager which
 creates and manages the type of layout specific to the component. If the layout configuration is not explicitly
 specified for a general purpose compopnent the default layout manager will be used.]]></description><name>componentLayout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default xtype of child Components to create in this Container when a child item is specified as a raw configuration
 object, rather than as an instantiated Component. Defaults to 'panel'.]]></description><name>defaultType</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[This option is a means of applying default settings to all added items whether added through the items config or via the
 add or insert methods. If an added item is a config object, and not an instantiated Component, then the default
 properties are unconditionally applied. If the added item is an instantiated Component, then the default properties are
 applied conditionally so as not to override existing properties in the item. If the defaults option is specified as a
 function, then the function will be called using this Container as the scope (this reference) and passing the added item
 as the first parameter. Any resulting object from that call is then applied to the item as default properties. For
 example, to automatically apply padding to the body of each of a set of contained Ext.Panel items, you could pass:
 defaults: {bodyStyle:'padding:15px'}. Usage: defaults: {               // defaults are applied to items, not the
 container
     autoScroll:true
 },
 items: [
     {
         xtype: 'panel',   // defaults do not have precedence over
       
 id: 'panel1',     // options in config objects, so the defaults
         autoScroll: false // will not be applied here,
 panel1 will be autoScroll:false
     },
     new Ext.Panel({       // defaults do have precedence over options
         id:
 'panel2',     // options in components, so the defaults
         autoScroll: false // will be applied here, panel2 will
 be autoScroll:true.
     })
 ]]]></description><name>defaults</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to disable the field (defaults to false). Be aware that conformant with the HTML specification, disabled Fields
 will not be submitted.]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class to add when the Component is disabled. Defaults to 'x-item-disabled'.]]></description><name>disabledCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Allows the component to be dragged via the touch event.]]></description><name>draggable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default CSS class for the field (defaults to 'x-form-field')]]></description><name>fieldCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Create the Component as a floating and use absolute positioning. Defaults to false.]]></description><name>floating</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of this component in pixels.]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to false.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional CSS class that will be added to the actual element (or whichever different element is defined by inputAutoEl).
 Defaults to undefined.]]></description><name>inputCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The type attribute for input fields -- e.g. radio, text, password, file (defaults to 'text'). The types 'file' and
 'password' must be used to render those field types currently -- there are no separate Ext components for those. Note
 that if you use inputType:'file', emptyText is not supported and should be avoided.]]></description><name>inputType</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[** IMPORTANT: be sure to specify a layout if needed ! ** A single item, or an array of child Components to be added to
 this container, for example: // specifying a single item
 items: {...},
 layout: 'fit',    // specify a layout!
 
 //
 specifying multiple items
 items: [{...}, {...}],
 layout: 'hbox', // specify a layout! Each item may be: any type of
 object based on Ext.Component a fully instanciated object or an object literal that: has a specified xtype the
 Ext.Component.xtype specified is associated with the Component desired and should be chosen from one of the available
 xtypes as listed in Ext.Component. If an xtype is not explicitly specified, the defaultType for that Container is used.
 will be "lazily instanciated", avoiding the overhead of constructing a fully instanciated Component object Notes: Ext
 uses lazy rendering. Child Components will only be rendered should it become necessary. Items are automatically laid out
 when they are first shown (no sizing is done while hidden), or in response to a doLayout call. Do not specify contentEl/
 html with items.]]></description><name>items</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The label to associate with this field. Defaults to null.]]></description><name>label</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The location to render the label of the field. Acceptable values are 'top' and 'left'. Defaults to 'left']]></description><name>labelAlign</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of the label, can be any valid CSS size. E.g '20%', '6em', '100px'. Defaults to '30%']]></description><name>labelWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[*Important: In order for child items to be correctly sized and positioned, typically a layout manager must be specified
 through the layout configuration option. The sizing and positioning of child items is the responsibility of the
 Container's layout manager which creates and manages the type of layout you have in mind. For example: If the layout
 configuration is not explicitly specified for a general purpose container (e.g. Container or Panel) the default layout
 manager will be used which does nothing but render child components sequentially into the Container (no sizing or
 positioning will be performed in this situation). layout may be specified as either as an Object or as a String: Specify
 as an Object Example usage: layout: {
     type: 'vbox',
     align: 'left'
 } type The layout type to be used for this
 container. If not specified, a default Ext.layout.ContainerLayout will be created and used. Valid layout type values
 are:
 auto - Default card fit hbox vbox Layout specific configuration properties Additional layout specific
 configuration properties may also be specified. For complete details regarding the valid config options for each layout
 type, see the layout class corresponding to the type specified. Specify as a String Example usage: layout: {
     type:
 'vbox',
     padding: '5',
     align: 'left'
 } layout The layout type to be used for this container (see list of valid
 layout type values above). Additional layout specific configuration properties. For complete details regarding the valid
 config options for each layout type, see the layout class corresponding to the layout specified.]]></description><name>layout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A config object containing one or more event handlers to be added to this object during initialization. This should be a
 valid listeners config object as specified in the addListener example for attaching multiple handlers at once. DOM
 events from ExtJs Components While some ExtJs Component classes export selected DOM events (e.g. "click", "mouseover"
 etc), this is usually only done when extra value can be added. For example the DataView's click event passing the node
 clicked on. To access DOM events directly from a child element of a Component, we need to specify the element option to
 identify the Component property to add a DOM listener to: new Ext.Panel({
     width: 400,
     height: 200,
    
 dockedItems: [{
         xtype: 'toolbar'
     }],
     listeners: {
         click: {
             element: 'el', //bind to
 the underlying el property on the panel
             fn: function(){ console.log('click el'); }
         },
        
 dblclick: {
             element: 'body', //bind to the underlying body property on the panel
             fn: function(){
 console.log('dblclick body'); }
         }
     }
 });]]></description><name>listeners</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the margin for this component. The margin can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>margin</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this Component will set its height to. Warning: This will override any size management
 applied by layout managers.]]></description><name>maxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this Component will set its width to. Warning: This will override any size management
 applied by layout managers.]]></description><name>maxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this Component will set its height to. Warning: This will override any size management
 applied by layout managers.]]></description><name>minHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this Component will set its width to. Warning: This will override any size management
 applied by layout managers.]]></description><name>minWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The field's HTML name attribute (defaults to ''). Note: this property must be set if this field is to be automatically
 included with form submit().]]></description><name>name</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the padding for this component. The padding can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>padding</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object containing properties specifying DomQuery selectors which identify child elements created by the render
 process. After the Component's internal structure is rendered according to the renderTpl, this object is iterated
 through, and the found Elements are added as properties to the Component using the renderSelector property name. For
 example, a Component which rendered an image, and description into its element might use the following properties coded
 into its prototype: renderTpl: '"{imageUrl}" class="x-image-component-img">
 "x-image-component-desc">{description}',
 
 renderSelectors: {
     image: 'img.x-image-component-img',
     descEl:
 'div.x-image-component-desc'
 } After rendering, the Component would have a property image referencing its child img
 Element, and a property descEl referencing the div Element which contains the description.]]></description><name>renderSelectors</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An XTemplate used to create the internal structure inside this Component's encapsulating Element. You do not normally
 need to specify this. For the base classes Ext.Component and Ext.Container, this defaults to null which means that they
 will be initially rendered with no internal structure; they render their Element empty. The more specialized ExtJS and
 Touch classes which use a more complex DOM structure, provide their own template definitions. This is intended to allow
 the developer to create application-specific utility Components with customized internal structure. Upon rendering, any
 created child elements may be automatically imported into object properties using the renderSelectors option.]]></description><name>renderTpl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to make this field required. Note: this only causes a visual indication. Doesn't prevent user from submitting the
 form.]]></description><name>required</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
             title: 'Some Title',
             renderTo: Ext.getBody(),
          
 width: 400, height: 300,
             layout: 'form',
             items: [{
                 xtype: 'textareafield',
      
 style: {
                     width: '95%',
                     marginBottom: '10px'
                 }
             },
    
 new Ext.Button({
                 text: 'Send',
                 minWidth: '100',
                 style: {
                
     marginBottom: '10px'
                 }
             })
             ]
         });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The class that is added to the content target when you set styleHtmlContent to true. Defaults to 'x-html']]></description><name>styleHtmlCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically style the html inside the content target of this component (body for panels). Defaults to false.]]></description><name>styleHtmlContent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The tabIndex for this field. Note this only applies to fields that are rendered, not those which are built via applyTo
 (defaults to undefined).]]></description><name>tabIndex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An Ext.Template, Ext.XTemplate or an array of strings to form an Ext.XTemplate. Used in conjunction with the data and
 tplWriteMode configurations.]]></description><name>tpl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A set of predefined ui styles for individual components. Most components support 'light' and 'dark'. Extra string added
 to the baseCls with an extra '-'. 
 <pre><code>
 new Ext.Panel({
     title: 'Some Title',
     baseCls: 'x-component'
     ui: 'green'
 });</pre></code>
 The ui configuration in this example would add 'x-component-green' as an additional class.]]></description><name>ui</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The string value to submit if the item is in a checked state.]]></description><name>value</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of this component in pixels.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original SenchaTouch API docs:
 <a href="http://docs.sencha.com/touch/">http://docs.sencha.com/touch/</a>

 <p>Specialized field which has a button which when pressed, shows a <a href="output/Ext.DatePicker.html"
 ext:cls="Ext.DatePicker">Ext.DatePicker</a>.</p>]]></description><name>form.datePicker</name><tag-class>org.brushingbits.jnap.ui.senchatouch.form.DatePicker</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[A string component id or the numeric index of the component that should be initially activated within the container's
 layout on render. For example, activeItem: 'item-1' or activeItem: 0 (index 0 = the first item in the container's
 collection). activeItem only applies to layout styles that can display items one at a time (like Ext.layout.CardLayout
 and Ext.layout.FitLayout). Related to Ext.layout.ContainerLayout.activeItem.]]></description><name>activeItem</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically create the field input element on render. This is true by default, but should be set to false for
 any Ext.Field subclasses that don't need an HTML input (e.g. Ext.Slider and similar)]]></description><name>autoCreateField</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If true the container will automatically destroy any contained component that is removed from it, else destruction must
 be handled manually (defaults to true).]]></description><name>autoDestroy</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The base CSS class to apply to this components's element. This will also be prepended to elements within this component
 like Panel's body will get a class x-panel-body. This means that if you create a subclass of Panel, and you want it to
 get all the Panels styling for the element and the body, you leave the baseCls x-panel and use componentCls to add
 specific styling for this component.]]></description><name>baseCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the border for this component. The border can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>border</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to ['add', 'remove'].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Animation to be used during transitions of cards. Note this only works when this container has a CardLayout. Any valid
 value from Ext.anims can be used ('fade', 'slide', 'flip', 'cube', 'pop', 'wipe'). Defaults to null.]]></description><name>cardSwitchAnimation</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom CSS class to apply to the field's underlying element (defaults to '').]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS Class to be added to a components root level element to give distinction to it via styling.]]></description><name>componentCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The sizing and positioning of the component Elements is the responsibility of the Component's layout manager which
 creates and manages the type of layout specific to the component. If the layout configuration is not explicitly
 specified for a general purpose compopnent the default layout manager will be used.]]></description><name>componentLayout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default xtype of child Components to create in this Container when a child item is specified as a raw configuration
 object, rather than as an instantiated Component. Defaults to 'panel'.]]></description><name>defaultType</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[This option is a means of applying default settings to all added items whether added through the items config or via the
 add or insert methods. If an added item is a config object, and not an instantiated Component, then the default
 properties are unconditionally applied. If the added item is an instantiated Component, then the default properties are
 applied conditionally so as not to override existing properties in the item. If the defaults option is specified as a
 function, then the function will be called using this Container as the scope (this reference) and passing the added item
 as the first parameter. Any resulting object from that call is then applied to the item as default properties. For
 example, to automatically apply padding to the body of each of a set of contained Ext.Panel items, you could pass:
 defaults: {bodyStyle:'padding:15px'}. Usage: defaults: {               // defaults are applied to items, not the
 container
     autoScroll:true
 },
 items: [
     {
         xtype: 'panel',   // defaults do not have precedence over
       
 id: 'panel1',     // options in config objects, so the defaults
         autoScroll: false // will not be applied here,
 panel1 will be autoScroll:false
     },
     new Ext.Panel({       // defaults do have precedence over options
         id:
 'panel2',     // options in components, so the defaults
         autoScroll: false // will be applied here, panel2 will
 be autoScroll:true.
     })
 ]]]></description><name>defaults</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Whether or not to destroy the picker widget on hide. This save memory if it's not used frequently, but increase delay
 time on the next show due to re-instantiation. Defaults to false]]></description><name>destroyPickerOnHide</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to disable the field (defaults to false). Be aware that conformant with the HTML specification, disabled Fields
 will not be submitted.]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class to add when the Component is disabled. Defaults to 'x-item-disabled'.]]></description><name>disabledCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Allows the component to be dragged via the touch event.]]></description><name>draggable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default CSS class for the field (defaults to 'x-form-field')]]></description><name>fieldCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Create the Component as a floating and use absolute positioning. Defaults to false.]]></description><name>floating</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of this component in pixels.]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to false.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional CSS class that will be added to the actual element (or whichever different element is defined by inputAutoEl).
 Defaults to undefined.]]></description><name>inputCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The type attribute for input fields -- e.g. radio, text, password, file (defaults to 'text'). The types 'file' and
 'password' must be used to render those field types currently -- there are no separate Ext components for those. Note
 that if you use inputType:'file', emptyText is not supported and should be avoided.]]></description><name>inputType</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[** IMPORTANT: be sure to specify a layout if needed ! ** A single item, or an array of child Components to be added to
 this container, for example: // specifying a single item
 items: {...},
 layout: 'fit',    // specify a layout!
 
 //
 specifying multiple items
 items: [{...}, {...}],
 layout: 'hbox', // specify a layout! Each item may be: any type of
 object based on Ext.Component a fully instanciated object or an object literal that: has a specified xtype the
 Ext.Component.xtype specified is associated with the Component desired and should be chosen from one of the available
 xtypes as listed in Ext.Component. If an xtype is not explicitly specified, the defaultType for that Container is used.
 will be "lazily instanciated", avoiding the overhead of constructing a fully instanciated Component object Notes: Ext
 uses lazy rendering. Child Components will only be rendered should it become necessary. Items are automatically laid out
 when they are first shown (no sizing is done while hidden), or in response to a doLayout call. Do not specify contentEl/
 html with items.]]></description><name>items</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The label to associate with this field. Defaults to null.]]></description><name>label</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The location to render the label of the field. Acceptable values are 'top' and 'left'. Defaults to 'left']]></description><name>labelAlign</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of the label, can be any valid CSS size. E.g '20%', '6em', '100px'. Defaults to '30%']]></description><name>labelWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[*Important: In order for child items to be correctly sized and positioned, typically a layout manager must be specified
 through the layout configuration option. The sizing and positioning of child items is the responsibility of the
 Container's layout manager which creates and manages the type of layout you have in mind. For example: If the layout
 configuration is not explicitly specified for a general purpose container (e.g. Container or Panel) the default layout
 manager will be used which does nothing but render child components sequentially into the Container (no sizing or
 positioning will be performed in this situation). layout may be specified as either as an Object or as a String: Specify
 as an Object Example usage: layout: {
     type: 'vbox',
     align: 'left'
 } type The layout type to be used for this
 container. If not specified, a default Ext.layout.ContainerLayout will be created and used. Valid layout type values
 are:
 auto - Default card fit hbox vbox Layout specific configuration properties Additional layout specific
 configuration properties may also be specified. For complete details regarding the valid config options for each layout
 type, see the layout class corresponding to the type specified. Specify as a String Example usage: layout: {
     type:
 'vbox',
     padding: '5',
     align: 'left'
 } layout The layout type to be used for this container (see list of valid
 layout type values above). Additional layout specific configuration properties. For complete details regarding the valid
 config options for each layout type, see the layout class corresponding to the layout specified.]]></description><name>layout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A config object containing one or more event handlers to be added to this object during initialization. This should be a
 valid listeners config object as specified in the addListener example for attaching multiple handlers at once. DOM
 events from ExtJs Components While some ExtJs Component classes export selected DOM events (e.g. "click", "mouseover"
 etc), this is usually only done when extra value can be added. For example the DataView's click event passing the node
 clicked on. To access DOM events directly from a child element of a Component, we need to specify the element option to
 identify the Component property to add a DOM listener to: new Ext.Panel({
     width: 400,
     height: 200,
    
 dockedItems: [{
         xtype: 'toolbar'
     }],
     listeners: {
         click: {
             element: 'el', //bind to
 the underlying el property on the panel
             fn: function(){ console.log('click el'); }
         },
        
 dblclick: {
             element: 'body', //bind to the underlying body property on the panel
             fn: function(){
 console.log('dblclick body'); }
         }
     }
 });]]></description><name>listeners</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the margin for this component. The margin can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>margin</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this Component will set its height to. Warning: This will override any size management
 applied by layout managers.]]></description><name>maxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this Component will set its width to. Warning: This will override any size management
 applied by layout managers.]]></description><name>maxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this Component will set its height to. Warning: This will override any size management
 applied by layout managers.]]></description><name>minHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this Component will set its width to. Warning: This will override any size management
 applied by layout managers.]]></description><name>minWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The field's HTML name attribute (defaults to ''). Note: this property must be set if this field is to be automatically
 included with form submit().]]></description><name>name</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the padding for this component. The padding can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>padding</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object that is used when creating the internal Ext.DatePicker component or a direct instance of Ext.DatePicker
 Defaults to null]]></description><name>picker</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object containing properties specifying DomQuery selectors which identify child elements created by the render
 process. After the Component's internal structure is rendered according to the renderTpl, this object is iterated
 through, and the found Elements are added as properties to the Component using the renderSelector property name. For
 example, a Component which rendered an image, and description into its element might use the following properties coded
 into its prototype: renderTpl: '"{imageUrl}" class="x-image-component-img">
 "x-image-component-desc">{description}',
 
 renderSelectors: {
     image: 'img.x-image-component-img',
     descEl:
 'div.x-image-component-desc'
 } After rendering, the Component would have a property image referencing its child img
 Element, and a property descEl referencing the div Element which contains the description.]]></description><name>renderSelectors</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An XTemplate used to create the internal structure inside this Component's encapsulating Element. You do not normally
 need to specify this. For the base classes Ext.Component and Ext.Container, this defaults to null which means that they
 will be initially rendered with no internal structure; they render their Element empty. The more specialized ExtJS and
 Touch classes which use a more complex DOM structure, provide their own template definitions. This is intended to allow
 the developer to create application-specific utility Components with customized internal structure. Upon rendering, any
 created child elements may be automatically imported into object properties using the renderSelectors option.]]></description><name>renderTpl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to make this field required. Note: this only causes a visual indication. Doesn't prevent user from submitting the
 form.]]></description><name>required</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
             title: 'Some Title',
             renderTo: Ext.getBody(),
          
 width: 400, height: 300,
             layout: 'form',
             items: [{
                 xtype: 'textareafield',
      
 style: {
                     width: '95%',
                     marginBottom: '10px'
                 }
             },
    
 new Ext.Button({
                 text: 'Send',
                 minWidth: '100',
                 style: {
                
     marginBottom: '10px'
                 }
             })
             ]
         });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The class that is added to the content target when you set styleHtmlContent to true. Defaults to 'x-html']]></description><name>styleHtmlCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically style the html inside the content target of this component (body for panels). Defaults to false.]]></description><name>styleHtmlContent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The tabIndex for this field. Note this only applies to fields that are rendered, not those which are built via applyTo
 (defaults to undefined).]]></description><name>tabIndex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An Ext.Template, Ext.XTemplate or an array of strings to form an Ext.XTemplate. Used in conjunction with the data and
 tplWriteMode configurations.]]></description><name>tpl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A set of predefined ui styles for individual components. Most components support 'light' and 'dark'. Extra string added
 to the baseCls with an extra '-'. 
 <pre><code>
 new Ext.Panel({
     title: 'Some Title',
     baseCls: 'x-component'
     ui: 'green'
 });</pre></code>
 The ui configuration in this example would add 'x-component-green' as an additional class.]]></description><name>ui</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Default value for the field and the internal Ext.DatePicker component. Accepts an object of 'year', 'month' and 'day'
 values, all of which should be numbers, or a Date. Example: {year: 1989, day: 1, month: 5} = 1st May 1989 or new Date()]]></description><name>value</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of this component in pixels.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original SenchaTouch API docs:
 <a href="http://docs.sencha.com/touch/">http://docs.sencha.com/touch/</a>

 Wraps an HTML5 email field.]]></description><name>form.emailField</name><tag-class>org.brushingbits.jnap.ui.senchatouch.form.EmailField</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[A string component id or the numeric index of the component that should be initially activated within the container's
 layout on render. For example, activeItem: 'item-1' or activeItem: 0 (index 0 = the first item in the container's
 collection). activeItem only applies to layout styles that can display items one at a time (like Ext.layout.CardLayout
 and Ext.layout.FitLayout). Related to Ext.layout.ContainerLayout.activeItem.]]></description><name>activeItem</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>autoCapitalize</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>autoComplete</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>autoCorrect</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically create the field input element on render. This is true by default, but should be set to false for
 any Ext.Field subclasses that don't need an HTML input (e.g. Ext.Slider and similar)]]></description><name>autoCreateField</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If true the container will automatically destroy any contained component that is removed from it, else destruction must
 be handled manually (defaults to true).]]></description><name>autoDestroy</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The base CSS class to apply to this components's element. This will also be prepended to elements within this component
 like Panel's body will get a class x-panel-body. This means that if you create a subclass of Panel, and you want it to
 get all the Panels styling for the element and the body, you leave the baseCls x-panel and use componentCls to add
 specific styling for this component.]]></description><name>baseCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the border for this component. The border can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>border</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to ['add', 'remove'].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Animation to be used during transitions of cards. Note this only works when this container has a CardLayout. Any valid
 value from Ext.anims can be used ('fade', 'slide', 'flip', 'cube', 'pop', 'wipe'). Defaults to null.]]></description><name>cardSwitchAnimation</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom CSS class to apply to the field's underlying element (defaults to '').]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS Class to be added to a components root level element to give distinction to it via styling.]]></description><name>componentCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The sizing and positioning of the component Elements is the responsibility of the Component's layout manager which
 creates and manages the type of layout specific to the component. If the layout configuration is not explicitly
 specified for a general purpose compopnent the default layout manager will be used.]]></description><name>componentLayout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default xtype of child Components to create in this Container when a child item is specified as a raw configuration
 object, rather than as an instantiated Component. Defaults to 'panel'.]]></description><name>defaultType</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[This option is a means of applying default settings to all added items whether added through the items config or via the
 add or insert methods. If an added item is a config object, and not an instantiated Component, then the default
 properties are unconditionally applied. If the added item is an instantiated Component, then the default properties are
 applied conditionally so as not to override existing properties in the item. If the defaults option is specified as a
 function, then the function will be called using this Container as the scope (this reference) and passing the added item
 as the first parameter. Any resulting object from that call is then applied to the item as default properties. For
 example, to automatically apply padding to the body of each of a set of contained Ext.Panel items, you could pass:
 defaults: {bodyStyle:'padding:15px'}. Usage: defaults: {               // defaults are applied to items, not the
 container
     autoScroll:true
 },
 items: [
     {
         xtype: 'panel',   // defaults do not have precedence over
       
 id: 'panel1',     // options in config objects, so the defaults
         autoScroll: false // will not be applied here,
 panel1 will be autoScroll:false
     },
     new Ext.Panel({       // defaults do have precedence over options
         id:
 'panel2',     // options in components, so the defaults
         autoScroll: false // will be applied here, panel2 will
 be autoScroll:true.
     })
 ]]]></description><name>defaults</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to disable the field (defaults to false). Be aware that conformant with the HTML specification, disabled Fields
 will not be submitted.]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class to add when the Component is disabled. Defaults to 'x-item-disabled'.]]></description><name>disabledCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Allows the component to be dragged via the touch event.]]></description><name>draggable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default CSS class for the field (defaults to 'x-form-field')]]></description><name>fieldCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Create the Component as a floating and use absolute positioning. Defaults to false.]]></description><name>floating</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class to use when the field receives focus (defaults to 'x-field-focus')]]></description><name>focusCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of this component in pixels.]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to false.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional CSS class that will be added to the actual element (or whichever different element is defined by inputAutoEl).
 Defaults to undefined.]]></description><name>inputCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The type attribute for input fields -- e.g. radio, text, password, file (defaults to 'text'). The types 'file' and
 'password' must be used to render those field types currently -- there are no separate Ext components for those. Note
 that if you use inputType:'file', emptyText is not supported and should be avoided.]]></description><name>inputType</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[** IMPORTANT: be sure to specify a layout if needed ! ** A single item, or an array of child Components to be added to
 this container, for example: // specifying a single item
 items: {...},
 layout: 'fit',    // specify a layout!
 
 //
 specifying multiple items
 items: [{...}, {...}],
 layout: 'hbox', // specify a layout! Each item may be: any type of
 object based on Ext.Component a fully instanciated object or an object literal that: has a specified xtype the
 Ext.Component.xtype specified is associated with the Component desired and should be chosen from one of the available
 xtypes as listed in Ext.Component. If an xtype is not explicitly specified, the defaultType for that Container is used.
 will be "lazily instanciated", avoiding the overhead of constructing a fully instanciated Component object Notes: Ext
 uses lazy rendering. Child Components will only be rendered should it become necessary. Items are automatically laid out
 when they are first shown (no sizing is done while hidden), or in response to a doLayout call. Do not specify contentEl/
 html with items.]]></description><name>items</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The label to associate with this field. Defaults to null.]]></description><name>label</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The location to render the label of the field. Acceptable values are 'top' and 'left'. Defaults to 'left']]></description><name>labelAlign</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of the label, can be any valid CSS size. E.g '20%', '6em', '100px'. Defaults to '30%']]></description><name>labelWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[*Important: In order for child items to be correctly sized and positioned, typically a layout manager must be specified
 through the layout configuration option. The sizing and positioning of child items is the responsibility of the
 Container's layout manager which creates and manages the type of layout you have in mind. For example: If the layout
 configuration is not explicitly specified for a general purpose container (e.g. Container or Panel) the default layout
 manager will be used which does nothing but render child components sequentially into the Container (no sizing or
 positioning will be performed in this situation). layout may be specified as either as an Object or as a String: Specify
 as an Object Example usage: layout: {
     type: 'vbox',
     align: 'left'
 } type The layout type to be used for this
 container. If not specified, a default Ext.layout.ContainerLayout will be created and used. Valid layout type values
 are:
 auto - Default card fit hbox vbox Layout specific configuration properties Additional layout specific
 configuration properties may also be specified. For complete details regarding the valid config options for each layout
 type, see the layout class corresponding to the type specified. Specify as a String Example usage: layout: {
     type:
 'vbox',
     padding: '5',
     align: 'left'
 } layout The layout type to be used for this container (see list of valid
 layout type values above). Additional layout specific configuration properties. For complete details regarding the valid
 config options for each layout type, see the layout class corresponding to the layout specified.]]></description><name>layout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A config object containing one or more event handlers to be added to this object during initialization. This should be a
 valid listeners config object as specified in the addListener example for attaching multiple handlers at once. DOM
 events from ExtJs Components While some ExtJs Component classes export selected DOM events (e.g. "click", "mouseover"
 etc), this is usually only done when extra value can be added. For example the DataView's click event passing the node
 clicked on. To access DOM events directly from a child element of a Component, we need to specify the element option to
 identify the Component property to add a DOM listener to: new Ext.Panel({
     width: 400,
     height: 200,
    
 dockedItems: [{
         xtype: 'toolbar'
     }],
     listeners: {
         click: {
             element: 'el', //bind to
 the underlying el property on the panel
             fn: function(){ console.log('click el'); }
         },
        
 dblclick: {
             element: 'body', //bind to the underlying body property on the panel
             fn: function(){
 console.log('dblclick body'); }
         }
     }
 });]]></description><name>listeners</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the margin for this component. The margin can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>margin</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this Component will set its height to. Warning: This will override any size management
 applied by layout managers.]]></description><name>maxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum number of permitted input characters (defaults to 0).]]></description><name>maxLength</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this Component will set its width to. Warning: This will override any size management
 applied by layout managers.]]></description><name>maxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this Component will set its height to. Warning: This will override any size management
 applied by layout managers.]]></description><name>minHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this Component will set its width to. Warning: This will override any size management
 applied by layout managers.]]></description><name>minWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The field's HTML name attribute (defaults to ''). Note: this property must be set if this field is to be automatically
 included with form submit().]]></description><name>name</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the padding for this component. The padding can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>padding</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A string value displayed in the input (if supported) when the control is empty.]]></description><name>placeHolder</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object containing properties specifying DomQuery selectors which identify child elements created by the render
 process. After the Component's internal structure is rendered according to the renderTpl, this object is iterated
 through, and the found Elements are added as properties to the Component using the renderSelector property name. For
 example, a Component which rendered an image, and description into its element might use the following properties coded
 into its prototype: renderTpl: '"{imageUrl}" class="x-image-component-img">
 "x-image-component-desc">{description}',
 
 renderSelectors: {
     image: 'img.x-image-component-img',
     descEl:
 'div.x-image-component-desc'
 } After rendering, the Component would have a property image referencing its child img
 Element, and a property descEl referencing the div Element which contains the description.]]></description><name>renderSelectors</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An XTemplate used to create the internal structure inside this Component's encapsulating Element. You do not normally
 need to specify this. For the base classes Ext.Component and Ext.Container, this defaults to null which means that they
 will be initially rendered with no internal structure; they render their Element empty. The more specialized ExtJS and
 Touch classes which use a more complex DOM structure, provide their own template definitions. This is intended to allow
 the developer to create application-specific utility Components with customized internal structure. Upon rendering, any
 created child elements may be automatically imported into object properties using the renderSelectors option.]]></description><name>renderTpl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to make this field required. Note: this only causes a visual indication. Doesn't prevent user from submitting the
 form.]]></description><name>required</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
             title: 'Some Title',
             renderTo: Ext.getBody(),
          
 width: 400, height: 300,
             layout: 'form',
             items: [{
                 xtype: 'textareafield',
      
 style: {
                     width: '95%',
                     marginBottom: '10px'
                 }
             },
    
 new Ext.Button({
                 text: 'Send',
                 minWidth: '100',
                 style: {
                
     marginBottom: '10px'
                 }
             })
             ]
         });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The class that is added to the content target when you set styleHtmlContent to true. Defaults to 'x-html']]></description><name>styleHtmlCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically style the html inside the content target of this component (body for panels). Defaults to false.]]></description><name>styleHtmlContent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The tabIndex for this field. Note this only applies to fields that are rendered, not those which are built via applyTo
 (defaults to undefined).]]></description><name>tabIndex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An Ext.Template, Ext.XTemplate or an array of strings to form an Ext.XTemplate. Used in conjunction with the data and
 tplWriteMode configurations.]]></description><name>tpl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A set of predefined ui styles for individual components. Most components support 'light' and 'dark'. Extra string added
 to the baseCls with an extra '-'. 
 <pre><code>
 new Ext.Panel({
     title: 'Some Title',
     baseCls: 'x-component'
     ui: 'green'
 });</pre></code>
 The ui configuration in this example would add 'x-component-green' as an additional class.]]></description><name>ui</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A value to initialize this field with (defaults to undefined).]]></description><name>value</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of this component in pixels.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original SenchaTouch API docs:
 <a href="http://docs.sencha.com/touch/">http://docs.sencha.com/touch/</a>

 <p>Simple FieldSet, can contain fields as items. FieldSets do not add any behavior, other than an optional title, and
 are just used to group similar fields together. Example usage (within a form):</p> 
 <pre><code><b>new</b>
 Ext.form.FormPanel({
     items: [
         {
             xtype: <em>'fieldset'</em>,
             title: <em>'About Me'</em>,
             items: [
                 {
                     xtype: <em>'textfield'</em>,
                     name : <em>'firstName'</em>,
                     <b>label</b>: <em>'First Name'</em>
                 },
                 {
                     xtype: <em>'textfield'</em>,
                     name : <em>'lastName'</em>,
                     <b>label</b>: <em>'Last Name'</em>
                 }
             ]
         }
     ]
 });</code></pre>]]></description><name>form.fieldSet</name><tag-class>org.brushingbits.jnap.ui.senchatouch.form.FieldSet</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[A string component id or the numeric index of the component that should be initially activated within the container's
 layout on render. For example, activeItem: 'item-1' or activeItem: 0 (index 0 = the first item in the container's
 collection). activeItem only applies to layout styles that can display items one at a time (like Ext.layout.CardLayout
 and Ext.layout.FitLayout). Related to Ext.layout.ContainerLayout.activeItem.]]></description><name>activeItem</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If true the container will automatically destroy any contained component that is removed from it, else destruction must
 be handled manually (defaults to true).]]></description><name>autoDestroy</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The base CSS class to apply to this components's element. This will also be prepended to elements within this component
 like Panel's body will get a class x-panel-body. This means that if you create a subclass of Panel, and you want it to
 get all the Panels styling for the element and the body, you leave the baseCls x-panel and use componentCls to add
 specific styling for this component.]]></description><name>baseCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the border for this component. The border can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>border</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to ['add', 'remove'].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Animation to be used during transitions of cards. Note this only works when this container has a CardLayout. Any valid
 value from Ext.anims can be used ('fade', 'slide', 'flip', 'cube', 'pop', 'wipe'). Defaults to null.]]></description><name>cardSwitchAnimation</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element (defaults to ''). This can be useful for
 adding customized styles to the component or any of its children using standard CSS rules.]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS Class to be added to a components root level element to give distinction to it via styling.]]></description><name>componentCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The sizing and positioning of the component Elements is the responsibility of the Component's layout manager which
 creates and manages the type of layout specific to the component. If the layout configuration is not explicitly
 specified for a general purpose compopnent the default layout manager will be used.]]></description><name>componentLayout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default xtype of child Components to create in this Container when a child item is specified as a raw configuration
 object, rather than as an instantiated Component. Defaults to 'panel'.]]></description><name>defaultType</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[This option is a means of applying default settings to all added items whether added through the items config or via the
 add or insert methods. If an added item is a config object, and not an instantiated Component, then the default
 properties are unconditionally applied. If the added item is an instantiated Component, then the default properties are
 applied conditionally so as not to override existing properties in the item. If the defaults option is specified as a
 function, then the function will be called using this Container as the scope (this reference) and passing the added item
 as the first parameter. Any resulting object from that call is then applied to the item as default properties. For
 example, to automatically apply padding to the body of each of a set of contained Ext.Panel items, you could pass:
 defaults: {bodyStyle:'padding:15px'}. Usage: defaults: {               // defaults are applied to items, not the
 container
     autoScroll:true
 },
 items: [
     {
         xtype: 'panel',   // defaults do not have precedence over
       
 id: 'panel1',     // options in config objects, so the defaults
         autoScroll: false // will not be applied here,
 panel1 will be autoScroll:false
     },
     new Ext.Panel({       // defaults do have precedence over options
         id:
 'panel2',     // options in components, so the defaults
         autoScroll: false // will be applied here, panel2 will
 be autoScroll:true.
     })
 ]]]></description><name>defaults</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to false.]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class to add when the Component is disabled. Defaults to 'x-item-disabled'.]]></description><name>disabledCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Allows the component to be dragged via the touch event.]]></description><name>draggable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Create the Component as a floating and use absolute positioning. Defaults to false.]]></description><name>floating</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of this component in pixels.]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to false.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional fieldset instructions, rendered just below the grouped fields]]></description><name>instructions</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[** IMPORTANT: be sure to specify a layout if needed ! ** A single item, or an array of child Components to be added to
 this container, for example: // specifying a single item
 items: {...},
 layout: 'fit',    // specify a layout!
 
 //
 specifying multiple items
 items: [{...}, {...}],
 layout: 'hbox', // specify a layout! Each item may be: any type of
 object based on Ext.Component a fully instanciated object or an object literal that: has a specified xtype the
 Ext.Component.xtype specified is associated with the Component desired and should be chosen from one of the available
 xtypes as listed in Ext.Component. If an xtype is not explicitly specified, the defaultType for that Container is used.
 will be "lazily instanciated", avoiding the overhead of constructing a fully instanciated Component object Notes: Ext
 uses lazy rendering. Child Components will only be rendered should it become necessary. Items are automatically laid out
 when they are first shown (no sizing is done while hidden), or in response to a doLayout call. Do not specify contentEl/
 html with items.]]></description><name>items</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[*Important: In order for child items to be correctly sized and positioned, typically a layout manager must be specified
 through the layout configuration option. The sizing and positioning of child items is the responsibility of the
 Container's layout manager which creates and manages the type of layout you have in mind. For example: If the layout
 configuration is not explicitly specified for a general purpose container (e.g. Container or Panel) the default layout
 manager will be used which does nothing but render child components sequentially into the Container (no sizing or
 positioning will be performed in this situation). layout may be specified as either as an Object or as a String: Specify
 as an Object Example usage: layout: {
     type: 'vbox',
     align: 'left'
 } type The layout type to be used for this
 container. If not specified, a default Ext.layout.ContainerLayout will be created and used. Valid layout type values
 are:
 auto - Default card fit hbox vbox Layout specific configuration properties Additional layout specific
 configuration properties may also be specified. For complete details regarding the valid config options for each layout
 type, see the layout class corresponding to the type specified. Specify as a String Example usage: layout: {
     type:
 'vbox',
     padding: '5',
     align: 'left'
 } layout The layout type to be used for this container (see list of valid
 layout type values above). Additional layout specific configuration properties. For complete details regarding the valid
 config options for each layout type, see the layout class corresponding to the layout specified.]]></description><name>layout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A config object containing one or more event handlers to be added to this object during initialization. This should be a
 valid listeners config object as specified in the addListener example for attaching multiple handlers at once. DOM
 events from ExtJs Components While some ExtJs Component classes export selected DOM events (e.g. "click", "mouseover"
 etc), this is usually only done when extra value can be added. For example the DataView's click event passing the node
 clicked on. To access DOM events directly from a child element of a Component, we need to specify the element option to
 identify the Component property to add a DOM listener to: new Ext.Panel({
     width: 400,
     height: 200,
    
 dockedItems: [{
         xtype: 'toolbar'
     }],
     listeners: {
         click: {
             element: 'el', //bind to
 the underlying el property on the panel
             fn: function(){ console.log('click el'); }
         },
        
 dblclick: {
             element: 'body', //bind to the underlying body property on the panel
             fn: function(){
 console.log('dblclick body'); }
         }
     }
 });]]></description><name>listeners</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the margin for this component. The margin can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>margin</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this Component will set its height to. Warning: This will override any size management
 applied by layout managers.]]></description><name>maxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this Component will set its width to. Warning: This will override any size management
 applied by layout managers.]]></description><name>maxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this Component will set its height to. Warning: This will override any size management
 applied by layout managers.]]></description><name>minHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this Component will set its width to. Warning: This will override any size management
 applied by layout managers.]]></description><name>minWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the padding for this component. The padding can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>padding</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object containing properties specifying DomQuery selectors which identify child elements created by the render
 process. After the Component's internal structure is rendered according to the renderTpl, this object is iterated
 through, and the found Elements are added as properties to the Component using the renderSelector property name. For
 example, a Component which rendered an image, and description into its element might use the following properties coded
 into its prototype: renderTpl: '"{imageUrl}" class="x-image-component-img">
 "x-image-component-desc">{description}',
 
 renderSelectors: {
     image: 'img.x-image-component-img',
     descEl:
 'div.x-image-component-desc'
 } After rendering, the Component would have a property image referencing its child img
 Element, and a property descEl referencing the div Element which contains the description.]]></description><name>renderSelectors</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An XTemplate used to create the internal structure inside this Component's encapsulating Element. You do not normally
 need to specify this. For the base classes Ext.Component and Ext.Container, this defaults to null which means that they
 will be initially rendered with no internal structure; they render their Element empty. The more specialized ExtJS and
 Touch classes which use a more complex DOM structure, provide their own template definitions. This is intended to allow
 the developer to create application-specific utility Components with customized internal structure. Upon rendering, any
 created child elements may be automatically imported into object properties using the renderSelectors option.]]></description><name>renderTpl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
             title: 'Some Title',
             renderTo: Ext.getBody(),
          
 width: 400, height: 300,
             layout: 'form',
             items: [{
                 xtype: 'textareafield',
      
 style: {
                     width: '95%',
                     marginBottom: '10px'
                 }
             },
    
 new Ext.Button({
                 text: 'Send',
                 minWidth: '100',
                 style: {
                
     marginBottom: '10px'
                 }
             })
             ]
         });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The class that is added to the content target when you set styleHtmlContent to true. Defaults to 'x-html']]></description><name>styleHtmlCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically style the html inside the content target of this component (body for panels). Defaults to false.]]></description><name>styleHtmlContent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional fieldset title, rendered just above the grouped fields]]></description><name>title</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An Ext.Template, Ext.XTemplate or an array of strings to form an Ext.XTemplate. Used in conjunction with the data and
 tplWriteMode configurations.]]></description><name>tpl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A set of predefined ui styles for individual components. Most components support 'light' and 'dark'. Extra string added
 to the baseCls with an extra '-'. 
 <pre><code>
 new Ext.Panel({
     title: 'Some Title',
     baseCls: 'x-component'
     ui: 'green'
 });</pre></code>
 The ui configuration in this example would add 'x-component-green' as an additional class.]]></description><name>ui</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of this component in pixels.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original SenchaTouch API docs:
 <a href="http://docs.sencha.com/touch/">http://docs.sencha.com/touch/</a>

 <p>Simple text input field. See <a href="output/Ext.form.FormPanel.html" ext:cls="Ext.form.FormPanel">FormPanel</a> for
 example usage.</p>]]></description><name>form.numberField</name><tag-class>org.brushingbits.jnap.ui.senchatouch.form.NumberField</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[A string component id or the numeric index of the component that should be initially activated within the container's
 layout on render. For example, activeItem: 'item-1' or activeItem: 0 (index 0 = the first item in the container's
 collection). activeItem only applies to layout styles that can display items one at a time (like Ext.layout.CardLayout
 and Ext.layout.FitLayout). Related to Ext.layout.ContainerLayout.activeItem.]]></description><name>activeItem</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>autoCapitalize</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>autoComplete</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>autoCorrect</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically create the field input element on render. This is true by default, but should be set to false for
 any Ext.Field subclasses that don't need an HTML input (e.g. Ext.Slider and similar)]]></description><name>autoCreateField</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If true the container will automatically destroy any contained component that is removed from it, else destruction must
 be handled manually (defaults to true).]]></description><name>autoDestroy</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The base CSS class to apply to this components's element. This will also be prepended to elements within this component
 like Panel's body will get a class x-panel-body. This means that if you create a subclass of Panel, and you want it to
 get all the Panels styling for the element and the body, you leave the baseCls x-panel and use componentCls to add
 specific styling for this component.]]></description><name>baseCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the border for this component. The border can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>border</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to ['add', 'remove'].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Animation to be used during transitions of cards. Note this only works when this container has a CardLayout. Any valid
 value from Ext.anims can be used ('fade', 'slide', 'flip', 'cube', 'pop', 'wipe'). Defaults to null.]]></description><name>cardSwitchAnimation</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom CSS class to apply to the field's underlying element (defaults to '').]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS Class to be added to a components root level element to give distinction to it via styling.]]></description><name>componentCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The sizing and positioning of the component Elements is the responsibility of the Component's layout manager which
 creates and manages the type of layout specific to the component. If the layout configuration is not explicitly
 specified for a general purpose compopnent the default layout manager will be used.]]></description><name>componentLayout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default xtype of child Components to create in this Container when a child item is specified as a raw configuration
 object, rather than as an instantiated Component. Defaults to 'panel'.]]></description><name>defaultType</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[This option is a means of applying default settings to all added items whether added through the items config or via the
 add or insert methods. If an added item is a config object, and not an instantiated Component, then the default
 properties are unconditionally applied. If the added item is an instantiated Component, then the default properties are
 applied conditionally so as not to override existing properties in the item. If the defaults option is specified as a
 function, then the function will be called using this Container as the scope (this reference) and passing the added item
 as the first parameter. Any resulting object from that call is then applied to the item as default properties. For
 example, to automatically apply padding to the body of each of a set of contained Ext.Panel items, you could pass:
 defaults: {bodyStyle:'padding:15px'}. Usage: defaults: {               // defaults are applied to items, not the
 container
     autoScroll:true
 },
 items: [
     {
         xtype: 'panel',   // defaults do not have precedence over
       
 id: 'panel1',     // options in config objects, so the defaults
         autoScroll: false // will not be applied here,
 panel1 will be autoScroll:false
     },
     new Ext.Panel({       // defaults do have precedence over options
         id:
 'panel2',     // options in components, so the defaults
         autoScroll: false // will be applied here, panel2 will
 be autoScroll:true.
     })
 ]]]></description><name>defaults</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to disable the field (defaults to false). Be aware that conformant with the HTML specification, disabled Fields
 will not be submitted.]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class to add when the Component is disabled. Defaults to 'x-item-disabled'.]]></description><name>disabledCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Allows the component to be dragged via the touch event.]]></description><name>draggable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default CSS class for the field (defaults to 'x-form-field')]]></description><name>fieldCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Create the Component as a floating and use absolute positioning. Defaults to false.]]></description><name>floating</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class to use when the field receives focus (defaults to 'x-field-focus')]]></description><name>focusCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of this component in pixels.]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to false.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional CSS class that will be added to the actual element (or whichever different element is defined by inputAutoEl).
 Defaults to undefined.]]></description><name>inputCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The type attribute for input fields -- e.g. radio, text, password, file (defaults to 'text'). The types 'file' and
 'password' must be used to render those field types currently -- there are no separate Ext components for those. Note
 that if you use inputType:'file', emptyText is not supported and should be avoided.]]></description><name>inputType</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[** IMPORTANT: be sure to specify a layout if needed ! ** A single item, or an array of child Components to be added to
 this container, for example: // specifying a single item
 items: {...},
 layout: 'fit',    // specify a layout!
 
 //
 specifying multiple items
 items: [{...}, {...}],
 layout: 'hbox', // specify a layout! Each item may be: any type of
 object based on Ext.Component a fully instanciated object or an object literal that: has a specified xtype the
 Ext.Component.xtype specified is associated with the Component desired and should be chosen from one of the available
 xtypes as listed in Ext.Component. If an xtype is not explicitly specified, the defaultType for that Container is used.
 will be "lazily instanciated", avoiding the overhead of constructing a fully instanciated Component object Notes: Ext
 uses lazy rendering. Child Components will only be rendered should it become necessary. Items are automatically laid out
 when they are first shown (no sizing is done while hidden), or in response to a doLayout call. Do not specify contentEl/
 html with items.]]></description><name>items</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The label to associate with this field. Defaults to null.]]></description><name>label</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The location to render the label of the field. Acceptable values are 'top' and 'left'. Defaults to 'left']]></description><name>labelAlign</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of the label, can be any valid CSS size. E.g '20%', '6em', '100px'. Defaults to '30%']]></description><name>labelWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[*Important: In order for child items to be correctly sized and positioned, typically a layout manager must be specified
 through the layout configuration option. The sizing and positioning of child items is the responsibility of the
 Container's layout manager which creates and manages the type of layout you have in mind. For example: If the layout
 configuration is not explicitly specified for a general purpose container (e.g. Container or Panel) the default layout
 manager will be used which does nothing but render child components sequentially into the Container (no sizing or
 positioning will be performed in this situation). layout may be specified as either as an Object or as a String: Specify
 as an Object Example usage: layout: {
     type: 'vbox',
     align: 'left'
 } type The layout type to be used for this
 container. If not specified, a default Ext.layout.ContainerLayout will be created and used. Valid layout type values
 are:
 auto - Default card fit hbox vbox Layout specific configuration properties Additional layout specific
 configuration properties may also be specified. For complete details regarding the valid config options for each layout
 type, see the layout class corresponding to the type specified. Specify as a String Example usage: layout: {
     type:
 'vbox',
     padding: '5',
     align: 'left'
 } layout The layout type to be used for this container (see list of valid
 layout type values above). Additional layout specific configuration properties. For complete details regarding the valid
 config options for each layout type, see the layout class corresponding to the layout specified.]]></description><name>layout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A config object containing one or more event handlers to be added to this object during initialization. This should be a
 valid listeners config object as specified in the addListener example for attaching multiple handlers at once. DOM
 events from ExtJs Components While some ExtJs Component classes export selected DOM events (e.g. "click", "mouseover"
 etc), this is usually only done when extra value can be added. For example the DataView's click event passing the node
 clicked on. To access DOM events directly from a child element of a Component, we need to specify the element option to
 identify the Component property to add a DOM listener to: new Ext.Panel({
     width: 400,
     height: 200,
    
 dockedItems: [{
         xtype: 'toolbar'
     }],
     listeners: {
         click: {
             element: 'el', //bind to
 the underlying el property on the panel
             fn: function(){ console.log('click el'); }
         },
        
 dblclick: {
             element: 'body', //bind to the underlying body property on the panel
             fn: function(){
 console.log('dblclick body'); }
         }
     }
 });]]></description><name>listeners</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the margin for this component. The margin can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>margin</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this Component will set its height to. Warning: This will override any size management
 applied by layout managers.]]></description><name>maxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum number of permitted input characters (defaults to 0).]]></description><name>maxLength</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this Component will set its width to. Warning: This will override any size management
 applied by layout managers.]]></description><name>maxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this Component will set its height to. Warning: This will override any size management
 applied by layout managers.]]></description><name>minHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this Component will set its width to. Warning: This will override any size management
 applied by layout managers.]]></description><name>minWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The field's HTML name attribute (defaults to ''). Note: this property must be set if this field is to be automatically
 included with form submit().]]></description><name>name</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the padding for this component. The padding can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>padding</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A string value displayed in the input (if supported) when the control is empty.]]></description><name>placeHolder</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object containing properties specifying DomQuery selectors which identify child elements created by the render
 process. After the Component's internal structure is rendered according to the renderTpl, this object is iterated
 through, and the found Elements are added as properties to the Component using the renderSelector property name. For
 example, a Component which rendered an image, and description into its element might use the following properties coded
 into its prototype: renderTpl: '"{imageUrl}" class="x-image-component-img">
 "x-image-component-desc">{description}',
 
 renderSelectors: {
     image: 'img.x-image-component-img',
     descEl:
 'div.x-image-component-desc'
 } After rendering, the Component would have a property image referencing its child img
 Element, and a property descEl referencing the div Element which contains the description.]]></description><name>renderSelectors</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An XTemplate used to create the internal structure inside this Component's encapsulating Element. You do not normally
 need to specify this. For the base classes Ext.Component and Ext.Container, this defaults to null which means that they
 will be initially rendered with no internal structure; they render their Element empty. The more specialized ExtJS and
 Touch classes which use a more complex DOM structure, provide their own template definitions. This is intended to allow
 the developer to create application-specific utility Components with customized internal structure. Upon rendering, any
 created child elements may be automatically imported into object properties using the renderSelectors option.]]></description><name>renderTpl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to make this field required. Note: this only causes a visual indication. Doesn't prevent user from submitting the
 form.]]></description><name>required</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
             title: 'Some Title',
             renderTo: Ext.getBody(),
          
 width: 400, height: 300,
             layout: 'form',
             items: [{
                 xtype: 'textareafield',
      
 style: {
                     width: '95%',
                     marginBottom: '10px'
                 }
             },
    
 new Ext.Button({
                 text: 'Send',
                 minWidth: '100',
                 style: {
                
     marginBottom: '10px'
                 }
             })
             ]
         });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The class that is added to the content target when you set styleHtmlContent to true. Defaults to 'x-html']]></description><name>styleHtmlCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically style the html inside the content target of this component (body for panels). Defaults to false.]]></description><name>styleHtmlContent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The tabIndex for this field. Note this only applies to fields that are rendered, not those which are built via applyTo
 (defaults to undefined).]]></description><name>tabIndex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An Ext.Template, Ext.XTemplate or an array of strings to form an Ext.XTemplate. Used in conjunction with the data and
 tplWriteMode configurations.]]></description><name>tpl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A set of predefined ui styles for individual components. Most components support 'light' and 'dark'. Extra string added
 to the baseCls with an extra '-'. 
 <pre><code>
 new Ext.Panel({
     title: 'Some Title',
     baseCls: 'x-component'
     ui: 'green'
 });</pre></code>
 The ui configuration in this example would add 'x-component-green' as an additional class.]]></description><name>ui</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A value to initialize this field with (defaults to undefined).]]></description><name>value</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of this component in pixels.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original SenchaTouch API docs:
 <a href="http://docs.sencha.com/touch/">http://docs.sencha.com/touch/</a>

 <p>Simple form panel which enables easy getting and setting of field values. Can load model instances. Example
 usage:</p> 
 <pre><code><b>var</b> form = <b>new</b> Ext.form.FormPanel({
     items: [
         {
             xtype: <em>'textfield'</em>,
             name : <em>'first'</em>,
             <b>label</b>: <em>'First name'</em>
         },
         {
             xtype: <em>'textfield'</em>,
             name : <em>'last'</em>,
             <b>label</b>: <em>'Last name'</em>
         },
         {
             xtype: <em>'numberfield'</em>,
             name : <em>'age'</em>,
             <b>label</b>: <em>'Age'</em>
         },
         {
             xtype: <em>'urlfield'</em>,
             name : <em>'url'</em>,
             <b>label</b>: <em>'Website'</em>
         }
     ]
 });</code></pre> 
 <p>Loading model
 instances:</p> 
 <pre><code>Ext.regModel(<em>'User'</em>, {
     fields: [
         {name: <em>'first'</em>, type: <em>'string'</em>},
         {name: <em>'last'</em>,  type: <em>'string'</em>},
         {name: <em>'age'</em>,   type: <em>'int'</em>},
         {name: <em>'url'</em>,   type: <em>'string'</em>}
     ]
 });
 
 <b>var</b> user =
 Ext.ModelMgr.create({
     first: <em>'Ed'</em>,
     last : <em>'Spencer'</em>,
     age  : 24,
     url  :
 <em>'http:<i>//extjs.com'</i></em>
 }, <em>'User'</em>);
 
 form.load(user);</code></pre>]]></description><name>form.panel</name><tag-class>org.brushingbits.jnap.ui.senchatouch.form.FormPanel</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[A string component id or the numeric index of the component that should be initially activated within the container's
 layout on render. For example, activeItem: 'item-1' or activeItem: 0 (index 0 = the first item in the container's
 collection). activeItem only applies to layout styles that can display items one at a time (like Ext.layout.CardLayout
 and Ext.layout.FitLayout). Related to Ext.layout.ContainerLayout.activeItem.]]></description><name>activeItem</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If true the container will automatically destroy any contained component that is removed from it, else destruction must
 be handled manually (defaults to true).]]></description><name>autoDestroy</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The base CSS class to apply to this panel's element (defaults to 'x-panel').]]></description><name>baseCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional hash of params to be sent (when standardSubmit configuration is false) on every submit.]]></description><name>baseParams</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A shortcut for setting a border style on the body element. The value can either be a number to be applied to all sides,
 or a normal css string describing borders. Defaults to undefined.]]></description><name>bodyBorder</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A shortcut for setting a margin style on the body element. The value can either be a number to be applied to all sides,
 or a normal css string describing margins. Defaults to undefined.]]></description><name>bodyMargin</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A shortcut for setting a padding style on the body element. The value can either be a number to be applied to all sides,
 or a normal css string describing padding. Defaults to undefined.]]></description><name>bodyPadding</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the border for this component. The border can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>border</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to ['add', 'remove'].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element (defaults to ''). This can be useful for
 adding customized styles to the component or any of its children using standard CSS rules.]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS Class to be added to a components root level element to give distinction to it via styling.]]></description><name>componentCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The sizing and positioning of the component Elements is the responsibility of the Component's layout manager which
 creates and manages the type of layout specific to the component. If the layout configuration is not explicitly
 specified for a general purpose compopnent the default layout manager will be used.]]></description><name>componentLayout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default xtype of child Components to create in this Container when a child item is specified as a raw configuration
 object, rather than as an instantiated Component. Defaults to 'panel'.]]></description><name>defaultType</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[This option is a means of applying default settings to all added items whether added through the items config or via the
 add or insert methods. If an added item is a config object, and not an instantiated Component, then the default
 properties are unconditionally applied. If the added item is an instantiated Component, then the default properties are
 applied conditionally so as not to override existing properties in the item. If the defaults option is specified as a
 function, then the function will be called using this Container as the scope (this reference) and passing the added item
 as the first parameter. Any resulting object from that call is then applied to the item as default properties. For
 example, to automatically apply padding to the body of each of a set of contained Ext.Panel items, you could pass:
 defaults: {bodyStyle:'padding:15px'}. Usage: defaults: {               // defaults are applied to items, not the
 container
     autoScroll:true
 },
 items: [
     {
         xtype: 'panel',   // defaults do not have precedence over
       
 id: 'panel1',     // options in config objects, so the defaults
         autoScroll: false // will not be applied here,
 panel1 will be autoScroll:false
     },
     new Ext.Panel({       // defaults do have precedence over options
         id:
 'panel2',     // options in components, so the defaults
         autoScroll: false // will be applied here, panel2 will
 be autoScroll:true.
     })
 ]]]></description><name>defaults</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to false.]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class to add when the Component is disabled. Defaults to 'x-item-disabled'.]]></description><name>disabledCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A component or series of components to be added as docked items to this panel. The docked items can be docked to either
 the top, right, left or bottom of a panel. This is typically used for things like toolbars or tab bars: var panel = new
 Ext.Panel({
     fullscreen: true,
     dockedItems: [{
         xtype: 'toolbar',
         dock: 'top',
         items: [{
  
           text: 'Docked to the bottom'
         }]
     }]
 });]]></description><name>dockedItems</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Allows the component to be dragged via the touch event.]]></description><name>draggable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Create the Component as a floating and use absolute positioning. Defaults to false.]]></description><name>floating</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of this component in pixels.]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to false.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[** IMPORTANT: be sure to specify a layout if needed ! ** A single item, or an array of child Components to be added to
 this container, for example: // specifying a single item
 items: {...},
 layout: 'fit',    // specify a layout!
 
 //
 specifying multiple items
 items: [{...}, {...}],
 layout: 'hbox', // specify a layout! Each item may be: any type of
 object based on Ext.Component a fully instanciated object or an object literal that: has a specified xtype the
 Ext.Component.xtype specified is associated with the Component desired and should be chosen from one of the available
 xtypes as listed in Ext.Component. If an xtype is not explicitly specified, the defaultType for that Container is used.
 will be "lazily instanciated", avoiding the overhead of constructing a fully instanciated Component object Notes: Ext
 uses lazy rendering. Child Components will only be rendered should it become necessary. Items are automatically laid out
 when they are first shown (no sizing is done while hidden), or in response to a doLayout call. Do not specify contentEl/
 html with items.]]></description><name>items</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[*Important: In order for child items to be correctly sized and positioned, typically a layout manager must be specified
 through the layout configuration option. The sizing and positioning of child items is the responsibility of the
 Container's layout manager which creates and manages the type of layout you have in mind. For example: If the layout
 configuration is not explicitly specified for a general purpose container (e.g. Container or Panel) the default layout
 manager will be used which does nothing but render child components sequentially into the Container (no sizing or
 positioning will be performed in this situation). layout may be specified as either as an Object or as a String: Specify
 as an Object Example usage: layout: {
     type: 'vbox',
     align: 'left'
 } type The layout type to be used for this
 container. If not specified, a default Ext.layout.ContainerLayout will be created and used. Valid layout type values
 are:
 auto - Default card fit hbox vbox Layout specific configuration properties Additional layout specific
 configuration properties may also be specified. For complete details regarding the valid config options for each layout
 type, see the layout class corresponding to the type specified. Specify as a String Example usage: layout: {
     type:
 'vbox',
     padding: '5',
     align: 'left'
 } layout The layout type to be used for this container (see list of valid
 layout type values above). Additional layout specific configuration properties. For complete details regarding the valid
 config options for each layout type, see the layout class corresponding to the layout specified.]]></description><name>layout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A config object containing one or more event handlers to be added to this object during initialization. This should be a
 valid listeners config object as specified in the addListener example for attaching multiple handlers at once. DOM
 events from ExtJs Components While some ExtJs Component classes export selected DOM events (e.g. "click", "mouseover"
 etc), this is usually only done when extra value can be added. For example the DataView's click event passing the node
 clicked on. To access DOM events directly from a child element of a Component, we need to specify the element option to
 identify the Component property to add a DOM listener to: new Ext.Panel({
     width: 400,
     height: 200,
    
 dockedItems: [{
         xtype: 'toolbar'
     }],
     listeners: {
         click: {
             element: 'el', //bind to
 the underlying el property on the panel
             fn: function(){ console.log('click el'); }
         },
        
 dblclick: {
             element: 'body', //bind to the underlying body property on the panel
             fn: function(){
 console.log('dblclick body'); }
         }
     }
 });]]></description><name>listeners</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the margin for this component. The margin can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>margin</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this Component will set its height to. Warning: This will override any size management
 applied by layout managers.]]></description><name>maxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this Component will set its width to. Warning: This will override any size management
 applied by layout managers.]]></description><name>maxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this Component will set its height to. Warning: This will override any size management
 applied by layout managers.]]></description><name>minHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this Component will set its width to. Warning: This will override any size management
 applied by layout managers.]]></description><name>minWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the padding for this component. The padding can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>padding</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object containing properties specifying DomQuery selectors which identify child elements created by the render
 process. After the Component's internal structure is rendered according to the renderTpl, this object is iterated
 through, and the found Elements are added as properties to the Component using the renderSelector property name. For
 example, a Component which rendered an image, and description into its element might use the following properties coded
 into its prototype: renderTpl: '"{imageUrl}" class="x-image-component-img">
 "x-image-component-desc">{description}',
 
 renderSelectors: {
     image: 'img.x-image-component-img',
     descEl:
 'div.x-image-component-desc'
 } After rendering, the Component would have a property image referencing its child img
 Element, and a property descEl referencing the div Element which contains the description.]]></description><name>renderSelectors</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An XTemplate used to create the internal structure inside this Component's encapsulating Element. You do not normally
 need to specify this. For the base classes Ext.Component and Ext.Container, this defaults to null which means that they
 will be initially rendered with no internal structure; they render their Element empty. The more specialized ExtJS and
 Touch classes which use a more complex DOM structure, provide their own template definitions. This is intended to allow
 the developer to create application-specific utility Components with customized internal structure. Upon rendering, any
 created child elements may be automatically imported into object properties using the renderSelectors option.]]></description><name>renderTpl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Wether or not we want to perform a standard form submit. Defaults to false]]></description><name>standardSubmit</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
             title: 'Some Title',
             renderTo: Ext.getBody(),
          
 width: 400, height: 300,
             layout: 'form',
             items: [{
                 xtype: 'textareafield',
      
 style: {
                     width: '95%',
                     marginBottom: '10px'
                 }
             },
    
 new Ext.Button({
                 text: 'Send',
                 minWidth: '100',
                 style: {
                
     marginBottom: '10px'
                 }
             })
             ]
         });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The class that is added to the content target when you set styleHtmlContent to true. Defaults to 'x-html']]></description><name>styleHtmlCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically style the html inside the content target of this component (body for panels). Defaults to false.]]></description><name>styleHtmlContent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[When this is set to true, the form will automatically submit itself whenever the 'action' event fires on a field in this
 form. The action event usually fires whenever you press go or enter inside a textfield.]]></description><name>submitOnAction</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An Ext.Template, Ext.XTemplate or an array of strings to form an Ext.XTemplate. Used in conjunction with the data and
 tplWriteMode configurations.]]></description><name>tpl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A set of predefined ui styles for individual components. Most components support 'light' and 'dark'. Extra string added
 to the baseCls with an extra '-'. 
 <pre><code>
 new Ext.Panel({
     title: 'Some Title',
     baseCls: 'x-component'
     ui: 'green'
 });</pre></code>
 The ui configuration in this example would add 'x-component-green' as an additional class.]]></description><name>ui</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default Url for submit actions]]></description><name>url</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The defined waitMsg template. Used for precise control over the masking agent used to mask the FormPanel (or other
 Element) during form Ajax/submission actions. For more options, see showMask method.]]></description><name>waitTpl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of this component in pixels.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original SenchaTouch API docs:
 <a href="http://docs.sencha.com/touch/">http://docs.sencha.com/touch/</a>

 Wraps an HTML5 search field.]]></description><name>form.searchField</name><tag-class>org.brushingbits.jnap.ui.senchatouch.form.SearchField</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[A string component id or the numeric index of the component that should be initially activated within the container's
 layout on render. For example, activeItem: 'item-1' or activeItem: 0 (index 0 = the first item in the container's
 collection). activeItem only applies to layout styles that can display items one at a time (like Ext.layout.CardLayout
 and Ext.layout.FitLayout). Related to Ext.layout.ContainerLayout.activeItem.]]></description><name>activeItem</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>autoCapitalize</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>autoComplete</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>autoCorrect</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically create the field input element on render. This is true by default, but should be set to false for
 any Ext.Field subclasses that don't need an HTML input (e.g. Ext.Slider and similar)]]></description><name>autoCreateField</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If true the container will automatically destroy any contained component that is removed from it, else destruction must
 be handled manually (defaults to true).]]></description><name>autoDestroy</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The base CSS class to apply to this components's element. This will also be prepended to elements within this component
 like Panel's body will get a class x-panel-body. This means that if you create a subclass of Panel, and you want it to
 get all the Panels styling for the element and the body, you leave the baseCls x-panel and use componentCls to add
 specific styling for this component.]]></description><name>baseCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the border for this component. The border can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>border</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to ['add', 'remove'].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Animation to be used during transitions of cards. Note this only works when this container has a CardLayout. Any valid
 value from Ext.anims can be used ('fade', 'slide', 'flip', 'cube', 'pop', 'wipe'). Defaults to null.]]></description><name>cardSwitchAnimation</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom CSS class to apply to the field's underlying element (defaults to '').]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS Class to be added to a components root level element to give distinction to it via styling.]]></description><name>componentCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The sizing and positioning of the component Elements is the responsibility of the Component's layout manager which
 creates and manages the type of layout specific to the component. If the layout configuration is not explicitly
 specified for a general purpose compopnent the default layout manager will be used.]]></description><name>componentLayout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default xtype of child Components to create in this Container when a child item is specified as a raw configuration
 object, rather than as an instantiated Component. Defaults to 'panel'.]]></description><name>defaultType</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[This option is a means of applying default settings to all added items whether added through the items config or via the
 add or insert methods. If an added item is a config object, and not an instantiated Component, then the default
 properties are unconditionally applied. If the added item is an instantiated Component, then the default properties are
 applied conditionally so as not to override existing properties in the item. If the defaults option is specified as a
 function, then the function will be called using this Container as the scope (this reference) and passing the added item
 as the first parameter. Any resulting object from that call is then applied to the item as default properties. For
 example, to automatically apply padding to the body of each of a set of contained Ext.Panel items, you could pass:
 defaults: {bodyStyle:'padding:15px'}. Usage: defaults: {               // defaults are applied to items, not the
 container
     autoScroll:true
 },
 items: [
     {
         xtype: 'panel',   // defaults do not have precedence over
       
 id: 'panel1',     // options in config objects, so the defaults
         autoScroll: false // will not be applied here,
 panel1 will be autoScroll:false
     },
     new Ext.Panel({       // defaults do have precedence over options
         id:
 'panel2',     // options in components, so the defaults
         autoScroll: false // will be applied here, panel2 will
 be autoScroll:true.
     })
 ]]]></description><name>defaults</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to disable the field (defaults to false). Be aware that conformant with the HTML specification, disabled Fields
 will not be submitted.]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class to add when the Component is disabled. Defaults to 'x-item-disabled'.]]></description><name>disabledCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Allows the component to be dragged via the touch event.]]></description><name>draggable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default CSS class for the field (defaults to 'x-form-field')]]></description><name>fieldCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Create the Component as a floating and use absolute positioning. Defaults to false.]]></description><name>floating</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class to use when the field receives focus (defaults to 'x-field-focus')]]></description><name>focusCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of this component in pixels.]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to false.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional CSS class that will be added to the actual element (or whichever different element is defined by inputAutoEl).
 Defaults to undefined.]]></description><name>inputCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The type attribute for input fields -- e.g. radio, text, password, file (defaults to 'text'). The types 'file' and
 'password' must be used to render those field types currently -- there are no separate Ext components for those. Note
 that if you use inputType:'file', emptyText is not supported and should be avoided.]]></description><name>inputType</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[** IMPORTANT: be sure to specify a layout if needed ! ** A single item, or an array of child Components to be added to
 this container, for example: // specifying a single item
 items: {...},
 layout: 'fit',    // specify a layout!
 
 //
 specifying multiple items
 items: [{...}, {...}],
 layout: 'hbox', // specify a layout! Each item may be: any type of
 object based on Ext.Component a fully instanciated object or an object literal that: has a specified xtype the
 Ext.Component.xtype specified is associated with the Component desired and should be chosen from one of the available
 xtypes as listed in Ext.Component. If an xtype is not explicitly specified, the defaultType for that Container is used.
 will be "lazily instanciated", avoiding the overhead of constructing a fully instanciated Component object Notes: Ext
 uses lazy rendering. Child Components will only be rendered should it become necessary. Items are automatically laid out
 when they are first shown (no sizing is done while hidden), or in response to a doLayout call. Do not specify contentEl/
 html with items.]]></description><name>items</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The label to associate with this field. Defaults to null.]]></description><name>label</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The location to render the label of the field. Acceptable values are 'top' and 'left'. Defaults to 'left']]></description><name>labelAlign</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of the label, can be any valid CSS size. E.g '20%', '6em', '100px'. Defaults to '30%']]></description><name>labelWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[*Important: In order for child items to be correctly sized and positioned, typically a layout manager must be specified
 through the layout configuration option. The sizing and positioning of child items is the responsibility of the
 Container's layout manager which creates and manages the type of layout you have in mind. For example: If the layout
 configuration is not explicitly specified for a general purpose container (e.g. Container or Panel) the default layout
 manager will be used which does nothing but render child components sequentially into the Container (no sizing or
 positioning will be performed in this situation). layout may be specified as either as an Object or as a String: Specify
 as an Object Example usage: layout: {
     type: 'vbox',
     align: 'left'
 } type The layout type to be used for this
 container. If not specified, a default Ext.layout.ContainerLayout will be created and used. Valid layout type values
 are:
 auto - Default card fit hbox vbox Layout specific configuration properties Additional layout specific
 configuration properties may also be specified. For complete details regarding the valid config options for each layout
 type, see the layout class corresponding to the type specified. Specify as a String Example usage: layout: {
     type:
 'vbox',
     padding: '5',
     align: 'left'
 } layout The layout type to be used for this container (see list of valid
 layout type values above). Additional layout specific configuration properties. For complete details regarding the valid
 config options for each layout type, see the layout class corresponding to the layout specified.]]></description><name>layout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A config object containing one or more event handlers to be added to this object during initialization. This should be a
 valid listeners config object as specified in the addListener example for attaching multiple handlers at once. DOM
 events from ExtJs Components While some ExtJs Component classes export selected DOM events (e.g. "click", "mouseover"
 etc), this is usually only done when extra value can be added. For example the DataView's click event passing the node
 clicked on. To access DOM events directly from a child element of a Component, we need to specify the element option to
 identify the Component property to add a DOM listener to: new Ext.Panel({
     width: 400,
     height: 200,
    
 dockedItems: [{
         xtype: 'toolbar'
     }],
     listeners: {
         click: {
             element: 'el', //bind to
 the underlying el property on the panel
             fn: function(){ console.log('click el'); }
         },
        
 dblclick: {
             element: 'body', //bind to the underlying body property on the panel
             fn: function(){
 console.log('dblclick body'); }
         }
     }
 });]]></description><name>listeners</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the margin for this component. The margin can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>margin</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this Component will set its height to. Warning: This will override any size management
 applied by layout managers.]]></description><name>maxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum number of permitted input characters (defaults to 0).]]></description><name>maxLength</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this Component will set its width to. Warning: This will override any size management
 applied by layout managers.]]></description><name>maxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this Component will set its height to. Warning: This will override any size management
 applied by layout managers.]]></description><name>minHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this Component will set its width to. Warning: This will override any size management
 applied by layout managers.]]></description><name>minWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The field's HTML name attribute (defaults to ''). Note: this property must be set if this field is to be automatically
 included with form submit().]]></description><name>name</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the padding for this component. The padding can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>padding</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A string value displayed in the input (if supported) when the control is empty.]]></description><name>placeHolder</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object containing properties specifying DomQuery selectors which identify child elements created by the render
 process. After the Component's internal structure is rendered according to the renderTpl, this object is iterated
 through, and the found Elements are added as properties to the Component using the renderSelector property name. For
 example, a Component which rendered an image, and description into its element might use the following properties coded
 into its prototype: renderTpl: '"{imageUrl}" class="x-image-component-img">
 "x-image-component-desc">{description}',
 
 renderSelectors: {
     image: 'img.x-image-component-img',
     descEl:
 'div.x-image-component-desc'
 } After rendering, the Component would have a property image referencing its child img
 Element, and a property descEl referencing the div Element which contains the description.]]></description><name>renderSelectors</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An XTemplate used to create the internal structure inside this Component's encapsulating Element. You do not normally
 need to specify this. For the base classes Ext.Component and Ext.Container, this defaults to null which means that they
 will be initially rendered with no internal structure; they render their Element empty. The more specialized ExtJS and
 Touch classes which use a more complex DOM structure, provide their own template definitions. This is intended to allow
 the developer to create application-specific utility Components with customized internal structure. Upon rendering, any
 created child elements may be automatically imported into object properties using the renderSelectors option.]]></description><name>renderTpl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to make this field required. Note: this only causes a visual indication. Doesn't prevent user from submitting the
 form.]]></description><name>required</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
             title: 'Some Title',
             renderTo: Ext.getBody(),
          
 width: 400, height: 300,
             layout: 'form',
             items: [{
                 xtype: 'textareafield',
      
 style: {
                     width: '95%',
                     marginBottom: '10px'
                 }
             },
    
 new Ext.Button({
                 text: 'Send',
                 minWidth: '100',
                 style: {
                
     marginBottom: '10px'
                 }
             })
             ]
         });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The class that is added to the content target when you set styleHtmlContent to true. Defaults to 'x-html']]></description><name>styleHtmlCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically style the html inside the content target of this component (body for panels). Defaults to false.]]></description><name>styleHtmlContent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The tabIndex for this field. Note this only applies to fields that are rendered, not those which are built via applyTo
 (defaults to undefined).]]></description><name>tabIndex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An Ext.Template, Ext.XTemplate or an array of strings to form an Ext.XTemplate. Used in conjunction with the data and
 tplWriteMode configurations.]]></description><name>tpl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A set of predefined ui styles for individual components. Most components support 'light' and 'dark'. Extra string added
 to the baseCls with an extra '-'. 
 <pre><code>
 new Ext.Panel({
     title: 'Some Title',
     baseCls: 'x-component'
     ui: 'green'
 });</pre></code>
 The ui configuration in this example would add 'x-component-green' as an additional class.]]></description><name>ui</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A value to initialize this field with (defaults to undefined).]]></description><name>value</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of this component in pixels.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original SenchaTouch API docs:
 <a href="http://docs.sencha.com/touch/">http://docs.sencha.com/touch/</a>

 Simple Select field wrapper. Example usage: 
 <pre><code><b>new</b> Ext.form.Select({
     options: [
         {text:
 <em>'First Option'</em>,  value: <em>'first'</em>},
         {text: <em>'Second Option'</em>, value: <em>'second'</em>},
 
        {text: <em>'Third Option'</em>,  value: <em>'third'</em>}
     ]
 });</code></pre>]]></description><name>form.select</name><tag-class>org.brushingbits.jnap.ui.senchatouch.form.Select</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[A string component id or the numeric index of the component that should be initially activated within the container's
 layout on render. For example, activeItem: 'item-1' or activeItem: 0 (index 0 = the first item in the container's
 collection). activeItem only applies to layout styles that can display items one at a time (like Ext.layout.CardLayout
 and Ext.layout.FitLayout). Related to Ext.layout.ContainerLayout.activeItem.]]></description><name>activeItem</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>autoCapitalize</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>autoComplete</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>autoCorrect</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically create the field input element on render. This is true by default, but should be set to false for
 any Ext.Field subclasses that don't need an HTML input (e.g. Ext.Slider and similar)]]></description><name>autoCreateField</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If true the container will automatically destroy any contained component that is removed from it, else destruction must
 be handled manually (defaults to true).]]></description><name>autoDestroy</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The base CSS class to apply to this components's element. This will also be prepended to elements within this component
 like Panel's body will get a class x-panel-body. This means that if you create a subclass of Panel, and you want it to
 get all the Panels styling for the element and the body, you leave the baseCls x-panel and use componentCls to add
 specific styling for this component.]]></description><name>baseCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the border for this component. The border can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>border</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to ['add', 'remove'].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Animation to be used during transitions of cards. Note this only works when this container has a CardLayout. Any valid
 value from Ext.anims can be used ('fade', 'slide', 'flip', 'cube', 'pop', 'wipe'). Defaults to null.]]></description><name>cardSwitchAnimation</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom CSS class to apply to the field's underlying element (defaults to '').]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS Class to be added to a components root level element to give distinction to it via styling.]]></description><name>componentCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The sizing and positioning of the component Elements is the responsibility of the Component's layout manager which
 creates and manages the type of layout specific to the component. If the layout configuration is not explicitly
 specified for a general purpose compopnent the default layout manager will be used.]]></description><name>componentLayout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default xtype of child Components to create in this Container when a child item is specified as a raw configuration
 object, rather than as an instantiated Component. Defaults to 'panel'.]]></description><name>defaultType</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[This option is a means of applying default settings to all added items whether added through the items config or via the
 add or insert methods. If an added item is a config object, and not an instantiated Component, then the default
 properties are unconditionally applied. If the added item is an instantiated Component, then the default properties are
 applied conditionally so as not to override existing properties in the item. If the defaults option is specified as a
 function, then the function will be called using this Container as the scope (this reference) and passing the added item
 as the first parameter. Any resulting object from that call is then applied to the item as default properties. For
 example, to automatically apply padding to the body of each of a set of contained Ext.Panel items, you could pass:
 defaults: {bodyStyle:'padding:15px'}. Usage: defaults: {               // defaults are applied to items, not the
 container
     autoScroll:true
 },
 items: [
     {
         xtype: 'panel',   // defaults do not have precedence over
       
 id: 'panel1',     // options in config objects, so the defaults
         autoScroll: false // will not be applied here,
 panel1 will be autoScroll:false
     },
     new Ext.Panel({       // defaults do have precedence over options
         id:
 'panel2',     // options in components, so the defaults
         autoScroll: false // will be applied here, panel2 will
 be autoScroll:true.
     })
 ]]]></description><name>defaults</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to disable the field (defaults to false). Be aware that conformant with the HTML specification, disabled Fields
 will not be submitted.]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class to add when the Component is disabled. Defaults to 'x-item-disabled'.]]></description><name>disabledCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The underlying data value name (or numeric Array index) to bind to this Select control. This resolved value is the
 visibly rendered value of the available selection options. (defaults to 'text')]]></description><name>displayField</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Allows the component to be dragged via the touch event.]]></description><name>draggable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default CSS class for the field (defaults to 'x-form-field')]]></description><name>fieldCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Create the Component as a floating and use absolute positioning. Defaults to false.]]></description><name>floating</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class to use when the field receives focus (defaults to 'x-field-focus')]]></description><name>focusCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of this component in pixels.]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to false.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify a hiddenName if you're using the standardSubmit option. This name will be used to post the underlying value of
 the select to the server.]]></description><name>hiddenName</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional CSS class that will be added to the actual element (or whichever different element is defined by inputAutoEl).
 Defaults to undefined.]]></description><name>inputCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The type attribute for input fields -- e.g. radio, text, password, file (defaults to 'text'). The types 'file' and
 'password' must be used to render those field types currently -- there are no separate Ext components for those. Note
 that if you use inputType:'file', emptyText is not supported and should be avoided.]]></description><name>inputType</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[** IMPORTANT: be sure to specify a layout if needed ! ** A single item, or an array of child Components to be added to
 this container, for example: // specifying a single item
 items: {...},
 layout: 'fit',    // specify a layout!
 
 //
 specifying multiple items
 items: [{...}, {...}],
 layout: 'hbox', // specify a layout! Each item may be: any type of
 object based on Ext.Component a fully instanciated object or an object literal that: has a specified xtype the
 Ext.Component.xtype specified is associated with the Component desired and should be chosen from one of the available
 xtypes as listed in Ext.Component. If an xtype is not explicitly specified, the defaultType for that Container is used.
 will be "lazily instanciated", avoiding the overhead of constructing a fully instanciated Component object Notes: Ext
 uses lazy rendering. Child Components will only be rendered should it become necessary. Items are automatically laid out
 when they are first shown (no sizing is done while hidden), or in response to a doLayout call. Do not specify contentEl/
 html with items.]]></description><name>items</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The label to associate with this field. Defaults to null.]]></description><name>label</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The location to render the label of the field. Acceptable values are 'top' and 'left'. Defaults to 'left']]></description><name>labelAlign</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of the label, can be any valid CSS size. E.g '20%', '6em', '100px'. Defaults to '30%']]></description><name>labelWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[*Important: In order for child items to be correctly sized and positioned, typically a layout manager must be specified
 through the layout configuration option. The sizing and positioning of child items is the responsibility of the
 Container's layout manager which creates and manages the type of layout you have in mind. For example: If the layout
 configuration is not explicitly specified for a general purpose container (e.g. Container or Panel) the default layout
 manager will be used which does nothing but render child components sequentially into the Container (no sizing or
 positioning will be performed in this situation). layout may be specified as either as an Object or as a String: Specify
 as an Object Example usage: layout: {
     type: 'vbox',
     align: 'left'
 } type The layout type to be used for this
 container. If not specified, a default Ext.layout.ContainerLayout will be created and used. Valid layout type values
 are:
 auto - Default card fit hbox vbox Layout specific configuration properties Additional layout specific
 configuration properties may also be specified. For complete details regarding the valid config options for each layout
 type, see the layout class corresponding to the type specified. Specify as a String Example usage: layout: {
     type:
 'vbox',
     padding: '5',
     align: 'left'
 } layout The layout type to be used for this container (see list of valid
 layout type values above). Additional layout specific configuration properties. For complete details regarding the valid
 config options for each layout type, see the layout class corresponding to the layout specified.]]></description><name>layout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A config object containing one or more event handlers to be added to this object during initialization. This should be a
 valid listeners config object as specified in the addListener example for attaching multiple handlers at once. DOM
 events from ExtJs Components While some ExtJs Component classes export selected DOM events (e.g. "click", "mouseover"
 etc), this is usually only done when extra value can be added. For example the DataView's click event passing the node
 clicked on. To access DOM events directly from a child element of a Component, we need to specify the element option to
 identify the Component property to add a DOM listener to: new Ext.Panel({
     width: 400,
     height: 200,
    
 dockedItems: [{
         xtype: 'toolbar'
     }],
     listeners: {
         click: {
             element: 'el', //bind to
 the underlying el property on the panel
             fn: function(){ console.log('click el'); }
         },
        
 dblclick: {
             element: 'body', //bind to the underlying body property on the panel
             fn: function(){
 console.log('dblclick body'); }
         }
     }
 });]]></description><name>listeners</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the margin for this component. The margin can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>margin</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this Component will set its height to. Warning: This will override any size management
 applied by layout managers.]]></description><name>maxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum number of permitted input characters (defaults to 0).]]></description><name>maxLength</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this Component will set its width to. Warning: This will override any size management
 applied by layout managers.]]></description><name>maxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this Component will set its height to. Warning: This will override any size management
 applied by layout managers.]]></description><name>minHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this Component will set its width to. Warning: This will override any size management
 applied by layout managers.]]></description><name>minWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The field's HTML name attribute (defaults to ''). Note: this property must be set if this field is to be automatically
 included with form submit().]]></description><name>name</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of select options. [
         {text: 'First Option',  value: 'first'},
         {text: 'Second Option', value:
 'second'},
         {text: 'Third Option',  value: 'third'}
     ] Note: option object member names should correspond with
 defined valueField and displayField values. This config will be ignore if a store instance is provided]]></description><name>options</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the padding for this component. The padding can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>padding</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A string value displayed in the input (if supported) when the control is empty.]]></description><name>placeHolder</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object containing properties specifying DomQuery selectors which identify child elements created by the render
 process. After the Component's internal structure is rendered according to the renderTpl, this object is iterated
 through, and the found Elements are added as properties to the Component using the renderSelector property name. For
 example, a Component which rendered an image, and description into its element might use the following properties coded
 into its prototype: renderTpl: '"{imageUrl}" class="x-image-component-img">
 "x-image-component-desc">{description}',
 
 renderSelectors: {
     image: 'img.x-image-component-img',
     descEl:
 'div.x-image-component-desc'
 } After rendering, the Component would have a property image referencing its child img
 Element, and a property descEl referencing the div Element which contains the description.]]></description><name>renderSelectors</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An XTemplate used to create the internal structure inside this Component's encapsulating Element. You do not normally
 need to specify this. For the base classes Ext.Component and Ext.Container, this defaults to null which means that they
 will be initially rendered with no internal structure; they render their Element empty. The more specialized ExtJS and
 Touch classes which use a more complex DOM structure, provide their own template definitions. This is intended to allow
 the developer to create application-specific utility Components with customized internal structure. Upon rendering, any
 created child elements may be automatically imported into object properties using the renderSelectors option.]]></description><name>renderTpl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to make this field required. Note: this only causes a visual indication. Doesn't prevent user from submitting the
 form.]]></description><name>required</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[store instance used to provide selection options data.]]></description><name>store</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
             title: 'Some Title',
             renderTo: Ext.getBody(),
          
 width: 400, height: 300,
             layout: 'form',
             items: [{
                 xtype: 'textareafield',
      
 style: {
                     width: '95%',
                     marginBottom: '10px'
                 }
             },
    
 new Ext.Button({
                 text: 'Send',
                 minWidth: '100',
                 style: {
                
     marginBottom: '10px'
                 }
             })
             ]
         });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The class that is added to the content target when you set styleHtmlContent to true. Defaults to 'x-html']]></description><name>styleHtmlCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically style the html inside the content target of this component (body for panels). Defaults to false.]]></description><name>styleHtmlContent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The tabIndex for this field. Note this only applies to fields that are rendered, not those which are built via applyTo
 (defaults to undefined).]]></description><name>tabIndex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An Ext.Template, Ext.XTemplate or an array of strings to form an Ext.XTemplate. Used in conjunction with the data and
 tplWriteMode configurations.]]></description><name>tpl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A set of predefined ui styles for individual components. Most components support 'light' and 'dark'. Extra string added
 to the baseCls with an extra '-'. 
 <pre><code>
 new Ext.Panel({
     title: 'Some Title',
     baseCls: 'x-component'
     ui: 'green'
 });</pre></code>
 The ui configuration in this example would add 'x-component-green' as an additional class.]]></description><name>ui</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A value to initialize this field with (defaults to undefined).]]></description><name>value</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The underlying data value name (or numeric Array index) to bind to this Select control. (defaults to 'value')]]></description><name>valueField</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of this component in pixels.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original SenchaTouch API docs:
 <a href="http://docs.sencha.com/touch/">http://docs.sencha.com/touch/</a>

 <p>Form component allowing a user to move a 'thumb' along a slider axis to choose a value. Sliders can equally be used
 outside of the context of a form. Example usage:</p> 
 <pre><code><b>new</b> Ext.form.FormPanel({
     items: [
         {
 
 xtype   : <em>'sliderfield'</em>,
             <b>label</b>   : <em>'Volume'</em>,
             value   : 5,
            
 minValue: 0,
             maxValue: 10
         }
     ]
 });</code></pre> Or as a standalone component:
 
 <pre><code><b>var</b> slider = <b>new</b> Ext.form.Slider({
     value: 5,
     minValue: 0,
     maxValue:
 10
 });
 
 slider.setValue(8); <i>//will update the value and move the thumb;</i>
 slider.getValue(); <i>//returns
 8</i></code></pre>]]></description><name>form.slider</name><tag-class>org.brushingbits.jnap.ui.senchatouch.form.Slider</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[A string component id or the numeric index of the component that should be initially activated within the container's
 layout on render. For example, activeItem: 'item-1' or activeItem: 0 (index 0 = the first item in the container's
 collection). activeItem only applies to layout styles that can display items one at a time (like Ext.layout.CardLayout
 and Ext.layout.FitLayout). Related to Ext.layout.ContainerLayout.activeItem.]]></description><name>activeItem</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[When set to a number greater than 0, it will be the animation duration in ms, defaults to 200]]></description><name>animationDuration</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically create the field input element on render. This is true by default, but should be set to false for
 any Ext.Field subclasses that don't need an HTML input (e.g. Ext.Slider and similar)]]></description><name>autoCreateField</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If true the container will automatically destroy any contained component that is removed from it, else destruction must
 be handled manually (defaults to true).]]></description><name>autoDestroy</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The base CSS class to apply to this components's element. This will also be prepended to elements within this component
 like Panel's body will get a class x-panel-body. This means that if you create a subclass of Panel, and you want it to
 get all the Panels styling for the element and the body, you leave the baseCls x-panel and use componentCls to add
 specific styling for this component.]]></description><name>baseCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the border for this component. The border can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>border</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to ['add', 'remove'].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Animation to be used during transitions of cards. Note this only works when this container has a CardLayout. Any valid
 value from Ext.anims can be used ('fade', 'slide', 'flip', 'cube', 'pop', 'wipe'). Defaults to null.]]></description><name>cardSwitchAnimation</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom CSS class to apply to the field's underlying element (defaults to '').]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS Class to be added to a components root level element to give distinction to it via styling.]]></description><name>componentCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The sizing and positioning of the component Elements is the responsibility of the Component's layout manager which
 creates and manages the type of layout specific to the component. If the layout configuration is not explicitly
 specified for a general purpose compopnent the default layout manager will be used.]]></description><name>componentLayout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default xtype of child Components to create in this Container when a child item is specified as a raw configuration
 object, rather than as an instantiated Component. Defaults to 'panel'.]]></description><name>defaultType</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[This option is a means of applying default settings to all added items whether added through the items config or via the
 add or insert methods. If an added item is a config object, and not an instantiated Component, then the default
 properties are unconditionally applied. If the added item is an instantiated Component, then the default properties are
 applied conditionally so as not to override existing properties in the item. If the defaults option is specified as a
 function, then the function will be called using this Container as the scope (this reference) and passing the added item
 as the first parameter. Any resulting object from that call is then applied to the item as default properties. For
 example, to automatically apply padding to the body of each of a set of contained Ext.Panel items, you could pass:
 defaults: {bodyStyle:'padding:15px'}. Usage: defaults: {               // defaults are applied to items, not the
 container
     autoScroll:true
 },
 items: [
     {
         xtype: 'panel',   // defaults do not have precedence over
       
 id: 'panel1',     // options in config objects, so the defaults
         autoScroll: false // will not be applied here,
 panel1 will be autoScroll:false
     },
     new Ext.Panel({       // defaults do have precedence over options
         id:
 'panel2',     // options in components, so the defaults
         autoScroll: false // will be applied here, panel2 will
 be autoScroll:true.
     })
 ]]]></description><name>defaults</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to disable the field (defaults to false). Be aware that conformant with the HTML specification, disabled Fields
 will not be submitted.]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class to add when the Component is disabled. Defaults to 'x-item-disabled'.]]></description><name>disabledCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Allows the component to be dragged via the touch event.]]></description><name>draggable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default CSS class for the field (defaults to 'x-form-field')]]></description><name>fieldCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Create the Component as a floating and use absolute positioning. Defaults to false.]]></description><name>floating</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of this component in pixels.]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to false.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The increment by which to snap each thumb when its value changes. Defaults to 1. Any thumb movement will be snapped to
 the nearest value that is a multiple of the increment (e.g. if increment is 10 and the user tries to move the thumb to
 67, it will be snapped to 70 instead)]]></description><name>increment</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Overrides Ext.form.Field's inputCls. Defaults to 'x-slider']]></description><name>inputCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The type attribute for input fields -- e.g. radio, text, password, file (defaults to 'text'). The types 'file' and
 'password' must be used to render those field types currently -- there are no separate Ext components for those. Note
 that if you use inputType:'file', emptyText is not supported and should be avoided.]]></description><name>inputType</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[** IMPORTANT: be sure to specify a layout if needed ! ** A single item, or an array of child Components to be added to
 this container, for example: // specifying a single item
 items: {...},
 layout: 'fit',    // specify a layout!
 
 //
 specifying multiple items
 items: [{...}, {...}],
 layout: 'hbox', // specify a layout! Each item may be: any type of
 object based on Ext.Component a fully instanciated object or an object literal that: has a specified xtype the
 Ext.Component.xtype specified is associated with the Component desired and should be chosen from one of the available
 xtypes as listed in Ext.Component. If an xtype is not explicitly specified, the defaultType for that Container is used.
 will be "lazily instanciated", avoiding the overhead of constructing a fully instanciated Component object Notes: Ext
 uses lazy rendering. Child Components will only be rendered should it become necessary. Items are automatically laid out
 when they are first shown (no sizing is done while hidden), or in response to a doLayout call. Do not specify contentEl/
 html with items.]]></description><name>items</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The label to associate with this field. Defaults to null.]]></description><name>label</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The location to render the label of the field. Acceptable values are 'top' and 'left'. Defaults to 'left']]></description><name>labelAlign</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of the label, can be any valid CSS size. E.g '20%', '6em', '100px'. Defaults to '30%']]></description><name>labelWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[*Important: In order for child items to be correctly sized and positioned, typically a layout manager must be specified
 through the layout configuration option. The sizing and positioning of child items is the responsibility of the
 Container's layout manager which creates and manages the type of layout you have in mind. For example: If the layout
 configuration is not explicitly specified for a general purpose container (e.g. Container or Panel) the default layout
 manager will be used which does nothing but render child components sequentially into the Container (no sizing or
 positioning will be performed in this situation). layout may be specified as either as an Object or as a String: Specify
 as an Object Example usage: layout: {
     type: 'vbox',
     align: 'left'
 } type The layout type to be used for this
 container. If not specified, a default Ext.layout.ContainerLayout will be created and used. Valid layout type values
 are:
 auto - Default card fit hbox vbox Layout specific configuration properties Additional layout specific
 configuration properties may also be specified. For complete details regarding the valid config options for each layout
 type, see the layout class corresponding to the type specified. Specify as a String Example usage: layout: {
     type:
 'vbox',
     padding: '5',
     align: 'left'
 } layout The layout type to be used for this container (see list of valid
 layout type values above). Additional layout specific configuration properties. For complete details regarding the valid
 config options for each layout type, see the layout class corresponding to the layout specified.]]></description><name>layout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A config object containing one or more event handlers to be added to this object during initialization. This should be a
 valid listeners config object as specified in the addListener example for attaching multiple handlers at once. DOM
 events from ExtJs Components While some ExtJs Component classes export selected DOM events (e.g. "click", "mouseover"
 etc), this is usually only done when extra value can be added. For example the DataView's click event passing the node
 clicked on. To access DOM events directly from a child element of a Component, we need to specify the element option to
 identify the Component property to add a DOM listener to: new Ext.Panel({
     width: 400,
     height: 200,
    
 dockedItems: [{
         xtype: 'toolbar'
     }],
     listeners: {
         click: {
             element: 'el', //bind to
 the underlying el property on the panel
             fn: function(){ console.log('click el'); }
         },
        
 dblclick: {
             element: 'body', //bind to the underlying body property on the panel
             fn: function(){
 console.log('dblclick body'); }
         }
     }
 });]]></description><name>listeners</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the margin for this component. The margin can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>margin</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this Component will set its height to. Warning: This will override any size management
 applied by layout managers.]]></description><name>maxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The highest value any thumb on this slider can be set to (defaults to 100)]]></description><name>maxValue</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this Component will set its width to. Warning: This will override any size management
 applied by layout managers.]]></description><name>maxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this Component will set its height to. Warning: This will override any size management
 applied by layout managers.]]></description><name>minHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The lowest value any thumb on this slider can be set to (defaults to 0)]]></description><name>minValue</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this Component will set its width to. Warning: This will override any size management
 applied by layout managers.]]></description><name>minWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The field's HTML name attribute (defaults to ''). Note: this property must be set if this field is to be automatically
 included with form submit().]]></description><name>name</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the padding for this component. The padding can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>padding</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object containing properties specifying DomQuery selectors which identify child elements created by the render
 process. After the Component's internal structure is rendered according to the renderTpl, this object is iterated
 through, and the found Elements are added as properties to the Component using the renderSelector property name. For
 example, a Component which rendered an image, and description into its element might use the following properties coded
 into its prototype: renderTpl: '"{imageUrl}" class="x-image-component-img">
 "x-image-component-desc">{description}',
 
 renderSelectors: {
     image: 'img.x-image-component-img',
     descEl:
 'div.x-image-component-desc'
 } After rendering, the Component would have a property image referencing its child img
 Element, and a property descEl referencing the div Element which contains the description.]]></description><name>renderSelectors</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An XTemplate used to create the internal structure inside this Component's encapsulating Element. You do not normally
 need to specify this. For the base classes Ext.Component and Ext.Container, this defaults to null which means that they
 will be initially rendered with no internal structure; they render their Element empty. The more specialized ExtJS and
 Touch classes which use a more complex DOM structure, provide their own template definitions. This is intended to allow
 the developer to create application-specific utility Components with customized internal structure. Upon rendering, any
 created child elements may be automatically imported into object properties using the renderSelectors option.]]></description><name>renderTpl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to make this field required. Note: this only causes a visual indication. Doesn't prevent user from submitting the
 form.]]></description><name>required</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
             title: 'Some Title',
             renderTo: Ext.getBody(),
          
 width: 400, height: 300,
             layout: 'form',
             items: [{
                 xtype: 'textareafield',
      
 style: {
                     width: '95%',
                     marginBottom: '10px'
                 }
             },
    
 new Ext.Button({
                 text: 'Send',
                 minWidth: '100',
                 style: {
                
     marginBottom: '10px'
                 }
             })
             ]
         });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The class that is added to the content target when you set styleHtmlContent to true. Defaults to 'x-html']]></description><name>styleHtmlCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically style the html inside the content target of this component (body for panels). Defaults to false.]]></description><name>styleHtmlContent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The tabIndex for this field. Note this only applies to fields that are rendered, not those which are built via applyTo
 (defaults to undefined).]]></description><name>tabIndex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional array of Ext.form.Slider.Thumb instances. Usually values should be used instead]]></description><name>thumbs</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An Ext.Template, Ext.XTemplate or an array of strings to form an Ext.XTemplate. Used in conjunction with the data and
 tplWriteMode configurations.]]></description><name>tpl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A set of predefined ui styles for individual components. Most components support 'light' and 'dark'. Extra string added
 to the baseCls with an extra '-'. 
 <pre><code>
 new Ext.Panel({
     title: 'Some Title',
     baseCls: 'x-component'
     ui: 'green'
 });</pre></code>
 The ui configuration in this example would add 'x-component-green' as an additional class.]]></description><name>ui</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The value to initialize the thumb at (defaults to 0)]]></description><name>value</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of this component in pixels.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original SenchaTouch API docs:
 <a href="http://docs.sencha.com/touch/">http://docs.sencha.com/touch/</a>

 <p>Wraps an HTML5 number field. Example usage: </p>
 <pre><code><b>new</b> Ext.form.Spinner({
     minValue: 0,
    
 maxValue: 100,
     incrementValue: 2,
     cycle: true
 });</code></pre>]]></description><name>form.spinner</name><tag-class>org.brushingbits.jnap.ui.senchatouch.form.Spinner</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[True if autorepeating should start slowly and accelerate. Defaults to true.]]></description><name>accelerateOnTapHold</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A string component id or the numeric index of the component that should be initially activated within the container's
 layout on render. For example, activeItem: 'item-1' or activeItem: 0 (index 0 = the first item in the container's
 collection). activeItem only applies to layout styles that can display items one at a time (like Ext.layout.CardLayout
 and Ext.layout.FitLayout). Related to Ext.layout.ContainerLayout.activeItem.]]></description><name>activeItem</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>autoCapitalize</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>autoComplete</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>autoCorrect</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically create the field input element on render. This is true by default, but should be set to false for
 any Ext.Field subclasses that don't need an HTML input (e.g. Ext.Slider and similar)]]></description><name>autoCreateField</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If true the container will automatically destroy any contained component that is removed from it, else destruction must
 be handled manually (defaults to true).]]></description><name>autoDestroy</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The base CSS class to apply to this components's element. This will also be prepended to elements within this component
 like Panel's body will get a class x-panel-body. This means that if you create a subclass of Panel, and you want it to
 get all the Panels styling for the element and the body, you leave the baseCls x-panel and use componentCls to add
 specific styling for this component.]]></description><name>baseCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the border for this component. The border can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>border</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to ['add', 'remove'].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Animation to be used during transitions of cards. Note this only works when this container has a CardLayout. Any valid
 value from Ext.anims can be used ('fade', 'slide', 'flip', 'cube', 'pop', 'wipe'). Defaults to null.]]></description><name>cardSwitchAnimation</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom CSS class to apply to the field's underlying element (defaults to '').]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS Class to be added to a components root level element to give distinction to it via styling.]]></description><name>componentCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The sizing and positioning of the component Elements is the responsibility of the Component's layout manager which
 creates and manages the type of layout specific to the component. If the layout configuration is not explicitly
 specified for a general purpose compopnent the default layout manager will be used.]]></description><name>componentLayout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[When set to true, it will loop the values of a minimum or maximum is reached. If the maximum value is reached, the value
 will be set to the minimum. If the minimum value is reached, the value will be set to the maximum. Defaults to false.]]></description><name>cycle</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default xtype of child Components to create in this Container when a child item is specified as a raw configuration
 object, rather than as an instantiated Component. Defaults to 'panel'.]]></description><name>defaultType</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[This option is a means of applying default settings to all added items whether added through the items config or via the
 add or insert methods. If an added item is a config object, and not an instantiated Component, then the default
 properties are unconditionally applied. If the added item is an instantiated Component, then the default properties are
 applied conditionally so as not to override existing properties in the item. If the defaults option is specified as a
 function, then the function will be called using this Container as the scope (this reference) and passing the added item
 as the first parameter. Any resulting object from that call is then applied to the item as default properties. For
 example, to automatically apply padding to the body of each of a set of contained Ext.Panel items, you could pass:
 defaults: {bodyStyle:'padding:15px'}. Usage: defaults: {               // defaults are applied to items, not the
 container
     autoScroll:true
 },
 items: [
     {
         xtype: 'panel',   // defaults do not have precedence over
       
 id: 'panel1',     // options in config objects, so the defaults
         autoScroll: false // will not be applied here,
 panel1 will be autoScroll:false
     },
     new Ext.Panel({       // defaults do have precedence over options
         id:
 'panel2',     // options in components, so the defaults
         autoScroll: false // will be applied here, panel2 will
 be autoScroll:true.
     })
 ]]]></description><name>defaults</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to disable the input field, meaning that only the spinner buttons can be used. Defaults to false.]]></description><name>disableInput</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to disable the field (defaults to false). Be aware that conformant with the HTML specification, disabled Fields
 will not be submitted.]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class to add when the Component is disabled. Defaults to 'x-item-disabled'.]]></description><name>disabledCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Allows the component to be dragged via the touch event.]]></description><name>draggable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default CSS class for the field (defaults to 'x-form-field')]]></description><name>fieldCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Create the Component as a floating and use absolute positioning. Defaults to false.]]></description><name>floating</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class to use when the field receives focus (defaults to 'x-field-focus')]]></description><name>focusCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of this component in pixels.]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to false.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Value that is added or subtracted from the current value when a spinner is used. Defaults to 1.]]></description><name>incrementValue</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional CSS class that will be added to the actual element (or whichever different element is defined by inputAutoEl).
 Defaults to undefined.]]></description><name>inputCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The type attribute for input fields -- e.g. radio, text, password, file (defaults to 'text'). The types 'file' and
 'password' must be used to render those field types currently -- there are no separate Ext components for those. Note
 that if you use inputType:'file', emptyText is not supported and should be avoided.]]></description><name>inputType</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[** IMPORTANT: be sure to specify a layout if needed ! ** A single item, or an array of child Components to be added to
 this container, for example: // specifying a single item
 items: {...},
 layout: 'fit',    // specify a layout!
 
 //
 specifying multiple items
 items: [{...}, {...}],
 layout: 'hbox', // specify a layout! Each item may be: any type of
 object based on Ext.Component a fully instanciated object or an object literal that: has a specified xtype the
 Ext.Component.xtype specified is associated with the Component desired and should be chosen from one of the available
 xtypes as listed in Ext.Component. If an xtype is not explicitly specified, the defaultType for that Container is used.
 will be "lazily instanciated", avoiding the overhead of constructing a fully instanciated Component object Notes: Ext
 uses lazy rendering. Child Components will only be rendered should it become necessary. Items are automatically laid out
 when they are first shown (no sizing is done while hidden), or in response to a doLayout call. Do not specify contentEl/
 html with items.]]></description><name>items</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The label to associate with this field. Defaults to null.]]></description><name>label</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The location to render the label of the field. Acceptable values are 'top' and 'left'. Defaults to 'left']]></description><name>labelAlign</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of the label, can be any valid CSS size. E.g '20%', '6em', '100px'. Defaults to '30%']]></description><name>labelWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[*Important: In order for child items to be correctly sized and positioned, typically a layout manager must be specified
 through the layout configuration option. The sizing and positioning of child items is the responsibility of the
 Container's layout manager which creates and manages the type of layout you have in mind. For example: If the layout
 configuration is not explicitly specified for a general purpose container (e.g. Container or Panel) the default layout
 manager will be used which does nothing but render child components sequentially into the Container (no sizing or
 positioning will be performed in this situation). layout may be specified as either as an Object or as a String: Specify
 as an Object Example usage: layout: {
     type: 'vbox',
     align: 'left'
 } type The layout type to be used for this
 container. If not specified, a default Ext.layout.ContainerLayout will be created and used. Valid layout type values
 are:
 auto - Default card fit hbox vbox Layout specific configuration properties Additional layout specific
 configuration properties may also be specified. For complete details regarding the valid config options for each layout
 type, see the layout class corresponding to the type specified. Specify as a String Example usage: layout: {
     type:
 'vbox',
     padding: '5',
     align: 'left'
 } layout The layout type to be used for this container (see list of valid
 layout type values above). Additional layout specific configuration properties. For complete details regarding the valid
 config options for each layout type, see the layout class corresponding to the layout specified.]]></description><name>layout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A config object containing one or more event handlers to be added to this object during initialization. This should be a
 valid listeners config object as specified in the addListener example for attaching multiple handlers at once. DOM
 events from ExtJs Components While some ExtJs Component classes export selected DOM events (e.g. "click", "mouseover"
 etc), this is usually only done when extra value can be added. For example the DataView's click event passing the node
 clicked on. To access DOM events directly from a child element of a Component, we need to specify the element option to
 identify the Component property to add a DOM listener to: new Ext.Panel({
     width: 400,
     height: 200,
    
 dockedItems: [{
         xtype: 'toolbar'
     }],
     listeners: {
         click: {
             element: 'el', //bind to
 the underlying el property on the panel
             fn: function(){ console.log('click el'); }
         },
        
 dblclick: {
             element: 'body', //bind to the underlying body property on the panel
             fn: function(){
 console.log('dblclick body'); }
         }
     }
 });]]></description><name>listeners</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the margin for this component. The margin can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>margin</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this Component will set its height to. Warning: This will override any size management
 applied by layout managers.]]></description><name>maxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum number of permitted input characters (defaults to 0).]]></description><name>maxLength</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum allowed value (defaults to Number.MAX_VALUE)]]></description><name>maxValue</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this Component will set its width to. Warning: This will override any size management
 applied by layout managers.]]></description><name>maxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this Component will set its height to. Warning: This will override any size management
 applied by layout managers.]]></description><name>minHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum allowed value (defaults to Number.NEGATIVE_INFINITY)]]></description><name>minValue</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this Component will set its width to. Warning: This will override any size management
 applied by layout managers.]]></description><name>minWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The field's HTML name attribute (defaults to ''). Note: this property must be set if this field is to be automatically
 included with form submit().]]></description><name>name</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the padding for this component. The padding can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>padding</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A string value displayed in the input (if supported) when the control is empty.]]></description><name>placeHolder</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object containing properties specifying DomQuery selectors which identify child elements created by the render
 process. After the Component's internal structure is rendered according to the renderTpl, this object is iterated
 through, and the found Elements are added as properties to the Component using the renderSelector property name. For
 example, a Component which rendered an image, and description into its element might use the following properties coded
 into its prototype: renderTpl: '"{imageUrl}" class="x-image-component-img">
 "x-image-component-desc">{description}',
 
 renderSelectors: {
     image: 'img.x-image-component-img',
     descEl:
 'div.x-image-component-desc'
 } After rendering, the Component would have a property image referencing its child img
 Element, and a property descEl referencing the div Element which contains the description.]]></description><name>renderSelectors</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An XTemplate used to create the internal structure inside this Component's encapsulating Element. You do not normally
 need to specify this. For the base classes Ext.Component and Ext.Container, this defaults to null which means that they
 will be initially rendered with no internal structure; they render their Element empty. The more specialized ExtJS and
 Touch classes which use a more complex DOM structure, provide their own template definitions. This is intended to allow
 the developer to create application-specific utility Components with customized internal structure. Upon rendering, any
 created child elements may be automatically imported into object properties using the renderSelectors option.]]></description><name>renderTpl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to make this field required. Note: this only causes a visual indication. Doesn't prevent user from submitting the
 form.]]></description><name>required</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
             title: 'Some Title',
             renderTo: Ext.getBody(),
          
 width: 400, height: 300,
             layout: 'form',
             items: [{
                 xtype: 'textareafield',
      
 style: {
                     width: '95%',
                     marginBottom: '10px'
                 }
             },
    
 new Ext.Button({
                 text: 'Send',
                 minWidth: '100',
                 style: {
                
     marginBottom: '10px'
                 }
             })
             ]
         });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The class that is added to the content target when you set styleHtmlContent to true. Defaults to 'x-html']]></description><name>styleHtmlCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically style the html inside the content target of this component (body for panels). Defaults to false.]]></description><name>styleHtmlContent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The tabIndex for this field. Note this only applies to fields that are rendered, not those which are built via applyTo
 (defaults to undefined).]]></description><name>tabIndex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An Ext.Template, Ext.XTemplate or an array of strings to form an Ext.XTemplate. Used in conjunction with the data and
 tplWriteMode configurations.]]></description><name>tpl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A set of predefined ui styles for individual components. Most components support 'light' and 'dark'. Extra string added
 to the baseCls with an extra '-'. 
 <pre><code>
 new Ext.Panel({
     title: 'Some Title',
     baseCls: 'x-component'
     ui: 'green'
 });</pre></code>
 The ui configuration in this example would add 'x-component-green' as an additional class.]]></description><name>ui</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A value to initialize this field with (defaults to undefined).]]></description><name>value</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of this component in pixels.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original SenchaTouch API docs:
 <a href="http://docs.sencha.com/touch/">http://docs.sencha.com/touch/</a>

 <p>Wraps a textarea. See <a href="output/Ext.form.FormPanel.html" ext:cls="Ext.form.FormPanel">FormPanel</a> for example
 usage.</p>]]></description><name>form.textArea</name><tag-class>org.brushingbits.jnap.ui.senchatouch.form.TextArea</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[A string component id or the numeric index of the component that should be initially activated within the container's
 layout on render. For example, activeItem: 'item-1' or activeItem: 0 (index 0 = the first item in the container's
 collection). activeItem only applies to layout styles that can display items one at a time (like Ext.layout.CardLayout
 and Ext.layout.FitLayout). Related to Ext.layout.ContainerLayout.activeItem.]]></description><name>activeItem</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>autoCapitalize</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>autoComplete</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>autoCorrect</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically create the field input element on render. This is true by default, but should be set to false for
 any Ext.Field subclasses that don't need an HTML input (e.g. Ext.Slider and similar)]]></description><name>autoCreateField</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If true the container will automatically destroy any contained component that is removed from it, else destruction must
 be handled manually (defaults to true).]]></description><name>autoDestroy</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The base CSS class to apply to this components's element. This will also be prepended to elements within this component
 like Panel's body will get a class x-panel-body. This means that if you create a subclass of Panel, and you want it to
 get all the Panels styling for the element and the body, you leave the baseCls x-panel and use componentCls to add
 specific styling for this component.]]></description><name>baseCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the border for this component. The border can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>border</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to ['add', 'remove'].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Animation to be used during transitions of cards. Note this only works when this container has a CardLayout. Any valid
 value from Ext.anims can be used ('fade', 'slide', 'flip', 'cube', 'pop', 'wipe'). Defaults to null.]]></description><name>cardSwitchAnimation</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom CSS class to apply to the field's underlying element (defaults to '').]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS Class to be added to a components root level element to give distinction to it via styling.]]></description><name>componentCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The sizing and positioning of the component Elements is the responsibility of the Component's layout manager which
 creates and manages the type of layout specific to the component. If the layout configuration is not explicitly
 specified for a general purpose compopnent the default layout manager will be used.]]></description><name>componentLayout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default xtype of child Components to create in this Container when a child item is specified as a raw configuration
 object, rather than as an instantiated Component. Defaults to 'panel'.]]></description><name>defaultType</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[This option is a means of applying default settings to all added items whether added through the items config or via the
 add or insert methods. If an added item is a config object, and not an instantiated Component, then the default
 properties are unconditionally applied. If the added item is an instantiated Component, then the default properties are
 applied conditionally so as not to override existing properties in the item. If the defaults option is specified as a
 function, then the function will be called using this Container as the scope (this reference) and passing the added item
 as the first parameter. Any resulting object from that call is then applied to the item as default properties. For
 example, to automatically apply padding to the body of each of a set of contained Ext.Panel items, you could pass:
 defaults: {bodyStyle:'padding:15px'}. Usage: defaults: {               // defaults are applied to items, not the
 container
     autoScroll:true
 },
 items: [
     {
         xtype: 'panel',   // defaults do not have precedence over
       
 id: 'panel1',     // options in config objects, so the defaults
         autoScroll: false // will not be applied here,
 panel1 will be autoScroll:false
     },
     new Ext.Panel({       // defaults do have precedence over options
         id:
 'panel2',     // options in components, so the defaults
         autoScroll: false // will be applied here, panel2 will
 be autoScroll:true.
     })
 ]]]></description><name>defaults</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to disable the field (defaults to false). Be aware that conformant with the HTML specification, disabled Fields
 will not be submitted.]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class to add when the Component is disabled. Defaults to 'x-item-disabled'.]]></description><name>disabledCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Allows the component to be dragged via the touch event.]]></description><name>draggable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default CSS class for the field (defaults to 'x-form-field')]]></description><name>fieldCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Create the Component as a floating and use absolute positioning. Defaults to false.]]></description><name>floating</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class to use when the field receives focus (defaults to 'x-field-focus')]]></description><name>focusCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of this component in pixels.]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to false.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional CSS class that will be added to the actual element (or whichever different element is defined by inputAutoEl).
 Defaults to undefined.]]></description><name>inputCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The type attribute for input fields -- e.g. radio, text, password, file (defaults to 'text'). The types 'file' and
 'password' must be used to render those field types currently -- there are no separate Ext components for those. Note
 that if you use inputType:'file', emptyText is not supported and should be avoided.]]></description><name>inputType</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[** IMPORTANT: be sure to specify a layout if needed ! ** A single item, or an array of child Components to be added to
 this container, for example: // specifying a single item
 items: {...},
 layout: 'fit',    // specify a layout!
 
 //
 specifying multiple items
 items: [{...}, {...}],
 layout: 'hbox', // specify a layout! Each item may be: any type of
 object based on Ext.Component a fully instanciated object or an object literal that: has a specified xtype the
 Ext.Component.xtype specified is associated with the Component desired and should be chosen from one of the available
 xtypes as listed in Ext.Component. If an xtype is not explicitly specified, the defaultType for that Container is used.
 will be "lazily instanciated", avoiding the overhead of constructing a fully instanciated Component object Notes: Ext
 uses lazy rendering. Child Components will only be rendered should it become necessary. Items are automatically laid out
 when they are first shown (no sizing is done while hidden), or in response to a doLayout call. Do not specify contentEl/
 html with items.]]></description><name>items</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The label to associate with this field. Defaults to null.]]></description><name>label</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The location to render the label of the field. Acceptable values are 'top' and 'left'. Defaults to 'left']]></description><name>labelAlign</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of the label, can be any valid CSS size. E.g '20%', '6em', '100px'. Defaults to '30%']]></description><name>labelWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[*Important: In order for child items to be correctly sized and positioned, typically a layout manager must be specified
 through the layout configuration option. The sizing and positioning of child items is the responsibility of the
 Container's layout manager which creates and manages the type of layout you have in mind. For example: If the layout
 configuration is not explicitly specified for a general purpose container (e.g. Container or Panel) the default layout
 manager will be used which does nothing but render child components sequentially into the Container (no sizing or
 positioning will be performed in this situation). layout may be specified as either as an Object or as a String: Specify
 as an Object Example usage: layout: {
     type: 'vbox',
     align: 'left'
 } type The layout type to be used for this
 container. If not specified, a default Ext.layout.ContainerLayout will be created and used. Valid layout type values
 are:
 auto - Default card fit hbox vbox Layout specific configuration properties Additional layout specific
 configuration properties may also be specified. For complete details regarding the valid config options for each layout
 type, see the layout class corresponding to the type specified. Specify as a String Example usage: layout: {
     type:
 'vbox',
     padding: '5',
     align: 'left'
 } layout The layout type to be used for this container (see list of valid
 layout type values above). Additional layout specific configuration properties. For complete details regarding the valid
 config options for each layout type, see the layout class corresponding to the layout specified.]]></description><name>layout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A config object containing one or more event handlers to be added to this object during initialization. This should be a
 valid listeners config object as specified in the addListener example for attaching multiple handlers at once. DOM
 events from ExtJs Components While some ExtJs Component classes export selected DOM events (e.g. "click", "mouseover"
 etc), this is usually only done when extra value can be added. For example the DataView's click event passing the node
 clicked on. To access DOM events directly from a child element of a Component, we need to specify the element option to
 identify the Component property to add a DOM listener to: new Ext.Panel({
     width: 400,
     height: 200,
    
 dockedItems: [{
         xtype: 'toolbar'
     }],
     listeners: {
         click: {
             element: 'el', //bind to
 the underlying el property on the panel
             fn: function(){ console.log('click el'); }
         },
        
 dblclick: {
             element: 'body', //bind to the underlying body property on the panel
             fn: function(){
 console.log('dblclick body'); }
         }
     }
 });]]></description><name>listeners</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the margin for this component. The margin can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>margin</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this Component will set its height to. Warning: This will override any size management
 applied by layout managers.]]></description><name>maxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum number of permitted input characters (defaults to 0).]]></description><name>maxLength</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum number of lines made visible by the input.]]></description><name>maxRows</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this Component will set its width to. Warning: This will override any size management
 applied by layout managers.]]></description><name>maxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this Component will set its height to. Warning: This will override any size management
 applied by layout managers.]]></description><name>minHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this Component will set its width to. Warning: This will override any size management
 applied by layout managers.]]></description><name>minWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The field's HTML name attribute (defaults to ''). Note: this property must be set if this field is to be automatically
 included with form submit().]]></description><name>name</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the padding for this component. The padding can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>padding</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A string value displayed in the input (if supported) when the control is empty.]]></description><name>placeHolder</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object containing properties specifying DomQuery selectors which identify child elements created by the render
 process. After the Component's internal structure is rendered according to the renderTpl, this object is iterated
 through, and the found Elements are added as properties to the Component using the renderSelector property name. For
 example, a Component which rendered an image, and description into its element might use the following properties coded
 into its prototype: renderTpl: '"{imageUrl}" class="x-image-component-img">
 "x-image-component-desc">{description}',
 
 renderSelectors: {
     image: 'img.x-image-component-img',
     descEl:
 'div.x-image-component-desc'
 } After rendering, the Component would have a property image referencing its child img
 Element, and a property descEl referencing the div Element which contains the description.]]></description><name>renderSelectors</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An XTemplate used to create the internal structure inside this Component's encapsulating Element. You do not normally
 need to specify this. For the base classes Ext.Component and Ext.Container, this defaults to null which means that they
 will be initially rendered with no internal structure; they render their Element empty. The more specialized ExtJS and
 Touch classes which use a more complex DOM structure, provide their own template definitions. This is intended to allow
 the developer to create application-specific utility Components with customized internal structure. Upon rendering, any
 created child elements may be automatically imported into object properties using the renderSelectors option.]]></description><name>renderTpl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to make this field required. Note: this only causes a visual indication. Doesn't prevent user from submitting the
 form.]]></description><name>required</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
             title: 'Some Title',
             renderTo: Ext.getBody(),
          
 width: 400, height: 300,
             layout: 'form',
             items: [{
                 xtype: 'textareafield',
      
 style: {
                     width: '95%',
                     marginBottom: '10px'
                 }
             },
    
 new Ext.Button({
                 text: 'Send',
                 minWidth: '100',
                 style: {
                
     marginBottom: '10px'
                 }
             })
             ]
         });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The class that is added to the content target when you set styleHtmlContent to true. Defaults to 'x-html']]></description><name>styleHtmlCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically style the html inside the content target of this component (body for panels). Defaults to false.]]></description><name>styleHtmlContent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The tabIndex for this field. Note this only applies to fields that are rendered, not those which are built via applyTo
 (defaults to undefined).]]></description><name>tabIndex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An Ext.Template, Ext.XTemplate or an array of strings to form an Ext.XTemplate. Used in conjunction with the data and
 tplWriteMode configurations.]]></description><name>tpl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A set of predefined ui styles for individual components. Most components support 'light' and 'dark'. Extra string added
 to the baseCls with an extra '-'. 
 <pre><code>
 new Ext.Panel({
     title: 'Some Title',
     baseCls: 'x-component'
     ui: 'green'
 });</pre></code>
 The ui configuration in this example would add 'x-component-green' as an additional class.]]></description><name>ui</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A value to initialize this field with (defaults to undefined).]]></description><name>value</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of this component in pixels.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original SenchaTouch API docs:
 <a href="http://docs.sencha.com/touch/">http://docs.sencha.com/touch/</a>

 <p>Simple text input field. See <a href="output/Ext.form.FormPanel.html" ext:cls="Ext.form.FormPanel">FormPanel</a> for
 example usage.</p>]]></description><name>form.textField</name><tag-class>org.brushingbits.jnap.ui.senchatouch.form.TextField</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[A string component id or the numeric index of the component that should be initially activated within the container's
 layout on render. For example, activeItem: 'item-1' or activeItem: 0 (index 0 = the first item in the container's
 collection). activeItem only applies to layout styles that can display items one at a time (like Ext.layout.CardLayout
 and Ext.layout.FitLayout). Related to Ext.layout.ContainerLayout.activeItem.]]></description><name>activeItem</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>autoCapitalize</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>autoComplete</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>autoCorrect</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically create the field input element on render. This is true by default, but should be set to false for
 any Ext.Field subclasses that don't need an HTML input (e.g. Ext.Slider and similar)]]></description><name>autoCreateField</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If true the container will automatically destroy any contained component that is removed from it, else destruction must
 be handled manually (defaults to true).]]></description><name>autoDestroy</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The base CSS class to apply to this components's element. This will also be prepended to elements within this component
 like Panel's body will get a class x-panel-body. This means that if you create a subclass of Panel, and you want it to
 get all the Panels styling for the element and the body, you leave the baseCls x-panel and use componentCls to add
 specific styling for this component.]]></description><name>baseCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the border for this component. The border can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>border</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to ['add', 'remove'].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Animation to be used during transitions of cards. Note this only works when this container has a CardLayout. Any valid
 value from Ext.anims can be used ('fade', 'slide', 'flip', 'cube', 'pop', 'wipe'). Defaults to null.]]></description><name>cardSwitchAnimation</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom CSS class to apply to the field's underlying element (defaults to '').]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS Class to be added to a components root level element to give distinction to it via styling.]]></description><name>componentCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The sizing and positioning of the component Elements is the responsibility of the Component's layout manager which
 creates and manages the type of layout specific to the component. If the layout configuration is not explicitly
 specified for a general purpose compopnent the default layout manager will be used.]]></description><name>componentLayout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default xtype of child Components to create in this Container when a child item is specified as a raw configuration
 object, rather than as an instantiated Component. Defaults to 'panel'.]]></description><name>defaultType</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[This option is a means of applying default settings to all added items whether added through the items config or via the
 add or insert methods. If an added item is a config object, and not an instantiated Component, then the default
 properties are unconditionally applied. If the added item is an instantiated Component, then the default properties are
 applied conditionally so as not to override existing properties in the item. If the defaults option is specified as a
 function, then the function will be called using this Container as the scope (this reference) and passing the added item
 as the first parameter. Any resulting object from that call is then applied to the item as default properties. For
 example, to automatically apply padding to the body of each of a set of contained Ext.Panel items, you could pass:
 defaults: {bodyStyle:'padding:15px'}. Usage: defaults: {               // defaults are applied to items, not the
 container
     autoScroll:true
 },
 items: [
     {
         xtype: 'panel',   // defaults do not have precedence over
       
 id: 'panel1',     // options in config objects, so the defaults
         autoScroll: false // will not be applied here,
 panel1 will be autoScroll:false
     },
     new Ext.Panel({       // defaults do have precedence over options
         id:
 'panel2',     // options in components, so the defaults
         autoScroll: false // will be applied here, panel2 will
 be autoScroll:true.
     })
 ]]]></description><name>defaults</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to disable the field (defaults to false). Be aware that conformant with the HTML specification, disabled Fields
 will not be submitted.]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class to add when the Component is disabled. Defaults to 'x-item-disabled'.]]></description><name>disabledCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Allows the component to be dragged via the touch event.]]></description><name>draggable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default CSS class for the field (defaults to 'x-form-field')]]></description><name>fieldCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Create the Component as a floating and use absolute positioning. Defaults to false.]]></description><name>floating</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class to use when the field receives focus (defaults to 'x-field-focus')]]></description><name>focusCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of this component in pixels.]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to false.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional CSS class that will be added to the actual element (or whichever different element is defined by inputAutoEl).
 Defaults to undefined.]]></description><name>inputCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The type attribute for input fields -- e.g. radio, text, password, file (defaults to 'text'). The types 'file' and
 'password' must be used to render those field types currently -- there are no separate Ext components for those. Note
 that if you use inputType:'file', emptyText is not supported and should be avoided.]]></description><name>inputType</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[** IMPORTANT: be sure to specify a layout if needed ! ** A single item, or an array of child Components to be added to
 this container, for example: // specifying a single item
 items: {...},
 layout: 'fit',    // specify a layout!
 
 //
 specifying multiple items
 items: [{...}, {...}],
 layout: 'hbox', // specify a layout! Each item may be: any type of
 object based on Ext.Component a fully instanciated object or an object literal that: has a specified xtype the
 Ext.Component.xtype specified is associated with the Component desired and should be chosen from one of the available
 xtypes as listed in Ext.Component. If an xtype is not explicitly specified, the defaultType for that Container is used.
 will be "lazily instanciated", avoiding the overhead of constructing a fully instanciated Component object Notes: Ext
 uses lazy rendering. Child Components will only be rendered should it become necessary. Items are automatically laid out
 when they are first shown (no sizing is done while hidden), or in response to a doLayout call. Do not specify contentEl/
 html with items.]]></description><name>items</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The label to associate with this field. Defaults to null.]]></description><name>label</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The location to render the label of the field. Acceptable values are 'top' and 'left'. Defaults to 'left']]></description><name>labelAlign</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of the label, can be any valid CSS size. E.g '20%', '6em', '100px'. Defaults to '30%']]></description><name>labelWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[*Important: In order for child items to be correctly sized and positioned, typically a layout manager must be specified
 through the layout configuration option. The sizing and positioning of child items is the responsibility of the
 Container's layout manager which creates and manages the type of layout you have in mind. For example: If the layout
 configuration is not explicitly specified for a general purpose container (e.g. Container or Panel) the default layout
 manager will be used which does nothing but render child components sequentially into the Container (no sizing or
 positioning will be performed in this situation). layout may be specified as either as an Object or as a String: Specify
 as an Object Example usage: layout: {
     type: 'vbox',
     align: 'left'
 } type The layout type to be used for this
 container. If not specified, a default Ext.layout.ContainerLayout will be created and used. Valid layout type values
 are:
 auto - Default card fit hbox vbox Layout specific configuration properties Additional layout specific
 configuration properties may also be specified. For complete details regarding the valid config options for each layout
 type, see the layout class corresponding to the type specified. Specify as a String Example usage: layout: {
     type:
 'vbox',
     padding: '5',
     align: 'left'
 } layout The layout type to be used for this container (see list of valid
 layout type values above). Additional layout specific configuration properties. For complete details regarding the valid
 config options for each layout type, see the layout class corresponding to the layout specified.]]></description><name>layout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A config object containing one or more event handlers to be added to this object during initialization. This should be a
 valid listeners config object as specified in the addListener example for attaching multiple handlers at once. DOM
 events from ExtJs Components While some ExtJs Component classes export selected DOM events (e.g. "click", "mouseover"
 etc), this is usually only done when extra value can be added. For example the DataView's click event passing the node
 clicked on. To access DOM events directly from a child element of a Component, we need to specify the element option to
 identify the Component property to add a DOM listener to: new Ext.Panel({
     width: 400,
     height: 200,
    
 dockedItems: [{
         xtype: 'toolbar'
     }],
     listeners: {
         click: {
             element: 'el', //bind to
 the underlying el property on the panel
             fn: function(){ console.log('click el'); }
         },
        
 dblclick: {
             element: 'body', //bind to the underlying body property on the panel
             fn: function(){
 console.log('dblclick body'); }
         }
     }
 });]]></description><name>listeners</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the margin for this component. The margin can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>margin</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this Component will set its height to. Warning: This will override any size management
 applied by layout managers.]]></description><name>maxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum number of permitted input characters (defaults to 0).]]></description><name>maxLength</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this Component will set its width to. Warning: This will override any size management
 applied by layout managers.]]></description><name>maxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this Component will set its height to. Warning: This will override any size management
 applied by layout managers.]]></description><name>minHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this Component will set its width to. Warning: This will override any size management
 applied by layout managers.]]></description><name>minWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The field's HTML name attribute (defaults to ''). Note: this property must be set if this field is to be automatically
 included with form submit().]]></description><name>name</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the padding for this component. The padding can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>padding</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A string value displayed in the input (if supported) when the control is empty.]]></description><name>placeHolder</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object containing properties specifying DomQuery selectors which identify child elements created by the render
 process. After the Component's internal structure is rendered according to the renderTpl, this object is iterated
 through, and the found Elements are added as properties to the Component using the renderSelector property name. For
 example, a Component which rendered an image, and description into its element might use the following properties coded
 into its prototype: renderTpl: '"{imageUrl}" class="x-image-component-img">
 "x-image-component-desc">{description}',
 
 renderSelectors: {
     image: 'img.x-image-component-img',
     descEl:
 'div.x-image-component-desc'
 } After rendering, the Component would have a property image referencing its child img
 Element, and a property descEl referencing the div Element which contains the description.]]></description><name>renderSelectors</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An XTemplate used to create the internal structure inside this Component's encapsulating Element. You do not normally
 need to specify this. For the base classes Ext.Component and Ext.Container, this defaults to null which means that they
 will be initially rendered with no internal structure; they render their Element empty. The more specialized ExtJS and
 Touch classes which use a more complex DOM structure, provide their own template definitions. This is intended to allow
 the developer to create application-specific utility Components with customized internal structure. Upon rendering, any
 created child elements may be automatically imported into object properties using the renderSelectors option.]]></description><name>renderTpl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to make this field required. Note: this only causes a visual indication. Doesn't prevent user from submitting the
 form.]]></description><name>required</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
             title: 'Some Title',
             renderTo: Ext.getBody(),
          
 width: 400, height: 300,
             layout: 'form',
             items: [{
                 xtype: 'textareafield',
      
 style: {
                     width: '95%',
                     marginBottom: '10px'
                 }
             },
    
 new Ext.Button({
                 text: 'Send',
                 minWidth: '100',
                 style: {
                
     marginBottom: '10px'
                 }
             })
             ]
         });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The class that is added to the content target when you set styleHtmlContent to true. Defaults to 'x-html']]></description><name>styleHtmlCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically style the html inside the content target of this component (body for panels). Defaults to false.]]></description><name>styleHtmlContent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The tabIndex for this field. Note this only applies to fields that are rendered, not those which are built via applyTo
 (defaults to undefined).]]></description><name>tabIndex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An Ext.Template, Ext.XTemplate or an array of strings to form an Ext.XTemplate. Used in conjunction with the data and
 tplWriteMode configurations.]]></description><name>tpl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A set of predefined ui styles for individual components. Most components support 'light' and 'dark'. Extra string added
 to the baseCls with an extra '-'. 
 <pre><code>
 new Ext.Panel({
     title: 'Some Title',
     baseCls: 'x-component'
     ui: 'green'
 });</pre></code>
 The ui configuration in this example would add 'x-component-green' as an additional class.]]></description><name>ui</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A value to initialize this field with (defaults to undefined).]]></description><name>value</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of this component in pixels.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original SenchaTouch API docs:
 <a href="http://docs.sencha.com/touch/">http://docs.sencha.com/touch/</a>

 <p>Specialized Slider with a single thumb and only two values. By default the toggle component can be switched between
 the values of 0 and 1.</p>]]></description><name>form.toggle</name><tag-class>org.brushingbits.jnap.ui.senchatouch.form.Toggle</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[A string component id or the numeric index of the component that should be initially activated within the container's
 layout on render. For example, activeItem: 'item-1' or activeItem: 0 (index 0 = the first item in the container's
 collection). activeItem only applies to layout styles that can display items one at a time (like Ext.layout.CardLayout
 and Ext.layout.FitLayout). Related to Ext.layout.ContainerLayout.activeItem.]]></description><name>activeItem</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[When set to a number greater than 0, it will be the animation duration in ms, defaults to 200]]></description><name>animationDuration</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically create the field input element on render. This is true by default, but should be set to false for
 any Ext.Field subclasses that don't need an HTML input (e.g. Ext.Slider and similar)]]></description><name>autoCreateField</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If true the container will automatically destroy any contained component that is removed from it, else destruction must
 be handled manually (defaults to true).]]></description><name>autoDestroy</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The base CSS class to apply to this components's element. This will also be prepended to elements within this component
 like Panel's body will get a class x-panel-body. This means that if you create a subclass of Panel, and you want it to
 get all the Panels styling for the element and the body, you leave the baseCls x-panel and use componentCls to add
 specific styling for this component.]]></description><name>baseCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the border for this component. The border can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>border</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to ['add', 'remove'].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Animation to be used during transitions of cards. Note this only works when this container has a CardLayout. Any valid
 value from Ext.anims can be used ('fade', 'slide', 'flip', 'cube', 'pop', 'wipe'). Defaults to null.]]></description><name>cardSwitchAnimation</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom CSS class to apply to the field's underlying element (defaults to '').]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS Class to be added to a components root level element to give distinction to it via styling.]]></description><name>componentCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The sizing and positioning of the component Elements is the responsibility of the Component's layout manager which
 creates and manages the type of layout specific to the component. If the layout configuration is not explicitly
 specified for a general purpose compopnent the default layout manager will be used.]]></description><name>componentLayout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default xtype of child Components to create in this Container when a child item is specified as a raw configuration
 object, rather than as an instantiated Component. Defaults to 'panel'.]]></description><name>defaultType</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[This option is a means of applying default settings to all added items whether added through the items config or via the
 add or insert methods. If an added item is a config object, and not an instantiated Component, then the default
 properties are unconditionally applied. If the added item is an instantiated Component, then the default properties are
 applied conditionally so as not to override existing properties in the item. If the defaults option is specified as a
 function, then the function will be called using this Container as the scope (this reference) and passing the added item
 as the first parameter. Any resulting object from that call is then applied to the item as default properties. For
 example, to automatically apply padding to the body of each of a set of contained Ext.Panel items, you could pass:
 defaults: {bodyStyle:'padding:15px'}. Usage: defaults: {               // defaults are applied to items, not the
 container
     autoScroll:true
 },
 items: [
     {
         xtype: 'panel',   // defaults do not have precedence over
       
 id: 'panel1',     // options in config objects, so the defaults
         autoScroll: false // will not be applied here,
 panel1 will be autoScroll:false
     },
     new Ext.Panel({       // defaults do have precedence over options
         id:
 'panel2',     // options in components, so the defaults
         autoScroll: false // will be applied here, panel2 will
 be autoScroll:true.
     })
 ]]]></description><name>defaults</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to disable the field (defaults to false). Be aware that conformant with the HTML specification, disabled Fields
 will not be submitted.]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class to add when the Component is disabled. Defaults to 'x-item-disabled'.]]></description><name>disabledCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Allows the component to be dragged via the touch event.]]></description><name>draggable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default CSS class for the field (defaults to 'x-form-field')]]></description><name>fieldCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Create the Component as a floating and use absolute positioning. Defaults to false.]]></description><name>floating</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of this component in pixels.]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to false.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The increment by which to snap each thumb when its value changes. Defaults to 1. Any thumb movement will be snapped to
 the nearest value that is a multiple of the increment (e.g. if increment is 10 and the user tries to move the thumb to
 67, it will be snapped to 70 instead)]]></description><name>increment</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Overrides Ext.form.Field's inputCls. Defaults to 'x-slider']]></description><name>inputCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The type attribute for input fields -- e.g. radio, text, password, file (defaults to 'text'). The types 'file' and
 'password' must be used to render those field types currently -- there are no separate Ext components for those. Note
 that if you use inputType:'file', emptyText is not supported and should be avoided.]]></description><name>inputType</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[** IMPORTANT: be sure to specify a layout if needed ! ** A single item, or an array of child Components to be added to
 this container, for example: // specifying a single item
 items: {...},
 layout: 'fit',    // specify a layout!
 
 //
 specifying multiple items
 items: [{...}, {...}],
 layout: 'hbox', // specify a layout! Each item may be: any type of
 object based on Ext.Component a fully instanciated object or an object literal that: has a specified xtype the
 Ext.Component.xtype specified is associated with the Component desired and should be chosen from one of the available
 xtypes as listed in Ext.Component. If an xtype is not explicitly specified, the defaultType for that Container is used.
 will be "lazily instanciated", avoiding the overhead of constructing a fully instanciated Component object Notes: Ext
 uses lazy rendering. Child Components will only be rendered should it become necessary. Items are automatically laid out
 when they are first shown (no sizing is done while hidden), or in response to a doLayout call. Do not specify contentEl/
 html with items.]]></description><name>items</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The label to associate with this field. Defaults to null.]]></description><name>label</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The location to render the label of the field. Acceptable values are 'top' and 'left'. Defaults to 'left']]></description><name>labelAlign</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of the label, can be any valid CSS size. E.g '20%', '6em', '100px'. Defaults to '30%']]></description><name>labelWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[*Important: In order for child items to be correctly sized and positioned, typically a layout manager must be specified
 through the layout configuration option. The sizing and positioning of child items is the responsibility of the
 Container's layout manager which creates and manages the type of layout you have in mind. For example: If the layout
 configuration is not explicitly specified for a general purpose container (e.g. Container or Panel) the default layout
 manager will be used which does nothing but render child components sequentially into the Container (no sizing or
 positioning will be performed in this situation). layout may be specified as either as an Object or as a String: Specify
 as an Object Example usage: layout: {
     type: 'vbox',
     align: 'left'
 } type The layout type to be used for this
 container. If not specified, a default Ext.layout.ContainerLayout will be created and used. Valid layout type values
 are:
 auto - Default card fit hbox vbox Layout specific configuration properties Additional layout specific
 configuration properties may also be specified. For complete details regarding the valid config options for each layout
 type, see the layout class corresponding to the type specified. Specify as a String Example usage: layout: {
     type:
 'vbox',
     padding: '5',
     align: 'left'
 } layout The layout type to be used for this container (see list of valid
 layout type values above). Additional layout specific configuration properties. For complete details regarding the valid
 config options for each layout type, see the layout class corresponding to the layout specified.]]></description><name>layout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A config object containing one or more event handlers to be added to this object during initialization. This should be a
 valid listeners config object as specified in the addListener example for attaching multiple handlers at once. DOM
 events from ExtJs Components While some ExtJs Component classes export selected DOM events (e.g. "click", "mouseover"
 etc), this is usually only done when extra value can be added. For example the DataView's click event passing the node
 clicked on. To access DOM events directly from a child element of a Component, we need to specify the element option to
 identify the Component property to add a DOM listener to: new Ext.Panel({
     width: 400,
     height: 200,
    
 dockedItems: [{
         xtype: 'toolbar'
     }],
     listeners: {
         click: {
             element: 'el', //bind to
 the underlying el property on the panel
             fn: function(){ console.log('click el'); }
         },
        
 dblclick: {
             element: 'body', //bind to the underlying body property on the panel
             fn: function(){
 console.log('dblclick body'); }
         }
     }
 });]]></description><name>listeners</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the margin for this component. The margin can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>margin</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this Component will set its height to. Warning: This will override any size management
 applied by layout managers.]]></description><name>maxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The highest value any thumb on this slider can be set to (defaults to 100)]]></description><name>maxValue</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class added to the field when toggled to its maxValue]]></description><name>maxValueCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this Component will set its width to. Warning: This will override any size management
 applied by layout managers.]]></description><name>maxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this Component will set its height to. Warning: This will override any size management
 applied by layout managers.]]></description><name>minHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The lowest value any thumb on this slider can be set to (defaults to 0)]]></description><name>minValue</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class added to the field when toggled to its minValue]]></description><name>minValueCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this Component will set its width to. Warning: This will override any size management
 applied by layout managers.]]></description><name>minWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The field's HTML name attribute (defaults to ''). Note: this property must be set if this field is to be automatically
 included with form submit().]]></description><name>name</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the padding for this component. The padding can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>padding</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object containing properties specifying DomQuery selectors which identify child elements created by the render
 process. After the Component's internal structure is rendered according to the renderTpl, this object is iterated
 through, and the found Elements are added as properties to the Component using the renderSelector property name. For
 example, a Component which rendered an image, and description into its element might use the following properties coded
 into its prototype: renderTpl: '"{imageUrl}" class="x-image-component-img">
 "x-image-component-desc">{description}',
 
 renderSelectors: {
     image: 'img.x-image-component-img',
     descEl:
 'div.x-image-component-desc'
 } After rendering, the Component would have a property image referencing its child img
 Element, and a property descEl referencing the div Element which contains the description.]]></description><name>renderSelectors</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An XTemplate used to create the internal structure inside this Component's encapsulating Element. You do not normally
 need to specify this. For the base classes Ext.Component and Ext.Container, this defaults to null which means that they
 will be initially rendered with no internal structure; they render their Element empty. The more specialized ExtJS and
 Touch classes which use a more complex DOM structure, provide their own template definitions. This is intended to allow
 the developer to create application-specific utility Components with customized internal structure. Upon rendering, any
 created child elements may be automatically imported into object properties using the renderSelectors option.]]></description><name>renderTpl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to make this field required. Note: this only causes a visual indication. Doesn't prevent user from submitting the
 form.]]></description><name>required</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
             title: 'Some Title',
             renderTo: Ext.getBody(),
          
 width: 400, height: 300,
             layout: 'form',
             items: [{
                 xtype: 'textareafield',
      
 style: {
                     width: '95%',
                     marginBottom: '10px'
                 }
             },
    
 new Ext.Button({
                 text: 'Send',
                 minWidth: '100',
                 style: {
                
     marginBottom: '10px'
                 }
             })
             ]
         });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The class that is added to the content target when you set styleHtmlContent to true. Defaults to 'x-html']]></description><name>styleHtmlCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically style the html inside the content target of this component (body for panels). Defaults to false.]]></description><name>styleHtmlContent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The tabIndex for this field. Note this only applies to fields that are rendered, not those which are built via applyTo
 (defaults to undefined).]]></description><name>tabIndex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional array of Ext.form.Slider.Thumb instances. Usually values should be used instead]]></description><name>thumbs</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An Ext.Template, Ext.XTemplate or an array of strings to form an Ext.XTemplate. Used in conjunction with the data and
 tplWriteMode configurations.]]></description><name>tpl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A set of predefined ui styles for individual components. Most components support 'light' and 'dark'. Extra string added
 to the baseCls with an extra '-'. 
 <pre><code>
 new Ext.Panel({
     title: 'Some Title',
     baseCls: 'x-component'
     ui: 'green'
 });</pre></code>
 The ui configuration in this example would add 'x-component-green' as an additional class.]]></description><name>ui</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The value to initialize the thumb at (defaults to 0)]]></description><name>value</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of this component in pixels.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original SenchaTouch API docs:
 <a href="http://docs.sencha.com/touch/">http://docs.sencha.com/touch/</a>

 Wraps an HTML5 url field.]]></description><name>form.urlField</name><tag-class>org.brushingbits.jnap.ui.senchatouch.form.UrlField</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[A string component id or the numeric index of the component that should be initially activated within the container's
 layout on render. For example, activeItem: 'item-1' or activeItem: 0 (index 0 = the first item in the container's
 collection). activeItem only applies to layout styles that can display items one at a time (like Ext.layout.CardLayout
 and Ext.layout.FitLayout). Related to Ext.layout.ContainerLayout.activeItem.]]></description><name>activeItem</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>autoCapitalize</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>autoComplete</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>autoCorrect</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically create the field input element on render. This is true by default, but should be set to false for
 any Ext.Field subclasses that don't need an HTML input (e.g. Ext.Slider and similar)]]></description><name>autoCreateField</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If true the container will automatically destroy any contained component that is removed from it, else destruction must
 be handled manually (defaults to true).]]></description><name>autoDestroy</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The base CSS class to apply to this components's element. This will also be prepended to elements within this component
 like Panel's body will get a class x-panel-body. This means that if you create a subclass of Panel, and you want it to
 get all the Panels styling for the element and the body, you leave the baseCls x-panel and use componentCls to add
 specific styling for this component.]]></description><name>baseCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the border for this component. The border can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>border</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to ['add', 'remove'].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Animation to be used during transitions of cards. Note this only works when this container has a CardLayout. Any valid
 value from Ext.anims can be used ('fade', 'slide', 'flip', 'cube', 'pop', 'wipe'). Defaults to null.]]></description><name>cardSwitchAnimation</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom CSS class to apply to the field's underlying element (defaults to '').]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS Class to be added to a components root level element to give distinction to it via styling.]]></description><name>componentCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The sizing and positioning of the component Elements is the responsibility of the Component's layout manager which
 creates and manages the type of layout specific to the component. If the layout configuration is not explicitly
 specified for a general purpose compopnent the default layout manager will be used.]]></description><name>componentLayout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default xtype of child Components to create in this Container when a child item is specified as a raw configuration
 object, rather than as an instantiated Component. Defaults to 'panel'.]]></description><name>defaultType</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[This option is a means of applying default settings to all added items whether added through the items config or via the
 add or insert methods. If an added item is a config object, and not an instantiated Component, then the default
 properties are unconditionally applied. If the added item is an instantiated Component, then the default properties are
 applied conditionally so as not to override existing properties in the item. If the defaults option is specified as a
 function, then the function will be called using this Container as the scope (this reference) and passing the added item
 as the first parameter. Any resulting object from that call is then applied to the item as default properties. For
 example, to automatically apply padding to the body of each of a set of contained Ext.Panel items, you could pass:
 defaults: {bodyStyle:'padding:15px'}. Usage: defaults: {               // defaults are applied to items, not the
 container
     autoScroll:true
 },
 items: [
     {
         xtype: 'panel',   // defaults do not have precedence over
       
 id: 'panel1',     // options in config objects, so the defaults
         autoScroll: false // will not be applied here,
 panel1 will be autoScroll:false
     },
     new Ext.Panel({       // defaults do have precedence over options
         id:
 'panel2',     // options in components, so the defaults
         autoScroll: false // will be applied here, panel2 will
 be autoScroll:true.
     })
 ]]]></description><name>defaults</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to disable the field (defaults to false). Be aware that conformant with the HTML specification, disabled Fields
 will not be submitted.]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class to add when the Component is disabled. Defaults to 'x-item-disabled'.]]></description><name>disabledCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Allows the component to be dragged via the touch event.]]></description><name>draggable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default CSS class for the field (defaults to 'x-form-field')]]></description><name>fieldCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Create the Component as a floating and use absolute positioning. Defaults to false.]]></description><name>floating</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class to use when the field receives focus (defaults to 'x-field-focus')]]></description><name>focusCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of this component in pixels.]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to false.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional CSS class that will be added to the actual element (or whichever different element is defined by inputAutoEl).
 Defaults to undefined.]]></description><name>inputCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The type attribute for input fields -- e.g. radio, text, password, file (defaults to 'text'). The types 'file' and
 'password' must be used to render those field types currently -- there are no separate Ext components for those. Note
 that if you use inputType:'file', emptyText is not supported and should be avoided.]]></description><name>inputType</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[** IMPORTANT: be sure to specify a layout if needed ! ** A single item, or an array of child Components to be added to
 this container, for example: // specifying a single item
 items: {...},
 layout: 'fit',    // specify a layout!
 
 //
 specifying multiple items
 items: [{...}, {...}],
 layout: 'hbox', // specify a layout! Each item may be: any type of
 object based on Ext.Component a fully instanciated object or an object literal that: has a specified xtype the
 Ext.Component.xtype specified is associated with the Component desired and should be chosen from one of the available
 xtypes as listed in Ext.Component. If an xtype is not explicitly specified, the defaultType for that Container is used.
 will be "lazily instanciated", avoiding the overhead of constructing a fully instanciated Component object Notes: Ext
 uses lazy rendering. Child Components will only be rendered should it become necessary. Items are automatically laid out
 when they are first shown (no sizing is done while hidden), or in response to a doLayout call. Do not specify contentEl/
 html with items.]]></description><name>items</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The label to associate with this field. Defaults to null.]]></description><name>label</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The location to render the label of the field. Acceptable values are 'top' and 'left'. Defaults to 'left']]></description><name>labelAlign</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of the label, can be any valid CSS size. E.g '20%', '6em', '100px'. Defaults to '30%']]></description><name>labelWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[*Important: In order for child items to be correctly sized and positioned, typically a layout manager must be specified
 through the layout configuration option. The sizing and positioning of child items is the responsibility of the
 Container's layout manager which creates and manages the type of layout you have in mind. For example: If the layout
 configuration is not explicitly specified for a general purpose container (e.g. Container or Panel) the default layout
 manager will be used which does nothing but render child components sequentially into the Container (no sizing or
 positioning will be performed in this situation). layout may be specified as either as an Object or as a String: Specify
 as an Object Example usage: layout: {
     type: 'vbox',
     align: 'left'
 } type The layout type to be used for this
 container. If not specified, a default Ext.layout.ContainerLayout will be created and used. Valid layout type values
 are:
 auto - Default card fit hbox vbox Layout specific configuration properties Additional layout specific
 configuration properties may also be specified. For complete details regarding the valid config options for each layout
 type, see the layout class corresponding to the type specified. Specify as a String Example usage: layout: {
     type:
 'vbox',
     padding: '5',
     align: 'left'
 } layout The layout type to be used for this container (see list of valid
 layout type values above). Additional layout specific configuration properties. For complete details regarding the valid
 config options for each layout type, see the layout class corresponding to the layout specified.]]></description><name>layout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A config object containing one or more event handlers to be added to this object during initialization. This should be a
 valid listeners config object as specified in the addListener example for attaching multiple handlers at once. DOM
 events from ExtJs Components While some ExtJs Component classes export selected DOM events (e.g. "click", "mouseover"
 etc), this is usually only done when extra value can be added. For example the DataView's click event passing the node
 clicked on. To access DOM events directly from a child element of a Component, we need to specify the element option to
 identify the Component property to add a DOM listener to: new Ext.Panel({
     width: 400,
     height: 200,
    
 dockedItems: [{
         xtype: 'toolbar'
     }],
     listeners: {
         click: {
             element: 'el', //bind to
 the underlying el property on the panel
             fn: function(){ console.log('click el'); }
         },
        
 dblclick: {
             element: 'body', //bind to the underlying body property on the panel
             fn: function(){
 console.log('dblclick body'); }
         }
     }
 });]]></description><name>listeners</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the margin for this component. The margin can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>margin</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this Component will set its height to. Warning: This will override any size management
 applied by layout managers.]]></description><name>maxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum number of permitted input characters (defaults to 0).]]></description><name>maxLength</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this Component will set its width to. Warning: This will override any size management
 applied by layout managers.]]></description><name>maxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this Component will set its height to. Warning: This will override any size management
 applied by layout managers.]]></description><name>minHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this Component will set its width to. Warning: This will override any size management
 applied by layout managers.]]></description><name>minWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The field's HTML name attribute (defaults to ''). Note: this property must be set if this field is to be automatically
 included with form submit().]]></description><name>name</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the padding for this component. The padding can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>padding</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A string value displayed in the input (if supported) when the control is empty.]]></description><name>placeHolder</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object containing properties specifying DomQuery selectors which identify child elements created by the render
 process. After the Component's internal structure is rendered according to the renderTpl, this object is iterated
 through, and the found Elements are added as properties to the Component using the renderSelector property name. For
 example, a Component which rendered an image, and description into its element might use the following properties coded
 into its prototype: renderTpl: '"{imageUrl}" class="x-image-component-img">
 "x-image-component-desc">{description}',
 
 renderSelectors: {
     image: 'img.x-image-component-img',
     descEl:
 'div.x-image-component-desc'
 } After rendering, the Component would have a property image referencing its child img
 Element, and a property descEl referencing the div Element which contains the description.]]></description><name>renderSelectors</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An XTemplate used to create the internal structure inside this Component's encapsulating Element. You do not normally
 need to specify this. For the base classes Ext.Component and Ext.Container, this defaults to null which means that they
 will be initially rendered with no internal structure; they render their Element empty. The more specialized ExtJS and
 Touch classes which use a more complex DOM structure, provide their own template definitions. This is intended to allow
 the developer to create application-specific utility Components with customized internal structure. Upon rendering, any
 created child elements may be automatically imported into object properties using the renderSelectors option.]]></description><name>renderTpl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to make this field required. Note: this only causes a visual indication. Doesn't prevent user from submitting the
 form.]]></description><name>required</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
             title: 'Some Title',
             renderTo: Ext.getBody(),
          
 width: 400, height: 300,
             layout: 'form',
             items: [{
                 xtype: 'textareafield',
      
 style: {
                     width: '95%',
                     marginBottom: '10px'
                 }
             },
    
 new Ext.Button({
                 text: 'Send',
                 minWidth: '100',
                 style: {
                
     marginBottom: '10px'
                 }
             })
             ]
         });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The class that is added to the content target when you set styleHtmlContent to true. Defaults to 'x-html']]></description><name>styleHtmlCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically style the html inside the content target of this component (body for panels). Defaults to false.]]></description><name>styleHtmlContent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The tabIndex for this field. Note this only applies to fields that are rendered, not those which are built via applyTo
 (defaults to undefined).]]></description><name>tabIndex</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An Ext.Template, Ext.XTemplate or an array of strings to form an Ext.XTemplate. Used in conjunction with the data and
 tplWriteMode configurations.]]></description><name>tpl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A set of predefined ui styles for individual components. Most components support 'light' and 'dark'. Extra string added
 to the baseCls with an extra '-'. 
 <pre><code>
 new Ext.Panel({
     title: 'Some Title',
     baseCls: 'x-component'
     ui: 'green'
 });</pre></code>
 The ui configuration in this example would add 'x-component-green' as an additional class.]]></description><name>ui</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A value to initialize this field with (defaults to undefined).]]></description><name>value</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of this component in pixels.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original SenchaTouch API docs:
 <a href="http://docs.sencha.com/touch/">http://docs.sencha.com/touch/</a>

 <p>IndexBar is a component used to display a list of data (primarily an <a
 href="output/Ext.IndexBar.html#Ext.IndexBar-alphabet" ext:member="alphabet" ext:cls="Ext.IndexBar">alphabet</a>) which
 can then be used to quickly navigate through a list (see <a href="output/Ext.List.html" ext:cls="Ext.List">Ext.List</a>)
 of data. When a user taps on an item in the <a href="output/Ext.IndexBar.html" ext:cls="Ext.IndexBar">Ext.IndexBar</a>,
 it will fire the <tt><a href="output/Ext.IndexBar.html#Ext.IndexBar-index" ext:member="index"
 ext:cls="Ext.IndexBar">index</a></tt> event.</p> 
 <h2>Screenshot:</h2> 
 <p><img
 src="doc_resources/Ext.IndexBar/screenshot.png" /></p> 
 <h2>Example code:</h2> 
 <p>Here is an example of the usage in a
 <a href="output/Ext.List.html" ext:cls="Ext.List">Ext.List</a>:</p> 
 <pre><code>Ext.regModel(<em>'Contact'</em>, {
    
 fields: [<em>'firstName'</em>, <em>'lastName'</em>]
 });
 
 <b>var</b> store = <b>new</b> Ext.data.JsonStore({
     model  :
 <em>'Contact'</em>,
     sorters: <em>'lastName'</em>,
 
     getGroupString : <b>function</b>(record) {
        
 <b>return</b> record.get(<em>'lastName'</em>)[0];
     },
 
     data: [
         {firstName: <em>'Tommy'</em>,   lastName:
 <em>'Maintz'</em>},
         {firstName: <em>'Rob'</em>,     lastName: <em>'Dougan'</em>},
         {firstName:
 <em>'Ed'</em>,      lastName: <em>'Spencer'</em>},
         {firstName: <em>'Jamie'</em>,   lastName: <em>'Avins'</em>},
 
 {firstName: <em>'Aaron'</em>,   lastName: <em>'Conran'</em>},
         {firstName: <em>'Dave'</em>,    lastName:
 <em>'Kaneda'</em>},
         {firstName: <em>'Michael'</em>, lastName: <em>'Mullany'</em>},
         {firstName:
 <em>'Abraham'</em>, lastName: <em>'Elias'</em>},
         {firstName: <em>'Jay'</em>,     lastName:
 <em>'Robinson'</em>},
         {firstName: <em>'Tommy'</em>,   lastName: <em>'Maintz'</em>},
         {firstName:
 <em>'Rob'</em>,     lastName: <em>'Dougan'</em>},
         {firstName: <em>'Ed'</em>,      lastName:
 <em>'Spencer'</em>},
         {firstName: <em>'Jamie'</em>,   lastName: <em>'Avins'</em>},
         {firstName:
 <em>'Aaron'</em>,   lastName: <em>'Conran'</em>},
         {firstName: <em>'Dave'</em>,    lastName: <em>'Kaneda'</em>},
 
 {firstName: <em>'Michael'</em>, lastName: <em>'Mullany'</em>},
         {firstName: <em>'Abraham'</em>, lastName:
 <em>'Elias'</em>},
         {firstName: <em>'Jay'</em>,     lastName: <em>'Robinson'</em>}
     ]
 });
 
 <b>var</b> list =
 <b>new</b> Ext.List({
     tpl: <em>'&lt;tpl <b>for</b>=<em>&quot;.&quot;</em>&gt;&lt;div
 class=<em>&quot;contact&quot;</em>&gt;{firstName}
 &lt;strong&gt;{lastName}&lt;/strong&gt;&lt;/div&gt;&lt;/tpl&gt;'</em>,
 
     itemSelector: <em>'div.contact'</em>,
    
 singleSelect: true,
     grouped     : true,
     indexBar    : true,
 
     store: store,
 
     floating     : true,
    
 width        : 350,
     height       : 370,
     centered     : true,
     modal        : true,
     hideOnMaskTap:
 false
 });
 list.show();</code></pre> 
 <p>Alternatively you can initate the <a href="output/Ext.IndexBar.html"
 ext:cls="Ext.IndexBar">Ext.IndexBar</a> component manually in a custom component by using something similar to the
 following example:</p>
 <p> <code></code></p>
 <pre><code>
 <b>var</b> indexBar = <b>new</b> Ext.IndexBar({
     dock    :
 <em>'right'</em>,
     overlay : true,
     alphabet: true
 });</code></pre>]]></description><name>indexBar</name><tag-class>org.brushingbits.jnap.ui.senchatouch.IndexBar</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[true to use the letters property to show a list of the alphabet. Should not be used in conjunction with store.]]></description><name>alphabet</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Base CSS class Defaults to 'x-indexbar']]></description><name>componentCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Layout direction, can be either 'vertical' or 'horizontal' Defaults to 'vertical']]></description><name>direction</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Required. A simple CSS selector (e.g. div.x-indexbar-item for items]]></description><name>itemSelector</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The letters to show on the index bar. Defaults to the English alphabet, A-Z.]]></description><name>letters</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The prefix string to be appended at the beginning of the list. E.g: useful to add a "#" prefix before numbers]]></description><name>listPrefix</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The store to be used for displaying data on the index bar. The store model must have a value field when using the
 default tpl. If no store is defined, it will create a store using the IndexBarModel model.]]></description><name>store</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Template for items]]></description><name>tpl</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original SenchaTouch API docs:
 <a href="http://docs.sencha.com/touch/">http://docs.sencha.com/touch/</a>

 <p>This class is intended to be extended or created via the <tt><b><a
 href="output/Ext.Container.html#Ext.Container-layout" ext:member="layout" ext:cls="Ext.Container">layout</a></b></tt>
 configuration property. See <tt><b><a href="output/Ext.Container.html#Ext.Container-layout" ext:member="layout"
 ext:cls="Ext.Container">Ext.Container.layout</a></b></tt> for additional details.</p>]]></description><name>layout.container</name><tag-class>org.brushingbits.jnap.ui.senchatouch.layout.ContainerLayout</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[An optional extra CSS class that will be added to the container. This can be useful for adding customized styles to the
 container or any of its children using standard CSS rules. See Ext.Component.ctCls also.]]></description><name>itemCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original SenchaTouch API docs:
 <a href="http://docs.sencha.com/touch/">http://docs.sencha.com/touch/</a>

 <p>A layout that arranges items horizontally across a Container. This layout optionally divides available horizontal
 space between child items containing a numeric <code>flex</code> configuration. The flex option is a ratio that
 distributes width after any items with explicit widths have been accounted for. In the code below, the width is
 calculated as follows: </p>
 <ul> 
  <li>The fixed width item is subtracted, leaving us with 300 width</li> 
  <li>The
 total flex number is counted, in this case, it is 3</li> 
  <li>The ratio is then calculated, 300 / 3 = 100</li> 
 
 <li>The first item has a flex of 2, so it is set to 2 * 100</li> 
  <li>The other remaining item is set to 1 * 100</li>
 
 </ul>
 <p></p> 
 <pre><code><b>new</b> Ext.Container({
     width: 400,
     height: 300,
     layout: {
         type:
 <em>'hbox'</em>,
         align: <em>'stretch'</em>
     },
     items: [{
         flex: 2,
         html: <em>'First'</em>
 
 },{
         width: 100,
         html: <em>'Second'</em>
     },{
         flex: 1,
         html: <em>'Third'</em>
    
 }]
 });</code></pre> This layout may also be used to set the heights of child items by configuring it with the 
 <a
 href="output/Ext.layout.HBoxLayout.html#Ext.layout.HBoxLayout-align" ext:member="align"
 ext:cls="Ext.layout.HBoxLayout">align</a> option.]]></description><name>layout.hbox</name><tag-class>org.brushingbits.jnap.ui.senchatouch.layout.HBoxLayout</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[Specifies the vertical alignment of child components. Defaults to 'center'. Acceptable values are: center : Aligned to
 the center of the container. end : Aligned to the bottom of the container. start : Aligned to the top of the container.
 stretch : Components are stretched vertically to fill the container.]]></description><name>align</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the direction in which child components are laid out. Defaults to 'normal', which means they are laid out in
 the order they are added. You can use the 'reverse' option to have them laid out in reverse.]]></description><name>direction</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to the container. This can be useful for adding customized styles to the
 container or any of its children using standard CSS rules. See Ext.Component.ctCls also.]]></description><name>itemCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the horizontal alignment of child components. Defaults to 'start'. Acceptable values are: center : Aligned to
 the center of the container. end : Aligned to the right of the container. justify : Justified with both the left and
 right of the container. start : Aligned to the left of the container.]]></description><name>pack</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original SenchaTouch API docs:
 <a href="http://docs.sencha.com/touch/">http://docs.sencha.com/touch/</a>

 <p>A layout that arranges items vertically down a Container. This layout optionally divides available vertical space
 between child items containing a numeric <code>flex</code> configuration. The flex option is a ratio that distributes
 height after any items with explicit heights have been accounted for. In the code below, the height is calculated as
 follows: </p>
 <ul> 
  <li>The fixed height item is subtracted, leaving us with 300 height</li> 
  <li>The total flex
 number is counted, in this case, it is 3</li> 
  <li>The ratio is then calculated, 300 / 3 = 100</li> 
  <li>The first
 item has a flex of 2, so it is set to 2 * 100</li> 
  <li>The other remaining item is set to 1 * 100</li> 
 </ul>
 <p></p>
 
 <pre><code><b>new</b> Ext.Container({
     width: 300,
     height: 400,
     layout: {
         type: <em>'vbox'</em>,
    
 align: <em>'stretch'</em>
     },
     items: [{
         flex: 2,
         html: <em>'First'</em>
     },{
         width:
 100,
         html: <em>'Second'</em>
     },{
         flex: 1,
         html: <em>'Third'</em>
     }]
 });</code></pre>
 This layout may also be used to set the widths of child items by configuring it with the 
 <a
 href="output/Ext.layout.VBoxLayout.html#Ext.layout.VBoxLayout-align" ext:member="align"
 ext:cls="Ext.layout.VBoxLayout">align</a> option.]]></description><name>layout.vbox</name><tag-class>org.brushingbits.jnap.ui.senchatouch.layout.VBoxLayout</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[Specifies the horizontal alignignment of child components. Defaults to 'center'. Acceptable values are: center : Aligned
 to the center of the container. end : Aligned to the right of the container. start : Aligned to the left of the
 container. stretch : Components are stretched horizontally to fill the container.]]></description><name>align</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the direction in which child components are laid out. Defaults to 'normal', which means they are laid out in
 the order they are added. You can use the 'reverse' option to have them laid out in reverse.]]></description><name>direction</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to the container. This can be useful for adding customized styles to the
 container or any of its children using standard CSS rules. See Ext.Component.ctCls also.]]></description><name>itemCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the vertical alignment of child components. Defaults to 'start'. Acceptable values are: center : Aligned to
 the center of the container. end : Aligned to the bottom of the container. justify : Justified with both the top and
 bottom of the container. start : Aligned to the top of the container.]]></description><name>pack</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original SenchaTouch API docs:
 <a href="http://docs.sencha.com/touch/">http://docs.sencha.com/touch/</a>

 <p>A mechanism for displaying data using a list layout template. List uses an <a href="output/Ext.XTemplate.html"
 ext:cls="Ext.XTemplate">Ext.XTemplate</a> as its internal templating mechanism, and is bound to an <a
 href="output/Ext.data.Store.html" ext:cls="Ext.data.Store">Ext.data.Store</a> so that as the data in the store changes
 the view is automatically updated to reflect the changes.</p> 
 <p>The view also provides built-in behavior for many
 common events that can occur for its contained items including itemtap, containertap, etc. as well as a built-in
 selection model. <b>In order to use these features, an <a href="output/Ext.List.html#Ext.List-itemSelector"
 ext:member="itemSelector" ext:cls="Ext.List">itemSelector</a> config must be provided for the DataView to determine what
 nodes it will be working with.</b></p> 
 <h2>Useful Properties</h2> 
 <ul class="list"> 
  <li><a
 href="output/Ext.List.html#Ext.List-itemTpl" ext:member="itemTpl" ext:cls="Ext.List">itemTpl</a></li> 
  <li><a
 href="output/Ext.List.html#Ext.List-store" ext:member="store" ext:cls="Ext.List">store</a></li> 
  <li><a
 href="output/Ext.List.html#Ext.List-grouped" ext:member="grouped" ext:cls="Ext.List">grouped</a></li> 
  <li><a
 href="output/Ext.List.html#Ext.List-indexBar" ext:member="indexBar" ext:cls="Ext.List">indexBar</a></li> 
  <li><a
 href="output/Ext.List.html#Ext.List-singleSelect" ext:member="singleSelect" ext:cls="Ext.List">singleSelect</a></li> 
 
 <li><a href="output/Ext.List.html#Ext.List-multiSelect" ext:member="multiSelect" ext:cls="Ext.List">multiSelect</a></li>
 
 </ul> 
 <h2>Useful Methods</h2> 
 <ul class="list"> 
  <li><a href="output/Ext.List.html#Ext.List-bindStore"
 ext:member="bindStore" ext:cls="Ext.List">bindStore</a></li> 
  <li><a href="output/Ext.List.html#Ext.List-getRecord"
 ext:member="getRecord" ext:cls="Ext.List">getRecord</a></li> 
  <li><a href="output/Ext.List.html#Ext.List-getRecords"
 ext:member="getRecords" ext:cls="Ext.List">getRecords</a></li> 
  <li><a
 href="output/Ext.List.html#Ext.List-getSelectedRecords" ext:member="getSelectedRecords"
 ext:cls="Ext.List">getSelectedRecords</a></li> 
  <li><a href="output/Ext.List.html#Ext.List-getSelectedNodes"
 ext:member="getSelectedNodes" ext:cls="Ext.List">getSelectedNodes</a></li> 
  <li><a
 href="output/Ext.List.html#Ext.List-indexOf" ext:member="indexOf" ext:cls="Ext.List">indexOf</a></li> 
 </ul> 
 <h2>Useful
 Events</h2> 
 <ul class="list"> 
  <li><a href="output/Ext.List.html#Ext.List-itemtap" ext:member="itemtap"
 ext:cls="Ext.List">itemtap</a></li> 
  <li><a href="output/Ext.List.html#Ext.List-itemdoubletap"
 ext:member="itemdoubletap" ext:cls="Ext.List">itemdoubletap</a></li> 
  <li><a
 href="output/Ext.List.html#Ext.List-itemswipe" ext:member="itemswipe" ext:cls="Ext.List">itemswipe</a></li> 
  <li><a
 href="output/Ext.List.html#Ext.List-selectionchange" ext:member="selectionchange"
 ext:cls="Ext.List">selectionchange</a></li> 
 </ul> 
 <h2>Screenshot:</h2> 
 <p><img
 src="doc_resources/Ext.List/screenshot.png" /></p> 
 <h2>Example code:</h2> 
 <pre><code>Ext.regModel(<em>'Contact'</em>,
 {
     fields: [<em>'firstName'</em>, <em>'lastName'</em>]
 });
 
 <b>var</b> store = <b>new</b> Ext.data.JsonStore({
    
 model  : <em>'Contact'</em>,
     sorters: <em>'lastName'</em>,
 
     getGroupString : <b>function</b>(record) {
        
 <b>return</b> record.get(<em>'lastName'</em>)[0];
     },
 
     data: [
         {firstName: <em>'Tommy'</em>,   lastName:
 <em>'Maintz'</em>},
         {firstName: <em>'Rob'</em>,     lastName: <em>'Dougan'</em>},
         {firstName:
 <em>'Ed'</em>,      lastName: <em>'Spencer'</em>},
         {firstName: <em>'Jamie'</em>,   lastName: <em>'Avins'</em>},
 
 {firstName: <em>'Aaron'</em>,   lastName: <em>'Conran'</em>},
         {firstName: <em>'Dave'</em>,    lastName:
 <em>'Kaneda'</em>},
         {firstName: <em>'Michael'</em>, lastName: <em>'Mullany'</em>},
         {firstName:
 <em>'Abraham'</em>, lastName: <em>'Elias'</em>},
         {firstName: <em>'Jay'</em>,     lastName: <em>'Robinson'</em>}
 
 ]
 });
 
 <b>var</b> list = <b>new</b> Ext.List({
     fullscreen: true,
     
     itemTpl : <em>'{firstName}
 {lastName}'</em>,
     grouped : true,
     indexBar: true,
     
     store: store
 });
 list.show();</code></pre>]]></description><name>list</name><tag-class>org.brushingbits.jnap.ui.senchatouch.List</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[Only respected if singleSelect is true. If this is set to false, a selected item will not be deselected when tapped on,
 ensuring that once an item has been selected at least one item will always be selected. Defaults to allowed (true).]]></description><name>allowDeselect</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The base CSS class to apply to this components's element. This will also be prepended to elements within this component
 like Panel's body will get a class x-panel-body. This means that if you create a subclass of Panel, and you want it to
 get all the Panels styling for the element and the body, you leave the baseCls x-panel and use componentCls to add
 specific styling for this component.]]></description><name>baseCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Set this to true to ignore datachanged events on the bound store. This is useful if you wish to provide custom
 transition animations via a plugin (defaults to false)]]></description><name>blockRefresh</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the border for this component. The border can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>border</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Center the Component. Defaults to false.]]></description><name>centered</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to clear any selections on the list when the list is deactivated (defaults to true).]]></description><name>clearSelectionOnDeactivate</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element (defaults to ''). This can be useful for
 adding customized styles to the component or any of its children using standard CSS rules.]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS Class to be added to a components root level element to give distinction to it via styling.]]></description><name>componentCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The sizing and positioning of the component Elements is the responsibility of the Component's layout manager which
 creates and manages the type of layout specific to the component. If the layout configuration is not explicitly
 specified for a general purpose compopnent the default layout manager will be used.]]></description><name>componentLayout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to defer emptyText being applied until the store's first load]]></description><name>deferEmptyText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to disable selection within the DataView. Defaults to false. This configuration will lock the selection model that
 the DataView uses.]]></description><name>disableSelection</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to false.]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class to add when the Component is disabled. Defaults to 'x-item-disabled'.]]></description><name>disabledCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Allows the component to be dragged via the touch event.]]></description><name>draggable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The text to display in the view when there is no data to display (defaults to '').]]></description><name>emptyText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Create the Component as a floating and use absolute positioning. Defaults to false.]]></description><name>floating</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The class that is being added to this component when its floating. (defaults to x-floating)]]></description><name>floatingCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Force the component to take up 100% width and height available. Defaults to false. Setting this configuration
 immediately sets the monitorOrientation config to true. Setting this to true will render the component instantly.]]></description><name>fullscreen</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to group the list items together (defaults to false). When using grouping, you must specify a method getGroupString
 on the store so that grouping can be maintained. Ext.regModel('Contact', {
     fields: ['firstName',
 'lastName']
 });
 
 var store = new Ext.data.JsonStore({
     model  : 'Contact',
     sorters: 'lastName',
 
    
 getGroupString : function(record) {
         // Group by the last name
         return record.get('lastName')[0];
     },
 
 
 data: [
         {firstName: 'Tommy',   lastName: 'Maintz'},
         {firstName: 'Rob',     lastName: 'Dougan'},
        
 {firstName: 'Ed',      lastName: 'Spencer'},
         {firstName: 'Jamie',   lastName: 'Avins'},
         {firstName:
 'Aaron',   lastName: 'Conran'},
         {firstName: 'Dave',    lastName: 'Kaneda'},
         {firstName: 'Michael',
 lastName: 'Mullany'},
         {firstName: 'Abraham', lastName: 'Elias'},
         {firstName: 'Jay',     lastName:
 'Robinson'},
         {firstName: 'Tommy',   lastName: 'Maintz'},
         {firstName: 'Rob',     lastName: 'Dougan'},
    
 {firstName: 'Ed',      lastName: 'Spencer'},
         {firstName: 'Jamie',   lastName: 'Avins'},
         {firstName:
 'Aaron',   lastName: 'Conran'},
         {firstName: 'Dave',    lastName: 'Kaneda'},
         {firstName: 'Michael',
 lastName: 'Mullany'},
         {firstName: 'Abraham', lastName: 'Elias'},
         {firstName: 'Jay',     lastName:
 'Robinson'}
     ]
 });]]></description><name>grouped</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of this component in pixels.]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to false.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically bind a tap listener to the mask that hides the window. Defaults to true. Note: if you set this
 property to false you have to programmaticaly hide the overlay.]]></description><name>hideOnMaskTap</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to render an alphabet IndexBar docked on the right. This can also be a config object that will be passed to
 Ext.IndexBar (defaults to false)]]></description><name>indexBar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An additional class that will be added to each item in the List. Defaults to ''.]]></description><name>itemCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>itemSelector</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The inner portion of the item template to be rendered. Follows an XTemplate structure and will be placed inside of a tpl
 for in the tpl configuration.]]></description><name>itemTpl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Set this to true to automatically relayout this component on orientation change. This property is set to true by default
 if a component is floating unless you specifically set this to false. Also note that you dont have to set this property
 to true if this component is a child of a fullscreen container, since fullscreen components are also laid out
 automatically on orientation change. Defaults to null]]></description><name>layoutOnOrientationChange</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A config object containing one or more event handlers to be added to this object during initialization. This should be a
 valid listeners config object as specified in the addListener example for attaching multiple handlers at once. DOM
 events from ExtJs Components While some ExtJs Component classes export selected DOM events (e.g. "click", "mouseover"
 etc), this is usually only done when extra value can be added. For example the DataView's click event passing the node
 clicked on. To access DOM events directly from a child element of a Component, we need to specify the element option to
 identify the Component property to add a DOM listener to: new Ext.Panel({
     width: 400,
     height: 200,
    
 dockedItems: [{
         xtype: 'toolbar'
     }],
     listeners: {
         click: {
             element: 'el', //bind to
 the underlying el property on the panel
             fn: function(){ console.log('click el'); }
         },
        
 dblclick: {
             element: 'body', //bind to the underlying body property on the panel
             fn: function(){
 console.log('dblclick body'); }
         }
     }
 });]]></description><name>listeners</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A string to display during data load operations (defaults to undefined). If specified, this text will be displayed in a
 loading div and the view's contents will be cleared while loading, otherwise the view's contents will continue to
 display normally until the new data is loaded and the contents are replaced.]]></description><name>loadingText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the margin for this component. The margin can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>margin</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this Component will set its height to. Warning: This will override any size management
 applied by layout managers.]]></description><name>maxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this Component will set its width to. Warning: This will override any size management
 applied by layout managers.]]></description><name>maxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this Component will set its height to. Warning: This will override any size management
 applied by layout managers.]]></description><name>minHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this Component will set its width to. Warning: This will override any size management
 applied by layout managers.]]></description><name>minWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to make the Component modal and mask everything behind it when displayed, false to display it without restricting
 access to other UI elements (defaults to false).]]></description><name>modal</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Monitor Orientation change]]></description><name>monitorOrientation</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to allow selection of more than one item at a time, false to allow selection of only a single item at a time or no
 selection at all, depending on the value of singleSelect (defaults to false).]]></description><name>multiSelect</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to display a disclosure icon on each list item. This won't bind a listener to the tap event. The list will still
 fire the disclose event though. By setting this config to a function, it will automatically add a tap event listeners to
 the disclosure buttons which will fire your function. Finally you can specify an object with a 'scope' and 'handler'
 property defined. This will also be bound to the tap event listener and is useful when you want to change the scope of
 the handler.]]></description><name>onItemDisclosure</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS class to apply to each item in the view on mouseover (defaults to undefined).]]></description><name>overItemCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the padding for this component. The padding can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>padding</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Whether or not to pin headers on top of item groups while scrolling for an iPhone native list experience. Defaults to
 false on Android and Blackberry (for performance reasons) Defaults to true on other devices.]]></description><name>pinHeaders</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS class to apply to an item on the view while it is being pressed (defaults to 'x-item-pressed').]]></description><name>pressedCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The amount of delay between the tapstart and the moment we add the pressedCls. Settings this to true defaults to 100ms]]></description><name>pressedDelay</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to prevent the item selection when the user taps a disclose icon. Defaults to true]]></description><name>preventSelectionOnDisclose</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object containing properties specifying DomQuery selectors which identify child elements created by the render
 process. After the Component's internal structure is rendered according to the renderTpl, this object is iterated
 through, and the found Elements are added as properties to the Component using the renderSelector property name. For
 example, a Component which rendered an image, and description into its element might use the following properties coded
 into its prototype: renderTpl: '"{imageUrl}" class="x-image-component-img">
 "x-image-component-desc">{description}',
 
 renderSelectors: {
     image: 'img.x-image-component-img',
     descEl:
 'div.x-image-component-desc'
 } After rendering, the Component would have a property image referencing its child img
 Element, and a property descEl referencing the div Element which contains the description.]]></description><name>renderSelectors</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An XTemplate used to create the internal structure inside this Component's encapsulating Element. You do not normally
 need to specify this. For the base classes Ext.Component and Ext.Container, this defaults to null which means that they
 will be initially rendered with no internal structure; they render their Element empty. The more specialized ExtJS and
 Touch classes which use a more complex DOM structure, provide their own template definitions. This is intended to allow
 the developer to create application-specific utility Components with customized internal structure. Upon rendering, any
 created child elements may be automatically imported into object properties using the renderSelectors option.]]></description><name>renderTpl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Configure the component to be scrollable. Acceptable values are: 'horizontal', 'vertical', 'both' to enabling scrolling
 for that direction. A Scroller configuration. false to explicitly disable scrolling. Enabling scrolling immediately sets
 the monitorOrientation config to true (for Panel)]]></description><name>scroll</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS class to apply to each selected item in the view (defaults to 'x-view-selected').]]></description><name>selectedItemCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The type of animation you want to use when this component is shown. If you set this this hide animation will
 automatically be the opposite.]]></description><name>showAnimation</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to enable multiselection by clicking on multiple items without requiring the user to hold Shift or Ctrl, false to
 force the user to hold Ctrl or Shift to select more than on item (defaults to false).]]></description><name>simpleSelect</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to allow selection of exactly one item at a time, false to allow no selection at all (defaults to false). Note that
 if multiSelect = true, this value will be ignored.]]></description><name>singleSelect</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to stop the event that fires when you click outside the floating component. Defalts to true.]]></description><name>stopMaskTapEvent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>store</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
             title: 'Some Title',
             renderTo: Ext.getBody(),
          
 width: 400, height: 300,
             layout: 'form',
             items: [{
                 xtype: 'textareafield',
      
 style: {
                     width: '95%',
                     marginBottom: '10px'
                 }
             },
    
 new Ext.Button({
                 text: 'Send',
                 minWidth: '100',
                 style: {
                
     marginBottom: '10px'
                 }
             })
             ]
         });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The class that is added to the content target when you set styleHtmlContent to true. Defaults to 'x-html']]></description><name>styleHtmlCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically style the html inside the content target of this component (body for panels). Defaults to false.]]></description><name>styleHtmlContent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>tpl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to enable mouseenter and mouseleave events]]></description><name>trackOver</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to 'singletap'. Other valid options are 'tap']]></description><name>triggerEvent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A set of predefined ui styles for individual components. Most components support 'light' and 'dark'. Extra string added
 to the baseCls with an extra '-'. 
 <pre><code>
 new Ext.Panel({
     title: 'Some Title',
     baseCls: 'x-component'
     ui: 'green'
 });</pre></code>
 The ui configuration in this example would add 'x-component-green' as an additional class.]]></description><name>ui</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of this component in pixels.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original SenchaTouch API docs:
 <a href="http://docs.sencha.com/touch/">http://docs.sencha.com/touch/</a>

 <p>Wraps a Google Map in an Ext.Component.<br /> http://code.google.com/apis/maps/documentation/v3/introduction.html</p>
 
 <p>To use this component you must include an additional JavaScript file from Google:</p> 
 <pre><code>&lt;script
 type=<em>&quot;text/javascript&quot;</em>
 src=<em>&quot;http://maps.google.com/maps/api/js?sensor=true&quot;</em>&gt;&lt;/script&gt;</code></pre>
 
 <h2>Screenshot:</h2> 
 <p><img src="doc_resources/Ext.Map/screenshot.png" /></p> 
 <h2>Example code:</h2>
 
 <pre><code><b>var</b> pnl = <b>new</b> Ext.Panel({
     fullscreen: true,
     items     : [
         {
             xtype 
            : <em>'map'</em>,
             useCurrentLocation: true
         }
     ]
 });</code></pre>]]></description><name>map</name><tag-class>org.brushingbits.jnap.ui.senchatouch.Map</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[The base CSS class to apply to the Maps's element (defaults to 'x-map').]]></description><name>baseCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the border for this component. The border can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>border</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Center the Component. Defaults to false.]]></description><name>centered</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element (defaults to ''). This can be useful for
 adding customized styles to the component or any of its children using standard CSS rules.]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS Class to be added to a components root level element to give distinction to it via styling.]]></description><name>componentCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The sizing and positioning of the component Elements is the responsibility of the Component's layout manager which
 creates and manages the type of layout specific to the component. If the layout configuration is not explicitly
 specified for a general purpose compopnent the default layout manager will be used.]]></description><name>componentLayout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to false.]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class to add when the Component is disabled. Defaults to 'x-item-disabled'.]]></description><name>disabledCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Allows the component to be dragged via the touch event.]]></description><name>draggable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Create the Component as a floating and use absolute positioning. Defaults to false.]]></description><name>floating</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The class that is being added to this component when its floating. (defaults to x-floating)]]></description><name>floatingCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Force the component to take up 100% width and height available. Defaults to false. Setting this configuration
 immediately sets the monitorOrientation config to true. Setting this to true will render the component instantly.]]></description><name>fullscreen</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of this component in pixels.]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to false.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically bind a tap listener to the mask that hides the window. Defaults to true. Note: if you set this
 property to false you have to programmaticaly hide the overlay.]]></description><name>hideOnMaskTap</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Set this to true to automatically relayout this component on orientation change. This property is set to true by default
 if a component is floating unless you specifically set this to false. Also note that you dont have to set this property
 to true if this component is a child of a fullscreen container, since fullscreen components are also laid out
 automatically on orientation change. Defaults to null]]></description><name>layoutOnOrientationChange</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A config object containing one or more event handlers to be added to this object during initialization. This should be a
 valid listeners config object as specified in the addListener example for attaching multiple handlers at once. DOM
 events from ExtJs Components While some ExtJs Component classes export selected DOM events (e.g. "click", "mouseover"
 etc), this is usually only done when extra value can be added. For example the DataView's click event passing the node
 clicked on. To access DOM events directly from a child element of a Component, we need to specify the element option to
 identify the Component property to add a DOM listener to: new Ext.Panel({
     width: 400,
     height: 200,
    
 dockedItems: [{
         xtype: 'toolbar'
     }],
     listeners: {
         click: {
             element: 'el', //bind to
 the underlying el property on the panel
             fn: function(){ console.log('click el'); }
         },
        
 dblclick: {
             element: 'body', //bind to the underlying body property on the panel
             fn: function(){
 console.log('dblclick body'); }
         }
     }
 });]]></description><name>listeners</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[MapOptions as specified by the Google Documentation: http://code.google.com/apis/maps/documentation/v3/reference.html]]></description><name>mapOptions</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the margin for this component. The margin can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>margin</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Masks the map (Defaults to false)]]></description><name>maskMap</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class to add to the map when maskMap is set to true.]]></description><name>maskMapCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this Component will set its height to. Warning: This will override any size management
 applied by layout managers.]]></description><name>maxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this Component will set its width to. Warning: This will override any size management
 applied by layout managers.]]></description><name>maxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this Component will set its height to. Warning: This will override any size management
 applied by layout managers.]]></description><name>minHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this Component will set its width to. Warning: This will override any size management
 applied by layout managers.]]></description><name>minWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to make the Component modal and mask everything behind it when displayed, false to display it without restricting
 access to other UI elements (defaults to false).]]></description><name>modal</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Monitor Orientation change]]></description><name>monitorOrientation</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the padding for this component. The padding can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>padding</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object containing properties specifying DomQuery selectors which identify child elements created by the render
 process. After the Component's internal structure is rendered according to the renderTpl, this object is iterated
 through, and the found Elements are added as properties to the Component using the renderSelector property name. For
 example, a Component which rendered an image, and description into its element might use the following properties coded
 into its prototype: renderTpl: '"{imageUrl}" class="x-image-component-img">
 "x-image-component-desc">{description}',
 
 renderSelectors: {
     image: 'img.x-image-component-img',
     descEl:
 'div.x-image-component-desc'
 } After rendering, the Component would have a property image referencing its child img
 Element, and a property descEl referencing the div Element which contains the description.]]></description><name>renderSelectors</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An XTemplate used to create the internal structure inside this Component's encapsulating Element. You do not normally
 need to specify this. For the base classes Ext.Component and Ext.Container, this defaults to null which means that they
 will be initially rendered with no internal structure; they render their Element empty. The more specialized ExtJS and
 Touch classes which use a more complex DOM structure, provide their own template definitions. This is intended to allow
 the developer to create application-specific utility Components with customized internal structure. Upon rendering, any
 created child elements may be automatically imported into object properties using the renderSelectors option.]]></description><name>renderTpl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Configure the component to be scrollable. Acceptable values are: 'horizontal', 'vertical', 'both' to enabling scrolling
 for that direction. A Scroller configuration. false to explicitly disable scrolling. Enabling scrolling immediately sets
 the monitorOrientation config to true (for Panel)]]></description><name>scroll</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The type of animation you want to use when this component is shown. If you set this this hide animation will
 automatically be the opposite.]]></description><name>showAnimation</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to stop the event that fires when you click outside the floating component. Defalts to true.]]></description><name>stopMaskTapEvent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
             title: 'Some Title',
             renderTo: Ext.getBody(),
          
 width: 400, height: 300,
             layout: 'form',
             items: [{
                 xtype: 'textareafield',
      
 style: {
                     width: '95%',
                     marginBottom: '10px'
                 }
             },
    
 new Ext.Button({
                 text: 'Send',
                 minWidth: '100',
                 style: {
                
     marginBottom: '10px'
                 }
             })
             ]
         });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The class that is added to the content target when you set styleHtmlContent to true. Defaults to 'x-html']]></description><name>styleHtmlCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically style the html inside the content target of this component (body for panels). Defaults to false.]]></description><name>styleHtmlContent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An Ext.Template, Ext.XTemplate or an array of strings to form an Ext.XTemplate. Used in conjunction with the data and
 tplWriteMode configurations.]]></description><name>tpl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A set of predefined ui styles for individual components. Most components support 'light' and 'dark'. Extra string added
 to the baseCls with an extra '-'. 
 <pre><code>
 new Ext.Panel({
     title: 'Some Title',
     baseCls: 'x-component'
     ui: 'green'
 });</pre></code>
 The ui configuration in this example would add 'x-component-green' as an additional class.]]></description><name>ui</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Pass in true to center the map based on the geolocation coordinates.]]></description><name>useCurrentLocation</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of this component in pixels.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original SenchaTouch API docs:
 <a href="http://docs.sencha.com/touch/">http://docs.sencha.com/touch/</a>

 <p>Provides a base class for audio/visual controls. Should not be used directly.</p>]]></description><name>media</name><tag-class>org.brushingbits.jnap.ui.senchatouch.Media</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[A string component id or the numeric index of the component that should be initially activated within the container's
 layout on render. For example, activeItem: 'item-1' or activeItem: 0 (index 0 = the first item in the container's
 collection). activeItem only applies to layout styles that can display items one at a time (like Ext.layout.CardLayout
 and Ext.layout.FitLayout). Related to Ext.layout.ContainerLayout.activeItem.]]></description><name>activeItem</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If true the container will automatically destroy any contained component that is removed from it, else destruction must
 be handled manually (defaults to true).]]></description><name>autoDestroy</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Will automatically pause the media when the container is deactivated. (Defaults to true)]]></description><name>autoPause</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Will automatically start playing the media when the container is activated. (Defaults to false)]]></description><name>autoResume</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The base CSS class to apply to this components's element. This will also be prepended to elements within this component
 like Panel's body will get a class x-panel-body. This means that if you create a subclass of Panel, and you want it to
 get all the Panels styling for the element and the body, you leave the baseCls x-panel and use componentCls to add
 specific styling for this component.]]></description><name>baseCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the border for this component. The border can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>border</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to ['add', 'remove'].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Animation to be used during transitions of cards. Note this only works when this container has a CardLayout. Any valid
 value from Ext.anims can be used ('fade', 'slide', 'flip', 'cube', 'pop', 'wipe'). Defaults to null.]]></description><name>cardSwitchAnimation</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element (defaults to ''). This can be useful for
 adding customized styles to the component or any of its children using standard CSS rules.]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS Class to be added to a components root level element to give distinction to it via styling.]]></description><name>componentCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The sizing and positioning of the component Elements is the responsibility of the Component's layout manager which
 creates and manages the type of layout specific to the component. If the layout configuration is not explicitly
 specified for a general purpose compopnent the default layout manager will be used.]]></description><name>componentLayout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default xtype of child Components to create in this Container when a child item is specified as a raw configuration
 object, rather than as an instantiated Component. Defaults to 'panel'.]]></description><name>defaultType</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[This option is a means of applying default settings to all added items whether added through the items config or via the
 add or insert methods. If an added item is a config object, and not an instantiated Component, then the default
 properties are unconditionally applied. If the added item is an instantiated Component, then the default properties are
 applied conditionally so as not to override existing properties in the item. If the defaults option is specified as a
 function, then the function will be called using this Container as the scope (this reference) and passing the added item
 as the first parameter. Any resulting object from that call is then applied to the item as default properties. For
 example, to automatically apply padding to the body of each of a set of contained Ext.Panel items, you could pass:
 defaults: {bodyStyle:'padding:15px'}. Usage: defaults: {               // defaults are applied to items, not the
 container
     autoScroll:true
 },
 items: [
     {
         xtype: 'panel',   // defaults do not have precedence over
       
 id: 'panel1',     // options in config objects, so the defaults
         autoScroll: false // will not be applied here,
 panel1 will be autoScroll:false
     },
     new Ext.Panel({       // defaults do have precedence over options
         id:
 'panel2',     // options in components, so the defaults
         autoScroll: false // will be applied here, panel2 will
 be autoScroll:true.
     })
 ]]]></description><name>defaults</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to false.]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class to add when the Component is disabled. Defaults to 'x-item-disabled'.]]></description><name>disabledCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Allows the component to be dragged via the touch event.]]></description><name>draggable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Set this to false to turn off the native media controls (Defaults to true).]]></description><name>enableControls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Create the Component as a floating and use absolute positioning. Defaults to false.]]></description><name>floating</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of this component in pixels.]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to false.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[** IMPORTANT: be sure to specify a layout if needed ! ** A single item, or an array of child Components to be added to
 this container, for example: // specifying a single item
 items: {...},
 layout: 'fit',    // specify a layout!
 
 //
 specifying multiple items
 items: [{...}, {...}],
 layout: 'hbox', // specify a layout! Each item may be: any type of
 object based on Ext.Component a fully instanciated object or an object literal that: has a specified xtype the
 Ext.Component.xtype specified is associated with the Component desired and should be chosen from one of the available
 xtypes as listed in Ext.Component. If an xtype is not explicitly specified, the defaultType for that Container is used.
 will be "lazily instanciated", avoiding the overhead of constructing a fully instanciated Component object Notes: Ext
 uses lazy rendering. Child Components will only be rendered should it become necessary. Items are automatically laid out
 when they are first shown (no sizing is done while hidden), or in response to a doLayout call. Do not specify contentEl/
 html with items.]]></description><name>items</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[*Important: In order for child items to be correctly sized and positioned, typically a layout manager must be specified
 through the layout configuration option. The sizing and positioning of child items is the responsibility of the
 Container's layout manager which creates and manages the type of layout you have in mind. For example: If the layout
 configuration is not explicitly specified for a general purpose container (e.g. Container or Panel) the default layout
 manager will be used which does nothing but render child components sequentially into the Container (no sizing or
 positioning will be performed in this situation). layout may be specified as either as an Object or as a String: Specify
 as an Object Example usage: layout: {
     type: 'vbox',
     align: 'left'
 } type The layout type to be used for this
 container. If not specified, a default Ext.layout.ContainerLayout will be created and used. Valid layout type values
 are:
 auto - Default card fit hbox vbox Layout specific configuration properties Additional layout specific
 configuration properties may also be specified. For complete details regarding the valid config options for each layout
 type, see the layout class corresponding to the type specified. Specify as a String Example usage: layout: {
     type:
 'vbox',
     padding: '5',
     align: 'left'
 } layout The layout type to be used for this container (see list of valid
 layout type values above). Additional layout specific configuration properties. For complete details regarding the valid
 config options for each layout type, see the layout class corresponding to the layout specified.]]></description><name>layout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A config object containing one or more event handlers to be added to this object during initialization. This should be a
 valid listeners config object as specified in the addListener example for attaching multiple handlers at once. DOM
 events from ExtJs Components While some ExtJs Component classes export selected DOM events (e.g. "click", "mouseover"
 etc), this is usually only done when extra value can be added. For example the DataView's click event passing the node
 clicked on. To access DOM events directly from a child element of a Component, we need to specify the element option to
 identify the Component property to add a DOM listener to: new Ext.Panel({
     width: 400,
     height: 200,
    
 dockedItems: [{
         xtype: 'toolbar'
     }],
     listeners: {
         click: {
             element: 'el', //bind to
 the underlying el property on the panel
             fn: function(){ console.log('click el'); }
         },
        
 dblclick: {
             element: 'body', //bind to the underlying body property on the panel
             fn: function(){
 console.log('dblclick body'); }
         }
     }
 });]]></description><name>listeners</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the margin for this component. The margin can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>margin</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this Component will set its height to. Warning: This will override any size management
 applied by layout managers.]]></description><name>maxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this Component will set its width to. Warning: This will override any size management
 applied by layout managers.]]></description><name>maxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this Component will set its height to. Warning: This will override any size management
 applied by layout managers.]]></description><name>minHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this Component will set its width to. Warning: This will override any size management
 applied by layout managers.]]></description><name>minWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the padding for this component. The padding can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>padding</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Will begin preloading the media immediately. (Defaults to true)]]></description><name>preload</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object containing properties specifying DomQuery selectors which identify child elements created by the render
 process. After the Component's internal structure is rendered according to the renderTpl, this object is iterated
 through, and the found Elements are added as properties to the Component using the renderSelector property name. For
 example, a Component which rendered an image, and description into its element might use the following properties coded
 into its prototype: renderTpl: '"{imageUrl}" class="x-image-component-img">
 "x-image-component-desc">{description}',
 
 renderSelectors: {
     image: 'img.x-image-component-img',
     descEl:
 'div.x-image-component-desc'
 } After rendering, the Component would have a property image referencing its child img
 Element, and a property descEl referencing the div Element which contains the description.]]></description><name>renderSelectors</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An XTemplate used to create the internal structure inside this Component's encapsulating Element. You do not normally
 need to specify this. For the base classes Ext.Component and Ext.Container, this defaults to null which means that they
 will be initially rendered with no internal structure; they render their Element empty. The more specialized ExtJS and
 Touch classes which use a more complex DOM structure, provide their own template definitions. This is intended to allow
 the developer to create application-specific utility Components with customized internal structure. Upon rendering, any
 created child elements may be automatically imported into object properties using the renderSelectors option.]]></description><name>renderTpl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
             title: 'Some Title',
             renderTo: Ext.getBody(),
          
 width: 400, height: 300,
             layout: 'form',
             items: [{
                 xtype: 'textareafield',
      
 style: {
                     width: '95%',
                     marginBottom: '10px'
                 }
             },
    
 new Ext.Button({
                 text: 'Send',
                 minWidth: '100',
                 style: {
                
     marginBottom: '10px'
                 }
             })
             ]
         });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The class that is added to the content target when you set styleHtmlContent to true. Defaults to 'x-html']]></description><name>styleHtmlCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically style the html inside the content target of this component (body for panels). Defaults to false.]]></description><name>styleHtmlContent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An Ext.Template, Ext.XTemplate or an array of strings to form an Ext.XTemplate. Used in conjunction with the data and
 tplWriteMode configurations.]]></description><name>tpl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A set of predefined ui styles for individual components. Most components support 'light' and 'dark'. Extra string added
 to the baseCls with an extra '-'. 
 <pre><code>
 new Ext.Panel({
     title: 'Some Title',
     baseCls: 'x-component'
     ui: 'green'
 });</pre></code>
 The ui configuration in this example would add 'x-component-green' as an additional class.]]></description><name>ui</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Location of the media to play.]]></description><name>url</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of this component in pixels.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original SenchaTouch API docs:
 <a href="http://docs.sencha.com/touch/">http://docs.sencha.com/touch/</a>

 <p>Utility class for generating different styles of message boxes. The framework provides a global singleton <a
 href="output/Ext.Msg.html" ext:cls="Ext.Msg">Ext.Msg</a> for common usage.</p>
 <p> </p>
 <p>Note that the MessageBox is
 asynchronous. Unlike a regular JavaScript <code>alert</code> (which will halt browser execution), showing a MessageBox
 will not cause the code to stop. For this reason, if you have code that should only run <em>after</em> some user
 feedback from the MessageBox, you must use a callback function (see the <code>fn</code> configuration option parameter
 for the <a href="output/Ext.MessageBox.html#Ext.MessageBox-show" ext:member="show" ext:cls="Ext.MessageBox">show</a>
 method for more details).</p> 
 <h2>Screenshot</h2> 
 <p><img src="doc_resources/Ext.MessageBox/screenshot.png" /></p>
 
 <h2>Example usage:</h2> 
 <pre><code><i>// Basic alert:</i>
 Ext.Msg.alert(<em>'Title'</em>, <em>'The quick brown fox
 jumped over the lazy dog.'</em>, Ext.emptyFn);
 
 <i>// Prompt <b>for</b> user data and process the result using a
 callback:</i>
 Ext.Msg.prompt(<em>'Name'</em>, <em>'Please enter your name:'</em>, <b>function</b>(text) {
     <i>//
 process text value and close...</i>
 });
 
 <i>// Confirmation alert</i>
 Ext.Msg.confirm(<em>&quot;Confirmation&quot;</em>,
 <em>&quot;Are you sure you want to <b>do</b> that?&quot;</em>, Ext.emptyFn);</code></pre>]]></description><name>messageBox</name><tag-class>org.brushingbits.jnap.ui.senchatouch.MessageBox</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[A string component id or the numeric index of the component that should be initially activated within the container's
 layout on render. For example, activeItem: 'item-1' or activeItem: 0 (index 0 = the first item in the container's
 collection). activeItem only applies to layout styles that can display items one at a time (like Ext.layout.CardLayout
 and Ext.layout.FitLayout). Related to Ext.layout.ContainerLayout.activeItem.]]></description><name>activeItem</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If true the container will automatically destroy any contained component that is removed from it, else destruction must
 be handled manually (defaults to true).]]></description><name>autoDestroy</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The base CSS class to apply to this panel's element (defaults to 'x-panel').]]></description><name>baseCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A shortcut for setting a border style on the body element. The value can either be a number to be applied to all sides,
 or a normal css string describing borders. Defaults to undefined.]]></description><name>bodyBorder</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A shortcut for setting a margin style on the body element. The value can either be a number to be applied to all sides,
 or a normal css string describing margins. Defaults to undefined.]]></description><name>bodyMargin</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A shortcut for setting a padding style on the body element. The value can either be a number to be applied to all sides,
 or a normal css string describing padding. Defaults to undefined.]]></description><name>bodyPadding</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the border for this component. The border can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>border</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to ['add', 'remove'].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element (defaults to ''). This can be useful for
 adding customized styles to the component or any of its children using standard CSS rules.]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Component's Base CSS class]]></description><name>componentCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The sizing and positioning of the component Elements is the responsibility of the Component's layout manager which
 creates and manages the type of layout specific to the component. If the layout configuration is not explicitly
 specified for a general purpose compopnent the default layout manager will be used.]]></description><name>componentLayout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>defaultTextHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default xtype of child Components to create in this Container when a child item is specified as a raw configuration
 object, rather than as an instantiated Component. Defaults to 'panel'.]]></description><name>defaultType</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[This option is a means of applying default settings to all added items whether added through the items config or via the
 add or insert methods. If an added item is a config object, and not an instantiated Component, then the default
 properties are unconditionally applied. If the added item is an instantiated Component, then the default properties are
 applied conditionally so as not to override existing properties in the item. If the defaults option is specified as a
 function, then the function will be called using this Container as the scope (this reference) and passing the added item
 as the first parameter. Any resulting object from that call is then applied to the item as default properties. For
 example, to automatically apply padding to the body of each of a set of contained Ext.Panel items, you could pass:
 defaults: {bodyStyle:'padding:15px'}. Usage: defaults: {               // defaults are applied to items, not the
 container
     autoScroll:true
 },
 items: [
     {
         xtype: 'panel',   // defaults do not have precedence over
       
 id: 'panel1',     // options in config objects, so the defaults
         autoScroll: false // will not be applied here,
 panel1 will be autoScroll:false
     },
     new Ext.Panel({       // defaults do have precedence over options
         id:
 'panel2',     // options in components, so the defaults
         autoScroll: false // will be applied here, panel2 will
 be autoScroll:true.
     })
 ]]]></description><name>defaults</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to false.]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class to add when the Component is disabled. Defaults to 'x-item-disabled'.]]></description><name>disabledCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A component or series of components to be added as docked items to this panel. The docked items can be docked to either
 the top, right, left or bottom of a panel. This is typically used for things like toolbars or tab bars: var panel = new
 Ext.Panel({
     fullscreen: true,
     dockedItems: [{
         xtype: 'toolbar',
         dock: 'top',
         items: [{
  
           text: 'Docked to the bottom'
         }]
     }]
 });]]></description><name>dockedItems</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Allows the component to be dragged via the touch event.]]></description><name>draggable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The viewport side from which to anchor the sheet when made visible (top, bottom, left, right) Defaults to 'bottom']]></description><name>enter</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[effect when the message box is being displayed (defaults to 'pop')]]></description><name>enterAnimation</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The viewport side used as the exit point when hidden (top, bottom, left, right) Applies to sliding animation effects
 only. Defaults to 'bottom']]></description><name>exit</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[effect when the message box is being hidden (defaults to 'pop')]]></description><name>exitAnimation</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Create the Component as a floating and use absolute positioning. Defaults to false.]]></description><name>floating</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of this component in pixels.]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to false.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically bind a tap listener to the mask that hides the window. Defaults to false. Note: if you don't set
 this property to false you have to programmaticaly hide the overlay.]]></description><name>hideOnMaskTap</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[** IMPORTANT: be sure to specify a layout if needed ! ** A single item, or an array of child Components to be added to
 this container, for example: // specifying a single item
 items: {...},
 layout: 'fit',    // specify a layout!
 
 //
 specifying multiple items
 items: [{...}, {...}],
 layout: 'hbox', // specify a layout! Each item may be: any type of
 object based on Ext.Component a fully instanciated object or an object literal that: has a specified xtype the
 Ext.Component.xtype specified is associated with the Component desired and should be chosen from one of the available
 xtypes as listed in Ext.Component. If an xtype is not explicitly specified, the defaultType for that Container is used.
 will be "lazily instanciated", avoiding the overhead of constructing a fully instanciated Component object Notes: Ext
 uses lazy rendering. Child Components will only be rendered should it become necessary. Items are automatically laid out
 when they are first shown (no sizing is done while hidden), or in response to a doLayout call. Do not specify contentEl/
 html with items.]]></description><name>items</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[*Important: In order for child items to be correctly sized and positioned, typically a layout manager must be specified
 through the layout configuration option. The sizing and positioning of child items is the responsibility of the
 Container's layout manager which creates and manages the type of layout you have in mind. For example: If the layout
 configuration is not explicitly specified for a general purpose container (e.g. Container or Panel) the default layout
 manager will be used which does nothing but render child components sequentially into the Container (no sizing or
 positioning will be performed in this situation). layout may be specified as either as an Object or as a String: Specify
 as an Object Example usage: layout: {
     type: 'vbox',
     align: 'left'
 } type The layout type to be used for this
 container. If not specified, a default Ext.layout.ContainerLayout will be created and used. Valid layout type values
 are:
 auto - Default card fit hbox vbox Layout specific configuration properties Additional layout specific
 configuration properties may also be specified. For complete details regarding the valid config options for each layout
 type, see the layout class corresponding to the type specified. Specify as a String Example usage: layout: {
     type:
 'vbox',
     padding: '5',
     align: 'left'
 } layout The layout type to be used for this container (see list of valid
 layout type values above). Additional layout specific configuration properties. For complete details regarding the valid
 config options for each layout type, see the layout class corresponding to the layout specified.]]></description><name>layout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A config object containing one or more event handlers to be added to this object during initialization. This should be a
 valid listeners config object as specified in the addListener example for attaching multiple handlers at once. DOM
 events from ExtJs Components While some ExtJs Component classes export selected DOM events (e.g. "click", "mouseover"
 etc), this is usually only done when extra value can be added. For example the DataView's click event passing the node
 clicked on. To access DOM events directly from a child element of a Component, we need to specify the element option to
 identify the Component property to add a DOM listener to: new Ext.Panel({
     width: 400,
     height: 200,
    
 dockedItems: [{
         xtype: 'toolbar'
     }],
     listeners: {
         click: {
             element: 'el', //bind to
 the underlying el property on the panel
             fn: function(){ console.log('click el'); }
         },
        
 dblclick: {
             element: 'body', //bind to the underlying body property on the panel
             fn: function(){
 console.log('dblclick body'); }
         }
     }
 });]]></description><name>listeners</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the margin for this component. The margin can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>margin</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this Component will set its height to. Warning: This will override any size management
 applied by layout managers.]]></description><name>maxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this Component will set its width to. Warning: This will override any size management
 applied by layout managers.]]></description><name>maxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this Component will set its height to. Warning: This will override any size management
 applied by layout managers.]]></description><name>minHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this Component will set its width to. Warning: This will override any size management
 applied by layout managers.]]></description><name>minWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the padding for this component. The padding can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>padding</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object containing properties specifying DomQuery selectors which identify child elements created by the render
 process. After the Component's internal structure is rendered according to the renderTpl, this object is iterated
 through, and the found Elements are added as properties to the Component using the renderSelector property name. For
 example, a Component which rendered an image, and description into its element might use the following properties coded
 into its prototype: renderTpl: '"{imageUrl}" class="x-image-component-img">
 "x-image-component-desc">{description}',
 
 renderSelectors: {
     image: 'img.x-image-component-img',
     descEl:
 'div.x-image-component-desc'
 } After rendering, the Component would have a property image referencing its child img
 Element, and a property descEl referencing the div Element which contains the description.]]></description><name>renderSelectors</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An XTemplate used to create the internal structure inside this Component's encapsulating Element. You do not normally
 need to specify this. For the base classes Ext.Component and Ext.Container, this defaults to null which means that they
 will be initially rendered with no internal structure; they render their Element empty. The more specialized ExtJS and
 Touch classes which use a more complex DOM structure, provide their own template definitions. This is intended to allow
 the developer to create application-specific utility Components with customized internal structure. Upon rendering, any
 created child elements may be automatically imported into object properties using the renderSelectors option.]]></description><name>renderTpl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If true, the width of anchored Sheets are adjusted to fill the entire top/bottom axis width, or false to center the
 Sheet along the same axis based upon the sheets current/calculated width. This option is ignored when {link #centered}
 is true or x/y coordinates are specified for the Sheet.]]></description><name>stretchX</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If true, the height of anchored Sheets are adjusted to fill the entire right/left axis height, or false to center the
 Sheet along the same axis based upon the sheets current/calculated height. This option is ignored when {link #centered}
 is true or x/y coordinates are specified for the Sheet.]]></description><name>stretchY</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
             title: 'Some Title',
             renderTo: Ext.getBody(),
          
 width: 400, height: 300,
             layout: 'form',
             items: [{
                 xtype: 'textareafield',
      
 style: {
                     width: '95%',
                     marginBottom: '10px'
                 }
             },
    
 new Ext.Button({
                 text: 'Send',
                 minWidth: '100',
                 style: {
                
     marginBottom: '10px'
                 }
             })
             ]
         });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The class that is added to the content target when you set styleHtmlContent to true. Defaults to 'x-html']]></description><name>styleHtmlCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically style the html inside the content target of this component (body for panels). Defaults to false.]]></description><name>styleHtmlContent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An Ext.Template, Ext.XTemplate or an array of strings to form an Ext.XTemplate. Used in conjunction with the data and
 tplWriteMode configurations.]]></description><name>tpl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A set of predefined ui styles for individual components. Most components support 'light' and 'dark'. Extra string added
 to the baseCls with an extra '-'. 
 <pre><code>
 new Ext.Panel({
     title: 'Some Title',
     baseCls: 'x-component'
     ui: 'green'
 });</pre></code>
 The ui configuration in this example would add 'x-component-green' as an additional class.]]></description><name>ui</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of this component in pixels.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original SenchaTouch API docs:
 <a href="http://docs.sencha.com/touch/">http://docs.sencha.com/touch/</a>

 <p>NestedList provides a miller column interface to navigate between nested sets and provide a clean interface with
 limited screen real-estate.</p> 
 <pre><code><i>// store <b>with</b> data</i>
 <b>var</b> data = {
     text:
 <em>'Groceries'</em>,
     items: [{
         text: <em>'Drinks'</em>,
         items: [{
             text:
 <em>'Water'</em>,
             items: [{
                 text: <em>'Sparkling'</em>,
                 leaf: true
          
 },{
                 text: <em>'Still'</em>,
                 leaf: true
             }]
         },{
             text:
 <em>'Coffee'</em>,
             leaf: true
         },{
             text: <em>'Espresso'</em>,
             leaf: true
     
 },{
             text: <em>'Redbull'</em>,
             leaf: true
         },{
             text: <em>'Coke'</em>,
         
 leaf: true
         },{
             text: <em>'Diet Coke'</em>,
             leaf: true
         }]
     },{
         text:
 <em>'Fruit'</em>,
         items: [{
             text: <em>'Bananas'</em>,
             leaf: true
         },{
            
 text: <em>'Lemon'</em>,
             leaf: true
         }]
     },{
         text: <em>'Snacks'</em>,
         items: [{
    
 text: <em>'Nuts'</em>,
             leaf: true
         },{
             text: <em>'Pretzels'</em>,
             leaf: true
 
 },{
             text: <em>'Wasabi Peas'</em>,
             leaf: true
         }]
     },{
         text: <em>'Empty
 Category'</em>,
         items: []
     }]
 };
 Ext.regModel(<em>'ListItem'</em>, {
     fields: [{name: <em>'text'</em>,
 type: <em>'string'</em>}]
 });
 <b>var</b> store = <b>new</b> Ext.data.TreeStore({
     model: <em>'ListItem'</em>,
    
 root: data,
     proxy: {
         type: <em>'ajax'</em>,
         reader: {
             type: <em>'tree'</em>,
            
 root: <em>'items'</em>
         }
     }
 });
 <b>var</b> nestedList = <b>new</b> Ext.NestedList({
     fullscreen: true,
    
 title: <em>'Groceries'</em>,
     displayField: <em>'text'</em>,
     store: store
 });</code></pre>]]></description><name>nestedList</name><tag-class>org.brushingbits.jnap.ui.senchatouch.NestedList</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[A string component id or the numeric index of the component that should be initially activated within the container's
 layout on render. For example, activeItem: 'item-1' or activeItem: 0 (index 0 = the first item in the container's
 collection). activeItem only applies to layout styles that can display items one at a time (like Ext.layout.CardLayout
 and Ext.layout.FitLayout). Related to Ext.layout.ContainerLayout.activeItem.]]></description><name>activeItem</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Set to true to alow the user to deselect leaf items via interaction. Defaults to false.]]></description><name>allowDeselect</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If true the container will automatically destroy any contained component that is removed from it, else destruction must
 be handled manually (defaults to true).]]></description><name>autoDestroy</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The label to display for the back button. Defaults to "Back".]]></description><name>backText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The base CSS class to apply to this panel's element (defaults to 'x-panel').]]></description><name>baseCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A shortcut for setting a border style on the body element. The value can either be a number to be applied to all sides,
 or a normal css string describing borders. Defaults to undefined.]]></description><name>bodyBorder</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A shortcut for setting a margin style on the body element. The value can either be a number to be applied to all sides,
 or a normal css string describing margins. Defaults to undefined.]]></description><name>bodyMargin</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A shortcut for setting a padding style on the body element. The value can either be a number to be applied to all sides,
 or a normal css string describing padding. Defaults to undefined.]]></description><name>bodyPadding</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the border for this component. The border can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>border</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to ['add', 'remove'].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Animation to be used during transitions of cards. Any valid value from Ext.anims can be used ('fade', 'slide', 'flip',
 'cube', 'pop', 'wipe'). Defaults to 'slide'.]]></description><name>cardSwitchAnimation</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Number of milliseconds to show the highlight when going back in a list. (Defaults to 200). Passing false will keep the
 prior list selection.]]></description><name>clearSelectionDelay</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element (defaults to ''). This can be useful for
 adding customized styles to the component or any of its children using standard CSS rules.]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS Class to be added to a components root level element to give distinction to it via styling.]]></description><name>componentCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The sizing and positioning of the component Elements is the responsibility of the Component's layout manager which
 creates and manages the type of layout specific to the component. If the layout configuration is not explicitly
 specified for a general purpose compopnent the default layout manager will be used.]]></description><name>componentLayout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default xtype of child Components to create in this Container when a child item is specified as a raw configuration
 object, rather than as an instantiated Component. Defaults to 'panel'.]]></description><name>defaultType</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[This option is a means of applying default settings to all added items whether added through the items config or via the
 add or insert methods. If an added item is a config object, and not an instantiated Component, then the default
 properties are unconditionally applied. If the added item is an instantiated Component, then the default properties are
 applied conditionally so as not to override existing properties in the item. If the defaults option is specified as a
 function, then the function will be called using this Container as the scope (this reference) and passing the added item
 as the first parameter. Any resulting object from that call is then applied to the item as default properties. For
 example, to automatically apply padding to the body of each of a set of contained Ext.Panel items, you could pass:
 defaults: {bodyStyle:'padding:15px'}. Usage: defaults: {               // defaults are applied to items, not the
 container
     autoScroll:true
 },
 items: [
     {
         xtype: 'panel',   // defaults do not have precedence over
       
 id: 'panel1',     // options in config objects, so the defaults
         autoScroll: false // will not be applied here,
 panel1 will be autoScroll:false
     },
     new Ext.Panel({       // defaults do have precedence over options
         id:
 'panel2',     // options in components, so the defaults
         autoScroll: false // will be applied here, panel2 will
 be autoScroll:true.
     })
 ]]]></description><name>defaults</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to false.]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class to add when the Component is disabled. Defaults to 'x-item-disabled'.]]></description><name>disabledCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Display field to use when setting item text and title. This configuration is ignored when overriding getItemTextTpl or
 getTitleTextTpl for the item text or title. (Defaults to 'text')]]></description><name>displayField</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A component or series of components to be added as docked items to this panel. The docked items can be docked to either
 the top, right, left or bottom of a panel. This is typically used for things like toolbars or tab bars: var panel = new
 Ext.Panel({
     fullscreen: true,
     dockedItems: [{
         xtype: 'toolbar',
         dock: 'top',
         items: [{
  
           text: 'Docked to the bottom'
         }]
     }]
 });]]></description><name>dockedItems</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Allows the component to be dragged via the touch event.]]></description><name>draggable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Empty text to display when a subtree is empty.]]></description><name>emptyText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Create the Component as a floating and use absolute positioning. Defaults to false.]]></description><name>floating</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of this component in pixels.]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to false.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[** IMPORTANT: be sure to specify a layout if needed ! ** A single item, or an array of child Components to be added to
 this container, for example: // specifying a single item
 items: {...},
 layout: 'fit',    // specify a layout!
 
 //
 specifying multiple items
 items: [{...}, {...}],
 layout: 'hbox', // specify a layout! Each item may be: any type of
 object based on Ext.Component a fully instanciated object or an object literal that: has a specified xtype the
 Ext.Component.xtype specified is associated with the Component desired and should be chosen from one of the available
 xtypes as listed in Ext.Component. If an xtype is not explicitly specified, the defaultType for that Container is used.
 will be "lazily instanciated", avoiding the overhead of constructing a fully instanciated Component object Notes: Ext
 uses lazy rendering. Child Components will only be rendered should it become necessary. Items are automatically laid out
 when they are first shown (no sizing is done while hidden), or in response to a doLayout call. Do not specify contentEl/
 html with items.]]></description><name>items</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[*Important: In order for child items to be correctly sized and positioned, typically a layout manager must be specified
 through the layout configuration option. The sizing and positioning of child items is the responsibility of the
 Container's layout manager which creates and manages the type of layout you have in mind. For example: If the layout
 configuration is not explicitly specified for a general purpose container (e.g. Container or Panel) the default layout
 manager will be used which does nothing but render child components sequentially into the Container (no sizing or
 positioning will be performed in this situation). layout may be specified as either as an Object or as a String: Specify
 as an Object Example usage: layout: {
     type: 'vbox',
     align: 'left'
 } type The layout type to be used for this
 container. If not specified, a default Ext.layout.ContainerLayout will be created and used. Valid layout type values
 are:
 auto - Default card fit hbox vbox Layout specific configuration properties Additional layout specific
 configuration properties may also be specified. For complete details regarding the valid config options for each layout
 type, see the layout class corresponding to the type specified. Specify as a String Example usage: layout: {
     type:
 'vbox',
     padding: '5',
     align: 'left'
 } layout The layout type to be used for this container (see list of valid
 layout type values above). Additional layout specific configuration properties. For complete details regarding the valid
 config options for each layout type, see the layout class corresponding to the layout specified.]]></description><name>layout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A config object containing one or more event handlers to be added to this object during initialization. This should be a
 valid listeners config object as specified in the addListener example for attaching multiple handlers at once. DOM
 events from ExtJs Components While some ExtJs Component classes export selected DOM events (e.g. "click", "mouseover"
 etc), this is usually only done when extra value can be added. For example the DataView's click event passing the node
 clicked on. To access DOM events directly from a child element of a Component, we need to specify the element option to
 identify the Component property to add a DOM listener to: new Ext.Panel({
     width: 400,
     height: 200,
    
 dockedItems: [{
         xtype: 'toolbar'
     }],
     listeners: {
         click: {
             element: 'el', //bind to
 the underlying el property on the panel
             fn: function(){ console.log('click el'); }
         },
        
 dblclick: {
             element: 'body', //bind to the underlying body property on the panel
             fn: function(){
 console.log('dblclick body'); }
         }
     }
 });]]></description><name>listeners</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Loading text to display when a subtree is loading.]]></description><name>loadingText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the margin for this component. The margin can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>margin</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this Component will set its height to. Warning: This will override any size management
 applied by layout managers.]]></description><name>maxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this Component will set its width to. Warning: This will override any size management
 applied by layout managers.]]></description><name>maxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this Component will set its height to. Warning: This will override any size management
 applied by layout managers.]]></description><name>minHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this Component will set its width to. Warning: This will override any size management
 applied by layout managers.]]></description><name>minWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Maps to the Ext.List onItemDisclosure configuration for individual lists. (Defaults to false)]]></description><name>onItemDisclosure</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the padding for this component. The padding can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>padding</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object containing properties specifying DomQuery selectors which identify child elements created by the render
 process. After the Component's internal structure is rendered according to the renderTpl, this object is iterated
 through, and the found Elements are added as properties to the Component using the renderSelector property name. For
 example, a Component which rendered an image, and description into its element might use the following properties coded
 into its prototype: renderTpl: '"{imageUrl}" class="x-image-component-img">
 "x-image-component-desc">{description}',
 
 renderSelectors: {
     image: 'img.x-image-component-img',
     descEl:
 'div.x-image-component-desc'
 } After rendering, the Component would have a property image referencing its child img
 Element, and a property descEl referencing the div Element which contains the description.]]></description><name>renderSelectors</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An XTemplate used to create the internal structure inside this Component's encapsulating Element. You do not normally
 need to specify this. For the base classes Ext.Component and Ext.Container, this defaults to null which means that they
 will be initially rendered with no internal structure; they render their Element empty. The more specialized ExtJS and
 Touch classes which use a more complex DOM structure, provide their own template definitions. This is intended to allow
 the developer to create application-specific utility Components with customized internal structure. Upon rendering, any
 created child elements may be automatically imported into object properties using the renderSelectors option.]]></description><name>renderTpl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.data.TreeStore to bind this NestedList to.]]></description><name>store</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
             title: 'Some Title',
             renderTo: Ext.getBody(),
          
 width: 400, height: 300,
             layout: 'form',
             items: [{
                 xtype: 'textareafield',
      
 style: {
                     width: '95%',
                     marginBottom: '10px'
                 }
             },
    
 new Ext.Button({
                 text: 'Send',
                 minWidth: '100',
                 style: {
                
     marginBottom: '10px'
                 }
             })
             ]
         });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The class that is added to the content target when you set styleHtmlContent to true. Defaults to 'x-html']]></description><name>styleHtmlCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically style the html inside the content target of this component (body for panels). Defaults to false.]]></description><name>styleHtmlContent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Configuration for the Ext.Toolbar that is created within the Ext.NestedList.]]></description><name>toolbar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An Ext.Template, Ext.XTemplate or an array of strings to form an Ext.XTemplate. Used in conjunction with the data and
 tplWriteMode configurations.]]></description><name>tpl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A set of predefined ui styles for individual components. Most components support 'light' and 'dark'. Extra string added
 to the baseCls with an extra '-'. 
 <pre><code>
 new Ext.Panel({
     title: 'Some Title',
     baseCls: 'x-component'
     ui: 'green'
 });</pre></code>
 The ui configuration in this example would add 'x-component-green' as an additional class.]]></description><name>ui</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Update the title with the currently selected category. Defaults to true.]]></description><name>updateTitleText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>useTitleAsBackText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to show the header toolbar. Defaults to true.]]></description><name>useToolbar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of this component in pixels.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original SenchaTouch API docs:
 <a href="http://docs.sencha.com/touch/">http://docs.sencha.com/touch/</a>

 <p>A general picker class. Slots are used to organize multiple scrollable slots into a single picker. <a
 href="output/Ext.Picker.html#Ext.Picker-slots" ext:member="slots" ext:cls="Ext.Picker">slots</a> is the only necessary
 property</p> 
 <h2>Example usage:</h2> 
 <pre><code><b>var</b> picker = <b>new</b> Ext.Picker({
     slots: [
         {
    
 name : <em>'limit_speed'</em>,
             title: <em>'Speed'</em>,
             data : [
                 {text: <em>'50
 KB/s'</em>, value: 50},
                 {text: <em>'100 KB/s'</em>, value: 100},
                 {text: <em>'200
 KB/s'</em>, value: 200},
                 {text: <em>'300 KB/s'</em>, value: 300}
             ]
         }
    
 ]
 });
 picker.show();</code></pre>]]></description><name>picker</name><tag-class>org.brushingbits.jnap.ui.senchatouch.Picker</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[CSS class to be applied to individual list items when they have been chosen.]]></description><name>activeCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A string component id or the numeric index of the component that should be initially activated within the container's
 layout on render. For example, activeItem: 'item-1' or activeItem: 0 (index 0 = the first item in the container's
 collection). activeItem only applies to layout styles that can display items one at a time (like Ext.layout.CardLayout
 and Ext.layout.FitLayout). Related to Ext.layout.ContainerLayout.activeItem.]]></description><name>activeItem</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If true the container will automatically destroy any contained component that is removed from it, else destruction must
 be handled manually (defaults to true).]]></description><name>autoDestroy</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The base CSS class to apply to this panel's element (defaults to 'x-panel').]]></description><name>baseCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A shortcut for setting a border style on the body element. The value can either be a number to be applied to all sides,
 or a normal css string describing borders. Defaults to undefined.]]></description><name>bodyBorder</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A shortcut for setting a margin style on the body element. The value can either be a number to be applied to all sides,
 or a normal css string describing margins. Defaults to undefined.]]></description><name>bodyMargin</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A shortcut for setting a padding style on the body element. The value can either be a number to be applied to all sides,
 or a normal css string describing padding. Defaults to undefined.]]></description><name>bodyPadding</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the border for this component. The border can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>border</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to ['add', 'remove'].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element (defaults to ''). This can be useful for
 adding customized styles to the component or any of its children using standard CSS rules.]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The main component class]]></description><name>componentCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The sizing and positioning of the component Elements is the responsibility of the Component's layout manager which
 creates and manages the type of layout specific to the component. If the layout configuration is not explicitly
 specified for a general purpose compopnent the default layout manager will be used.]]></description><name>componentLayout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default xtype of child Components to create in this Container when a child item is specified as a raw configuration
 object, rather than as an instantiated Component. Defaults to 'panel'.]]></description><name>defaultType</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[This option is a means of applying default settings to all added items whether added through the items config or via the
 add or insert methods. If an added item is a config object, and not an instantiated Component, then the default
 properties are unconditionally applied. If the added item is an instantiated Component, then the default properties are
 applied conditionally so as not to override existing properties in the item. If the defaults option is specified as a
 function, then the function will be called using this Container as the scope (this reference) and passing the added item
 as the first parameter. Any resulting object from that call is then applied to the item as default properties. For
 example, to automatically apply padding to the body of each of a set of contained Ext.Panel items, you could pass:
 defaults: {bodyStyle:'padding:15px'}. Usage: defaults: {               // defaults are applied to items, not the
 container
     autoScroll:true
 },
 items: [
     {
         xtype: 'panel',   // defaults do not have precedence over
       
 id: 'panel1',     // options in config objects, so the defaults
         autoScroll: false // will not be applied here,
 panel1 will be autoScroll:false
     },
     new Ext.Panel({       // defaults do have precedence over options
         id:
 'panel2',     // options in components, so the defaults
         autoScroll: false // will be applied here, panel2 will
 be autoScroll:true.
     })
 ]]]></description><name>defaults</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to false.]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class to add when the Component is disabled. Defaults to 'x-item-disabled'.]]></description><name>disabledCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A component or series of components to be added as docked items to this panel. The docked items can be docked to either
 the top, right, left or bottom of a panel. This is typically used for things like toolbars or tab bars: var panel = new
 Ext.Panel({
     fullscreen: true,
     dockedItems: [{
         xtype: 'toolbar',
         dock: 'top',
         items: [{
  
           text: 'Docked to the bottom'
         }]
     }]
 });]]></description><name>dockedItems</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Can be either: A {String} text to be used on the Done button An {Object} as config for Ext.Button false or null to hide
 it Defaults to 'Done'.]]></description><name>doneButton</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Allows the component to be dragged via the touch event.]]></description><name>draggable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The viewport side from which to anchor the sheet when made visible (top, bottom, left, right) Defaults to 'bottom']]></description><name>enter</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[the named Ext.anim effect or animation configuration object used for transitions when the component is shown. Defaults
 to 'slide']]></description><name>enterAnimation</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The viewport side used as the exit point when hidden (top, bottom, left, right) Applies to sliding animation effects
 only. Defaults to 'bottom']]></description><name>exit</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[the named Ext.anim effect or animation configuration object used for transitions when the component is hidden. Defaults
 to 'slide']]></description><name>exitAnimation</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Create the Component as a floating and use absolute positioning. Defaults to false.]]></description><name>floating</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of the picker. Defaults to 220]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to false.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically bind a tap listener to the mask that hides the window. Defaults to false. Note: if you don't set
 this property to false you have to programmaticaly hide the overlay.]]></description><name>hideOnMaskTap</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[** IMPORTANT: be sure to specify a layout if needed ! ** A single item, or an array of child Components to be added to
 this container, for example: // specifying a single item
 items: {...},
 layout: 'fit',    // specify a layout!
 
 //
 specifying multiple items
 items: [{...}, {...}],
 layout: 'hbox', // specify a layout! Each item may be: any type of
 object based on Ext.Component a fully instanciated object or an object literal that: has a specified xtype the
 Ext.Component.xtype specified is associated with the Component desired and should be chosen from one of the available
 xtypes as listed in Ext.Component. If an xtype is not explicitly specified, the defaultType for that Container is used.
 will be "lazily instanciated", avoiding the overhead of constructing a fully instanciated Component object Notes: Ext
 uses lazy rendering. Child Components will only be rendered should it become necessary. Items are automatically laid out
 when they are first shown (no sizing is done while hidden), or in response to a doLayout call. Do not specify contentEl/
 html with items.]]></description><name>items</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[*Important: In order for child items to be correctly sized and positioned, typically a layout manager must be specified
 through the layout configuration option. The sizing and positioning of child items is the responsibility of the
 Container's layout manager which creates and manages the type of layout you have in mind. For example: If the layout
 configuration is not explicitly specified for a general purpose container (e.g. Container or Panel) the default layout
 manager will be used which does nothing but render child components sequentially into the Container (no sizing or
 positioning will be performed in this situation). layout may be specified as either as an Object or as a String: Specify
 as an Object Example usage: layout: {
     type: 'vbox',
     align: 'left'
 } type The layout type to be used for this
 container. If not specified, a default Ext.layout.ContainerLayout will be created and used. Valid layout type values
 are:
 auto - Default card fit hbox vbox Layout specific configuration properties Additional layout specific
 configuration properties may also be specified. For complete details regarding the valid config options for each layout
 type, see the layout class corresponding to the type specified. Specify as a String Example usage: layout: {
     type:
 'vbox',
     padding: '5',
     align: 'left'
 } layout The layout type to be used for this container (see list of valid
 layout type values above). Additional layout specific configuration properties. For complete details regarding the valid
 config options for each layout type, see the layout class corresponding to the layout specified.]]></description><name>layout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A config object containing one or more event handlers to be added to this object during initialization. This should be a
 valid listeners config object as specified in the addListener example for attaching multiple handlers at once. DOM
 events from ExtJs Components While some ExtJs Component classes export selected DOM events (e.g. "click", "mouseover"
 etc), this is usually only done when extra value can be added. For example the DataView's click event passing the node
 clicked on. To access DOM events directly from a child element of a Component, we need to specify the element option to
 identify the Component property to add a DOM listener to: new Ext.Panel({
     width: 400,
     height: 200,
    
 dockedItems: [{
         xtype: 'toolbar'
     }],
     listeners: {
         click: {
             element: 'el', //bind to
 the underlying el property on the panel
             fn: function(){ console.log('click el'); }
         },
        
 dblclick: {
             element: 'body', //bind to the underlying body property on the panel
             fn: function(){
 console.log('dblclick body'); }
         }
     }
 });]]></description><name>listeners</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the margin for this component. The margin can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>margin</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this Component will set its height to. Warning: This will override any size management
 applied by layout managers.]]></description><name>maxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this Component will set its width to. Warning: This will override any size management
 applied by layout managers.]]></description><name>maxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this Component will set its height to. Warning: This will override any size management
 applied by layout managers.]]></description><name>minHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this Component will set its width to. Warning: This will override any size management
 applied by layout managers.]]></description><name>minWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the padding for this component. The padding can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>padding</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object containing properties specifying DomQuery selectors which identify child elements created by the render
 process. After the Component's internal structure is rendered according to the renderTpl, this object is iterated
 through, and the found Elements are added as properties to the Component using the renderSelector property name. For
 example, a Component which rendered an image, and description into its element might use the following properties coded
 into its prototype: renderTpl: '"{imageUrl}" class="x-image-component-img">
 "x-image-component-desc">{description}',
 
 renderSelectors: {
     image: 'img.x-image-component-img',
     descEl:
 'div.x-image-component-desc'
 } After rendering, the Component would have a property image referencing its child img
 Element, and a property descEl referencing the div Element which contains the description.]]></description><name>renderSelectors</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An XTemplate used to create the internal structure inside this Component's encapsulating Element. You do not normally
 need to specify this. For the base classes Ext.Component and Ext.Container, this defaults to null which means that they
 will be initially rendered with no internal structure; they render their Element empty. The more specialized ExtJS and
 Touch classes which use a more complex DOM structure, provide their own template definitions. This is intended to allow
 the developer to create application-specific utility Components with customized internal structure. Upon rendering, any
 created child elements may be automatically imported into object properties using the renderSelectors option.]]></description><name>renderTpl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of slot configurations. name - {String} - Name of the slot align - {String} - Alignment of the slot. left,
 right, or center items - {Array} - An array of text/value pairs in the format {text: 'myKey', value: 'myValue'} title -
 {String} - Title of the slot. This is used in conjunction with useTitles: true.]]></description><name>slots</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If true, the width of anchored Sheets are adjusted to fill the entire top/bottom axis width, or false to center the
 Sheet along the same axis based upon the sheets current/calculated width. This option is ignored when {link #centered}
 is true or x/y coordinates are specified for the Sheet.]]></description><name>stretchX</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If true, the height of anchored Sheets are adjusted to fill the entire right/left axis height, or false to center the
 Sheet along the same axis based upon the sheets current/calculated height. This option is ignored when {link #centered}
 is true or x/y coordinates are specified for the Sheet.]]></description><name>stretchY</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
             title: 'Some Title',
             renderTo: Ext.getBody(),
          
 width: 400, height: 300,
             layout: 'form',
             items: [{
                 xtype: 'textareafield',
      
 style: {
                     width: '95%',
                     marginBottom: '10px'
                 }
             },
    
 new Ext.Button({
                 text: 'Send',
                 minWidth: '100',
                 style: {
                
     marginBottom: '10px'
                 }
             })
             ]
         });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The class that is added to the content target when you set styleHtmlContent to true. Defaults to 'x-html']]></description><name>styleHtmlCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically style the html inside the content target of this component (body for panels). Defaults to false.]]></description><name>styleHtmlContent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An Ext.Template, Ext.XTemplate or an array of strings to form an Ext.XTemplate. Used in conjunction with the data and
 tplWriteMode configurations.]]></description><name>tpl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A set of predefined ui styles for individual components. Most components support 'light' and 'dark'. Extra string added
 to the baseCls with an extra '-'. 
 <pre><code>
 new Ext.Panel({
     title: 'Some Title',
     baseCls: 'x-component'
     ui: 'green'
 });</pre></code>
 The ui configuration in this example would add 'x-component-green' as an additional class.]]></description><name>ui</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Generate a title header for each individual slot and use the title configuration of the slot. Defaults to false.]]></description><name>useTitles</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of this component in pixels.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original SenchaTouch API docs:
 <a href="http://docs.sencha.com/touch/">http://docs.sencha.com/touch/</a>

 This plugin adds pull to refresh functionality to the List.]]></description><name>plugins.listPaging</name><tag-class>org.brushingbits.jnap.ui.senchatouch.plugins.ListPagingPlugin</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[True to automatically load the next page when you scroll to the bottom of the list. Defaults to false.]]></description><name>autoPaging</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A config object containing one or more event handlers to be added to this object during initialization. This should be a
 valid listeners config object as specified in the addListener example for attaching multiple handlers at once. DOM
 events from ExtJs Components While some ExtJs Component classes export selected DOM events (e.g. "click", "mouseover"
 etc), this is usually only done when extra value can be added. For example the DataView's click event passing the node
 clicked on. To access DOM events directly from a child element of a Component, we need to specify the element option to
 identify the Component property to add a DOM listener to: new Ext.Panel({
     width: 400,
     height: 200,
    
 dockedItems: [{
         xtype: 'toolbar'
     }],
     listeners: {
         click: {
             element: 'el', //bind to
 the underlying el property on the panel
             fn: function(){ console.log('click el'); }
         },
        
 dblclick: {
             element: 'body', //bind to the underlying body property on the panel
             fn: function(){
 console.log('dblclick body'); }
         }
     }
 });]]></description><name>listeners</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The text used as the label of the Load More button.]]></description><name>loadMoreText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The text that will be shown while you are pulling down.]]></description><name>pullRefreshText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The template being used for the pull to refresh markup.]]></description><name>pullTpl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The function that will be called to refresh the list. If this is not defined, the store's load function will be called.
 The refresh function gets called with two parameters. The first one is the callback function that should be called after
 your refresh is complete. The second one is a reference to this plugin instance.]]></description><name>refreshFn</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The duration for snapping back animation after the data has been refreshed]]></description><name>snappingAnimationDuration</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original SenchaTouch API docs:
 <a href="http://docs.sencha.com/touch/">http://docs.sencha.com/touch/</a>

 <p>SegmentedButton is a container for a group of <a href="output/Ext.Button.html" ext:cls="Ext.Button">Ext.Button</a>s.
 Generally a SegmentedButton would be a child of a <a href="output/Ext.Toolbar.html"
 ext:cls="Ext.Toolbar">Ext.Toolbar</a> and would be used to switch between different views.</p> 
 <h2>Useful
 Properties</h2> 
 <ul class="list"> 
  <li><a href="output/Ext.SegmentedButton.html#Ext.SegmentedButton-allowMultiple"
 ext:member="allowMultiple" ext:cls="Ext.SegmentedButton">allowMultiple</a></li> 
 </ul> 
 <h2>Screenshot:</h2> 
 <p><img
 src="doc_resources/Ext.SegmentedButton/screenshot.png" /></p> 
 <h2>Example usage:</h2> 
 <pre><code><b>var</b>
 segmentedButton = <b>new</b> Ext.SegmentedButton({
     allowMultiple: true,
     items: [
         {
             text:
 <em>'Option 1'</em>
         },
         {
             text   : <em>'Option 2'</em>,
             pressed: true,
           
 handler: tappedFn
         },
         {
             text: <em>'Option 3'</em>
         }
     ],
     listeners: {
        
 toggle: <b>function</b>(container, button, pressed){
             console.log(<em>&quot;User toggled the <em>'&quot;</em>
 + button.text + <em>&quot;'</em> button: &quot;</em> + (pressed ? <em>'on'</em> : <em>'off'</em>));
         }
    
 }
 });</code></pre>]]></description><name>segmentedButton</name><tag-class>org.brushingbits.jnap.ui.senchatouch.SegmentedButton</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[A string component id or the numeric index of the component that should be initially activated within the container's
 layout on render. For example, activeItem: 'item-1' or activeItem: 0 (index 0 = the first item in the container's
 collection). activeItem only applies to layout styles that can display items one at a time (like Ext.layout.CardLayout
 and Ext.layout.FitLayout). Related to Ext.layout.ContainerLayout.activeItem.]]></description><name>activeItem</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Allow to depress a pressed button. (defaults to true when allowMultiple is true)]]></description><name>allowDepress</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Allow multiple pressed buttons (defaults to false).]]></description><name>allowMultiple</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If true the container will automatically destroy any contained component that is removed from it, else destruction must
 be handled manually (defaults to true).]]></description><name>autoDestroy</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The base CSS class to apply to this components's element. This will also be prepended to elements within this component
 like Panel's body will get a class x-panel-body. This means that if you create a subclass of Panel, and you want it to
 get all the Panels styling for the element and the body, you leave the baseCls x-panel and use componentCls to add
 specific styling for this component.]]></description><name>baseCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the border for this component. The border can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>border</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to ['add', 'remove'].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Animation to be used during transitions of cards. Note this only works when this container has a CardLayout. Any valid
 value from Ext.anims can be used ('fade', 'slide', 'flip', 'cube', 'pop', 'wipe'). Defaults to null.]]></description><name>cardSwitchAnimation</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element (defaults to ''). This can be useful for
 adding customized styles to the component or any of its children using standard CSS rules.]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS Class to be added to a components root level element to give distinction to it via styling.]]></description><name>componentCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The sizing and positioning of the component Elements is the responsibility of the Component's layout manager which
 creates and manages the type of layout specific to the component. If the layout configuration is not explicitly
 specified for a general purpose compopnent the default layout manager will be used.]]></description><name>componentLayout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default xtype of child Components to create in this Container when a child item is specified as a raw configuration
 object, rather than as an instantiated Component. Defaults to 'panel'.]]></description><name>defaultType</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[This option is a means of applying default settings to all added items whether added through the items config or via the
 add or insert methods. If an added item is a config object, and not an instantiated Component, then the default
 properties are unconditionally applied. If the added item is an instantiated Component, then the default properties are
 applied conditionally so as not to override existing properties in the item. If the defaults option is specified as a
 function, then the function will be called using this Container as the scope (this reference) and passing the added item
 as the first parameter. Any resulting object from that call is then applied to the item as default properties. For
 example, to automatically apply padding to the body of each of a set of contained Ext.Panel items, you could pass:
 defaults: {bodyStyle:'padding:15px'}. Usage: defaults: {               // defaults are applied to items, not the
 container
     autoScroll:true
 },
 items: [
     {
         xtype: 'panel',   // defaults do not have precedence over
       
 id: 'panel1',     // options in config objects, so the defaults
         autoScroll: false // will not be applied here,
 panel1 will be autoScroll:false
     },
     new Ext.Panel({       // defaults do have precedence over options
         id:
 'panel2',     // options in components, so the defaults
         autoScroll: false // will be applied here, panel2 will
 be autoScroll:true.
     })
 ]]]></description><name>defaults</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to false.]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class to add when the Component is disabled. Defaults to 'x-item-disabled'.]]></description><name>disabledCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Allows the component to be dragged via the touch event.]]></description><name>draggable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Create the Component as a floating and use absolute positioning. Defaults to false.]]></description><name>floating</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of this component in pixels.]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to false.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[** IMPORTANT: be sure to specify a layout if needed ! ** A single item, or an array of child Components to be added to
 this container, for example: // specifying a single item
 items: {...},
 layout: 'fit',    // specify a layout!
 
 //
 specifying multiple items
 items: [{...}, {...}],
 layout: 'hbox', // specify a layout! Each item may be: any type of
 object based on Ext.Component a fully instanciated object or an object literal that: has a specified xtype the
 Ext.Component.xtype specified is associated with the Component desired and should be chosen from one of the available
 xtypes as listed in Ext.Component. If an xtype is not explicitly specified, the defaultType for that Container is used.
 will be "lazily instanciated", avoiding the overhead of constructing a fully instanciated Component object Notes: Ext
 uses lazy rendering. Child Components will only be rendered should it become necessary. Items are automatically laid out
 when they are first shown (no sizing is done while hidden), or in response to a doLayout call. Do not specify contentEl/
 html with items.]]></description><name>items</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[*Important: In order for child items to be correctly sized and positioned, typically a layout manager must be specified
 through the layout configuration option. The sizing and positioning of child items is the responsibility of the
 Container's layout manager which creates and manages the type of layout you have in mind. For example: If the layout
 configuration is not explicitly specified for a general purpose container (e.g. Container or Panel) the default layout
 manager will be used which does nothing but render child components sequentially into the Container (no sizing or
 positioning will be performed in this situation). layout may be specified as either as an Object or as a String: Specify
 as an Object Example usage: layout: {
     type: 'vbox',
     align: 'left'
 } type The layout type to be used for this
 container. If not specified, a default Ext.layout.ContainerLayout will be created and used. Valid layout type values
 are:
 auto - Default card fit hbox vbox Layout specific configuration properties Additional layout specific
 configuration properties may also be specified. For complete details regarding the valid config options for each layout
 type, see the layout class corresponding to the type specified. Specify as a String Example usage: layout: {
     type:
 'vbox',
     padding: '5',
     align: 'left'
 } layout The layout type to be used for this container (see list of valid
 layout type values above). Additional layout specific configuration properties. For complete details regarding the valid
 config options for each layout type, see the layout class corresponding to the layout specified.]]></description><name>layout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A config object containing one or more event handlers to be added to this object during initialization. This should be a
 valid listeners config object as specified in the addListener example for attaching multiple handlers at once. DOM
 events from ExtJs Components While some ExtJs Component classes export selected DOM events (e.g. "click", "mouseover"
 etc), this is usually only done when extra value can be added. For example the DataView's click event passing the node
 clicked on. To access DOM events directly from a child element of a Component, we need to specify the element option to
 identify the Component property to add a DOM listener to: new Ext.Panel({
     width: 400,
     height: 200,
    
 dockedItems: [{
         xtype: 'toolbar'
     }],
     listeners: {
         click: {
             element: 'el', //bind to
 the underlying el property on the panel
             fn: function(){ console.log('click el'); }
         },
        
 dblclick: {
             element: 'body', //bind to the underlying body property on the panel
             fn: function(){
 console.log('dblclick body'); }
         }
     }
 });]]></description><name>listeners</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the margin for this component. The margin can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>margin</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this Component will set its height to. Warning: This will override any size management
 applied by layout managers.]]></description><name>maxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this Component will set its width to. Warning: This will override any size management
 applied by layout managers.]]></description><name>maxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this Component will set its height to. Warning: This will override any size management
 applied by layout managers.]]></description><name>minHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this Component will set its width to. Warning: This will override any size management
 applied by layout managers.]]></description><name>minWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the padding for this component. The padding can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>padding</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object containing properties specifying DomQuery selectors which identify child elements created by the render
 process. After the Component's internal structure is rendered according to the renderTpl, this object is iterated
 through, and the found Elements are added as properties to the Component using the renderSelector property name. For
 example, a Component which rendered an image, and description into its element might use the following properties coded
 into its prototype: renderTpl: '"{imageUrl}" class="x-image-component-img">
 "x-image-component-desc">{description}',
 
 renderSelectors: {
     image: 'img.x-image-component-img',
     descEl:
 'div.x-image-component-desc'
 } After rendering, the Component would have a property image referencing its child img
 Element, and a property descEl referencing the div Element which contains the description.]]></description><name>renderSelectors</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An XTemplate used to create the internal structure inside this Component's encapsulating Element. You do not normally
 need to specify this. For the base classes Ext.Component and Ext.Container, this defaults to null which means that they
 will be initially rendered with no internal structure; they render their Element empty. The more specialized ExtJS and
 Touch classes which use a more complex DOM structure, provide their own template definitions. This is intended to allow
 the developer to create application-specific utility Components with customized internal structure. Upon rendering, any
 created child elements may be automatically imported into object properties using the renderSelectors option.]]></description><name>renderTpl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
             title: 'Some Title',
             renderTo: Ext.getBody(),
          
 width: 400, height: 300,
             layout: 'form',
             items: [{
                 xtype: 'textareafield',
      
 style: {
                     width: '95%',
                     marginBottom: '10px'
                 }
             },
    
 new Ext.Button({
                 text: 'Send',
                 minWidth: '100',
                 style: {
                
     marginBottom: '10px'
                 }
             })
             ]
         });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The class that is added to the content target when you set styleHtmlContent to true. Defaults to 'x-html']]></description><name>styleHtmlCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically style the html inside the content target of this component (body for panels). Defaults to false.]]></description><name>styleHtmlContent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An Ext.Template, Ext.XTemplate or an array of strings to form an Ext.XTemplate. Used in conjunction with the data and
 tplWriteMode configurations.]]></description><name>tpl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A set of predefined ui styles for individual components. Most components support 'light' and 'dark'. Extra string added
 to the baseCls with an extra '-'. 
 <pre><code>
 new Ext.Panel({
     title: 'Some Title',
     baseCls: 'x-component'
     ui: 'green'
 });</pre></code>
 The ui configuration in this example would add 'x-component-green' as an additional class.]]></description><name>ui</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of this component in pixels.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original SenchaTouch API docs:
 <a href="http://docs.sencha.com/touch/">http://docs.sencha.com/touch/</a>

 <p>A general sheet class. This renderable container provides base support for orientation-aware transitions for popup or
 side-anchored sliding Panels.</p> 
 <h2>Screenshot:</h2> 
 <p><img src="doc_resources/Ext.Sheet/screenshot.png" /></p>
 
 <h2>Example usage:</h2> 
 <pre><code><b>var</b> sheet = <b>new</b> Ext.Sheet({
     height  : 200,
     stretchX: true,
   
 stretchY: true,
     
     layout: {
         type: <em>'hbox'</em>,
         align: <em>'stretch'</em>
     },
     
    
 dockedItems: [
         {
             dock : <em>'bottom'</em>,
             xtype: <em>'button'</em>,
             text :
 <em>'Click me'</em>
         }
     ]
 });
 sheet.show();</code></pre> 
 <p>See <a href="output/Ext.Picker.html"
 ext:cls="Ext.Picker">Ext.Picker</a> and <a href="output/Ext.DatePicker.html"
 ext:cls="Ext.DatePicker">Ext.DatePicker</a></p>]]></description><name>sheet</name><tag-class>org.brushingbits.jnap.ui.senchatouch.Sheet</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[A string component id or the numeric index of the component that should be initially activated within the container's
 layout on render. For example, activeItem: 'item-1' or activeItem: 0 (index 0 = the first item in the container's
 collection). activeItem only applies to layout styles that can display items one at a time (like Ext.layout.CardLayout
 and Ext.layout.FitLayout). Related to Ext.layout.ContainerLayout.activeItem.]]></description><name>activeItem</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If true the container will automatically destroy any contained component that is removed from it, else destruction must
 be handled manually (defaults to true).]]></description><name>autoDestroy</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The base CSS class to apply to this panel's element (defaults to 'x-panel').]]></description><name>baseCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A shortcut for setting a border style on the body element. The value can either be a number to be applied to all sides,
 or a normal css string describing borders. Defaults to undefined.]]></description><name>bodyBorder</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A shortcut for setting a margin style on the body element. The value can either be a number to be applied to all sides,
 or a normal css string describing margins. Defaults to undefined.]]></description><name>bodyMargin</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A shortcut for setting a padding style on the body element. The value can either be a number to be applied to all sides,
 or a normal css string describing padding. Defaults to undefined.]]></description><name>bodyPadding</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the border for this component. The border can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>border</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to ['add', 'remove'].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element (defaults to ''). This can be useful for
 adding customized styles to the component or any of its children using standard CSS rules.]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS Class to be added to a components root level element to give distinction to it via styling.]]></description><name>componentCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The sizing and positioning of the component Elements is the responsibility of the Component's layout manager which
 creates and manages the type of layout specific to the component. If the layout configuration is not explicitly
 specified for a general purpose compopnent the default layout manager will be used.]]></description><name>componentLayout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default xtype of child Components to create in this Container when a child item is specified as a raw configuration
 object, rather than as an instantiated Component. Defaults to 'panel'.]]></description><name>defaultType</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[This option is a means of applying default settings to all added items whether added through the items config or via the
 add or insert methods. If an added item is a config object, and not an instantiated Component, then the default
 properties are unconditionally applied. If the added item is an instantiated Component, then the default properties are
 applied conditionally so as not to override existing properties in the item. If the defaults option is specified as a
 function, then the function will be called using this Container as the scope (this reference) and passing the added item
 as the first parameter. Any resulting object from that call is then applied to the item as default properties. For
 example, to automatically apply padding to the body of each of a set of contained Ext.Panel items, you could pass:
 defaults: {bodyStyle:'padding:15px'}. Usage: defaults: {               // defaults are applied to items, not the
 container
     autoScroll:true
 },
 items: [
     {
         xtype: 'panel',   // defaults do not have precedence over
       
 id: 'panel1',     // options in config objects, so the defaults
         autoScroll: false // will not be applied here,
 panel1 will be autoScroll:false
     },
     new Ext.Panel({       // defaults do have precedence over options
         id:
 'panel2',     // options in components, so the defaults
         autoScroll: false // will be applied here, panel2 will
 be autoScroll:true.
     })
 ]]]></description><name>defaults</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to false.]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class to add when the Component is disabled. Defaults to 'x-item-disabled'.]]></description><name>disabledCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A component or series of components to be added as docked items to this panel. The docked items can be docked to either
 the top, right, left or bottom of a panel. This is typically used for things like toolbars or tab bars: var panel = new
 Ext.Panel({
     fullscreen: true,
     dockedItems: [{
         xtype: 'toolbar',
         dock: 'top',
         items: [{
  
           text: 'Docked to the bottom'
         }]
     }]
 });]]></description><name>dockedItems</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Allows the component to be dragged via the touch event.]]></description><name>draggable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The viewport side from which to anchor the sheet when made visible (top, bottom, left, right) Defaults to 'bottom']]></description><name>enter</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[the named Ext.anim effect or animation configuration object used for transitions when the component is shown. Defaults
 to 'slide']]></description><name>enterAnimation</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The viewport side used as the exit point when hidden (top, bottom, left, right) Applies to sliding animation effects
 only. Defaults to 'bottom']]></description><name>exit</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[the named Ext.anim effect or animation configuration object used for transitions when the component is hidden. Defaults
 to 'slide']]></description><name>exitAnimation</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Create the Component as a floating and use absolute positioning. Defaults to false.]]></description><name>floating</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of this component in pixels.]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to false.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically bind a tap listener to the mask that hides the window. Defaults to false. Note: if you don't set
 this property to false you have to programmaticaly hide the overlay.]]></description><name>hideOnMaskTap</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[** IMPORTANT: be sure to specify a layout if needed ! ** A single item, or an array of child Components to be added to
 this container, for example: // specifying a single item
 items: {...},
 layout: 'fit',    // specify a layout!
 
 //
 specifying multiple items
 items: [{...}, {...}],
 layout: 'hbox', // specify a layout! Each item may be: any type of
 object based on Ext.Component a fully instanciated object or an object literal that: has a specified xtype the
 Ext.Component.xtype specified is associated with the Component desired and should be chosen from one of the available
 xtypes as listed in Ext.Component. If an xtype is not explicitly specified, the defaultType for that Container is used.
 will be "lazily instanciated", avoiding the overhead of constructing a fully instanciated Component object Notes: Ext
 uses lazy rendering. Child Components will only be rendered should it become necessary. Items are automatically laid out
 when they are first shown (no sizing is done while hidden), or in response to a doLayout call. Do not specify contentEl/
 html with items.]]></description><name>items</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[*Important: In order for child items to be correctly sized and positioned, typically a layout manager must be specified
 through the layout configuration option. The sizing and positioning of child items is the responsibility of the
 Container's layout manager which creates and manages the type of layout you have in mind. For example: If the layout
 configuration is not explicitly specified for a general purpose container (e.g. Container or Panel) the default layout
 manager will be used which does nothing but render child components sequentially into the Container (no sizing or
 positioning will be performed in this situation). layout may be specified as either as an Object or as a String: Specify
 as an Object Example usage: layout: {
     type: 'vbox',
     align: 'left'
 } type The layout type to be used for this
 container. If not specified, a default Ext.layout.ContainerLayout will be created and used. Valid layout type values
 are:
 auto - Default card fit hbox vbox Layout specific configuration properties Additional layout specific
 configuration properties may also be specified. For complete details regarding the valid config options for each layout
 type, see the layout class corresponding to the type specified. Specify as a String Example usage: layout: {
     type:
 'vbox',
     padding: '5',
     align: 'left'
 } layout The layout type to be used for this container (see list of valid
 layout type values above). Additional layout specific configuration properties. For complete details regarding the valid
 config options for each layout type, see the layout class corresponding to the layout specified.]]></description><name>layout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A config object containing one or more event handlers to be added to this object during initialization. This should be a
 valid listeners config object as specified in the addListener example for attaching multiple handlers at once. DOM
 events from ExtJs Components While some ExtJs Component classes export selected DOM events (e.g. "click", "mouseover"
 etc), this is usually only done when extra value can be added. For example the DataView's click event passing the node
 clicked on. To access DOM events directly from a child element of a Component, we need to specify the element option to
 identify the Component property to add a DOM listener to: new Ext.Panel({
     width: 400,
     height: 200,
    
 dockedItems: [{
         xtype: 'toolbar'
     }],
     listeners: {
         click: {
             element: 'el', //bind to
 the underlying el property on the panel
             fn: function(){ console.log('click el'); }
         },
        
 dblclick: {
             element: 'body', //bind to the underlying body property on the panel
             fn: function(){
 console.log('dblclick body'); }
         }
     }
 });]]></description><name>listeners</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the margin for this component. The margin can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>margin</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this Component will set its height to. Warning: This will override any size management
 applied by layout managers.]]></description><name>maxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this Component will set its width to. Warning: This will override any size management
 applied by layout managers.]]></description><name>maxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this Component will set its height to. Warning: This will override any size management
 applied by layout managers.]]></description><name>minHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this Component will set its width to. Warning: This will override any size management
 applied by layout managers.]]></description><name>minWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the padding for this component. The padding can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>padding</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object containing properties specifying DomQuery selectors which identify child elements created by the render
 process. After the Component's internal structure is rendered according to the renderTpl, this object is iterated
 through, and the found Elements are added as properties to the Component using the renderSelector property name. For
 example, a Component which rendered an image, and description into its element might use the following properties coded
 into its prototype: renderTpl: '"{imageUrl}" class="x-image-component-img">
 "x-image-component-desc">{description}',
 
 renderSelectors: {
     image: 'img.x-image-component-img',
     descEl:
 'div.x-image-component-desc'
 } After rendering, the Component would have a property image referencing its child img
 Element, and a property descEl referencing the div Element which contains the description.]]></description><name>renderSelectors</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An XTemplate used to create the internal structure inside this Component's encapsulating Element. You do not normally
 need to specify this. For the base classes Ext.Component and Ext.Container, this defaults to null which means that they
 will be initially rendered with no internal structure; they render their Element empty. The more specialized ExtJS and
 Touch classes which use a more complex DOM structure, provide their own template definitions. This is intended to allow
 the developer to create application-specific utility Components with customized internal structure. Upon rendering, any
 created child elements may be automatically imported into object properties using the renderSelectors option.]]></description><name>renderTpl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If true, the width of anchored Sheets are adjusted to fill the entire top/bottom axis width, or false to center the
 Sheet along the same axis based upon the sheets current/calculated width. This option is ignored when {link #centered}
 is true or x/y coordinates are specified for the Sheet.]]></description><name>stretchX</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If true, the height of anchored Sheets are adjusted to fill the entire right/left axis height, or false to center the
 Sheet along the same axis based upon the sheets current/calculated height. This option is ignored when {link #centered}
 is true or x/y coordinates are specified for the Sheet.]]></description><name>stretchY</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
             title: 'Some Title',
             renderTo: Ext.getBody(),
          
 width: 400, height: 300,
             layout: 'form',
             items: [{
                 xtype: 'textareafield',
      
 style: {
                     width: '95%',
                     marginBottom: '10px'
                 }
             },
    
 new Ext.Button({
                 text: 'Send',
                 minWidth: '100',
                 style: {
                
     marginBottom: '10px'
                 }
             })
             ]
         });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The class that is added to the content target when you set styleHtmlContent to true. Defaults to 'x-html']]></description><name>styleHtmlCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically style the html inside the content target of this component (body for panels). Defaults to false.]]></description><name>styleHtmlContent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An Ext.Template, Ext.XTemplate or an array of strings to form an Ext.XTemplate. Used in conjunction with the data and
 tplWriteMode configurations.]]></description><name>tpl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A set of predefined ui styles for individual components. Most components support 'light' and 'dark'. Extra string added
 to the baseCls with an extra '-'. 
 <pre><code>
 new Ext.Panel({
     title: 'Some Title',
     baseCls: 'x-component'
     ui: 'green'
 });</pre></code>
 The ui configuration in this example would add 'x-component-green' as an additional class.]]></description><name>ui</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of this component in pixels.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original SenchaTouch API docs:
 <a href="http://docs.sencha.com/touch/">http://docs.sencha.com/touch/</a>

 <p>Used in the <a href="output/Ext.TabBar.html" ext:cls="Ext.TabBar">Ext.TabBar</a> component. This shouldn't be used
 directly, instead use <a href="output/Ext.TabBar.html" ext:cls="Ext.TabBar">Ext.TabBar</a> or <a
 href="output/Ext.TabPanel.html" ext:cls="Ext.TabPanel">Ext.TabPanel</a>.</p>]]></description><name>tab</name><tag-class>org.brushingbits.jnap.ui.senchatouch.Tab</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[The CSS class to be applied to a Tab when it is active. Defaults to 'x-tab-active'. Providing your own CSS for this
 class enables you to customize the active state.]]></description><name>activeCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If provided, a handler function is automatically created that fires the given event in the configured scope.]]></description><name>autoEvent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class for badge Defaults to 'x-badge']]></description><name>badgeCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The text to be used for a small badge on the button. Defaults to '']]></description><name>badgeText</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Base CSS class Defaults to 'x-button']]></description><name>baseCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the border for this component. The border can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>border</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Center the Component. Defaults to false.]]></description><name>centered</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A CSS class string to apply to the button's main element.]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS Class to be added to a components root level element to give distinction to it via styling.]]></description><name>componentCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The sizing and positioning of the component Elements is the responsibility of the Component's layout manager which
 creates and manages the type of layout specific to the component. If the layout configuration is not explicitly
 specified for a general purpose compopnent the default layout manager will be used.]]></description><name>componentLayout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to start disabled (defaults to false)]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class to add when the Component is disabled. Defaults to 'x-item-disabled'.]]></description><name>disabledCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Allows the component to be dragged via the touch event.]]></description><name>draggable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Create the Component as a floating and use absolute positioning. Defaults to false.]]></description><name>floating</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The class that is being added to this component when its floating. (defaults to x-floating)]]></description><name>floatingCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Force the component to take up 100% width and height available. Defaults to false. Setting this configuration
 immediately sets the monitorOrientation config to true. Setting this to true will render the component instantly.]]></description><name>fullscreen</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A function called when the button is clicked (can be used instead of click event). The handler is passed the following
 parameters: b : Button This Button. e : EventObject The click event.]]></description><name>handler</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of this component in pixels.]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to start hidden (defaults to false)]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically bind a tap listener to the mask that hides the window. Defaults to true. Note: if you set this
 property to false you have to programmaticaly hide the overlay.]]></description><name>hideOnMaskTap</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The path to an image to display in the button (the image will be set as the background-image CSS property of the button
 by default, so if you want a mixed icon/text button, set cls:'x-btn-text-icon')]]></description><name>icon</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The alignment of the buttons icon if one has been defined. Valid options are 'top', 'right', 'bottom', 'left' (defaults
 to 'left').]]></description><name>iconAlign</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A css class which sets a background image to be used as the icon for this button]]></description><name>iconCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Whether or not to mask the icon with the iconMaskCls configuration. Defaults to false.]]></description><name>iconMask</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class to be added to the iconEl when the iconMask config is set to true. Defaults to 'x-icon-mask']]></description><name>iconMaskCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Set this to true to automatically relayout this component on orientation change. This property is set to true by default
 if a component is floating unless you specifically set this to false. Also note that you dont have to set this property
 to true if this component is a child of a fullscreen container, since fullscreen components are also laid out
 automatically on orientation change. Defaults to null]]></description><name>layoutOnOrientationChange</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A config object containing one or more event handlers to be added to this object during initialization. This should be a
 valid listeners config object as specified in the addListener example for attaching multiple handlers at once. DOM
 events from ExtJs Components While some ExtJs Component classes export selected DOM events (e.g. "click", "mouseover"
 etc), this is usually only done when extra value can be added. For example the DataView's click event passing the node
 clicked on. To access DOM events directly from a child element of a Component, we need to specify the element option to
 identify the Component property to add a DOM listener to: new Ext.Panel({
     width: 400,
     height: 200,
    
 dockedItems: [{
         xtype: 'toolbar'
     }],
     listeners: {
         click: {
             element: 'el', //bind to
 the underlying el property on the panel
             fn: function(){ console.log('click el'); }
         },
        
 dblclick: {
             element: 'body', //bind to the underlying body property on the panel
             fn: function(){
 console.log('dblclick body'); }
         }
     }
 });]]></description><name>listeners</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the margin for this component. The margin can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>margin</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this Component will set its height to. Warning: This will override any size management
 applied by layout managers.]]></description><name>maxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this Component will set its width to. Warning: This will override any size management
 applied by layout managers.]]></description><name>maxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this Component will set its height to. Warning: This will override any size management
 applied by layout managers.]]></description><name>minHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this Component will set its width to. Warning: This will override any size management
 applied by layout managers.]]></description><name>minWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to make the Component modal and mask everything behind it when displayed, false to display it without restricting
 access to other UI elements (defaults to false).]]></description><name>modal</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Monitor Orientation change]]></description><name>monitorOrientation</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the padding for this component. The padding can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>padding</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class to be applied to a Tab when it is pressed. Defaults to 'x-tab-pressed'. Providing your own CSS for this
 class enables you to customize the pressed state.]]></description><name>pressedCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The amount of delay between the tapstart and the moment we add the pressedCls. Settings this to true defaults to 100ms]]></description><name>pressedDelay</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object containing properties specifying DomQuery selectors which identify child elements created by the render
 process. After the Component's internal structure is rendered according to the renderTpl, this object is iterated
 through, and the found Elements are added as properties to the Component using the renderSelector property name. For
 example, a Component which rendered an image, and description into its element might use the following properties coded
 into its prototype: renderTpl: '"{imageUrl}" class="x-image-component-img">
 "x-image-component-desc">{description}',
 
 renderSelectors: {
     image: 'img.x-image-component-img',
     descEl:
 'div.x-image-component-desc'
 } After rendering, the Component would have a property image referencing its child img
 Element, and a property descEl referencing the div Element which contains the description.]]></description><name>renderSelectors</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An XTemplate used to create the internal structure inside this Component's encapsulating Element. You do not normally
 need to specify this. For the base classes Ext.Component and Ext.Container, this defaults to null which means that they
 will be initially rendered with no internal structure; they render their Element empty. The more specialized ExtJS and
 Touch classes which use a more complex DOM structure, provide their own template definitions. This is intended to allow
 the developer to create application-specific utility Components with customized internal structure. Upon rendering, any
 created child elements may be automatically imported into object properties using the renderSelectors option.]]></description><name>renderTpl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The scope (this reference) in which the handler and toggleHandler is executed. Defaults to this Button.]]></description><name>scope</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Configure the component to be scrollable. Acceptable values are: 'horizontal', 'vertical', 'both' to enabling scrolling
 for that direction. A Scroller configuration. false to explicitly disable scrolling. Enabling scrolling immediately sets
 the monitorOrientation config to true (for Panel)]]></description><name>scroll</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The type of animation you want to use when this component is shown. If you set this this hide animation will
 automatically be the opposite.]]></description><name>showAnimation</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to stop the event that fires when you click outside the floating component. Defalts to true.]]></description><name>stopMaskTapEvent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
             title: 'Some Title',
             renderTo: Ext.getBody(),
          
 width: 400, height: 300,
             layout: 'form',
             items: [{
                 xtype: 'textareafield',
      
 style: {
                     width: '95%',
                     marginBottom: '10px'
                 }
             },
    
 new Ext.Button({
                 text: 'Send',
                 minWidth: '100',
                 style: {
                
     marginBottom: '10px'
                 }
             })
             ]
         });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The class that is added to the content target when you set styleHtmlContent to true. Defaults to 'x-html']]></description><name>styleHtmlCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically style the html inside the content target of this component (body for panels). Defaults to false.]]></description><name>styleHtmlContent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The button text to be used as innerHTML (html tags are accepted)]]></description><name>text</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An Ext.Template, Ext.XTemplate or an array of strings to form an Ext.XTemplate. Used in conjunction with the data and
 tplWriteMode configurations.]]></description><name>tpl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Determines the UI look and feel of the button. Valid options are 'normal', 'back', 'round', 'action', 'forward'.
 Defaults to 'normal'.]]></description><name>ui</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of this component in pixels.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original SenchaTouch API docs:
 <a href="http://docs.sencha.com/touch/">http://docs.sencha.com/touch/</a>

 <p>Used in the <a href="output/Ext.TabPanel.html" ext:cls="Ext.TabPanel">Ext.TabPanel</a> component to display <a
 href="output/Ext.Tab.html" ext:cls="Ext.Tab">Ext.Tab</a> components.</p> 
 <h2>Screenshot:</h2> 
 <p><img
 src="doc_resources/Ext.TabBar/screenshot.png" /></p> 
 <h2>Example code:</h2> 
 <pre><code><b>var</b> bar = <b>new</b>
 Ext.TabBar({
     dock : <em>'top'</em>,
     ui   : <em>'dark'</em>,
     items: [
         {
             text: <em>'1st
 Button'</em>
         },
         {
             text: <em>'2nd Button'</em>
         }
     ]
 });
 
 <b>var</b> myPanel =
 <b>new</b> Ext.Panel({
     dockedItems: [bar],
     fullscreen : true,
     html       : <em>'Test
 Panel'</em>
 });</code></pre>]]></description><name>tabBar</name><tag-class>org.brushingbits.jnap.ui.senchatouch.TabBar</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[A string component id or the numeric index of the component that should be initially activated within the container's
 layout on render. For example, activeItem: 'item-1' or activeItem: 0 (index 0 = the first item in the container's
 collection). activeItem only applies to layout styles that can display items one at a time (like Ext.layout.CardLayout
 and Ext.layout.FitLayout). Related to Ext.layout.ContainerLayout.activeItem.]]></description><name>activeItem</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If true the container will automatically destroy any contained component that is removed from it, else destruction must
 be handled manually (defaults to true).]]></description><name>autoDestroy</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The base CSS class to apply to this panel's element (defaults to 'x-panel').]]></description><name>baseCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A shortcut for setting a border style on the body element. The value can either be a number to be applied to all sides,
 or a normal css string describing borders. Defaults to undefined.]]></description><name>bodyBorder</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A shortcut for setting a margin style on the body element. The value can either be a number to be applied to all sides,
 or a normal css string describing margins. Defaults to undefined.]]></description><name>bodyMargin</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A shortcut for setting a padding style on the body element. The value can either be a number to be applied to all sides,
 or a normal css string describing padding. Defaults to undefined.]]></description><name>bodyPadding</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the border for this component. The border can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>border</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to ['add', 'remove'].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element (defaults to ''). This can be useful for
 adding customized styles to the component or any of its children using standard CSS rules.]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS Class to be added to a components root level element to give distinction to it via styling.]]></description><name>componentCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The sizing and positioning of the component Elements is the responsibility of the Component's layout manager which
 creates and manages the type of layout specific to the component. If the layout configuration is not explicitly
 specified for a general purpose compopnent the default layout manager will be used.]]></description><name>componentLayout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default xtype of child Components to create in this Container when a child item is specified as a raw configuration
 object, rather than as an instantiated Component. Defaults to 'panel'.]]></description><name>defaultType</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[This option is a means of applying default settings to all added items whether added through the items config or via the
 add or insert methods. If an added item is a config object, and not an instantiated Component, then the default
 properties are unconditionally applied. If the added item is an instantiated Component, then the default properties are
 applied conditionally so as not to override existing properties in the item. If the defaults option is specified as a
 function, then the function will be called using this Container as the scope (this reference) and passing the added item
 as the first parameter. Any resulting object from that call is then applied to the item as default properties. For
 example, to automatically apply padding to the body of each of a set of contained Ext.Panel items, you could pass:
 defaults: {bodyStyle:'padding:15px'}. Usage: defaults: {               // defaults are applied to items, not the
 container
     autoScroll:true
 },
 items: [
     {
         xtype: 'panel',   // defaults do not have precedence over
       
 id: 'panel1',     // options in config objects, so the defaults
         autoScroll: false // will not be applied here,
 panel1 will be autoScroll:false
     },
     new Ext.Panel({       // defaults do have precedence over options
         id:
 'panel2',     // options in components, so the defaults
         autoScroll: false // will be applied here, panel2 will
 be autoScroll:true.
     })
 ]]]></description><name>defaults</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to false.]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class to add when the Component is disabled. Defaults to 'x-item-disabled'.]]></description><name>disabledCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A component or series of components to be added as docked items to this panel. The docked items can be docked to either
 the top, right, left or bottom of a panel. This is typically used for things like toolbars or tab bars: var panel = new
 Ext.Panel({
     fullscreen: true,
     dockedItems: [{
         xtype: 'toolbar',
         dock: 'top',
         items: [{
  
           text: 'Docked to the bottom'
         }]
     }]
 });]]></description><name>dockedItems</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Allows the component to be dragged via the touch event.]]></description><name>draggable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Create the Component as a floating and use absolute positioning. Defaults to false.]]></description><name>floating</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of this component in pixels.]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to false.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[** IMPORTANT: be sure to specify a layout if needed ! ** A single item, or an array of child Components to be added to
 this container, for example: // specifying a single item
 items: {...},
 layout: 'fit',    // specify a layout!
 
 //
 specifying multiple items
 items: [{...}, {...}],
 layout: 'hbox', // specify a layout! Each item may be: any type of
 object based on Ext.Component a fully instanciated object or an object literal that: has a specified xtype the
 Ext.Component.xtype specified is associated with the Component desired and should be chosen from one of the available
 xtypes as listed in Ext.Component. If an xtype is not explicitly specified, the defaultType for that Container is used.
 will be "lazily instanciated", avoiding the overhead of constructing a fully instanciated Component object Notes: Ext
 uses lazy rendering. Child Components will only be rendered should it become necessary. Items are automatically laid out
 when they are first shown (no sizing is done while hidden), or in response to a doLayout call. Do not specify contentEl/
 html with items.]]></description><name>items</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[*Important: In order for child items to be correctly sized and positioned, typically a layout manager must be specified
 through the layout configuration option. The sizing and positioning of child items is the responsibility of the
 Container's layout manager which creates and manages the type of layout you have in mind. For example: If the layout
 configuration is not explicitly specified for a general purpose container (e.g. Container or Panel) the default layout
 manager will be used which does nothing but render child components sequentially into the Container (no sizing or
 positioning will be performed in this situation). layout may be specified as either as an Object or as a String: Specify
 as an Object Example usage: layout: {
     type: 'vbox',
     align: 'left'
 } type The layout type to be used for this
 container. If not specified, a default Ext.layout.ContainerLayout will be created and used. Valid layout type values
 are:
 auto - Default card fit hbox vbox Layout specific configuration properties Additional layout specific
 configuration properties may also be specified. For complete details regarding the valid config options for each layout
 type, see the layout class corresponding to the type specified. Specify as a String Example usage: layout: {
     type:
 'vbox',
     padding: '5',
     align: 'left'
 } layout The layout type to be used for this container (see list of valid
 layout type values above). Additional layout specific configuration properties. For complete details regarding the valid
 config options for each layout type, see the layout class corresponding to the layout specified.]]></description><name>layout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A config object containing one or more event handlers to be added to this object during initialization. This should be a
 valid listeners config object as specified in the addListener example for attaching multiple handlers at once. DOM
 events from ExtJs Components While some ExtJs Component classes export selected DOM events (e.g. "click", "mouseover"
 etc), this is usually only done when extra value can be added. For example the DataView's click event passing the node
 clicked on. To access DOM events directly from a child element of a Component, we need to specify the element option to
 identify the Component property to add a DOM listener to: new Ext.Panel({
     width: 400,
     height: 200,
    
 dockedItems: [{
         xtype: 'toolbar'
     }],
     listeners: {
         click: {
             element: 'el', //bind to
 the underlying el property on the panel
             fn: function(){ console.log('click el'); }
         },
        
 dblclick: {
             element: 'body', //bind to the underlying body property on the panel
             fn: function(){
 console.log('dblclick body'); }
         }
     }
 });]]></description><name>listeners</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the margin for this component. The margin can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>margin</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this Component will set its height to. Warning: This will override any size management
 applied by layout managers.]]></description><name>maxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this Component will set its width to. Warning: This will override any size management
 applied by layout managers.]]></description><name>maxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this Component will set its height to. Warning: This will override any size management
 applied by layout managers.]]></description><name>minHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this Component will set its width to. Warning: This will override any size management
 applied by layout managers.]]></description><name>minWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the padding for this component. The padding can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>padding</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object containing properties specifying DomQuery selectors which identify child elements created by the render
 process. After the Component's internal structure is rendered according to the renderTpl, this object is iterated
 through, and the found Elements are added as properties to the Component using the renderSelector property name. For
 example, a Component which rendered an image, and description into its element might use the following properties coded
 into its prototype: renderTpl: '"{imageUrl}" class="x-image-component-img">
 "x-image-component-desc">{description}',
 
 renderSelectors: {
     image: 'img.x-image-component-img',
     descEl:
 'div.x-image-component-desc'
 } After rendering, the Component would have a property image referencing its child img
 Element, and a property descEl referencing the div Element which contains the description.]]></description><name>renderSelectors</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An XTemplate used to create the internal structure inside this Component's encapsulating Element. You do not normally
 need to specify this. For the base classes Ext.Component and Ext.Container, this defaults to null which means that they
 will be initially rendered with no internal structure; they render their Element empty. The more specialized ExtJS and
 Touch classes which use a more complex DOM structure, provide their own template definitions. This is intended to allow
 the developer to create application-specific utility Components with customized internal structure. Upon rendering, any
 created child elements may be automatically imported into object properties using the renderSelectors option.]]></description><name>renderTpl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Duration in milliseconds that a user must hold a tab before dragging. The sortable configuration must be set for this
 setting to be used.]]></description><name>sortHoldThreshold</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Enable sorting functionality for the TabBar.]]></description><name>sortable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
             title: 'Some Title',
             renderTo: Ext.getBody(),
          
 width: 400, height: 300,
             layout: 'form',
             items: [{
                 xtype: 'textareafield',
      
 style: {
                     width: '95%',
                     marginBottom: '10px'
                 }
             },
    
 new Ext.Button({
                 text: 'Send',
                 minWidth: '100',
                 style: {
                
     marginBottom: '10px'
                 }
             })
             ]
         });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The class that is added to the content target when you set styleHtmlContent to true. Defaults to 'x-html']]></description><name>styleHtmlCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically style the html inside the content target of this component (body for panels). Defaults to false.]]></description><name>styleHtmlContent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An Ext.Template, Ext.XTemplate or an array of strings to form an Ext.XTemplate. Used in conjunction with the data and
 tplWriteMode configurations.]]></description><name>tpl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A set of predefined ui styles for individual components. Most components support 'light' and 'dark'. Extra string added
 to the baseCls with an extra '-'. 
 <pre><code>
 new Ext.Panel({
     title: 'Some Title',
     baseCls: 'x-component'
     ui: 'green'
 });</pre></code>
 The ui configuration in this example would add 'x-component-green' as an additional class.]]></description><name>ui</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of this component in pixels.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original SenchaTouch API docs:
 <a href="http://docs.sencha.com/touch/">http://docs.sencha.com/touch/</a>

 TabPanel is a Container which can hold other components to be accessed in a tabbed interface. It uses a 
 <a
 href="output/Ext.TabBar.html" ext:cls="Ext.TabBar">Ext.TabBar</a> to display a 
 <a href="output/Ext.Tab.html"
 ext:cls="Ext.Tab">Ext.Tab</a> for each item defined. 
 <h2>Useful Properties</h2> 
 <ul class="list"> 
  <li><a
 href="output/Ext.TabPanel.html#Ext.TabPanel-ui" ext:member="ui" ext:cls="Ext.TabPanel">ui</a></li> 
  <li><a
 href="output/Ext.TabPanel.html#Ext.TabPanel-tabBarDock" ext:member="tabBarDock"
 ext:cls="Ext.TabPanel">tabBarDock</a></li> 
  <li><a href="output/Ext.TabPanel.html#Ext.TabPanel-cardSwitchAnimation"
 ext:member="cardSwitchAnimation" ext:cls="Ext.TabPanel">cardSwitchAnimation</a></li> 
  <li><a
 href="output/Ext.TabPanel.html#Ext.TabPanel-sortable" ext:member="sortable" ext:cls="Ext.TabPanel">sortable</a></li>
 
 </ul> 
 <h2>Screenshot:</h2> 
 <p><img src="doc_resources/Ext.TabPanel/screenshot.png" /></p> 
 <h2>Example code:</h2>
 
 <pre><code><b>new</b> Ext.TabPanel({
     fullscreen: true,
     ui        : <em>'dark'</em>,
     sortable  : true,
    
 items: [
         {
             title: <em>'Tab 1'</em>,
             html : <em>'1'</em>,
             cls  :
 <em>'card1'</em>
         },
         {
             title: <em>'Tab 2'</em>,
             html : <em>'2'</em>,
            
 cls  : <em>'card2'</em>
         },
         {
             title: <em>'Tab 3'</em>,
             html : <em>'3'</em>,
      
       cls  : <em>'card3'</em>
         }
     ]
 });</code></pre>]]></description><name>tabPanel</name><tag-class>org.brushingbits.jnap.ui.senchatouch.TabPanel</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[A string component id or the numeric index of the component that should be initially activated within the container's
 layout on render. For example, activeItem: 'item-1' or activeItem: 0 (index 0 = the first item in the container's
 collection). activeItem only applies to layout styles that can display items one at a time (like Ext.layout.CardLayout
 and Ext.layout.FitLayout). Related to Ext.layout.ContainerLayout.activeItem.]]></description><name>activeItem</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If true the container will automatically destroy any contained component that is removed from it, else destruction must
 be handled manually (defaults to true).]]></description><name>autoDestroy</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The base CSS class to apply to this panel's element (defaults to 'x-panel').]]></description><name>baseCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A shortcut for setting a border style on the body element. The value can either be a number to be applied to all sides,
 or a normal css string describing borders. Defaults to undefined.]]></description><name>bodyBorder</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A shortcut for setting a margin style on the body element. The value can either be a number to be applied to all sides,
 or a normal css string describing margins. Defaults to undefined.]]></description><name>bodyMargin</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A shortcut for setting a padding style on the body element. The value can either be a number to be applied to all sides,
 or a normal css string describing padding. Defaults to undefined.]]></description><name>bodyPadding</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the border for this component. The border can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>border</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to ['add', 'remove'].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Animation to be used during transitions of cards. Any valid value from Ext.anims can be used ('fade', 'slide', 'flip',
 'cube', 'pop', 'wipe'), or false. Defaults to 'slide'.]]></description><name>cardSwitchAnimation</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element (defaults to ''). This can be useful for
 adding customized styles to the component or any of its children using standard CSS rules.]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS Class to be added to a components root level element to give distinction to it via styling.]]></description><name>componentCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The sizing and positioning of the component Elements is the responsibility of the Component's layout manager which
 creates and manages the type of layout specific to the component. If the layout configuration is not explicitly
 specified for a general purpose compopnent the default layout manager will be used.]]></description><name>componentLayout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default xtype of child Components to create in this Container when a child item is specified as a raw configuration
 object, rather than as an instantiated Component. Defaults to 'panel'.]]></description><name>defaultType</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[This option is a means of applying default settings to all added items whether added through the items config or via the
 add or insert methods. If an added item is a config object, and not an instantiated Component, then the default
 properties are unconditionally applied. If the added item is an instantiated Component, then the default properties are
 applied conditionally so as not to override existing properties in the item. If the defaults option is specified as a
 function, then the function will be called using this Container as the scope (this reference) and passing the added item
 as the first parameter. Any resulting object from that call is then applied to the item as default properties. For
 example, to automatically apply padding to the body of each of a set of contained Ext.Panel items, you could pass:
 defaults: {bodyStyle:'padding:15px'}. Usage: defaults: {               // defaults are applied to items, not the
 container
     autoScroll:true
 },
 items: [
     {
         xtype: 'panel',   // defaults do not have precedence over
       
 id: 'panel1',     // options in config objects, so the defaults
         autoScroll: false // will not be applied here,
 panel1 will be autoScroll:false
     },
     new Ext.Panel({       // defaults do have precedence over options
         id:
 'panel2',     // options in components, so the defaults
         autoScroll: false // will be applied here, panel2 will
 be autoScroll:true.
     })
 ]]]></description><name>defaults</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to false.]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class to add when the Component is disabled. Defaults to 'x-item-disabled'.]]></description><name>disabledCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A component or series of components to be added as docked items to this panel. The docked items can be docked to either
 the top, right, left or bottom of a panel. This is typically used for things like toolbars or tab bars: var panel = new
 Ext.Panel({
     fullscreen: true,
     dockedItems: [{
         xtype: 'toolbar',
         dock: 'top',
         items: [{
  
           text: 'Docked to the bottom'
         }]
     }]
 });]]></description><name>dockedItems</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Allows the component to be dragged via the touch event.]]></description><name>draggable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Create the Component as a floating and use absolute positioning. Defaults to false.]]></description><name>floating</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of this component in pixels.]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to false.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[** IMPORTANT: be sure to specify a layout if needed ! ** A single item, or an array of child Components to be added to
 this container, for example: // specifying a single item
 items: {...},
 layout: 'fit',    // specify a layout!
 
 //
 specifying multiple items
 items: [{...}, {...}],
 layout: 'hbox', // specify a layout! Each item may be: any type of
 object based on Ext.Component a fully instanciated object or an object literal that: has a specified xtype the
 Ext.Component.xtype specified is associated with the Component desired and should be chosen from one of the available
 xtypes as listed in Ext.Component. If an xtype is not explicitly specified, the defaultType for that Container is used.
 will be "lazily instanciated", avoiding the overhead of constructing a fully instanciated Component object Notes: Ext
 uses lazy rendering. Child Components will only be rendered should it become necessary. Items are automatically laid out
 when they are first shown (no sizing is done while hidden), or in response to a doLayout call. Do not specify contentEl/
 html with items.]]></description><name>items</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[*Important: In order for child items to be correctly sized and positioned, typically a layout manager must be specified
 through the layout configuration option. The sizing and positioning of child items is the responsibility of the
 Container's layout manager which creates and manages the type of layout you have in mind. For example: If the layout
 configuration is not explicitly specified for a general purpose container (e.g. Container or Panel) the default layout
 manager will be used which does nothing but render child components sequentially into the Container (no sizing or
 positioning will be performed in this situation). layout may be specified as either as an Object or as a String: Specify
 as an Object Example usage: layout: {
     type: 'vbox',
     align: 'left'
 } type The layout type to be used for this
 container. If not specified, a default Ext.layout.ContainerLayout will be created and used. Valid layout type values
 are:
 auto - Default card fit hbox vbox Layout specific configuration properties Additional layout specific
 configuration properties may also be specified. For complete details regarding the valid config options for each layout
 type, see the layout class corresponding to the type specified. Specify as a String Example usage: layout: {
     type:
 'vbox',
     padding: '5',
     align: 'left'
 } layout The layout type to be used for this container (see list of valid
 layout type values above). Additional layout specific configuration properties. For complete details regarding the valid
 config options for each layout type, see the layout class corresponding to the layout specified.]]></description><name>layout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A config object containing one or more event handlers to be added to this object during initialization. This should be a
 valid listeners config object as specified in the addListener example for attaching multiple handlers at once. DOM
 events from ExtJs Components While some ExtJs Component classes export selected DOM events (e.g. "click", "mouseover"
 etc), this is usually only done when extra value can be added. For example the DataView's click event passing the node
 clicked on. To access DOM events directly from a child element of a Component, we need to specify the element option to
 identify the Component property to add a DOM listener to: new Ext.Panel({
     width: 400,
     height: 200,
    
 dockedItems: [{
         xtype: 'toolbar'
     }],
     listeners: {
         click: {
             element: 'el', //bind to
 the underlying el property on the panel
             fn: function(){ console.log('click el'); }
         },
        
 dblclick: {
             element: 'body', //bind to the underlying body property on the panel
             fn: function(){
 console.log('dblclick body'); }
         }
     }
 });]]></description><name>listeners</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the margin for this component. The margin can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>margin</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this Component will set its height to. Warning: This will override any size management
 applied by layout managers.]]></description><name>maxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this Component will set its width to. Warning: This will override any size management
 applied by layout managers.]]></description><name>maxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this Component will set its height to. Warning: This will override any size management
 applied by layout managers.]]></description><name>minHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this Component will set its width to. Warning: This will override any size management
 applied by layout managers.]]></description><name>minWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the padding for this component. The padding can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>padding</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object containing properties specifying DomQuery selectors which identify child elements created by the render
 process. After the Component's internal structure is rendered according to the renderTpl, this object is iterated
 through, and the found Elements are added as properties to the Component using the renderSelector property name. For
 example, a Component which rendered an image, and description into its element might use the following properties coded
 into its prototype: renderTpl: '"{imageUrl}" class="x-image-component-img">
 "x-image-component-desc">{description}',
 
 renderSelectors: {
     image: 'img.x-image-component-img',
     descEl:
 'div.x-image-component-desc'
 } After rendering, the Component would have a property image referencing its child img
 Element, and a property descEl referencing the div Element which contains the description.]]></description><name>renderSelectors</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An XTemplate used to create the internal structure inside this Component's encapsulating Element. You do not normally
 need to specify this. For the base classes Ext.Component and Ext.Container, this defaults to null which means that they
 will be initially rendered with no internal structure; they render their Element empty. The more specialized ExtJS and
 Touch classes which use a more complex DOM structure, provide their own template definitions. This is intended to allow
 the developer to create application-specific utility Components with customized internal structure. Upon rendering, any
 created child elements may be automatically imported into object properties using the renderSelectors option.]]></description><name>renderTpl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Enable sorting functionality for the TabBar.]]></description><name>sortable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
             title: 'Some Title',
             renderTo: Ext.getBody(),
          
 width: 400, height: 300,
             layout: 'form',
             items: [{
                 xtype: 'textareafield',
      
 style: {
                     width: '95%',
                     marginBottom: '10px'
                 }
             },
    
 new Ext.Button({
                 text: 'Send',
                 minWidth: '100',
                 style: {
                
     marginBottom: '10px'
                 }
             })
             ]
         });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The class that is added to the content target when you set styleHtmlContent to true. Defaults to 'x-html']]></description><name>styleHtmlCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically style the html inside the content target of this component (body for panels). Defaults to false.]]></description><name>styleHtmlContent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An Ext.TabBar configuration]]></description><name>tabBar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Where to dock the Ext.TabPanel. Valid values are 'top' and 'bottom'.]]></description><name>tabBarDock</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An Ext.Template, Ext.XTemplate or an array of strings to form an Ext.XTemplate. Used in conjunction with the data and
 tplWriteMode configurations.]]></description><name>tpl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to 'dark'.]]></description><name>ui</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of this component in pixels.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original SenchaTouch API docs:
 <a href="http://docs.sencha.com/touch/">http://docs.sencha.com/touch/</a>

 <p>Represents an HTML fragment template. Templates may be <a href="output/Ext.Template.html#Ext.Template-compile"
 ext:member="compile" ext:cls="Ext.Template">precompiled</a> for greater performance.</p> An instance of this class may
 be created by passing to the constructor either a single argument, or multiple arguments: 
 <div class="mdetail-params">
 
 <ul> 
   <li><b>single argument</b> : String/Array 
    <div class="sub-desc">
      The single argument may be either a
 String or an Array:
     <ul> 
      <li><tt>String</tt> : </li>
      <pre><code><b>var</b> t = <b>new</b>
 Ext.Template(<em>&quot;&lt;div&gt;Hello {0}.&lt;/div&gt;&quot;</em>);
 t.<a
 href="output/Ext.Template.html#Ext.Template-append" ext:member="append"
 ext:cls="Ext.Template">append</a>(<em>'some-element'</em>, [<em>'foo'</em>]);</code></pre> 
      <li><tt>Array</tt> :
 </li> An Array will be combined with 
      <code>join(<em>''</em>)</code>. 
      <pre><code><b>var</b> t = <b>new</b>
 Ext.Template([
     <em>'&lt;div name=<em>&quot;{id}&quot;</em>&gt;'</em>,
         <em>'&lt;span
 class=<em>&quot;{cls}&quot;</em>&gt;{name:trim} {value:ellipsis(10)}&lt;/span&gt;'</em>,
    
 <em>'&lt;/div&gt;'</em>,
 ]);
 t.<a href="output/Ext.Template.html#Ext.Template-compile" ext:member="compile"
 ext:cls="Ext.Template">compile</a>();
 t.<a href="output/Ext.Template.html#Ext.Template-append" ext:member="append"
 ext:cls="Ext.Template">append</a>(<em>'some-element'</em>, {id: <em>'myid'</em>, cls: <em>'myclass'</em>, name:
 <em>'foo'</em>, value: <em>'bar'</em>});</code></pre> 
     </ul>
    </div></li> 
   <li><b>multiple arguments</b> :
 String, Object, Array, ... 
    <div class="sub-desc">
      Multiple arguments will be combined with 
    
 <code>join(<em>''</em>)</code>. 
     <pre><code><b>var</b> t = <b>new</b> Ext.Template(
     <em>'&lt;div
 name=<em>&quot;{id}&quot;</em>&gt;'</em>,
         <em>'&lt;span class=<em>&quot;{cls}&quot;</em>&gt;{name}
 {value}&lt;/span&gt;'</em>,
     <em>'&lt;/div&gt;'</em>,
     <i>// a configuration object:</i>
     {
         compiled:
 true,      <i>// <a href="output/Ext.Template.html#Ext.Template-compile" ext:member="compile"
 ext:cls="Ext.Template">compile</a> immediately</i>
     }
 );</code></pre> 
     <p><b>Notes</b>:</p> 
     <div
 class="mdetail-params">
      <ul> 
       <li>Formatting and <code>disableFormats</code> are not applicable for Sencha
 Touch.</li> 
       <li>For a list of available format functions, see <a href="output/Ext.util.Format.html"
 ext:cls="Ext.util.Format">Ext.util.Format</a>.</li> 
       <li><code>disableFormats</code> reduces <code><a
 href="output/Ext.Template.html#Ext.Template-apply" ext:member="apply" ext:cls="Ext.Template">apply</a></code> time when
 no formatting is required.</li> 
      </ul>
     </div> 
    </div></li> 
  </ul>
 </div>]]></description><name>template</name><tag-class>org.brushingbits.jnap.ui.senchatouch.Template</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[true to disable format functions in the template. If the template doesn't contain format functions, setting
 disableFormats to true will reduce apply time (defaults to false)]]></description><name>disableFormats</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original SenchaTouch API docs:
 <a href="http://docs.sencha.com/touch/">http://docs.sencha.com/touch/</a>

 <p>Toolbars are most commonly used as dockedItems within an Ext.Panel. They can be docked at the 'top' or 'bottom' of a
 Panel by specifying the dock config.</p> 
 <p>The <a href="output/Ext.Toolbar.html#Ext.Toolbar-defaultType"
 ext:member="defaultType" ext:cls="Ext.Toolbar">defaultType</a> of Toolbar's is '<a href="output/Ext.Button.html"
 ext:cls="Ext.Button">button</a>'.</p> 
 <h2>Screenshot:</h2> 
 <p><img src="doc_resources/Ext.Toolbar/screenshot.png"
 /></p> 
 <h2>Example code:</h2> 
 <pre><code><b>var</b> myToolbar = <b>new</b> Ext.Toolbar({
     dock : <em>'top'</em>,
   
 title: <em>'My Toolbar'</em>,
     items: [
         {
             text: <em>'My Button'</em>
         }
    
 ]
 });
 
 <b>var</b> myPanel = <b>new</b> Ext.Panel({
     dockedItems: [myToolbar],
     fullscreen : true,
     html       :
 <em>'Test Panel'</em>
 });</code></pre>]]></description><name>toolbar</name><tag-class>org.brushingbits.jnap.ui.senchatouch.Toolbar</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[A string component id or the numeric index of the component that should be initially activated within the container's
 layout on render. For example, activeItem: 'item-1' or activeItem: 0 (index 0 = the first item in the container's
 collection). activeItem only applies to layout styles that can display items one at a time (like Ext.layout.CardLayout
 and Ext.layout.FitLayout). Related to Ext.layout.ContainerLayout.activeItem.]]></description><name>activeItem</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If true the container will automatically destroy any contained component that is removed from it, else destruction must
 be handled manually (defaults to true).]]></description><name>autoDestroy</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The base CSS class to apply to the Carousel's element (defaults to 'x-toolbar').]]></description><name>baseCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the border for this component. The border can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>border</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to ['add', 'remove'].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Animation to be used during transitions of cards. Note this only works when this container has a CardLayout. Any valid
 value from Ext.anims can be used ('fade', 'slide', 'flip', 'cube', 'pop', 'wipe'). Defaults to null.]]></description><name>cardSwitchAnimation</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element (defaults to ''). This can be useful for
 adding customized styles to the component or any of its children using standard CSS rules.]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS Class to be added to a components root level element to give distinction to it via styling.]]></description><name>componentCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The sizing and positioning of the component Elements is the responsibility of the Component's layout manager which
 creates and manages the type of layout specific to the component. If the layout configuration is not explicitly
 specified for a general purpose compopnent the default layout manager will be used.]]></description><name>componentLayout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default xtype to create. (Defaults to 'button')]]></description><name>defaultType</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[This option is a means of applying default settings to all added items whether added through the items config or via the
 add or insert methods. If an added item is a config object, and not an instantiated Component, then the default
 properties are unconditionally applied. If the added item is an instantiated Component, then the default properties are
 applied conditionally so as not to override existing properties in the item. If the defaults option is specified as a
 function, then the function will be called using this Container as the scope (this reference) and passing the added item
 as the first parameter. Any resulting object from that call is then applied to the item as default properties. For
 example, to automatically apply padding to the body of each of a set of contained Ext.Panel items, you could pass:
 defaults: {bodyStyle:'padding:15px'}. Usage: defaults: {               // defaults are applied to items, not the
 container
     autoScroll:true
 },
 items: [
     {
         xtype: 'panel',   // defaults do not have precedence over
       
 id: 'panel1',     // options in config objects, so the defaults
         autoScroll: false // will not be applied here,
 panel1 will be autoScroll:false
     },
     new Ext.Panel({       // defaults do have precedence over options
         id:
 'panel2',     // options in components, so the defaults
         autoScroll: false // will be applied here, panel2 will
 be autoScroll:true.
     })
 ]]]></description><name>defaults</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to false.]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class to add when the Component is disabled. Defaults to 'x-item-disabled'.]]></description><name>disabledCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Allows the component to be dragged via the touch event.]]></description><name>draggable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Create the Component as a floating and use absolute positioning. Defaults to false.]]></description><name>floating</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of this component in pixels.]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to false.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[** IMPORTANT: be sure to specify a layout if needed ! ** A single item, or an array of child Components to be added to
 this container, for example: // specifying a single item
 items: {...},
 layout: 'fit',    // specify a layout!
 
 //
 specifying multiple items
 items: [{...}, {...}],
 layout: 'hbox', // specify a layout! Each item may be: any type of
 object based on Ext.Component a fully instanciated object or an object literal that: has a specified xtype the
 Ext.Component.xtype specified is associated with the Component desired and should be chosen from one of the available
 xtypes as listed in Ext.Component. If an xtype is not explicitly specified, the defaultType for that Container is used.
 will be "lazily instanciated", avoiding the overhead of constructing a fully instanciated Component object Notes: Ext
 uses lazy rendering. Child Components will only be rendered should it become necessary. Items are automatically laid out
 when they are first shown (no sizing is done while hidden), or in response to a doLayout call. Do not specify contentEl/
 html with items.]]></description><name>items</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A layout config object. A string is NOT supported here.]]></description><name>layout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A config object containing one or more event handlers to be added to this object during initialization. This should be a
 valid listeners config object as specified in the addListener example for attaching multiple handlers at once. DOM
 events from ExtJs Components While some ExtJs Component classes export selected DOM events (e.g. "click", "mouseover"
 etc), this is usually only done when extra value can be added. For example the DataView's click event passing the node
 clicked on. To access DOM events directly from a child element of a Component, we need to specify the element option to
 identify the Component property to add a DOM listener to: new Ext.Panel({
     width: 400,
     height: 200,
    
 dockedItems: [{
         xtype: 'toolbar'
     }],
     listeners: {
         click: {
             element: 'el', //bind to
 the underlying el property on the panel
             fn: function(){ console.log('click el'); }
         },
        
 dblclick: {
             element: 'body', //bind to the underlying body property on the panel
             fn: function(){
 console.log('dblclick body'); }
         }
     }
 });]]></description><name>listeners</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the margin for this component. The margin can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>margin</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this Component will set its height to. Warning: This will override any size management
 applied by layout managers.]]></description><name>maxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this Component will set its width to. Warning: This will override any size management
 applied by layout managers.]]></description><name>maxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this Component will set its height to. Warning: This will override any size management
 applied by layout managers.]]></description><name>minHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this Component will set its width to. Warning: This will override any size management
 applied by layout managers.]]></description><name>minWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the padding for this component. The padding can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>padding</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object containing properties specifying DomQuery selectors which identify child elements created by the render
 process. After the Component's internal structure is rendered according to the renderTpl, this object is iterated
 through, and the found Elements are added as properties to the Component using the renderSelector property name. For
 example, a Component which rendered an image, and description into its element might use the following properties coded
 into its prototype: renderTpl: '"{imageUrl}" class="x-image-component-img">
 "x-image-component-desc">{description}',
 
 renderSelectors: {
     image: 'img.x-image-component-img',
     descEl:
 'div.x-image-component-desc'
 } After rendering, the Component would have a property image referencing its child img
 Element, and a property descEl referencing the div Element which contains the description.]]></description><name>renderSelectors</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An XTemplate used to create the internal structure inside this Component's encapsulating Element. You do not normally
 need to specify this. For the base classes Ext.Component and Ext.Container, this defaults to null which means that they
 will be initially rendered with no internal structure; they render their Element empty. The more specialized ExtJS and
 Touch classes which use a more complex DOM structure, provide their own template definitions. This is intended to allow
 the developer to create application-specific utility Components with customized internal structure. Upon rendering, any
 created child elements may be automatically imported into object properties using the renderSelectors option.]]></description><name>renderTpl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
             title: 'Some Title',
             renderTo: Ext.getBody(),
          
 width: 400, height: 300,
             layout: 'form',
             items: [{
                 xtype: 'textareafield',
      
 style: {
                     width: '95%',
                     marginBottom: '10px'
                 }
             },
    
 new Ext.Button({
                 text: 'Send',
                 minWidth: '100',
                 style: {
                
     marginBottom: '10px'
                 }
             })
             ]
         });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The class that is added to the content target when you set styleHtmlContent to true. Defaults to 'x-html']]></description><name>styleHtmlCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically style the html inside the content target of this component (body for panels). Defaults to false.]]></description><name>styleHtmlContent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The title of the Toolbar.]]></description><name>title</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The CSS class to apply to the titleEl (defaults to 'x-toolbar-title').]]></description><name>titleCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An Ext.Template, Ext.XTemplate or an array of strings to form an Ext.XTemplate. Used in conjunction with the data and
 tplWriteMode configurations.]]></description><name>tpl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Style options for Toolbar. Default is 'dark'. 'light' is also available.]]></description><name>ui</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of this component in pixels.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original SenchaTouch API docs:
 <a href="http://docs.sencha.com/touch/">http://docs.sencha.com/touch/</a>

 Represents any object whose data can be saved by a 
 <a href="output/Ext.data.Proxy.html"
 ext:cls="Ext.data.Proxy">Proxy</a>. Ext.Model and Ext.View both inherit from this class as both can save state (Models
 save field state, Views save configuration)]]></description><name>util.stateful</name><tag-class>org.brushingbits.jnap.ui.senchatouch.util.Stateful</tag-class><body-content>scriptless</body-content><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A config object containing one or more event handlers to be added to this object during initialization. This should be a
 valid listeners config object as specified in the addListener example for attaching multiple handlers at once. DOM
 events from ExtJs Components While some ExtJs Component classes export selected DOM events (e.g. "click", "mouseover"
 etc), this is usually only done when extra value can be added. For example the DataView's click event passing the node
 clicked on. To access DOM events directly from a child element of a Component, we need to specify the element option to
 identify the Component property to add a DOM listener to: new Ext.Panel({
     width: 400,
     height: 200,
    
 dockedItems: [{
         xtype: 'toolbar'
     }],
     listeners: {
         click: {
             element: 'el', //bind to
 the underlying el property on the panel
             fn: function(){ console.log('click el'); }
         },
        
 dblclick: {
             element: 'body', //bind to the underlying body property on the panel
             fn: function(){
 console.log('dblclick body'); }
         }
     }
 });]]></description><name>listeners</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The property on this Persistable object that its data is saved to. Defaults to 'data' (e.g. all persistable data resides
 in this.data.)]]></description><name>persistanceProperty</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original SenchaTouch API docs:
 <a href="http://docs.sencha.com/touch/">http://docs.sencha.com/touch/</a>

 <p>Provides a simple Container for HTML5 Video.</p> 
 <h2>Useful Properties</h2> 
 <ul class="list"> 
  <li><a
 href="output/Ext.Video.html#Ext.Video-url" ext:member="url" ext:cls="Ext.Video">url</a></li> 
  <li><a
 href="output/Ext.Video.html#Ext.Video-autoPause" ext:member="autoPause" ext:cls="Ext.Video">autoPause</a></li> 
  <li><a
 href="output/Ext.Video.html#Ext.Video-autoResume" ext:member="autoResume" ext:cls="Ext.Video">autoResume</a></li> 
 </ul>
 
 <h2>Useful Methods</h2> 
 <ul class="list"> 
  <li><a href="output/Ext.Video.html#Ext.Video-pause" ext:member="pause"
 ext:cls="Ext.Video">pause</a></li> 
  <li><a href="output/Ext.Video.html#Ext.Video-play" ext:member="play"
 ext:cls="Ext.Video">play</a></li> 
  <li><a href="output/Ext.Video.html#Ext.Video-toggle" ext:member="toggle"
 ext:cls="Ext.Video">toggle</a></li> 
 </ul> 
 <h2>Screenshot:</h2> 
 <p><img src="doc_resources/Ext.Video/screenshot.png"
 /></p> 
 <h2>Example code:</h2> 
 <pre><code><b>var</b> pnl = <b>new</b> Ext.Panel({
     fullscreen: true,
     items: [
   
 {
             xtype    : <em>'video'</em>,
             x        : 600,
             y        : 300,
             width   
 : 175,
             height   : 98,
             url      : <em>&quot;porsche911.mov&quot;</em>,
             posterUrl:
 <em>'porsche.png'</em>
         }
     ]
 });</code></pre>]]></description><name>video</name><tag-class>org.brushingbits.jnap.ui.senchatouch.Video</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[A string component id or the numeric index of the component that should be initially activated within the container's
 layout on render. For example, activeItem: 'item-1' or activeItem: 0 (index 0 = the first item in the container's
 collection). activeItem only applies to layout styles that can display items one at a time (like Ext.layout.CardLayout
 and Ext.layout.FitLayout). Related to Ext.layout.ContainerLayout.activeItem.]]></description><name>activeItem</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[If true the container will automatically destroy any contained component that is removed from it, else destruction must
 be handled manually (defaults to true).]]></description><name>autoDestroy</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Will automatically pause the media when the container is deactivated. (Defaults to true)]]></description><name>autoPause</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Will automatically start playing the media when the container is activated. (Defaults to false)]]></description><name>autoResume</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The base CSS class to apply to this components's element. This will also be prepended to elements within this component
 like Panel's body will get a class x-panel-body. This means that if you create a subclass of Panel, and you want it to
 get all the Panels styling for the element and the body, you leave the baseCls x-panel and use componentCls to add
 specific styling for this component.]]></description><name>baseCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the border for this component. The border can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>border</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An array of events that, when fired, should be bubbled to any parent container. See Ext.util.Observable.enableBubble.
 Defaults to ['add', 'remove'].]]></description><name>bubbleEvents</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Animation to be used during transitions of cards. Note this only works when this container has a CardLayout. Any valid
 value from Ext.anims can be used ('fade', 'slide', 'flip', 'cube', 'pop', 'wipe'). Defaults to null.]]></description><name>cardSwitchAnimation</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An optional extra CSS class that will be added to this component's Element (defaults to ''). This can be useful for
 adding customized styles to the component or any of its children using standard CSS rules.]]></description><name>cls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS Class to be added to a components root level element to give distinction to it via styling.]]></description><name>componentCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The sizing and positioning of the component Elements is the responsibility of the Component's layout manager which
 creates and manages the type of layout specific to the component. If the layout configuration is not explicitly
 specified for a general purpose compopnent the default layout manager will be used.]]></description><name>componentLayout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Optional. Specify an existing HTML element, or the id of an existing HTML element to use as the content for this
 component. Description : This config option is used to take an existing HTML element and place it in the layout element
 of a new component (it simply moves the specified DOM element after the Component is rendered to use as the content.
 Notes : The specified HTML element is appended to the layout element of the component after any configured HTML has been
 inserted, and so the document will not contain this element at the time the render event is fired. The specified HTML
 element used will not participate in any layout scheme that the Component may use. It is just HTML. Layouts operate on
 child items. Add either the x-hidden or the x-hide-display CSS class to prevent a brief flicker of the content before it
 is rendered to the panel.]]></description><name>contentEl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The initial set of data to apply to the tpl to update the content area of the Component.]]></description><name>data</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The default xtype of child Components to create in this Container when a child item is specified as a raw configuration
 object, rather than as an instantiated Component. Defaults to 'panel'.]]></description><name>defaultType</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[This option is a means of applying default settings to all added items whether added through the items config or via the
 add or insert methods. If an added item is a config object, and not an instantiated Component, then the default
 properties are unconditionally applied. If the added item is an instantiated Component, then the default properties are
 applied conditionally so as not to override existing properties in the item. If the defaults option is specified as a
 function, then the function will be called using this Container as the scope (this reference) and passing the added item
 as the first parameter. Any resulting object from that call is then applied to the item as default properties. For
 example, to automatically apply padding to the body of each of a set of contained Ext.Panel items, you could pass:
 defaults: {bodyStyle:'padding:15px'}. Usage: defaults: {               // defaults are applied to items, not the
 container
     autoScroll:true
 },
 items: [
     {
         xtype: 'panel',   // defaults do not have precedence over
       
 id: 'panel1',     // options in config objects, so the defaults
         autoScroll: false // will not be applied here,
 panel1 will be autoScroll:false
     },
     new Ext.Panel({       // defaults do have precedence over options
         id:
 'panel2',     // options in components, so the defaults
         autoScroll: false // will be applied here, panel2 will
 be autoScroll:true.
     })
 ]]]></description><name>defaults</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to false.]]></description><name>disabled</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[CSS class to add when the Component is disabled. Defaults to 'x-item-disabled'.]]></description><name>disabledCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Allows the component to be dragged via the touch event.]]></description><name>draggable</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Set this to false to turn off the native media controls (Defaults to true).]]></description><name>enableControls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Create the Component as a floating and use absolute positioning. Defaults to false.]]></description><name>floating</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The height of this component in pixels.]]></description><name>height</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Defaults to false.]]></description><name>hidden</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An HTML fragment, or a DomHelper specification to use as the layout element content (defaults to ''). The HTML content
 is added after the component is rendered, so the document will not contain this HTML at the time the render event is
 fired. This content is inserted into the body before any configured contentEl is appended.]]></description><name>html</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[** IMPORTANT: be sure to specify a layout if needed ! ** A single item, or an array of child Components to be added to
 this container, for example: // specifying a single item
 items: {...},
 layout: 'fit',    // specify a layout!
 
 //
 specifying multiple items
 items: [{...}, {...}],
 layout: 'hbox', // specify a layout! Each item may be: any type of
 object based on Ext.Component a fully instanciated object or an object literal that: has a specified xtype the
 Ext.Component.xtype specified is associated with the Component desired and should be chosen from one of the available
 xtypes as listed in Ext.Component. If an xtype is not explicitly specified, the defaultType for that Container is used.
 will be "lazily instanciated", avoiding the overhead of constructing a fully instanciated Component object Notes: Ext
 uses lazy rendering. Child Components will only be rendered should it become necessary. Items are automatically laid out
 when they are first shown (no sizing is done while hidden), or in response to a doLayout call. Do not specify contentEl/
 html with items.]]></description><name>items</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[*Important: In order for child items to be correctly sized and positioned, typically a layout manager must be specified
 through the layout configuration option. The sizing and positioning of child items is the responsibility of the
 Container's layout manager which creates and manages the type of layout you have in mind. For example: If the layout
 configuration is not explicitly specified for a general purpose container (e.g. Container or Panel) the default layout
 manager will be used which does nothing but render child components sequentially into the Container (no sizing or
 positioning will be performed in this situation). layout may be specified as either as an Object or as a String: Specify
 as an Object Example usage: layout: {
     type: 'vbox',
     align: 'left'
 } type The layout type to be used for this
 container. If not specified, a default Ext.layout.ContainerLayout will be created and used. Valid layout type values
 are:
 auto - Default card fit hbox vbox Layout specific configuration properties Additional layout specific
 configuration properties may also be specified. For complete details regarding the valid config options for each layout
 type, see the layout class corresponding to the type specified. Specify as a String Example usage: layout: {
     type:
 'vbox',
     padding: '5',
     align: 'left'
 } layout The layout type to be used for this container (see list of valid
 layout type values above). Additional layout specific configuration properties. For complete details regarding the valid
 config options for each layout type, see the layout class corresponding to the layout specified.]]></description><name>layout</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A config object containing one or more event handlers to be added to this object during initialization. This should be a
 valid listeners config object as specified in the addListener example for attaching multiple handlers at once. DOM
 events from ExtJs Components While some ExtJs Component classes export selected DOM events (e.g. "click", "mouseover"
 etc), this is usually only done when extra value can be added. For example the DataView's click event passing the node
 clicked on. To access DOM events directly from a child element of a Component, we need to specify the element option to
 identify the Component property to add a DOM listener to: new Ext.Panel({
     width: 400,
     height: 200,
    
 dockedItems: [{
         xtype: 'toolbar'
     }],
     listeners: {
         click: {
             element: 'el', //bind to
 the underlying el property on the panel
             fn: function(){ console.log('click el'); }
         },
        
 dblclick: {
             element: 'body', //bind to the underlying body property on the panel
             fn: function(){
 console.log('dblclick body'); }
         }
     }
 });]]></description><name>listeners</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the margin for this component. The margin can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>margin</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this Component will set its height to. Warning: This will override any size management
 applied by layout managers.]]></description><name>maxHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The maximum value in pixels which this Component will set its width to. Warning: This will override any size management
 applied by layout managers.]]></description><name>maxWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this Component will set its height to. Warning: This will override any size management
 applied by layout managers.]]></description><name>minHeight</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The minimum value in pixels which this Component will set its width to. Warning: This will override any size management
 applied by layout managers.]]></description><name>minWidth</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specifies the padding for this component. The padding can be a single numeric value to apply to all sides or it can be a
 CSS style specification for each style, for example: '10 5 3 10'.]]></description><name>padding</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object or array of objects that will provide custom functionality for this component. The only requirement for a
 valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is
 created, if any plugins are available, the component will call the init method on each plugin, passing a reference to
 itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.]]></description><name>plugins</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Location of a poster image to be shown before showing the video.]]></description><name>posterUrl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Will begin preloading the media immediately. (Defaults to true)]]></description><name>preload</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An object containing properties specifying DomQuery selectors which identify child elements created by the render
 process. After the Component's internal structure is rendered according to the renderTpl, this object is iterated
 through, and the found Elements are added as properties to the Component using the renderSelector property name. For
 example, a Component which rendered an image, and description into its element might use the following properties coded
 into its prototype: renderTpl: '"{imageUrl}" class="x-image-component-img">
 "x-image-component-desc">{description}',
 
 renderSelectors: {
     image: 'img.x-image-component-img',
     descEl:
 'div.x-image-component-desc'
 } After rendering, the Component would have a property image referencing its child img
 Element, and a property descEl referencing the div Element which contains the description.]]></description><name>renderSelectors</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Specify the id of the element, a DOM element or an existing Element that this component will be rendered into. Notes :
 Do not use this option if the Component is to be a child item of a Container. It is the responsibility of the
 Container's layout manager to render and manage its child items. When using this config, a call to render() is not
 required. See render also.]]></description><name>renderTo</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An XTemplate used to create the internal structure inside this Component's encapsulating Element. You do not normally
 need to specify this. For the base classes Ext.Component and Ext.Container, this defaults to null which means that they
 will be initially rendered with no internal structure; they render their Element empty. The more specialized ExtJS and
 Touch classes which use a more complex DOM structure, provide their own template definitions. This is intended to allow
 the developer to create application-specific utility Components with customized internal structure. Upon rendering, any
 created child elements may be automatically imported into object properties using the renderSelectors option.]]></description><name>renderTpl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A custom style specification to be applied to this component's Element. Should be a valid argument to
 Ext.Element.applyStyles. new Ext.Panel({
             title: 'Some Title',
             renderTo: Ext.getBody(),
          
 width: 400, height: 300,
             layout: 'form',
             items: [{
                 xtype: 'textareafield',
      
 style: {
                     width: '95%',
                     marginBottom: '10px'
                 }
             },
    
 new Ext.Button({
                 text: 'Send',
                 minWidth: '100',
                 style: {
                
     marginBottom: '10px'
                 }
             })
             ]
         });]]></description><name>style</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The class that is added to the content target when you set styleHtmlContent to true. Defaults to 'x-html']]></description><name>styleHtmlCls</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[True to automatically style the html inside the content target of this component (body for panels). Defaults to false.]]></description><name>styleHtmlContent</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[An Ext.Template, Ext.XTemplate or an array of strings to form an Ext.XTemplate. Used in conjunction with the data and
 tplWriteMode configurations.]]></description><name>tpl</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The Ext.(X)Template method to use when updating the content area of the Component. Defaults to 'overwrite' (see
 Ext.XTemplate.overwrite).]]></description><name>tplWriteMode</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[A set of predefined ui styles for individual components. Most components support 'light' and 'dark'. Extra string added
 to the baseCls with an extra '-'. 
 <pre><code>
 new Ext.Panel({
     title: 'Some Title',
     baseCls: 'x-component'
     ui: 'green'
 });</pre></code>
 The ui configuration in this example would add 'x-component-green' as an additional class.]]></description><name>ui</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[Location of the video to play. This should be in H.264 format and in a .mov file format.]]></description><name>url</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[The width of this component in pixels.]]></description><name>width</name><rtexprvalue>true</rtexprvalue></attribute></tag><tag><description><![CDATA[The documentation of this component was copied from the original SenchaTouch API docs:
 <a href="http://docs.sencha.com/touch/">http://docs.sencha.com/touch/</a>

 <p>A template class that supports advanced functionality like:</p>
 <div class="mdetail-params">
  <ul> 
   <li>Autofilling
 arrays using templates and sub-templates</li> 
   <li>Conditional processing with basic comparison operators</li> 
  
 <li>Basic math function support</li> 
   <li>Execute arbitrary inline code with special built-in template variables</li>
 
   <li>Custom member functions</li> 
   <li>Many special tags and built-in operators that aren't defined as part of the
 API, but are supported in the templates that can be created</li> 
  </ul>
 </div>
 <p></p> 
 <p>XTemplate provides the
 templating mechanism built into:</p>
 <div class="mdetail-params">
  <ul> 
   <li><a href="output/Ext.DataView.html"
 ext:cls="Ext.DataView">Ext.DataView</a></li> 
  </ul>
 </div>
 <p></p> The 
 <a href="output/Ext.Template.html"
 ext:cls="Ext.Template">Ext.Template</a> describes the acceptable parameters to pass to the constructor. The following
 examples demonstrate all of the supported features.
 <p></p> 
 <div class="mdetail-params">
  <ul> 
   <li><b><u>Sample
 Data</u></b> 
    <div class="sub-desc"> 
     <p>This is the data object used for reference in each code example:</p> 
   
 <pre><code><b>var</b> data = {
 name: <em>'Tommy Maintz'</em>,
 title: <em>'Lead Developer'</em>,
 company: <em>'Ext JS,
 Inc'</em>,
 email: <em>'tommy@extjs.com'</em>,
 address: <em>'5 Cups Drive'</em>,
 city: <em>'Palo Alto'</em>,
 state:
 <em>'CA'</em>,
 zip: <em>'44102'</em>,
 drinks: [<em>'Coffee'</em>, <em>'Soda'</em>, <em>'Water'</em>],
 kids: [{
        
 name: <em>'Joshua'</em>,
         age:3
     },{
         name: <em>'Matthew'</em>,
         age:2
     },{
         name:
 <em>'Solomon'</em>,
         age:0
 }]
 };</code></pre> 
    </div> </li> 
   <li><b><u>Auto filling of arrays</u></b> 
   
 <div class="sub-desc"> 
     <p>The <b><tt>tpl</tt></b> tag and the <b><tt>for</tt></b> operator are used to process the
 provided data object: </p>
     <ul> 
      <li>If the value specified in <tt>for</tt> is an array, it will auto-fill,
 repeating the template block inside the <tt>tpl</tt> tag for each item in the array.</li> 
      <li>If
 <tt>for=&quot;.&quot;</tt> is specified, the data object provided is examined.</li> 
      <li>While processing an array,
 the special variable <tt>{#}</tt> will provide the current array index + 1 (starts at 1, not 0).</li> 
     </ul> 
    
 <p></p> 
     <pre><code>&lt;tpl <b><b>for</b></b>=<em>&quot;.&quot;</em>&gt;...&lt;/tpl&gt;       <i>// loop through
 array at root node</i>
 &lt;tpl <b><b>for</b></b>=<em>&quot;foo&quot;</em>&gt;...&lt;/tpl&gt;     <i>// loop through
 array at foo node</i>
 &lt;tpl <b><b>for</b></b>=<em>&quot;foo.bar&quot;</em>&gt;...&lt;/tpl&gt; <i>// loop through array
 at foo.bar node</i></code></pre> Using the sample data above: 
     <pre><code><b>var</b> tpl = <b>new</b>
 Ext.XTemplate(
     <em>'&lt;p&gt;Kids: '</em>,
     <em>'&lt;tpl <b><b>for</b></b>=<em>&quot;.&quot;</em>&gt;'</em>,     
 <i>// process the data.kids node</i>
         <em>'&lt;p&gt;{#}. {name}&lt;/p&gt;'</em>,  <i>// use current array index
 to autonumber</i>
     <em>'&lt;/tpl&gt;&lt;/p&gt;'</em>
 );
 tpl.overwrite(panel.body, data.kids); <i>// pass the kids
 property of the data object</i></code></pre> 
     <p>An example illustrating how the <b><tt>for</tt></b> property can be
 leveraged to access specified members of the provided data object to populate the template:</p> 
    
 <pre><code><b>var</b> tpl = <b>new</b> Ext.XTemplate(
     <em>'&lt;p&gt;Name: {name}&lt;/p&gt;'</em>,
    
 <em>'&lt;p&gt;Title: {title}&lt;/p&gt;'</em>,
     <em>'&lt;p&gt;Company: {company}&lt;/p&gt;'</em>,
    
 <em>'&lt;p&gt;Kids: '</em>,
     <em>'&lt;tpl <b><b>for</b>=<em>&quot;kids&quot;</em></b>&gt;'</em>,     <i>//
 interrogate the kids property within the data</i>
         <em>'&lt;p&gt;{name}&lt;/p&gt;'</em>,
    
 <em>'&lt;/tpl&gt;&lt;/p&gt;'</em>
 );
 tpl.overwrite(panel.body, data);  <i>// pass the root node of the data
 object</i></code></pre> 
     <p>Flat arrays that contain values (and not objects) can be auto-rendered using the special
 <b><tt>{.}</tt></b> variable inside a loop. This variable will represent the value of the array at the current
 index:</p> 
     <pre><code><b>var</b> tpl = <b>new</b> Ext.XTemplate(
     <em>'&lt;p&gt;{name}\'s favorite
 beverages:&lt;/p&gt;'</em>,
     <em>'&lt;tpl <b>for</b>=<em>&quot;drinks&quot;</em>&gt;'</em>,
         <em>'&lt;div&gt;
 - {.}&lt;/div&gt;'</em>,
     <em>'&lt;/tpl&gt;'</em>
 );
 tpl.overwrite(panel.body, data);</code></pre> 
     <p>When
 processing a sub-template, for example while looping through a child array, you can access the parent object's members
 via the <b><tt>parent</tt></b> object:</p> 
     <pre><code><b>var</b> tpl = <b>new</b> Ext.XTemplate(
    
 <em>'&lt;p&gt;Name: {name}&lt;/p&gt;'</em>,
     <em>'&lt;p&gt;Kids: '</em>,
     <em>'&lt;tpl
 <b>for</b>=<em>&quot;kids&quot;</em>&gt;'</em>,
         <em>'&lt;tpl <b>if</b>=<em>&quot;age &amp;gt;
 1&quot;</em>&gt;'</em>,
             <em>'&lt;p&gt;{name}&lt;/p&gt;'</em>,
             <em>'&lt;p&gt;Dad:
 {<b>parent</b>.name}&lt;/p&gt;'</em>,
         <em>'&lt;/tpl&gt;'</em>,
    
 <em>'&lt;/tpl&gt;&lt;/p&gt;'</em>
 );
 tpl.overwrite(panel.body, data);</code></pre> 
    </div> </li> 
  
 <li><b><u>Conditional processing with basic comparison operators</u></b> 
    <div class="sub-desc"> 
     <p>The
 <b><tt>tpl</tt></b> tag and the <b><tt>if</tt></b> operator are used to provide conditional checks for deciding whether
 or not to render specific parts of the template. Notes:</p>
     <div class="sub-desc">
      <ul> 
       <li>Double quotes must be encoded if used within the conditional</li> 
       <li>There is no <tt>else</tt> operator - if needed, two opposite <tt>if</tt> statements should be used.</li> 
      </ul>
     </div> 
     <pre><code>&lt;tpl
 <b>if</b>=<em>&quot;age &gt; 1 &amp;&amp; age &lt; 10&quot;</em>&gt;Child&lt;/tpl&gt;
 &lt;tpl <b>if</b>=<em>&quot;age
 &gt;= 10 &amp;&amp; age &lt; 18&quot;</em>&gt;Teenager&lt;/tpl&gt;
 &lt;tpl
 <b><b>if</b></b>=<em>&quot;this.isGirl(name)&quot;</em>&gt;...&lt;/tpl&gt;
 &lt;tpl
 <b><b>if</b></b>=<em>&quot;id==\<em>'download\'</em>&quot;</em>&gt;...&lt;/tpl&gt;
 &lt;tpl
 <b><b>if</b></b>=<em>&quot;needsIcon&quot;</em>&gt;&lt;img src=<em>&quot;{icon}&quot;</em>
 class=<em>&quot;{iconCls}&quot;</em>/&gt;&lt;/tpl&gt;
 <i>// no good:</i>
 &lt;tpl <b>if</b>=<em>&quot;name ==
 &quot;</em>Tommy<em>&quot;&quot;</em>&gt;Hello&lt;/tpl&gt;
 <i>// encode &quot; <b>if</b> it is part of the condition,
 e.g.</i>
 &lt;tpl <b>if</b>=<em>&quot;name == &amp;quot;Tommy&amp;quot;&quot;</em>&gt;Hello&lt;/tpl&gt;</code></pre>
 Using the sample data above: 
     <pre><code><b>var</b> tpl = <b>new</b> Ext.XTemplate(
     <em>'&lt;p&gt;Name:
 {name}&lt;/p&gt;'</em>,
     <em>'&lt;p&gt;Kids: '</em>,
     <em>'&lt;tpl
 <b>for</b>=<em>&quot;kids&quot;</em>&gt;'</em>,
         <em>'&lt;tpl <b>if</b>=<em>&quot;age &amp;gt;
 1&quot;</em>&gt;'</em>,
             <em>'&lt;p&gt;{name}&lt;/p&gt;'</em>,
         <em>'&lt;/tpl&gt;'</em>,
    
 <em>'&lt;/tpl&gt;&lt;/p&gt;'</em>
 );
 tpl.overwrite(panel.body, data);</code></pre> 
    </div> </li> 
   <li><b><u>Basic
 math support</u></b> 
    <div class="sub-desc"> 
     <p>The following basic math operators may be applied directly on
 numeric data values:</p>
     <pre>
 + - * /
 </pre> For example: 
     <pre><code><b>var</b> tpl = <b>new</b>
 Ext.XTemplate(
     <em>'&lt;p&gt;Name: {name}&lt;/p&gt;'</em>,
     <em>'&lt;p&gt;Kids: '</em>,
     <em>'&lt;tpl
 <b>for</b>=<em>&quot;kids&quot;</em>&gt;'</em>,
         <em>'&lt;tpl <b>if</b>=<em>&quot;age &amp;gt;
 1&quot;</em>&gt;'</em>,  <i>// &lt;-- Note that the &gt; is encoded</i>
             <em>'&lt;p&gt;{#}:
 {name}&lt;/p&gt;'</em>,  <i>// &lt;-- Auto-number each item</i>
             <em>'&lt;p&gt;In 5 Years:
 {age+5}&lt;/p&gt;'</em>,  <i>// &lt;-- Basic math</i>
             <em>'&lt;p&gt;Dad: {parent.name}&lt;/p&gt;'</em>,
     
 <em>'&lt;/tpl&gt;'</em>,
     <em>'&lt;/tpl&gt;&lt;/p&gt;'</em>
 );
 tpl.overwrite(panel.body, data);</code></pre> 
   
 </div> </li> 
   <li><b><u>Execute arbitrary inline code with special built-in template variables</u></b> 
    <div
 class="sub-desc"> 
     <p>Anything between <code>{[ ... ]}</code> is considered code to be executed in the scope of the
 template. There are some special variables available in that code: </p>
     <ul> 
      <li><b><tt>values</tt></b>: The
 values in the current scope. If you are using scope changing sub-templates, you can change what <tt>values</tt> is.</li>
 
      <li><b><tt>parent</tt></b>: The scope (values) of the ancestor template.</li> 
      <li><b><tt>xindex</tt></b>: If
 you are in a looping template, the index of the loop you are in (1-based).</li> 
      <li><b><tt>xcount</tt></b>: If you
 are in a looping template, the total length of the array you are looping.</li> 
     </ul> This example demonstrates
 basic row striping using an inline code block and the 
     <tt>xindex</tt> variable:
     <p></p> 
    
 <pre><code><b>var</b> tpl = <b>new</b> Ext.XTemplate(
     <em>'&lt;p&gt;Name: {name}&lt;/p&gt;'</em>,
    
 <em>'&lt;p&gt;Company: {[values.company.toUpperCase() + <em>&quot;, &quot;</em> + values.title]}&lt;/p&gt;'</em>,
    
 <em>'&lt;p&gt;Kids: '</em>,
     <em>'&lt;tpl <b>for</b>=<em>&quot;kids&quot;</em>&gt;'</em>,
         <em>'&lt;div
 class=<em>&quot;{[xindex % 2 === 0 ? &quot;</em>even<em>&quot; : &quot;</em>odd<em>&quot;]}&quot;</em>&gt;'</em>,
       
 <em>'{name}'</em>,
         <em>'&lt;/div&gt;'</em>,
     <em>'&lt;/tpl&gt;&lt;/p&gt;'</em>
  );
 tpl.overwrite(panel.body,
 data);</code></pre> 
    </div> </li> 
   <li><b><u>Template member functions</u></b> 
    <div class="sub-desc"> 
    
 <p>One or more member functions can be specified in a configuration object passed into the XTemplate constructor for
 more complex processing:</p> 
     <pre><code><b>var</b> tpl = <b>new</b> Ext.XTemplate(
     <em>'&lt;p&gt;Name:
 {name}&lt;/p&gt;'</em>,
     <em>'&lt;p&gt;Kids: '</em>,
     <em>'&lt;tpl
 <b>for</b>=<em>&quot;kids&quot;</em>&gt;'</em>,
         <em>'&lt;tpl
 <b>if</b>=<em>&quot;this.isGirl(name)&quot;</em>&gt;'</em>,
             <em>'&lt;p&gt;Girl: {name} -
 {age}&lt;/p&gt;'</em>,
         <em>'&lt;/tpl&gt;'</em>,
          <i>// use opposite <b>if</b> statement to simulate
 <em>'<b>else</b>'</em> processing:</i>
         <em>'&lt;tpl <b>if</b>=<em>&quot;this.isGirl(name) ==
 false&quot;</em>&gt;'</em>,
             <em>'&lt;p&gt;Boy: {name} - {age}&lt;/p&gt;'</em>,
        
 <em>'&lt;/tpl&gt;'</em>,
         <em>'&lt;tpl <b>if</b>=<em>&quot;this.isBaby(age)&quot;</em>&gt;'</em>,
            
 <em>'&lt;p&gt;{name} is a baby!&lt;/p&gt;'</em>,
         <em>'&lt;/tpl&gt;'</em>,
    
 <em>'&lt;/tpl&gt;&lt;/p&gt;'</em>,
     {
         <i>// XTemplate configuration:</i>
         compiled: true,
        
 <i>// member functions:</i>
         isGirl: <b>function</b>(name){
            <b>return</b> name == <em>'Sara
 Grace'</em>;
         },
         isBaby: <b>function</b>(age){
            <b>return</b> age &lt; 1;
         }
    
 }
 );
 tpl.overwrite(panel.body, data);</code></pre> 
    </div> </li> 
  </ul>
 </div>]]></description><name>xTemplate</name><tag-class>org.brushingbits.jnap.ui.senchatouch.XTemplate</tag-class><body-content>scriptless</body-content><attribute><description><![CDATA[The regular expression used to match code variables (default: matches {[expression]}).]]></description><name>codeRe</name><rtexprvalue>true</rtexprvalue></attribute><attribute><description><![CDATA[true to disable format functions in the template. If the template doesn't contain format functions, setting
 disableFormats to true will reduce apply time (defaults to false)]]></description><name>disableFormats</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsRef</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>jsVar</name><rtexprvalue>true</rtexprvalue></attribute><attribute><name>onReady</name><rtexprvalue>true</rtexprvalue></attribute></tag></taglib>